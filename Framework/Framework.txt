=== Auth/Application/Action/LoginAction.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Action;


use Gemini\Auth\Application\Service\AuthenticationService;
use Gemini\Auth\Application\Service\RateLimiterService;
use Gemini\Auth\Domain\Exception\AuthenticationException;
use Gemini\Auth\Domain\ValueObject\Credentials;
use Gemini\Auth\DTO\AuthenticationDTO;
use Gemini\Exceptions\ValidationException;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * LoginAction handles user login requests, combining validation, authentication, and response generation.
 */
final readonly class LoginAction
{
    /**
     * @param RateLimiterService    $rateLimiter           Action to prevent brute-force attacks.
     * @param AuthenticationService $authenticationService Action handling authentication logic.
     */
    public function __construct(
        private RateLimiterService    $rateLimiter,
        private AuthenticationService $authenticationService
    ) {}

    /**
     * Handles the processing of a login request.
     *
     * @param Request $request The HTTP request containing user login data.
     *
     * @return ResponseInterface A response indicating the login result.
     * @throws AuthenticationException|\ReflectionException
     */
    public function login(Request $request) : ResponseInterface
    {
        try {
            // Validate input using AuthenticationDTO
            $authenticationDTO = new AuthenticationDTO(data: $request->allInputs());
            $credentials       = new Credentials(authenticationDTO: $authenticationDTO);

            // Rate-limiting check. Brute force prevention.
            $identifier = $credentials->getIdentifierValue();
            if (! $this->rateLimiter->canAttempt(identifier: $identifier)) {
                return response()->send(data: ['error' => 'Too many login attempts'], status: 429);
            }

            // Authenticate user
            if (! $user = $this->authenticationService->login(credentials: $credentials)) {
                throw new ValidationException(message: 'Invalid credentials');
            }

            // Reset the rate limiter on success
            $this->rateLimiter->resetAttempts(identifier: $identifier);

            return response()->send(data: ['success' => 'Logged in', 'user' => $user]);
        } catch (ValidationException $e) {
            return response()->send(
                data  : ['error' => 'Validation failed', 'details' => $e->getErrors()],
                status: 422
            );
        }
    }
}

=== Auth/Application/Action/LogoutAction.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Action;

use Gemini\Auth\Application\Service\AuthenticationService;
use Gemini\HTTP\Security\CsrfTokenManager;
use Psr\Http\Message\ResponseInterface;

/**
 * LogoutAction handles user logout requests by properly terminating sessions and generating a new CSRF token.
 */
final readonly class LogoutAction
{
    public function __construct(
        private AuthenticationService $authenticationService,
        private CsrfTokenManager      $csrfTokenManager
    ) {}

    /**
     * Handles the logout process.
     *
     * - Terminates the authenticated session.
     * - Clears session data and regenerates session ID.
     * - Invalidates and regenerates the CSRF token for security.
     * - Returns a standardized response.
     *
     * @return ResponseInterface Response indicating successful logout.
     * @throws \Exception
     */
    public function logout() : ResponseInterface
    {
        // Step 1: Log out the user
        $this->authenticationService->logout();

        // Step 2: Invalidate all CSRF tokens and generate a new one
        $this->csrfTokenManager->invalidateAllTokens();
        $newToken = $this->csrfTokenManager->getToken();

        // Step 3: Return a response indicating successful logout
        return response()->send(
            data: [
                      'status'     => 'success',
                      'message'    => 'Logged out successfully.',
                      'csrf_token' => $newToken,
                  ]
        );
    }
}

=== Auth/Application/Action/RegisterUserAction.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Action;

use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\DTO\RegistrationDTO;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Handles user registration logic.
 */
final readonly class RegisterUserAction
{
    public function __construct(private UserSourceInterface $userProvider) {}

    /**
     * Handles the user registration process.
     *
     * @param Request $request The HTTP request containing registration data.
     *
     * @return ResponseInterface The response indicating the registration result.
     * @throws \ReflectionException
     */
    public function register(Request $request) : ResponseInterface
    {
        // Validate user request and create DTO
        $validatedDataFromRequest = new RegistrationDTO(
            data: [
                      'first_name' => $request->get(key: 'first_name'),
                      'last_name'  => $request->get(key: 'last_name'),
                      'email'      => $request->get(key: 'email'),
                      'username'   => $request->get(key: 'username'),
                      'is_admin'   => $request->get(key: 'is_admin', default: false),
                      'password'   => $request->get(key: 'password'),
                  ]
        );

        // Create user via Subject
        $user = $this->userProvider->createUser(registrationDTO: $validatedDataFromRequest);

        // Return response
        return response()->send(
            data  : [
                        'status' => 'success',
                        'user'   => [
                            'id'       => $user->getId(),
                            'email'    => $user->getEmail(),
                            'username' => $user->getUsername(),
                        ],
                    ],
            status: 201
        );
    }
}

=== Auth/Application/Service/AccessControl/AccessControlService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service\AccessControl;

use Gemini\Auth\Contracts\Identity\Subject\RABC\PermissionInterface;
use Gemini\Auth\Contracts\Identity\Subject\RABC\RoleInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;

/**
 * Action class responsible for managing access control, specifically roles and permissions.
 */
class AccessControlService
{
    /**
     * Adds a role to a user if the user doesn't already have it.
     *
     * @param UserInterface $user The user to which the role will be added.
     * @param RoleInterface $role The role to add to the user.
     *
     * @return bool True if the role was added, false if the user already had the role.
     */
    public function addRole(UserInterface $user, RoleInterface $role) : bool
    {
        if (! $user->hasRole($role->getRole())) {
            $user->addRole($role);

            return true;
        }

        return false;
    }

    /**
     * Checks if a user has a specific role.
     *
     * @param UserInterface $user The user to check.
     * @param string        $role The role to check for.
     *
     * @return bool True if the user has the specified role, false otherwise.
     */
    public function hasRole(UserInterface $user, string $role) : bool
    {
        return $user->hasRole($role);
    }

    /**
     * Removes a role from a user if the user has it.
     *
     * @param UserInterface $user The user from which the role will be removed.
     * @param string        $role The role to remove from the user.
     *
     * @return bool True if the role was removed, false if the user didn't have the role.
     */
    public function removeRole(UserInterface $user, string $role) : bool
    {
        if ($user->hasRole($role)) {
            $user->removeRole($role);

            return true;
        }

        return false;
    }

    /**
     * Adds a permission to a role if the role doesn't already have it.
     *
     * @param RoleInterface       $role       The role to which the permission will be added.
     * @param PermissionInterface $permission The permission to add to the role.
     *
     * @return bool True if the permission was added, false if the role already had the permission.
     */
    public function addPermissionToRole(RoleInterface $role, PermissionInterface $permission) : bool
    {
        if (! $role->hasPermission($permission->getPermission())) {
            $role->addPermission($permission);

            return true;
        }

        return false;
    }

    /**
     * Checks if a user has a specific permission through any of their roles.
     *
     * @param UserInterface $user       The user to check.
     * @param string        $permission The permission to check for.
     *
     * @return bool True if the user has the permission, false otherwise.
     */
    public function hasPermission(UserInterface $user, string $permission) : bool
    {
        foreach ($user->getRoles() as $role) {
            if ($this->roleHasPermission($role, $permission)) {
                return true;
            }
        }

        return false;
    }

    /**
     * A helper function to check if a role has a specific permission.
     *
     * @param RoleInterface $role       The role to check.
     * @param string        $permission The permission to check for.
     *
     * @return bool True if the role has the permission, false otherwise.
     */
    private function roleHasPermission(RoleInterface $role, string $permission) : bool
    {
        return $role->hasPermission($permission);
    }

    /**
     * Removes a permission from a role if the role has it.
     *
     * @param RoleInterface       $role       The role from which the permission will be removed.
     * @param PermissionInterface $permission The permission to remove from the role.
     *
     * @return bool True if the permission was removed, false if the role didn't have the permission.
     */
    public function removePermissionFromRole(RoleInterface $role, PermissionInterface $permission) : bool
    {
        if ($role->hasPermission($permission->getPermission())) {
            $role->removePermission($permission);

            return true;
        }

        return false;
    }

    /**
     * Checks access to a given policy string (role or permission).
     *
     * @param UserInterface $user
     * @param string        $policy
     *
     * @return bool
     */
    public function check(UserInterface $user, string $policy) : bool
    {
        // First check role match
        if ($this->hasRole(user: $user, role: $policy)) {
            return true;
        }

        // Then fallback to permission match
        return $this->hasPermission(user: $user, permission: $policy);
    }

}

=== Auth/Application/Service/AccessControl/UserPermissionService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service\AccessControl;

class UserPermissionService {}
=== Auth/Application/Service/AccessControl/UserRoleService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service\AccessControl;

class UserRoleService {}
=== Auth/Application/Service/AuthenticationService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service;

use Gemini\Auth\Contracts\AuthenticationServiceInterface;
use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Domain\Exception\AuthenticationException;

/**
 * Class AuthenticationService
 *
 * Provides core authentication logic using dependency injection for guard and session management.
 */
final readonly class AuthenticationService implements AuthenticationServiceInterface
{
    /**
     * AuthenticationService constructor.
     *
     * @param IdentityInterface $identity The guard responsible for session authentication.
     *
     * @technical This constructor sets up the service with a guard instance responsible for handling
     *            authentication-related tasks such as verifying user credentials, managing sessions, and user
     *            retrieval.
     * @business  Initializes the service to manage user authentication seamlessly, enabling secure login/logout
     *            functionality.
     */
    public function __construct(private IdentityInterface $identity) {}

    /**
     * Attempts to authenticate a user with given credentials.
     *
     * @param CredentialsInterface $credentials AccessControl credentials like 'email' and 'password'.
     *
     * @return UserInterface Authenticated user.
     * @throws AuthenticationException If login fails.
     *
     * @technical Validates user credentials using the guard's `attempt` method. If validation succeeds,
     *            it retrieves and returns the authenticated user. Throws an exception for invalid credentials.
     * @business  Allows a user to log in by providing valid login details (e.g., email and password),
     *            ensuring secure access to the system.
     */
    public function login(CredentialsInterface $credentials) : UserInterface
    {
        if (! $this->identity->attempt(credentials: $credentials)) {
            throw new AuthenticationException(message: 'Invalid credentials provided.');
        }

        return $this->identity->user();
    }

    /**
     * Retrieves the currently authenticated user.
     *
     * @return UserInterface|null Authenticated user or null if not authenticated.
     *
     * @technical Delegates to the guard to fetch the user currently associated with the session.
     *            Returns null if no session exists or the user is not logged in.
     * @business  Provides user-related information to interact with the system while logged in (e.g., username, roles).
     */
    public function user() : UserInterface|null
    {
        return $this->identity->user();
    }

    /**
     * Checks if a user is currently authenticated.
     *
     * @return bool True if authenticated, otherwise false.
     *
     * @technical Uses the guard's `check` method to verify if an active session exists and is associated with an
     *            authenticated user.
     * @business  Confirms whether a user is logged in, allowing the system to personalize the experience or restrict
     *            access.
     */
    public function check() : bool
    {
        return $this->identity->check();
    }

    /**
     * Logs out the authenticated user.
     *
     * @technical Calls the guard's `logout` method to clear the authenticated user's session and invalidate their
     *            tokens.
     * @business  Ends a user's session, securely logging them out to prevent unauthorized use of their account.
     */
    public function logout() : void
    {
        $this->identity->logout();
    }

    /**
     * Invalidates the current user session and clears authentication data.
     *
     * @technical Invokes the guard's `invalidate` method to destroy the current session, erasing all stored
     *            authentication information.
     * @business  Ensures that a user's session is completely destroyed, preventing misuse or unauthorized access after
     *            logout.
     */
    public function invalidateSession() : void
    {
        $this->identity->invalidate();
    }
}
=== Auth/Application/Service/ChangePasswordService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service;

use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Service responsible for handling password changes.
 */
final readonly class ChangePasswordService
{
    public function __construct(
        private AuthenticationService $authenticationService,
        private UserSourceInterface   $userProvider,
        private PasswordHasher        $passwordHasher
    ) {}

    /**
     * Handles the password change request.
     *
     * ## Technical Description
     * - Retrieves the currently authenticated user.
     * - Validates the current password.
     * - Hashes and updates the new password.
     * - Returns an appropriate response.
     *
     * ## Business Description
     * - Ensures secure password changes.
     * - Enforces validation rules.
     * - Prevents unauthorized password modifications.
     *
     * @param Request $request The HTTP request containing old and new passwords.
     *
     * @return ResponseInterface Response indicating success or failure.
     */
    public function changePassword(Request $request) : ResponseInterface
    {
        // Retrieve authenticated user
        $user = $this->authenticationService->user();
        if (! $user instanceof UserInterface) {
            return $this->unauthorizedResponse();
        }

        // Validate input
        $currentPassword = $request->get(key: 'current_password');
        $newPassword     = $request->get(key: 'new_password');
        $confirmPassword = $request->get(key: 'confirm_password');

        if (empty($currentPassword) || empty($newPassword) || empty($confirmPassword)) {
            return $this->validationErrorResponse(message: 'All password fields are required.');
        }

        // Check if the current password is valid
        if (! $this->passwordHasher->verify($currentPassword, $user->getPassword())) {
            return $this->validationErrorResponse(message: 'Current password is incorrect.');
        }

        // Ensure a new password and confirmation match
        if ($newPassword !== $confirmPassword) {
            return $this->validationErrorResponse(message: 'New password and confirmation do not match.');
        }

        // Hash and update new password
        $hashedPassword = $this->passwordHasher->hash($newPassword);
        $this->userProvider->updatePassword($user->getId(), $hashedPassword);

        return $this->successResponse();
    }

    /**
     * Returns an unauthorized response.
     */
    private function unauthorizedResponse() : ResponseInterface
    {
        return response()->send(
            data  : ['message' => 'Unauthorized'],
            status: 401
        );
    }

    /**
     * Returns a validation error response.
     */
    private function validationErrorResponse(string $message) : ResponseInterface
    {
        return response()->send(
            data  : ['error' => $message],
            status: 422
        );
    }

    /**
     * Returns a success response indicating password change success.
     */
    private function successResponse() : ResponseInterface
    {
        return response()->send(data: ['success' => 'Password changed successfully.']);
    }
}

=== Auth/Application/UseCase/API/ApiLoginUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCase\API;

use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Domain\Exception\AuthenticationException;
use Gemini\Auth\Domain\ValueObject\Credentials;
use Gemini\Auth\DTO\AuthenticationDTO;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Class ApiLoginUseCase
 *
 * This class encapsulates the logic for authenticating a user via an API.
 * The final modifier ensures that this class cannot be extended.
 */
final class ApiLoginUseCase
{
    /**
     * Key for accessing identifier in the request data. Could be email or username
     * Keeping it private and constant ensures consistency and immutability.
     */
    private const string IDENTIFIER_KEY = 'identifier';

    /**
     * Key for accessing password in the request data.
     * Similar to IDENTIFIER_KEY, it's immutable and consistent.
     */
    private const string PASSWORD_KEY = 'password';

    /**
     * Executes the login process.
     *
     * This method handles the main flow of user authentication including:
     * - Extracting credentials from the request.
     * - Authenticating the user.
     * - Generating a JWT token.
     * - Constructing a success or error response.
     *
     * @param Request $request The HTTP request containing login data.
     *
     * @return ResponseInterface The HTTP response with login results.
     * @throws \Exception This is a general exception thrown if anything unexpected happens.
     */
    public function execute(Request $request) : ResponseInterface
    {
        try {
            $credentials = $this->createCredentialsFromRequest(request: $request);
            $user        = auth()->login(credentials: $credentials);
            $token       = $this->generateJwtTokenForUser(user: $user, request: $request);

            return $this->successResponse(user: $user, token: $token);
        } catch (AuthenticationException $authenticationException) {
            return $this->errorResponse($authenticationException);
        }
    }

    /**
     * Extracts credentials from the HTTP request.
     *
     * This method parses the request data to create a Credentials object
     * using the identifier and password extracted from the request.
     *
     * @param Request $request The HTTP request containing login data.
     *
     * @return Credentials The created credentials object.
     * @throws \ReflectionException
     */
    private function createCredentialsFromRequest(Request $request) : Credentials
    {
        $authenticationData = [
            self::IDENTIFIER_KEY => $request->get(key: self::IDENTIFIER_KEY),
            self::PASSWORD_KEY   => $request->get(key: self::PASSWORD_KEY),
        ];

        return new Credentials(authenticationDTO: new AuthenticationDTO(data: $authenticationData));
    }

    /**
     * Generates a JWT token for the authenticated user.
     *
     * The token contains the user's id, email, and username.
     * This token will be used for further authenticated API requests.
     *
     * @param UserInterface $user    The authenticated user.
     * @param Request       $request The HTTP request.
     *
     * @return string The generated JWT token.
     */
    private function generateJwtTokenForUser(UserInterface $user, Request $request) : string
    {
        $payload = [
            'sub'      => $user->getId(),
            'email'    => $user->getEmail(),
            'username' => $user->getUsername(),
        ];

        return $request->generateJwtToken(payload: $payload);
    }

    /**
     * Constructs a successful response.
     *
     * This method formats a successful login response which includes
     * the generated JWT token and user details.
     *
     * @param UserInterface $user  The authenticated user.
     * @param string        $token The generated JWT token.
     *
     * @return ResponseInterface A response indicating successful authentication.
     * @throws \Exception If the response construction fails.
     */
    private function successResponse(UserInterface $user, string $token) : ResponseInterface
    {
        return response()->send(
            data: [
                      'status' => 'success',
                      'token'  => $token,
                      'user'   => [
                          'id'       => $user->getId(),
                          'email'    => $user->getEmail(),
                          'username' => $user->getUsername(),
                      ],
                  ],
        );
    }

    /**
     * Constructs an error response.
     *
     * This method formats an error response, indicating invalid credentials.
     *
     * @param AuthenticationException $authenticationException The exception thrown during authentication failure.
     *
     * @return ResponseInterface A response indicating failed authentication.
     * @throws \Exception If the response construction fails.
     */
    private function errorResponse(AuthenticationException $authenticationException) : ResponseInterface
    {
        return response()->send(
            data  : [
                        'status'  => 'error',
                        'message' => 'Invalid credentials. ' . $authenticationException->getMessage(),
                    ],
            status: 401,
        );
    }
}

=== Auth/Application/UseCase/API/ApiLogoutUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCase\API;

use Psr\Http\Message\ResponseInterface;

/**
 * Class ApiLogoutUseCase
 * This class handles the user logout operation.
 *
 * This class uses the auth() helper to access authentication services and handle
 * the logout process. It ensures a response is returned indicating the success of the operation.
 */
final class ApiLogoutUseCase
{
    /**
     * Executes the logout operation.
     *
     * This method will log out the authenticated user by calling the logout method
     * on the authentication service. After logging the user out, it returns a
     * response with a success message.
     *
     * @return ResponseInterface Returns a success logout response.
     * @throws \Exception If any error occurs during the logout process.
     */
    public function execute() : ResponseInterface
    {
        // Perform the logout operation via the auth helper.
        auth()->logout();

        // Return a standardized response indicating the logout was successful.
        return response()->send(
            data: [
                      'status'  => 'success',
                      'message' => 'Logged out successfully.',
                  ],
        );
    }
}

=== Auth/Application/UseCase/API/ApiRegisterUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCase\API;

use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\DTO\RegistrationDTO;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Class ApiRegisterUseCase
 * Handles user registration process.
 */
final class ApiRegisterUseCase
{
    /**
     * Executes the user registration process.
     *
     * @param Request $request The HTTP request containing the user registration data.
     *
     * @return ResponseInterface The HTTP response indicating registration success or failure.
     * @throws \Exception If any part of the registration process fails.
     */
    public function execute(Request $request) : ResponseInterface
    {
        // Extract registration data from the request and populate RegistrationDTO.
        $registrationDTO = new RegistrationDTO(
            data: [
                      'email'    => $request->get(key: 'email'),
                      'username' => $request->get(key: 'username'),
                      'password' => $request->get(key: 'password'),
                  ],
        );

        // Create a new user using the UserSourceInterface service.
        $user = app(abstract: UserSourceInterface::class)->createUser($registrationDTO);

        // Return a JSON response with the newly created user details.
        return response()->send(
            data  : [
                        'status' => 'success',
                        'user'   => [
                            'id'       => $user->getId(),
                            'email'    => $user->getEmail(),
                            'username' => $user->getUsername(),
                        ],
                    ],
            status: 201,
        );
    }
}

=== Auth/Application/UseCase/Web/LoginUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCase\Web;

use Gemini\Auth\Application\Action\LoginAction;
use Gemini\Auth\Domain\Exception\AuthenticationException;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * LoginUseCase orchestrates the login process by utilizing LoginAction.
 *
 * - It acts as an application-level use case, making it easy to adapt and extend.
 * - It ensures that login logic remains separate from controllers.
 */
final readonly class LoginUseCase
{
    /**
     * Constructor for injecting dependencies.
     *
     * @param \Gemini\Auth\Application\Action\LoginAction $loginAction
     */
    public function __construct(private LoginAction $loginAction) {}

    /**
     * Handles user login.
     *
     * @param Request $request The HTTP request containing login credentials.
     *
     * @return ResponseInterface The response indicating login success or failure.
     * @throws AuthenticationException
     * @throws \ReflectionException
     */
    public function execute(Request $request) : ResponseInterface
    {
        return $this->loginAction->login(request: $request);
    }

}

=== Auth/Application/UseCase/Web/LogoutUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCases\Web;

use Exception;
use Gemini\Auth\Application\Service\LogoutAction;
use Psr\Http\Message\ResponseInterface;

/**
 * The `LogoutUseCase` class encapsulates the user logout process.
 *
 * Responsibilities:
 * - Delegates logout logic to `LogoutAction`, ensuring separation of concerns.
 * - Makes logout logic reusable across different authentication contexts.
 * - Isolates business logic from lower-level session and security management.
 */
final readonly class LogoutUseCase
{
    /**
     * LogoutUseCase constructor.
     *
     * @param LogoutAction $logoutService Handles logout logic.
     */
    public function __construct(private LogoutAction $logoutService) {}

    /**
     * Executes the complete logout process.
     *
     * @return ResponseInterface Response object indicating successful logout, with a new CSRF token.
     * @throws Exception
     */
    public function execute() : ResponseInterface
    {
        return $this->logoutService->logout();
    }
}

=== Auth/Application/UseCase/Web/RegisterUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCases\Web;

use Gemini\Auth\Application\Service\RegisterUserAction;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Handles user registration through the `RegisterUserAction`.
 *
 * Technical Description:
 * This class serves as a use case for processing user registration requests.
 * It delegates the actual registration logic to the `RegisterUserAction` class.
 *
 * Business Description:
 * This use case facilitates the registration of new users,
 * enabling them to create accounts and access platform features.
 */
final readonly class RegisterUseCase
{
    public function __construct(private RegisterUserAction $registerService) {}

    /**
     * @param Request $request The HTTP request containing user registration data.
     *
     * @return ResponseInterface The response that contains the outcome of the registration process.
     */
    public function execute(Request $request) : ResponseInterface
    {
        return $this->registerService->register($request);
    }
}
=== Auth/Application/UseCase/Web/RetrieveCurrentUserUseCase.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\UseCase\Web;

use Psr\Http\Message\ResponseInterface;

/**
 * Handles the use case of retrieving the currently authenticated user.
 * This class ensures the user is authenticated before returning user data.
 */
final readonly class RetrieveCurrentUserUseCase
{
//    /**
//     * @param RetrieveCurrentUserService $retrieveCurrentUserService Handles user authentication retrieval logic.
//     */
//    public function __construct(private RetrieveCurrentUserService $retrieveCurrentUserService) {}

    /**
     * Executes the process to retrieve the authenticated user.
     *
     * ## Technical Description
     * - Delegates the authentication check to `RetrieveCurrentUserService`.
     * - Ensures that the logic remains clean, modular, and reusable.
     *
     * ## Business Description
     * - Ensures that **only authenticated users** can retrieve their own details.
     * - This abstraction allows **easy adaptation** to different authentication strategies.
     *
     * @return ResponseInterface The response containing user data if authenticated, or unauthorized status.
     */
    public function execute() : ResponseInterface
    {
        // TODO: Implement the logic to retrieve the authenticated user.
//        return $this->retrieveCurrentUserService->retrieve();
        return app(ResponseInterface::class);
    }
}

=== Auth/Contracts/AuthenticationServiceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts;

use Gemini\Auth\Contracts\Identity\Subject\UserInterface;

/**
 * Interface AuthenticationServiceInterface
 *
 * Defines the contract for authentication-related operations.
 * This interface standardizes methods for user login and logout.
 */
interface AuthenticationServiceInterface
{
    /**
     * Authenticate and log in a user with the given credentials.
     *
     * @param \Gemini\Auth\Contracts\CredentialsInterface $credentials AccessControl credentials, usually an email and
     *                                                                 password.
     *
     * @return UserInterface The authenticated user instance.
     */
    public function login(CredentialsInterface $credentials) : UserInterface;

    /**
     * Log out the currently authenticated user.
     *
     * This method might clear user session, tokens, or other forms of persistent authentication.
     */
    public function logout() : void;
}

=== Auth/Contracts/CredentialsInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts;

/**
 * This interface is designed for defining the structure of login credentials.
 * It provides method signatures to retrieve the key and value of an identifier, as well as the password.
 * This ensures a consistent way to handle credentials across different implementations.
 */
interface CredentialsInterface
{
    /**
     * Retrieve the key used to identify the credentials (e.g., "username" or "email").
     *
     * @return string The identifier key, such as "username" or "email".
     */
    public function getIdentifierKey() : string;

    /**
     * Retrieve the actual value associated with the identifier key.
     *
     * @return string The actual identifier value.
     */
    public function getIdentifierValue() : string;

    /**
     * Retrieve the password or secret necessary for authentication.
     *
     * @return string The password or secret for authentication.
     */
    public function getPassword() : string;
}

=== Auth/Contracts/Identity/IdentityInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts\Identity;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;

/**
 * IdentityInterface defines the basic contract for authentication mechanisms.
 * This interface is implemented by classes responsible for handling authentication operations.
 */
interface IdentityInterface
{
    /**
     * Attempt to authenticate a user with the provided credentials.
     * This method returns true if authentication is successful, otherwise false.
     *
     * @param CredentialsInterface $credentials The user's credentials (e.g., email and password).
     *
     * @return bool True on successful authentication, false otherwise.
     */
    public function attempt(CredentialsInterface $credentials) : bool;

    /**
     * Retrieve the currently authenticated user.
     * Returns null if no user is authenticated.
     *
     * @return UserInterface|null The authenticated user, or null if no user is authenticated.
     */
    public function user() : UserInterface|null;

    /**
     * Log out the currently authenticated user.
     * This should invalidate the current session or token.
     */
    public function logout() : void;

    /**
     * Check if a user is currently authenticated.
     *
     * @return bool True if a user is authenticated, otherwise false.
     */
    public function check() : bool;
}

=== Auth/Contracts/Identity/Subject/RABC/PermissionInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts\Identity\Subject\RABC;

/**
 * PermissionInterface defines a contract for permission-related functionalities.
 * Any class implementing this interface must provide a string representation of a permission.
 */
interface PermissionInterface
{
    /**
     * Retrieve the string representation of a permission.
     *
     * The intention behind this method is to ensure consistent access and representation of permissions
     * across the application, which can be essential for authorization mechanisms.
     *
     * @return string The permission string.
     */
    public function getPermission() : string;
}

=== Auth/Contracts/Identity/Subject/RABC/RoleInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts\Identity\Subject\RABC;

/**
 * Interface RoleInterface
 *
 * Defines the contract for role-based authentication, including permission management.
 */
interface RoleInterface
{
    public function getRole() : string;

    public function hasPermission(string $permission) : bool;

    /**
     * Add a permission to the role.
     */
    public function addPermission(PermissionInterface $permission) : void;

    /**
     * Remove a permission from the role.
     */
    public function removePermission(PermissionInterface $permission) : void;
}

=== Auth/Contracts/Identity/Subject/UserInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts\Identity\Subject;

use Gemini\Auth\Contracts\Identity\Subject\RABC\RoleInterface;

/**
 * Interface UserInterface
 *
 * This interface defines a contract for user entities, specifying the essential methods required
 * for managing user data, roles, and permissions. By enforcing this contract, we ensure that any
 * class implementing `UserInterface` will provide consistent behavior in terms of these operations.
 */
interface UserInterface
{
    /**
     * Retrieves the unique identifier for the user.
     *
     * @return int The unique user identifier.
     */
    public function getId() : int;

    /**
     * Retrieves the user's email address.
     *
     * @return string The user's email.
     */
    public function getEmail() : string;

    /**
     * Retrieves the user's username.
     *
     * @return string The username.
     */
    public function getUsername() : string;

    /**
     * Retrieves the user's hashed password.
     *
     * @return string The hashed password.
     */
    public function getPassword() : string;

    /**
     * Sets the user's password.
     *
     * @param string $password The new password to be set, which should be hashed.
     */
    public function setPassword(string $password) : void;

    /**
     * Retrieves the roles associated with the user.
     *
     * @return array An array of roles associated with the user.
     */
    public function getRoles() : array;

    /**
     * Checks if the user has a specific permission.
     *
     * This method leverages the roles of the user to determine if the permission is granted.
     *
     * @param string $permission The permission to check.
     *
     * @return bool True if the user has the permission, false otherwise.
     */
    public function hasPermission(string $permission) : bool;

    /**
     * Checks if the user has a specific role.
     *
     * @param string $role The role to check for.
     *
     * @return bool True if the user has the specified role, false otherwise.
     */
    public function hasRole(string $role) : bool;

    /**
     * Adds a role to the user.
     *
     * This facilitates role-based access control by associating a new role with the user.
     *
     * @param RoleInterface $role The role to add.
     */
    public function addRole(RoleInterface $role) : void;

    /**
     * Removes a role from the user.
     *
     * This method is used to disassociate a given role from the user.
     *
     * @param string $role The role identifier to remove.
     */
    public function removeRole(string $role) : void;
}

=== Auth/Contracts/Identity/UserSourceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Contracts\Identity;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\DTO\RegistrationDTO;

/**
 * Interface for a user provider that
 * abstracts the retrieval, validation, and management of user data.
 */
interface UserSourceInterface
{
    /**
     * Retrieve a user by their unique identifier.
     *
     * @param mixed $identifier The unique identifier for the user. Type can vary based on implementation.
     *
     * @return UserInterface|null The user object, or null if not found.
     */
    public function retrieveById(mixed $identifier) : UserInterface|null;

    /**
     * Retrieve a user based on a set of credentials.
     *
     * @param CredentialsInterface $credentials The set of credentials.
     *
     * @return UserInterface|null The user object if found, or null if the credentials do not match any user.
     */
    public function retrieveByCredentials(CredentialsInterface $credentials) : UserInterface|null;

    /**
     * Validate the provided credentials against the stored user credentials.
     *
     * @param UserInterface        $user        The user whose credentials are to be validated.
     * @param CredentialsInterface $credentials The credentials to validate.
     *
     * @return bool True if the credentials are valid, otherwise false.
     */
    public function validateCredentials(UserInterface $user, CredentialsInterface $credentials) : bool;

    /**
     * Creates a new user based on the provided registration data.
     *
     */
    public function createUser(RegistrationDTO $registrationDTO) : UserInterface;

    /**
     * Update an existing user with the provided data.
     *
     * @param UserInterface $user The user instance to update.
     * @param array         $data Associative array containing updated user data.
     *
     * @return bool True if the update was successful, otherwise false.
     */
    public function updateUser(UserInterface $user, array $data) : bool;

    /**
     * Delete a user by their unique identifier.
     *
     * @param mixed $identifier The unique identifier for the user to delete.
     *
     * @return bool True if the user was successfully deleted, otherwise false.
     */
    public function deleteUser(mixed $identifier) : bool;
}

=== Auth/Domain/Exception/AuthenticationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Domain\Exception;

use Exception;

/**
 * Custom exception class to handle authentication-related errors.
 *
 * This class extends the base Exception class to provide specific
 * handling for authentication failures within the application.
 *
 * The default message and code properties are overridden to ensure
 * that all instances of this exception carry a consistent error message
 * and HTTP status code (401), indicating unauthorized access.
 */
class AuthenticationException extends Exception
{
    /**
     * Default error message for authentication exceptions.
     *
     * This property ensures all instances of this exception have a
     * clear and uniform message that indicates the nature of the error.
     */
    protected $message = 'Authentication failed.';

    /**
     * HTTP status code for unauthorized access.
     *
     * By setting this property to 401, we provide a standard
     * status code that signifies the authentication error to the clients.
     */
    protected $code = 401;
}

=== Auth/Domain/Exception/AuthorizationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Domain\Exception;

use Exception;

/**
 * AuthorizationException represents an exception thrown during authorization failures.
 *
 * This custom exception is specifically for handling authorization errors within
 * the application, providing a clear message and an appropriate HTTP status code.
 */
class AuthorizationException extends Exception
{
    /**
     * The error message associated with the authorization exception.
     *
     * @var string
     */
    protected $message = 'Authorization failed.';

    /**
     * The HTTP status code used for authorization exceptions.
     *
     * @var int
     */
    protected $code = 403;
}

=== Auth/Domain/ValueObject/Credentials.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Domain\ValueObject;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\DTO\AuthenticationDTO;

/**
 * The Credentials class encapsulates user credentials, such as an identifier (email or username) and a password.
 * It ensures strict typing and provides method implementations to retrieve these credentials.
 */
final readonly class Credentials implements CredentialsInterface
{
    /**
     * Class representing a simple counter with ability to increment and reset.
     *
     * This class is thread-safe due to the usage of the synchronized blocks.
     * Particularly useful in scenarios where shared access to the counter state is necessary.
     */
    private string $identifier;

    /**
     * Represents a user password which includes hashing and validation functionalities.
     * The use of private visibility ensures encapsulation.
     * The constant SALT adds an additional layer of security to password hashing.
     */
    private string $password;

    /**
     * Constructor to initialize the credentials.
     */
    public function __construct(AuthenticationDTO $authenticationDTO)
    {
        $this->identifier = $authenticationDTO->identifier;
        $this->password   = $authenticationDTO->password;
    }

    /**
     * Determines and returns the type of identifier based on format validation.
     *
     * Using PHP's filter_var function, this method checks if the identifier is a valid email format.
     * If valid, it returns "email"; otherwise, it returns "username".
     *
     * @return string 'email' if identifier is a valid email address, otherwise 'username'.
     */
    public function getIdentifierKey() : string
    {
        return filter_var($this->identifier, FILTER_VALIDATE_EMAIL) ? 'email' : 'username';
    }

    /**
     * Retrieves the actual value of the identifier.
     *
     * This function returns the value of the identifier, which could be either an email or a username.
     *
     * @return string The identifier value.
     */
    public function getIdentifierValue() : string
    {
        return $this->identifier;
    }

    /**
     * Retrieves the password for authentication.
     *
     * This function returns the stored password, which is required for authentication processes.
     *
     * @return string The password or secret for authentication.
     */
    public function getPassword() : string
    {
        return $this->password;
    }
}

=== Auth/DTO/AuthenticationDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\AlphaNumOrEmail;
use Gemini\DataHandling\Validation\Attributes\Rules\RegexException;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * Data Transfer Object (DTO) for User Authentication.
 *
 * This DTO defines the structure and validation for user login credentials, enforcing
 * strict rules to maintain data integrity and security. The attributes used in this class
 * provide declarative validation to streamline validation logic and ensure consistency.
 *
 * Key Features:
 * - **Identifier**: Supports either alphanumeric usernames or email addresses.
 * - **Password**: Enforces secure password constraints, including length and complexity.
 *
 * This class uses PHP attributes for validation, making it both concise and highly readable.
 * Validation rules adhere to OWASP guidelines for secure authentication practices.
 */
class AuthenticationDTO extends AbstractDTO
{
    /**
     * User identifier.
     *
     * - Can be an alphanumeric username or a valid email address.
     * - Validated for format consistency to ensure proper input.
     */
    #[Required(message: "Identifier is required.")]
    #[StringType(message: "Identifier must be a string.")]
    #[AlphaNumOrEmail(message: "Identifier must be an alphanumeric username or a valid email.")]
    public string $identifier;

    /**
     * User password.
     *
     * - Must meet strict security requirements for length and complexity.
     * - Follows OWASP recommendations to ensure secure handling of sensitive data.
     */
    #[Required(message: "Password is required.")]
    #[RegexException(
        pattern: "/^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/",
        message: "Password must include at least one letter, one number, and one special character, 
        and must be between 8 and 64 characters long."
    )]
    public string $password;
}

=== Auth/DTO/RegistrationDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\AlphaNum;
use Gemini\DataHandling\Validation\Attributes\Rules\AlphaNumOrEmail;
use Gemini\DataHandling\Validation\Attributes\Rules\Max;
use Gemini\DataHandling\Validation\Attributes\Rules\Min;
use Gemini\DataHandling\Validation\Attributes\Rules\RegexException;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * RegistrationDTO is designed to represent the essential data for user registration.
 *
 * It ensures strict validation of email, username, and password fields, aiming to enhance security
 * and maintain data integrity according to business requirements.
 */
class RegistrationDTO extends AbstractDTO
{
    /**
     * The user's email address.
     *
     * Validation:
     * - Required
     * - Must be a valid email or alphanumeric value.
     */
    #[Required]
    #[StringType]
    #[AlphaNumOrEmail]
    public string $email;

    /**
     * The user's alphanumeric username.
     *
     * Validation:
     * - Required
     * - Alphanumeric
     * - Minimum length: 3 characters
     */
    #[Required]
    #[StringType]
    #[Min(min: 3)]
    #[AlphaNum]
    public string $username;

    /**
     * The user's password, designed to be secure.
     *
     * Validation:
     * - Required
     * - Minimum length: 8 characters
     * - Maximum length: 64 characters
     * - Must include at least one letter, one number, and one special character.
     */
    #[Required]
    #[StringType]
    #[Min(min: 8)]
    #[Max(max: 64)]
    #[RegexException(pattern: "/^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/")]
    public string $password;

    /**
     * The user's first name.
     *
     * Validation:
     * - Required
     * - Alphanumeric
     * - Maximum length: 50 characters
     */
    #[Required]
    #[StringType]
    #[AlphaNum]
    #[Max(max: 50)]
    public string $first_name;

    /**
     * The user's last name.
     *
     * Validation:
     * - Required
     * - Alphanumeric
     * - Maximum length: 50 characters
     */
    #[Required]
    #[StringType]
    #[AlphaNum]
    #[Max(max: 50)]
    public string $last_name;

    /**
     * The user's admin status.
     *
     * Validation:
     * - Required
     * - Boolean
     *
     * Default: false
     */
    #[Required]
    public bool $is_admin = false;

    /**
     * Converts the DTO to an associative array.
     *
     * @return array<string, mixed> The data as an array.
     */
    public function toArray() : array
    {
        return [
            'email'      => $this->email,
            'username'   => $this->username,
            'password'   => $this->password,
            'first_name' => $this->first_name,
            'last_name'  => $this->last_name,
            'is_admin'   => $this->is_admin,
        ];
    }
}

=== Auth/DTO/ResponseDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Class ResponseDTO
 *
 * This class extends AbstractDTO to leverage its automatic property
 * validation and assignment mechanism. It's specifically designed to
 * handle user response data. By extending AbstractDTO, we ensure
 * consistency and reduce boilerplate validation code.
 */
class ResponseDTO extends AbstractDTO
{
    /**
     * AccessControl ID, must be an integer.
     */
    public int $id;

    /**
     * AccessControl email, must be a valid string format.
     */
    public string $email;

    /**
     * AccessControl username, a string identifier for the user.
     */
    public string $username;

    /**
     * AccessControl roles, an array to hold roles or null if no roles are assigned.
     * Nullable type written in longer format for clarity.
     */
    public array|null $roles = null;
}

=== Auth/Infrastructure/Identity/Identity.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Infrastructure\Identity;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\Infrastructure\User\DB\User;

/**
 * Identity serves as an abstract implementation for authentication mechanisms.
 * It utilizes a UserSourceInterface to retrieve and authenticate users based on their credentials.
 * Simply -> identity is user from db
 */
abstract class Identity
{
    /**
     * Construct the Identity with a UserSourceInterface instance.
     *
     * @param User $user The provider responsible for user retrieval and data operations.
     */
    public function __construct(protected UserSourceInterface $user) {}

    /**
     * Authenticate a user based on provided credentials.
     *
     * This method retrieves a user using their credentials and verifies their password.
     * If the credentials are valid and the password matches, the user is authenticated.
     *
     * @param CredentialsInterface $credentials The credentials used to authenticate the user.
     *
     * @return UserInterface|string|null The authenticated user, or null if authentication fails.
     *
     * @throws \Exception|\Psr\SimpleCache\InvalidArgumentException If any issues arise during the authentication
     *                                                              process.
     */
    protected function authenticate(CredentialsInterface $credentials) : UserInterface|string|null
    {
        /** Retrieve the user based on the provided credentials */
        $user = $this->user->retrieveByCredentials($credentials);

        /**
         * Verify if the retrieved user's password matches the provided credentials.
         * If yes, return the user. Otherwise, return null indicating authentication failure.
         */
        if ($user instanceof UserInterface && password_verify($credentials->getPassword(), $user->getPassword())) {
            return $user;
        }

        return null;
    }
}

=== Auth/Infrastructure/Identity/Jwt/JwtIdentity.php ===
<?php
/** @noinspection GlobalVariableUsageInspection */

declare(strict_types=1);

namespace Gemini\Auth\Infrastructure\Identity\Jwt;

use Carbon\Carbon;
use DomainException;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\AuthGuardInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Infrastructure\Identity\Identity;
use Gemini\Auth\Infrastructure\User\DB\User;
use Psr\Log\LoggerInterface;
use UnexpectedValueException;

class JwtIdentity extends Identity implements AuthGuardInterface
{
    /**
     * JwtIdentity constructor.
     *
     * @param User                 $userProvider The user provider to retrieve users.
     * @param string               $secret       The JWT secret for encoding and decoding tokens.
     * @param int                  $tokenExpiry  The token expiration time in seconds.
     * @param LoggerInterface|null $logger       Optional logger for tracking authentication issues.
     */
    public function __construct(
        User                                  $userProvider,
        private readonly string               $secret,
        private readonly int                  $tokenExpiry = 3600,
        private readonly LoggerInterface|null $logger = null,
    ) {
        parent::__construct(userProvider: $userProvider);
    }

    /**
     * Attempts to authenticate a user based on provided credentials.
     *
     * @param CredentialsInterface $credentials Subject credentials.
     *
     * @return bool True if authentication is successful, otherwise false.
     * @throws \Exception
     * @throws \Exception
     */
    public function attempt(CredentialsInterface $credentials) : bool
    {
        return $this->authenticate(credentials: $credentials) !== null;
    }

    /**
     * Retrieves the currently authenticated user based on the JWT token in the Authorization header.
     *
     * @return UserInterface|null The authenticated user, or null if no valid token is found.
     * @throws \Exception
     * @throws \Exception
     */
    public function user() : UserInterface|null
    {
        $token = $this->getTokenFromHeader();

        if ($token === null || $token === '' || $token === '0') {
            $this->logger?->warning(message: "Authorization token not provided or invalid format.");

            return null;
        }

        try {
            $decoded = JWT::decode(jwt: $token, keyOrKeyArray: new Key(keyMaterial: $this->secret, algorithm: 'HS256'));

            if (isset($decoded->sub) && $this->isTokenValid(decodedToken: $decoded)) {
                return $this->userProvider->retrieveById(identifier: $decoded->sub);
            }

            $this->logger?->warning(message: "Invalid token claims or token expired.");
        } catch (UnexpectedValueException|DomainException $e) {
            $this->logger?->error(message: "JWT decoding failed: " . $e->getMessage());
        }

        return null;
    }

    /**
     * Retrieves the JWT token from the Authorization header.
     *
     * @return string|null The JWT token if available, otherwise null.
     */
    private function getTokenFromHeader() : string|null
    {
        $authHeader = $_SERVER['HTTP_AUTHORIZATION'] ?? '';

        if (str_starts_with((string) $authHeader, 'Bearer ')) {
            return substr((string) $authHeader, 7);
        }

        return null;
    }

    /**
     * Validates the token claims, specifically expiration.
     *
     * @param object $decodedToken The decoded JWT token.
     *
     * @return bool True if the token is valid, otherwise false.
     */
    private function isTokenValid(object $decodedToken) : bool
    {
        return isset($decodedToken->exp) && $decodedToken->exp >= Carbon::now()->timestamp;
    }

    /**
     * Generates a JWT token for the authenticated user.
     *
     * @param UserInterface $user The user for whom the token is generated.
     *
     * @return string The generated JWT token.
     */
    public function generateToken(UserInterface $user) : string
    {
        $payload = [
            'sub' => $user->getId(),
            'exp' => Carbon::now()->timestamp + $this->tokenExpiry,
            'iat' => Carbon::now()->timestamp,
        ];

        return JWT::encode(payload: $payload, key: $this->secret, alg: 'HS256');
    }

    /**
     * Logs out the current user by invalidating the JWT (no action for stateless JWT).
     */
    public function logout() : void
    {
        // Stateless logout for JWT; clients must discard the token on logout.
    }
}

=== Auth/Infrastructure/Identity/Session/SessionIdentity.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Infrastructure\Identity\Session;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\Domain\Exception\AuthenticationException;
use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * SessionIdentity provides authentication and session management for users using session storage.
 */
class SessionIdentity implements IdentityInterface
{
    private const string USER_KEY = 'authenticated_user_id';

    /**
     * Constructor method for the class.
     *
     * @param SessionInterface    $session      The session interface instance.
     * @param UserSourceInterface $userProvider The user provider interface instance.
     *
     * @return void
     */
    public function __construct(
        private readonly SessionInterface    $session,
        private readonly UserSourceInterface $userProvider,
    ) {}

    /**
     * Attempt to authenticate a user with the provided credentials.
     *
     * @param CredentialsInterface $credentials The user's credentials (e.g., email and password).
     *
     * @return bool True on successful authentication, false otherwise.
     * @throws AuthenticationException If authentication fails.
     */
    public function attempt(CredentialsInterface $credentials) : bool
    {
        $user = $this->userProvider->retrieveByCredentials(credentials: $credentials);

        if (! $user instanceof UserInterface) {
            throw new AuthenticationException(message: 'Subject not found.');
        }

        if (! password_verify($credentials->getPassword(), $user->getPassword())) {
            throw new AuthenticationException(message: 'Invalid credentials.');
        }

        // Session ID regeneration for security
        $this->session->regenerateId();

        // Saving the user ID in the session
        $this->session->set(key: self::USER_KEY, value: $user->getId());

        return true;
    }

    /**
     * Log out the currently authenticated user.
     */
    public function logout() : void
    {
        $this->session->delete(key: self::USER_KEY);
        $this->session->invalidate();
    }

    /**
     * Invalidates the current session.
     *
     * This method calls the session's invalidate function to end the current session.
     */
    public function invalidate() : void
    {
        $this->session->invalidate();
    }

    /**
     * Retrieve the currently authenticated user.
     *
     * @return UserInterface|null The authenticated user, or null if no user is authenticated.
     */
    public function user() : UserInterface|null
    {
        $userId = $this->session->get(key: self::USER_KEY);

        return $userId ? $this->userProvider->retrieveById(identifier: $userId) : null;
    }

    /**
     * Check if a user is currently authenticated.
     *
     * @return bool True if a user is authenticated, otherwise false.
     */
    public function check() : bool
    {
        return $this->session->has(key: self::USER_KEY);
    }
}

=== Auth/Infrastructure/Security/PasswordHasher.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Infrastructure\Security;

/**
 * PasswordHasher handles secure password hashing and verification using Argon2id.
 */
final class PasswordHasher
{
    /**
     * Hash a password using Argon2id.
     *
     * @param string $password The plain-text password to hash.
     *
     * @return string The hashed password.
     */
    public function hash(string $password) : string
    {
        return password_hash($password, PASSWORD_ARGON2ID, [
            'memory_cost' => 65536, // 64MB memory
            'time_cost'   => 4,     // 4 iterations
            'threads'     => 2,     // 2 parallel threads
        ]);
    }

    /**
     * Verify if the given password matches the hashed password.
     *
     * @param string $password       The plain-text password.
     * @param string $hashedPassword The hashed password.
     *
     * @return bool True if the password matches, false otherwise.
     */
    public function verify(string $password, string $hashedPassword) : bool
    {
        return password_verify($password, $hashedPassword);
    }

    /**
     * Check if a password hash needs to be rehashed.
     *
     * @param string $hashedPassword The existing hashed password.
     *
     * @return bool True if rehashing is needed, false otherwise.
     */
    public function needsRehash(string $hashedPassword) : bool
    {
        return password_needs_rehash($hashedPassword, PASSWORD_ARGON2ID, [
            'memory_cost' => 65536,
            'time_cost'   => 4,
            'threads'     => 2,
        ]);
    }
}

=== Auth/Infrastructure/Security/RateLimiterService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Application\Service;

use Carbon\CarbonImmutable;
use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * RateLimiterService tracks login attempts and enforces cooldowns via session.
 */
class RateLimiterService
{
    /**
     * The default maximum number of attempts allowed.
     */
    private int $defaultMaxAttempts = 5;

    /**
     * The default duration (in seconds) for which a lockout is enforced.
     */
    private int $defaultLockoutDuration = 300; // 5 minutes lockout duration

    /**
     * Constructor with session dependency injection.
     *
     * @param SessionInterface $session The session interface for managing session data.
     */
    public function __construct(private readonly SessionInterface $session) {}

    /**
     * Determines if a user or identifier can attempt an action based on rate limits.
     *
     * @param string   $identifier  Unique identifier for the user or IP.
     * @param int|null $maxAttempts Optional maximum attempts.
     * @param int|null $timeWindow  Optional time window for lockout (seconds).
     *
     * @return bool True if attempt is allowed, false if locked out.
     */
    public function canAttempt(string $identifier, int|null $maxAttempts = null, int|null $timeWindow = null) : bool
    {
        $maxAttempts ??= $this->defaultMaxAttempts;

        $attempts = $this->getAttempts(identifier: $identifier);

        return $attempts < $maxAttempts || ! $this->isLockedOut(identifier: $identifier);
    }

    /**
     * Retrieves the number of attempts made for a specific identifier.
     *
     * @param string $identifier The user's unique identifier (e.g., email or IP).
     *
     * @return int The number of attempts.
     */
    private function getAttempts(string $identifier) : int
    {
        $attemptsKey = $this->getSessionKey(identifier: $identifier, property: 'attempts');

        return $this->session->get(key: $attemptsKey, default: 0);
    }

    /**
     * Generates a session key for the given identifier and property.
     *
     * @param string $identifier The user's unique identifier (e.g., email or IP).
     * @param string $property   The property (e.g., 'attempts' or 'lockout_until').
     *
     * @return string The generated session key.
     */
    private function getSessionKey(string $identifier, string $property) : string
    {
        return hash('sha256', sprintf('rate_limiter_%s_%s', $identifier, $property));
    }

    /**
     * Checks if a user or identifier is locked out.
     *
     * @param string $identifier The user's unique identifier (e.g., email or IP).
     *
     * @return bool True if the user is locked out, false otherwise.
     */
    private function isLockedOut(string $identifier) : bool
    {
        $lockoutKey   = $this->getSessionKey(identifier: $identifier, property: 'lockout_until');
        $lockoutUntil = $this->session->get(key: $lockoutKey);

        return $lockoutUntil && CarbonImmutable::now() < CarbonImmutable::parse(time: $lockoutUntil);
    }

    /**
     * Records a failed attempt and enforces lockout if the maximum is reached.
     *
     * @param string   $identifier  Unique identifier for the user or IP.
     * @param int|null $maxAttempts Optional maximum attempts.
     * @param int|null $timeWindow  Optional lockout duration (seconds).
     */
    public function recordFailedAttempt(
        string   $identifier,
        int|null $maxAttempts = null,
        int|null $timeWindow = null
    ) : void {
        $maxAttempts ??= $this->defaultMaxAttempts;
        $timeWindow  ??= $this->defaultLockoutDuration;

        $attemptsKey = $this->getSessionKey(identifier: $identifier, property: 'attempts');
        $attempts    = $this->getAttempts(identifier: $identifier) + 1;

        $this->session->set(key: $attemptsKey, value: $attempts);

        if ($attempts >= $maxAttempts) {
            $this->lockOut(identifier: $identifier, duration: $timeWindow);
        }
    }

    /**
     * Sets a lockout period for the user after exceeding the maximum attempts.
     *
     * @param string $identifier Unique identifier for the user or IP.
     * @param int    $duration   Lockout duration in seconds.
     */
    private function lockOut(string $identifier, int $duration) : void
    {
        $lockoutKey   = $this->getSessionKey(identifier: $identifier, property: 'lockout_until');
        $lockoutUntil = CarbonImmutable::now()->addSeconds($duration)->toDateTimeString();

        $this->session->set(key: $lockoutKey, value: $lockoutUntil);
    }

    /**
     * Resets the attempt counter and lockout state for a specific identifier.
     *
     * @param string $identifier The user's unique identifier (e.g., email or IP).
     */
    public function resetAttempts(string $identifier) : void
    {
        $attemptsKey = $this->getSessionKey(identifier: $identifier, property: 'attempts');
        $lockoutKey  = $this->getSessionKey(identifier: $identifier, property: 'lockout_until');

        $this->session->delete(key: $attemptsKey);
        $this->session->delete(key: $lockoutKey);
    }
}

=== Auth/Infrastructure/User/DB/User.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Infrastructure\User\DB;

use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\Subject\RABC\RoleInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\DTO\RegistrationDTO;
use Gemini\Auth\Infrastructure\Security\PasswordHasher;
use Gemini\Database\QueryBuilder\QueryBuilder;

readonly class User implements UserSourceInterface
{
    public function __construct(
        private QueryBuilder   $queryBuilder,
        private PasswordHasher $passwordHasher
    ) {}

    /**
     * Retrieve a user based on a set of credentials.
     *
     * @throws \Exception|\Psr\SimpleCache\InvalidArgumentException
     */
    public function retrieveByCredentials(CredentialsInterface $credentials) : UserInterface|null
    {
        $identifierKey   = $credentials->getIdentifierKey();
        $identifierValue = $credentials->getIdentifierValue();

        $result = $this->queryBuilder
            ->table(tableName: 'users')
            ->where(column: $identifierKey, value: $identifierValue)
            ->first();

        return $result ? $this->mapToInterface(data: $result) : null;
    }

    /**
     * Maps a database record to an instance of a class implementing UserInterface.
     */
    private function mapToInterface(object|array|null $data) : UserInterface|null
    {
        if (! $data) {
            return null;
        }

        $data = is_array($data) ? (object) $data : $data;

        return new class ($data) implements UserInterface {
            public readonly int    $id;

            public readonly string $email;

            public readonly string $username;

            private string         $password;

            public readonly array  $roles;

            public function __construct(object $data)
            {
                $this->id       = $data->id;
                $this->email    = $data->email;
                $this->username = $data->username;
                $this->password = $data->password;
                $this->roles    = $data->roles ?? [];
            }

            public function getId() : int { return $this->id; }

            public function getEmail() : string { return $this->email; }

            public function getUsername() : string { return $this->username; }

            public function getPassword() : string { return $this->password; }

            public function getRoles() : array { return $this->roles; }

            public function setPassword(string $password) : void { $this->password = $password; }

            public function hasPermission(string $permission) : bool
            {
                return in_array(
                    $permission,
                    $this->roles,
                    true
                );
            }

            public function hasRole(string $role) : bool { return in_array($role, $this->roles, true); }

            public function addRole(RoleInterface $role) : void { /* TODO: Implement */ }

            public function removeRole(string $role) : void { /* TODO: Implement */ }
        };
    }

    /**
     * Validate the provided credentials against the stored user credentials.
     */
    public function validateCredentials(UserInterface $user, CredentialsInterface $credentials) : bool
    {
        return $this->passwordHasher->verify($credentials->getPassword(), $user->getPassword());
    }

    /**
     * Creates a new user based on the provided registration data.
     *
     * @throws \Exception
     */
    public function createUser(RegistrationDTO $registrationDTO) : UserInterface
    {
        $userData = [
            'first_name' => $registrationDTO->first_name,
            'last_name'  => $registrationDTO->last_name,
            'username'   => $registrationDTO->username,
            'email'      => $registrationDTO->email,
            'password'   => $this->passwordHasher->hash($registrationDTO->password),
            'is_admin'   => (int) $registrationDTO->is_admin,
        ];

        logger(message: 'Creating user with data:', context: $userData);

//        $id = $this->queryBuilder
//            ->table(tableName: 'users')
//            ->getLastInsertIdAfterInsert(parameters: $userData);
        $id = '1asaa1'; //TODO: Update this to use the actual ID from the database

        return $this->retrieveById(identifier: $id);
    }

    /**
     * Retrieve a user by their unique identifier.
     *
     * @throws \Exception
     */
    public function retrieveById(mixed $identifier) : UserInterface|null
    {
        $result = $this->queryBuilder
            ->table(tableName: 'users')
            ->select('id', 'first_name', 'last_name', 'email', 'username', 'password', 'is_admin')
            ->where(column: 'id', value: $identifier)
            ->first();

        return $this->mapToInterface(data: $result);
    }

    /**
     * Update an existing user with the provided data.
     */
    public function updateUser(UserInterface $user, array $data) : bool
    {
        return false;
//        if (isset($data['password'])) {
//            $data['password'] = $this->passwordHasher->hash($data['password']);
//        }
//
//        return $this->queryBuilder
//                   ->table(tableName: 'users')
//                   ->where(column: 'id', operator: '=', value: $user->getId())
//                   ->update(parameters: $data) > 0;
    }

    /**
     * Delete a user by their unique identifier.
     *
     * @throws \Exception
     */
    public function deleteUser(mixed $identifier) : bool
    {
        return false;

//        return $this->queryBuilder
//                   ->table(tableName: 'users')
//                   ->where(column: 'id', operator: '=', value: $identifier)
//                   ->delete() > 0;
    }
}

=== Auth/Interface/HTTP/Middleware/AuthenticationMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Interface\HTTP\Middleware;

use Closure;

/**
 * Middleware to ensure a user is authenticated.
 *
 * The class is marked as 'readonly', which indicates to the developers
 * that once instantiated, its properties cannot be modified.
 */
readonly class AuthenticationMiddleware
{
    /**
     * Handle an incoming request.
     *
     * Redirects to log in if the user is not authenticated.
     *
     * @param mixed   $request The HTTP request object. The exact type isn't specified here for flexibility.
     * @param Closure $next    The next middleware or request handler.
     *
     *
     * @return mixed The result of $next middleware if the user is authenticated.
     */
    public function handle(mixed $request, Closure $next) : mixed
    {
//        dd(auth()->user());
//        // Check for user authentication
//        if (! auth()->check()) {
//            // Log an unauthenticated access attempt for monitoring/security purposes
//            error_log(
//                sprintf(
//                    'Unauthenticated access attempt to "%s".',
//                    $request->getUri()->getPath()
//                )
//            );
//
//            // Redirect unauthenticated user to the login page
//            redirect(route('auth.login.form'));
////            redirect('/login');
////            header("Location: " . route('auth.login.form'), true, 302);
////            exit;
//            // Optional: Throw an exception instead of redirecting
//            // Uncomment the line below to enable throwing an authentication exception
//            // throw new AuthenticationException(message: 'Subject is not authenticated. Please log in.');
//        }
//
//        // Proceed to the next middleware if the user is authenticated
        return $next($request);
    }
}
=== Auth/Interface/HTTP/Middleware/AuthorizeMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Interface\HTTP\Middleware;

use Closure;
use Gemini\Auth\Application\Service\RABC\AccessControlService;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;
use RuntimeException;

/**
 * Middleware for handling user authorization based on policies.
 *
 * This middleware ensures that a user has access to a specific route or functionality
 * by verifying the defined authorization policy and the user's associated permissions or roles.
 */
final readonly class AuthorizeMiddleware
{
    /**
     * @var AccessControlService $authorization The service responsible for handling
     *                                          access control decisions, such as checking user roles and permissions.
     */
    public function __construct(private AccessControlService $authorization) {}

    /**
     * Handles the authorization process for incoming requests.
     *
     * This method is executed during the middleware lifecycle to ensure that the user
     * is authorized to proceed based on a specified policy.
     *
     * Steps:
     * - Retrieve the authorization policy from the request.
     * - Validate the request's user object against the defined policy.
     * - If the policy is not met, an exception is thrown.
     * - Otherwise, the request is passed to the next middleware.
     *
     * @param Request $request The HTTP request containing user and policy attributes.
     * @param Closure $next    The next middleware or final request handler to execute.
     *
     * @return ResponseInterface The processed response if authorization passes.
     * @throws RuntimeException If the policy is missing, the user is not found, or authorization fails.
     *
     */
    public function handle(Request $request, Closure $next) : ResponseInterface
    {
        // Retrieve the authorization policy from the request attributes.
        $policy = $request->getAttribute(name: 'route:authorization');

        // Ensure the policy exists and is a valid string.
        if (! is_string($policy)) {
            throw new RuntimeException(message: 'Route authorization policy is missing or invalid.');
        }

        // Retrieve the user from the request attributes.
        $user = $request->getAttribute(name: 'user');

        // Ensure the user is available and implements the UserInterface contract.
        if (! $user instanceof UserInterface) {
            throw new RuntimeException(message: 'Cannot authorize: No user available in request.');
        }

        // Verify if the user is authorized for the specific policy.
        if (! $this->authorization->check(user: $user, policy: $policy)) {
            throw new RuntimeException(message: "Unauthorized: policy [{$policy}] denied.");
        }

        // If authorization succeeded, pass the request to the next middleware.
        return $next($request);
    }
}
=== Auth/Interface/HTTP/Middleware/PermissionMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Interface\HTTP\Middleware;

use Closure;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Domain\Exception\AuthorizationException;

/**
 * Middleware to ensure the user has the specified permission.
 */
readonly class PermissionMiddleware
{
    public function __construct(private IdentityInterface $guard) {}

    /**
     * @throws AuthorizationException
     */
    public function handle($request, Closure $next, string $permission)
    {
        $user = $this->guard->user();

        if (! $user instanceof UserInterface || ! $user->hasPermission(
                permission: $permission,
            )) {
            throw new AuthorizationException(
                message: sprintf(
                             'AccessControl lacks the required permission: %s.',
                             $permission
                         )
            );
        }

        return $next($request);
    }
}

=== Auth/Interface/HTTP/Middleware/RoleMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Auth\Interface\HTTP\Middleware;

use Closure;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\Subject\UserInterface;
use Gemini\Auth\Domain\Exception\AuthorizationException;

/**
 * Middleware to ensure the user has the specified role.
 */
class RoleMiddleware
{
    public function __construct(private readonly IdentityInterface $guard) {}

    /**
     * @throws AuthorizationException
     */
    public function handle($request, Closure $next, string $role)
    {
        $user = $this->guard->user();

        if (! $user instanceof UserInterface || ! $user->hasRole(
                role: $role,
            )) {
            throw new AuthorizationException(message: sprintf('AccessControl lacks the required role: %s.', $role));
        }

        return $next($request);
    }
}

=== Cache/CacheBackendInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Cache;

use Psr\SimpleCache\CacheInterface;

/**
 * Interface CacheBackendInterface
 *
 * Defines a contract for a cache backend. Implements PSR-16 for compatibility.
 */
interface CacheBackendInterface extends CacheInterface
{
    /**
     * Clears a specific namespace or group of cache items if supported.
     *
     * @param string $namespace The namespace or group to clear.
     *
     * @return bool True on success, false otherwise.
     */
    public function clearNamespace(string $namespace) : bool;

    /**
     * Increments a stored integer value atomically.
     *
     * @param string $key   Cache key.
     * @param int    $value The amount to increment by.
     *
     * @return int New incremented value.
     */
    public function increment(string $key, int $value = 1) : int;

    /**
     * Decrements a stored integer value atomically.
     *
     * @param string $key   Cache key.
     * @param int    $value The amount to decrement by.
     *
     * @return int New decremented value.
     */
    public function decrement(string $key, int $value = 1) : int;
}

=== Cache/CacheManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\Cache;

use DateInterval;
use Psr\Log\LoggerInterface;
use Psr\SimpleCache\CacheInterface;
use Throwable;

/**
 * Class CacheManager
 *
 * Manages caching operations and delegates them to the backend.
 */
readonly class CacheManager implements CacheInterface
{
    public function __construct(
        private CacheBackendInterface $cacheBackend,
        private LoggerInterface       $logger
    ) {}

    public function get(string $key, mixed $default = null) : mixed
    {
        try {
            return $this->cacheBackend->get(key: $key, default: $default);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache get failed', context: ['key' => $key, 'error' => $e->getMessage()]);

            return $default;
        }
    }

    public function set(string $key, mixed $value, int|DateInterval|null $ttl = null) : bool
    {
        try {
            return $this->cacheBackend->set(key: $key, value: $value, ttl: $ttl);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache set failed', context: ['key' => $key, 'error' => $e->getMessage()]);

            return false;
        }
    }

    public function delete(string $key) : bool
    {
        try {
            return $this->cacheBackend->delete($key);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache delete failed', context: ['key' => $key, 'error' => $e->getMessage()]);

            return false;
        }
    }

    public function clear() : bool
    {
        try {
            return $this->cacheBackend->clear();
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache clear failed', context: ['error' => $e->getMessage()]);

            return false;
        }
    }

    public function getMultiple(iterable $keys, mixed $default = null) : iterable
    {
        try {
            return $this->cacheBackend->getMultiple(keys: $keys, default: $default);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache getMultiple failed', context: ['error' => $e->getMessage()]);

            return [];
        }
    }

    public function setMultiple(iterable $values, int|DateInterval|null $ttl = null) : bool
    {
        try {
            return $this->cacheBackend->setMultiple(values: $values, ttl: $ttl);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache setMultiple failed', context: ['error' => $e->getMessage()]);

            return false;
        }
    }

    public function deleteMultiple(iterable $keys) : bool
    {
        try {
            return $this->cacheBackend->deleteMultiple($keys);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache deleteMultiple failed', context: ['error' => $e->getMessage()]);

            return false;
        }
    }

    public function has(string $key) : bool
    {
        try {
            return $this->cacheBackend->has($key);
        } catch (Throwable $e) {
            $this->logger->error(message: 'Cache has failed', context: ['key' => $key, 'error' => $e->getMessage()]);

            return false;
        }
    }

    public function getBackend() : CacheBackendInterface
    {
        return $this->cacheBackend;
    }
}

=== Cache/Exception/InMemoryInvalidArgumentException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Cache\Exception;

use InvalidArgumentException as BaseInvalidArgumentException;
use Psr\SimpleCache\InvalidArgumentException as CacheInvalidArgumentException;

/**
 * Class InMemoryInvalidArgumentException
 *
 * Custom exception for invalid arguments in InMemoryCache.
 */
class InMemoryInvalidArgumentException extends BaseInvalidArgumentException implements CacheInvalidArgumentException {}

=== Cache/InMemoryCache.php ===
<?php

declare(strict_types=1);

namespace Gemini\Cache;

use DateInterval;
use DateTimeImmutable;
use Gemini\Cache\Exception\InMemoryInvalidArgumentException;
use Psr\SimpleCache\CacheInterface;
use Psr\SimpleCache\InvalidArgumentException;

/**
 * Class InMemoryCache
 *
 * A lightweight in-memory caching system implementing PSR-16.
 *
 * Features:
 * - Supports expiration times (TTL)
 * - Implements atomic increment/decrement operations
 * - Provides namespace-based cache clearing
 * - Handles batch operations efficiently
 */
class InMemoryCache implements CacheInterface
{
    /**
     * @var array<string, array{value: mixed, expires_at: int|null}>
     * Holds cached items with expiration metadata.
     */
    private array $cache = [];

    /**
     * Clears all cached items.
     *
     * @return bool True on success.
     */
    public function clear() : bool
    {
        $this->cache = [];

        return true;
    }

    /**
     * Retrieves multiple items from the cache.
     *
     * @param iterable $keys    The list of cache keys.
     * @param mixed    $default Default value if key does not exist.
     *
     * @return iterable<string, mixed> The key-value pairs.
     *
     * @throws InvalidArgumentException If any key is invalid.
     */
    public function getMultiple(iterable $keys, mixed $default = null) : iterable
    {
        $this->validateKeys($keys);

        $results = [];
        foreach ($keys as $key) {
            $results[$key] = $this->get($key, $default);
        }

        return $results;
    }

    /**
     * Validates multiple cache keys.
     *
     * @throws InvalidArgumentException If any key is invalid.
     */
    private function validateKeys(iterable $keys) : void
    {
        foreach ($keys as $key) {
            $this->validateKey($key);
        }
    }

    /**
     * Validates a cache key.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    private function validateKey(string $key) : void
    {
        if (! is_string($key) || trim($key) === '') {
            throw new InMemoryInvalidArgumentException('Cache key must be a non-empty string.');
        }
    }

    /**
     * Retrieves a value from the cache.
     *
     * @param string $key     The cache key.
     * @param mixed  $default Default value if key does not exist or is expired.
     *
     * @return mixed The cached value or default if key is not found.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $this->validateKey($key);

        if (! $this->has($key)) {
            return $default;
        }

        return $this->cache[$key]['value'];
    }

    /**
     * Checks if a key exists in the cache and is not expired.
     *
     * @param string $key The cache key.
     *
     * @return bool True if the item exists and is valid, false otherwise.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function has(string $key) : bool
    {
        $this->validateKey($key);

        if (! isset($this->cache[$key])) {
            return false;
        }

        $expiresAt = $this->cache[$key]['expires_at'];
        if ($expiresAt !== null && $expiresAt < time()) {
            $this->delete($key);

            return false;
        }

        return true;
    }

    /**
     * Deletes an item from the cache.
     *
     * @param string $key The cache key.
     *
     * @return bool True on success.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function delete(string $key) : bool
    {
        $this->validateKey($key);
        unset($this->cache[$key]);

        return true;
    }

    /**
     * Stores multiple items in the cache.
     *
     * @param iterable              $values The key-value pairs.
     * @param int|DateInterval|null $ttl    Time-to-live for all values.
     *
     * @return bool True on success.
     *
     * @throws InvalidArgumentException If any key is invalid.
     */
    public function setMultiple(iterable $values, int|DateInterval|null $ttl = null) : bool
    {
        $this->validateKeys(array_keys(iterator_to_array($values)));

        foreach ($values as $key => $value) {
            $this->set($key, $value, $ttl);
        }

        return true;
    }

    /**
     * Stores an item in the cache.
     *
     * @param string                $key   The cache key.
     * @param mixed                 $value The value to store.
     * @param int|DateInterval|null $ttl   Time-to-live in seconds or a DateInterval.
     *
     * @return bool True on success.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function set(string $key, mixed $value, int|DateInterval|null $ttl = null) : bool
    {
        $this->validateKey($key);

        $expiresAt         = $this->calculateExpirationTime($ttl);
        $this->cache[$key] = ['value' => $value, 'expires_at' => $expiresAt];

        return true;
    }

    /**
     * Calculates the expiration timestamp.
     */
    private function calculateExpirationTime(int|DateInterval|null $ttl) : ?int
    {
        if ($ttl === null) {
            return null;
        }

        return ($ttl instanceof DateInterval)
            ? (new DateTimeImmutable())->add($ttl)->getTimestamp()
            : (time() + $ttl);
    }

    /**
     * Deletes multiple items from the cache.
     *
     * @param iterable $keys The list of cache keys.
     *
     * @return bool True on success.
     *
     * @throws InvalidArgumentException If any key is invalid.
     */
    public function deleteMultiple(iterable $keys) : bool
    {
        $this->validateKeys($keys);

        foreach ($keys as $key) {
            $this->delete($key);
        }

        return true;
    }

    /**
     * Decrements a numeric value in the cache.
     *
     * @param string $key   The cache key.
     * @param int    $value The decrement amount.
     *
     * @return int The new decremented value.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function decrement(string $key, int $value = 1) : int
    {
        return $this->increment($key, -$value);
    }

    /**
     * Increments a numeric value in the cache.
     *
     * @param string $key   The cache key.
     * @param int    $value The increment amount.
     *
     * @return int The new incremented value.
     *
     * @throws InvalidArgumentException If the key is invalid.
     */
    public function increment(string $key, int $value = 1) : int
    {
        $this->validateKey($key);

        $currentValue = $this->get($key, 0);
        if (! is_numeric($currentValue)) {
            throw new InMemoryInvalidArgumentException("Value at key '$key' is not numeric.");
        }

        $newValue = (int) $currentValue + $value;
        $this->set($key, $newValue);

        return $newValue;
    }

    /**
     * Clears all items within a specific namespace.
     *
     * @param string $namespace The namespace prefix to clear.
     *
     * @return bool True on success.
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function clearNamespace(string $namespace) : bool
    {
        foreach (array_keys($this->cache) as $key) {
            if (str_starts_with($key, $namespace . ':')) {
                $this->delete($key);
            }
        }

        return true;
    }
}

=== Commands/App/MakeControllerCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Commands\App;

use Gemini\Database\Migration\Runner\Generators\Controller\ControllerGenerator;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MakeControllerCommand
{
    public function __construct(
        private ControllerGenerator $controllerGenerator,
        private LoggerInterface     $logger
    ) {}

    public function execute(array $arguments) : void
    {
        $name = $arguments['name'] ?? null;

        if (empty($name)) {
            $this->logger->error(message: "Controller name is required.");
            echo "Error: Controller name is required.\n";

            return;
        }

        try {
            $this->controllerGenerator->create(name: $name);
            $this->logger->info(message: sprintf("Controller '%s' created successfully.", $name));
        } catch (Throwable $throwable) {
            $this->logger->error(message: 'Error creating controller: ' . $throwable->getMessage());
        }
    }
}

=== Commands/App/MakeEntityCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Commands\App;

use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MakeEntityCommand
{
    public function __construct(
        private EntityGenerator $entityGenerator,
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        $table       = $arguments['table'] ?? null;
        $fieldsInput = $arguments['fields'] ?? '';

        if (empty($table)) {
            $this->logger->error(message: "Table name is required for entity generation.");
            echo "Error: Table name is required.\n";

            return;
        }

        try {
            $fields = $this->parseFields(fieldsInput: $fieldsInput);
            $this->entityGenerator->create(tableName: $table, fields: $fields);
            $this->logger->info(message: sprintf("Entity for table '%s' created successfully.", $table));
        } catch (Throwable $throwable) {
            $this->logger->error(message: 'Error creating entity: ' . $throwable->getMessage());
        }
    }

    private function parseFields(string $fieldsInput) : array
    {
        if ($fieldsInput === '' || $fieldsInput === '0') {
            return [];
        }

        $fields = [];
        foreach (explode(',', $fieldsInput) as $pair) {
            [$name, $type] = explode(':', $pair) + [1 => 'string'];
            $fields[] = ['name' => $name, 'type' => $type];
        }

        return $fields;
    }
}

=== Commands/App/MakeRepositoryCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Commands\App;

use Gemini\Database\Migration\Runner\Generators\Repository\RepositoryGenerator;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MakeRepositoryCommand
{
    public function __construct(
        private RepositoryGenerator $repositoryGenerator,
        private LoggerInterface     $logger
    ) {}

    public function execute(array $arguments) : void
    {
        $name   = $arguments['name'] ?? null;
        $entity = $arguments['entity'] ?? null;

        if (empty($name) || empty($entity)) {
            $this->logger->error(message: "Repository name and entity are required.");
            echo "Error: Repository name and entity are required.\n";

            return;
        }

        try {
            $this->repositoryGenerator->create(tableName: $name, entity: $entity);
            $this->logger->info(
                message: sprintf(
                             "Repository '%s' for entity '%s' created successfully.",
                             $name,
                             $entity
                         )
            );
        } catch (Throwable $throwable) {
            $this->logger->error(message: 'Error creating repository: ' . $throwable->getMessage());
        }
    }
}

=== Commands/App/MakeServiceCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Commands\App;

use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MakeServiceCommand
{
    public function __construct(
        private ServiceGenerator $serviceGenerator,
        private LoggerInterface  $logger
    ) {}

    public function execute(array $arguments) : void
    {
        $name = $arguments['name'] ?? null;

        if (empty($name)) {
            $this->logger->error(message: "Action name is required.");
            echo "Error: Action name is required.\n";

            return;
        }

        try {
            $this->serviceGenerator->create(name: $name);
            $this->logger->info(message: sprintf("Action '%s' created successfully.", $name));
        } catch (Throwable $throwable) {
            $this->logger->error(message: 'Error creating service: ' . $throwable->getMessage());
        }
    }
}

=== Commands/CommandDefinitions.php ===
<?php

declare(strict_types=1);

namespace Gemini\Commands;

use Gemini\Commands\App\MakeControllerCommand;
use Gemini\Commands\App\MakeRepositoryCommand;
use Gemini\Database\Migration\Runner\Commands\InstallCommand;
use Gemini\Database\Migration\Runner\Commands\MakeMigrationCommand;
use Gemini\Database\Migration\Runner\Commands\MigrateCommand;
use Gemini\Database\Migration\Runner\Commands\MigrateFreshCommand;
use Gemini\Database\Migration\Runner\Commands\MigrateRefreshCommand;
use Gemini\Database\Migration\Runner\Commands\MigrateRollbackCommand;

class CommandDefinitions
{
    public static function getCommandByAlias(string $alias) : ?array
    {
        foreach (self::getAllCommands() as $name => $details) {
            if ($name === $alias || ($details['alias'] ?? null) === $alias) {
                return $details;
            }
        }

        return null;
    }

    public static function getAllCommands() : array
    {
        return array_merge(
            self::getMigrationCommands(),
            self::getGeneratorCommands(),
            self::getUtilityCommands()
        );
    }

    private static function getMigrationCommands() : array
    {
        return [
            'migrate'          => [
                'alias'       => 'migrate:up',
                'description' => 'Run all pending migrations.',
                'class'       => MigrateCommand::class,
                'arguments'   => [],
                'options'     => [],
            ],
            'migrate:rollback' => [
                'alias'       => 'migrate:down',
                'description' => 'Rollback the last batch of migrations.',
                'class'       => MigrateRollbackCommand::class,
                'arguments'   => [],
                'options'     => [],
            ],
            'migrate:refresh'  => [
                'alias'       => 'migrate:reapply',
                'description' => 'Reset and rerun all migrations.',
                'class'       => MigrateRefreshCommand::class,
                'arguments'   => [],
                'options'     => [],
            ],
            'migrate:fresh'    => [
                'alias'       => 'migrate:clean',
                'description' => 'Drop all tables and re-run all migrations.',
                'class'       => MigrateFreshCommand::class,
                'arguments'   => [],
                'options'     => [],
            ],
            'make:migration'   => [
                'alias'       => 'create:migration',
                'description' => 'Create a new migration file.',
                'class'       => MakeMigrationCommand::class,
                'arguments'   => [
                    'name' => 'The name of the migration.',
                ],
                'options'     => [
                    '--table' => 'The table to create or modify.',
                ],
            ],
        ];
    }

    private static function getGeneratorCommands() : array
    {
        return [
            'make:controller' => [
                'alias'       => null,
                'description' => 'Generate a new controller.',
                'class'       => MakeControllerCommand::class,
                'arguments'   => [
                    'name' => 'The name of the controller.',
                ],
                'options'     => [
                    '--resource' => 'Generate a resource controller.',
                ],
            ],
            'make:repository' => [
                'alias'       => null,
                'description' => 'Generate a new repository.',
                'class'       => MakeRepositoryCommand::class,
                'arguments'   => [
                    'name' => 'The name of the repository.',
                ],
                'options'     => [],
            ],
        ];
    }

    private static function getUtilityCommands() : array
    {
        return [
            'install' => [
                'alias'       => null,
                'description' => 'Set up the application (e.g., create the migrations table).',
                'class'       => InstallCommand::class,
                'arguments'   => [],
                'options'     => [],
            ],
        ];
    }
}

=== Config/Architecture/DDD/AppPath.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config\Architecture\DDD;

use RuntimeException;

/**
 * Enum AppPath
 *
 * This enum is responsible for managing various important directory paths
 * within the application. Each enum case represents a relative path to a
 * significant part of the framework or project. The enum provides a
 * dynamic method to resolve these paths based on the root directory of
 * the project, ensuring flexibility and maintainability.
 */
enum AppPath: string
{
    /**
     * The path to the view cache directory where compiled Blade views are stored.
     * This case represents the directory for storing cached view files, allowing
     * the application to load views more quickly on subsequent requests.
     */
    case VIEW_CACHE_PATH = 'storage/views';

    /**
     * This constant defines the path to the logs directory.
     *
     * The constant LOGS_PATH can be used throughout the application
     * whenever the logs directory path is needed, ensuring consistency.
     *
     * Example usage:
     * ```
     * $logFilePath = LOGS_PATH . 'error.log';
     * ```
     */
    case LOGS_PATH = 'storage/logs/';

    /**
     * The path to the configuration files within the project.
     * This case represents the location where all configuration files
     * related to the application are stored. The configuration files typically
     * include settings such as database configurations, service configurations,
     * and other environment-specific options.
     */
    case CONFIG = 'Infrastructure/Config';

    /**
     * The path to the Composer autoload file.
     * This case represents the path to Composer's autoload file, which is
     * essential for automatically loading classes in the project based on the
     * PSR-4 autoloading standard. This is typically located in the vendor directory.
     *
     */
    case AUTOLOAD_PATH = 'vendor/autoload.php'; // Removed the leading slash

    /**
     * The path to the helper functions used throughout the framework.
     * This case points to the helper functions, which are reusable, framework-agnostic
     * utilities that can be used globally within the application. These functions are
     * typically generic and assist in tasks such as formatting, array manipulation,
     * string handling, and debugging.
     */
    case HELPERS_PATH = 'Infrastructure/Framework/Helpers/helpers.php'; // Removed the leading slash

    /**
     * The path to the web routes file which defines the HTTP routes for the application.
     * This case refers to the file where all HTTP routes are defined, mapping
     * incoming web requests to their respective controllers and actions within the
     * application. This is essential for the routing system to function.
     */
    case ROUTES_PATH = 'Presentation/HTTP/routes/'; // Removed the leading slash

    /**
     * The path to the database migration files.
     * This case represents the directory where migration files are stored.
     * These migrations are responsible for defining the database schema changes
     * such as creating, modifying, or dropping tables. They allow for easy
     * version control of the database schema.
     */
    case MIGRATIONS_PATH = 'Infrastructure/migrations'; // Removed the leading slash

    /**
     * Constant representing the directory path for Data Transfer Objects (DTOs).
     *
     * DTOs are lightweight objects used to transfer data between layers in the system,
     * specifically designed to minimize coupling and improve separation of concerns.
     *
     * @var string DTO_PATH The relative path for storing application DTOs.
     */
    case DTO_PATH = 'Application/DTO'; // Removed the leading slash for project-relative paths

    /**
     * The path to the compiled route cache file.
     *
     * This path should point to a file where the precompiled routes
     * are dumped by the route compiler and later loaded at boot time.
     * This dramatically reduces routing overhead.
     */
    case ROUTE_CACHE_PATH = 'storage/cache/routes.cache.php';

    case STUBS_PATH       = 'Infrastructure/Framework/Database/Migration/Runner/Stubs/';

    /**
     * Get the full path by prepending the root directory to the enum case value.
     *
     * This method dynamically resolves the full path for each enum case by
     * prepending the project's root directory to the relative path defined
     * in the enum case. This allows the paths to be flexible and environment-independent.
     *
     * @return string The full absolute path based on the enum case.
     */
    public function get() : string
    {
        return self::getRoot() . $this->value; // Constructs the full path
    }

    /**
     * Dynamically determines the project's root directory.
     *
     * This method traverses up the directory hierarchy until it locates the `composer.json` file,
     * which serves as a reliable indicator of the project's root. This approach ensures that
     * the method remains flexible and independent of any hardcoded directory structure.
     *
     * If the root cannot be determined, an exception is thrown to prevent incorrect path resolution.
     *
     * @return string The absolute path to the project's root directory.
     * @throws RuntimeException If the project root cannot be found.
     */
    public static function getRoot() : string
    {
        $currentDir   = __DIR__; // Im here right now
        $composerFile = 'composer.json'; // looking for composer in the project
        $rootDir      = '/'; // should be root of (any) project

        // (1) Start from the current directory
        while (! file_exists($currentDir . DIRECTORY_SEPARATOR . $composerFile)) { // (2) Check if composer.json exists
            $currentDir = dirname($currentDir); // (3) Move one directory up

            if ($currentDir === $rootDir) { // (4) Prevent infinite loop if root is not found
                throw new RuntimeException(message: 'Project root not found');
            }
        }

        // (5) Return the root path
        return $currentDir . DIRECTORY_SEPARATOR;
    }

}

=== Config/AuthConfig.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config;

/**
 * Class AuthConfig
 *
 * This class handles configuration settings for authentication,
 * allowing for dynamic retrieval from environment variables with
 * fallback to default values. This approach supports flexible and
 * easily configurable authentication mechanisms.
 */
class AuthConfig
{
    /** @var string DEFAULT_GUARD Default authentication guard */
    public const string DEFAULT_GUARD = 'session';

    /** @var string DEFAULT_PROVIDER Default authentication provider */
    public const string DEFAULT_PROVIDER = 'userProvider';

    /**
     * Retrieves the current authentication guard.
     *
     * @return string
     * The guard is first fetched from the environment variable 'AUTH_GUARD'.
     * If not set, it falls back to the default guard defined by DEFAULT_GUARD.
     */
    public static function getGuard() : string
    {
        // Fetch guard from environment or use default
        return env(key: 'AUTH_GUARD') ?: self::DEFAULT_GUARD;
    }

    /**
     * Retrieves the current authentication provider.
     *
     * @return string
     * The provider is first fetched from the environment variable 'AUTH_PROVIDER'.
     * If not set, it falls back to the default provider defined by DEFAULT_PROVIDER.
     */
    public static function getProvider() : string
    {
        // Fetch provider from environment or use default
        return env(key: 'AUTH_PROVIDER') ?: self::DEFAULT_PROVIDER;
    }
}

=== Config/Configurator/AppConfigurator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config\Configurator;

use Gemini\Config\Configurator\FileLoader\ConfigLoaderInterface;
use Gemini\DataHandling\ObjectHandling\Collections\Collection;
use RuntimeException;
use WeakMap;

/**
 * Abstract base class for managing application configuration.
 *
 * This class provides a foundational structure for configuration management,
 * using a `WeakMap` for in-memory caching, which allows for lightweight and
 * automatic cleanup of configuration data when no longer needed.
 */
abstract class AppConfigurator implements ConfiguratorInterface
{
    // WeakMap used to cache configuration data by instance of the configurator
    private static WeakMap $weakMap;

    // Holds the loaded configuration data as a Collection instance
    protected Collection $configuration;

    /**
     * Constructor to initialize the configurator with a config loader.
     *
     * @param ConfigLoaderInterface $configLoader An instance responsible for loading config files.
     */
    public function __construct(
        protected ConfigLoaderInterface $configLoader,
    ) {
        // Initialize WeakMap if not already set
        self::$weakMap ??= new WeakMap();
        // Load configuration, either from cache or fresh data
        $this->initializeConfiguration();
    }

    /**
     * Initializes configuration data.
     *
     * This method first checks if configuration data is cached for the current instance
     * in `WeakMap`. If available, it uses the cached data; otherwise, it loads a fresh
     * configuration and caches it.
     */
    private function initializeConfiguration() : void
    {
        // Check if configuration is already cached for this instance
        $this->configuration = self::$weakMap[$this] ?? $this->loadFreshConfigAndCache();
    }

    /**
     * Loads fresh configuration data from source files and caches it.
     *
     * This method loads configuration data from source files using the config loader,
     * and then caches the result in the `WeakMap` for this instance.
     *
     * @return Collection The newly loaded configuration data.
     */
    private function loadFreshConfigAndCache() : Collection
    {
        $collection = $this->loadConfigurationFiles();
        // Cache the configuration for the current instance in WeakMap
        self::$weakMap[$this] = $collection;

        return $collection;
    }

    /**
     * Loads configuration data from specified files through the config loader.
     *
     * This method iterates through each defined configuration path, loading the configuration
     * file and storing it under the appropriate namespace. The configuration data is returned
     * as a `Collection` instance for further processing.
     *
     * @return Collection The loaded configuration data.
     */
    protected function loadConfigurationFiles() : Collection
    {
        $configData = [];
        foreach ($this->getConfigurationPaths() as $namespace => $filePath) {
            // Load the configuration file and store it under the associated namespace
            $configData[$namespace] = $this->configLoader->loadConfigFile(filePath: $filePath);
        }

        return new Collection(items: $configData);
    }

    /**
     * Define paths to configuration files.
     *
     * Subclasses should implement this method to provide an associative array
     * mapping configuration namespaces to their respective file paths.
     *
     * @return array<string, string> Associative array of configuration namespaces and file paths.
     */
    abstract protected function getConfigurationPaths() : array;

    /**
     * Retrieve a configuration value by dot-notated key.
     *
     * This method supports dot notation for nested keys, allowing access to deeply nested
     * configuration values (e.g., "database.mysql.dsn"). It uses `data_get` to efficiently
     * resolve nested paths.
     *
     * @param string $key     The configuration key, supporting dot notation for nested access.
     * @param mixed  $default Default value if the key does not exist.
     *
     * @return mixed The configuration value or the default value if not found.
     * @throws RuntimeException if the configuration key does not exist and no default is provided.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Access the base data from the collection
        $items = $this->configuration->getItems();

        // Use data_get for dot-notated configuration access
        $value = data_get(target: $items, key: $key, default: $default);

        if ($value === $default && $default === null) {
            throw new RuntimeException(message: "Configuration key [" . $key . "] does not exist.");
        }

        return $value;
    }

    /**
     * Check if a specific configuration key exists.
     *
     * @param string $key The configuration key, potentially in dot notation.
     *
     * @return bool Returns true if the key exists, false otherwise.
     */
    public function has(string $key) : bool
    {
        return $this->configuration->contains($key);
    }

    /**
     * Retrieve all configuration data.
     *
     * @return Collection The entire configuration data as a Collection.
     */
    public function all() : Collection
    {
        return $this->configuration;
    }

    /**
     * Refresh the configuration data by reloading it from the source files.
     *
     * This method discards any cached configuration data for the current instance
     * and loads fresh data from the configuration files.
     *
     * @return Collection The newly loaded configuration data.
     */
    public function refresh() : Collection
    {
        return $this->configuration = $this->loadFreshConfigAndCache();
    }
}

=== Config/Configurator/ConfiguratorInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config\Configurator;

use Gemini\DataHandling\ObjectHandling\Collections\Collection;
use InvalidArgumentException;

/**
 * ConfiguratorInterface provides a contract for configuration management.
 *
 * This interface mandates methods for managing and retrieving configuration data.
 * It decouples configuration logic, enabling different components to interact with configurations
 * consistently, regardless of the specific implementation details.
 */
interface ConfiguratorInterface
{
    /**
     * Retrieves the paths to configuration files.
     *
     * By using a unified method for accessing configuration paths, the system can dynamically
     * load and manage configuration data based on varying contexts or environments.
     *
     * @return array<string, string> Associative array where the key is the configuration namespace
     *                               and the value is the path to the configuration file.
     */
    public function configurationFilePaths() : array;

    /**
     * Retrieves a configuration value by its key with an optional default.
     *
     * This method standardizes the retrieval of configuration values, reducing dependency on
     * hard-coded configuration keys and enhancing code consistency. If the key does not exist,
     * a default value can be returned.
     *
     * @param string $key     The configuration key to retrieve.
     * @param mixed  $default A default value to return if the key does not exist.
     *                        Use meaningful defaults relevant to the configuration context.
     *
     * @return mixed The configuration value, or the default if the key is missing.
     * @throws InvalidArgumentException if the configuration key does not exist and no default is provided.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Determines if a configuration key exists.
     *
     * Enables conditional logic based on the presence of specific configuration settings,
     * improving code robustness by ensuring configuration values are available when needed.
     *
     * @param string $key The configuration key to check.
     *
     * @return bool True if the key exists in the configuration, false otherwise.
     */
    public function has(string $key) : bool;

    /**
     * Returns all configuration settings as a collection.
     *
     * This provides a way to access all configurations for operations that
     * require bulk processing.
     *
     * @return Collection The complete set of configuration data.
     */
    public function all() : Collection;

    /**
     * Refreshes the configuration data by reloading from files and updating the cache.
     *
     * This method reloads the configuration from the original source files,
     * ensuring that the configuration data is current without reconstructing the object.
     *
     * @return Collection The refreshed configuration data.
     */
    public function refresh() : Collection;
}

=== Config/Configurator/FileLoader/ConfigFileLoader.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config\Configurator\FileLoader;

use RuntimeException;

/**
 * Implementation of ConfigLoaderInterface for loading configuration files.
 *
 * This class supports loading configurations from PHP and JSON files.
 * It throws exceptions for unsupported file formats and non-existent files.
 */
class ConfigFileLoader implements ConfigLoaderInterface
{
    /**
     * Load and parse the configuration from the specified file path.
     *
     * @param string $filePath The path to the configuration file.
     *
     * @return array Parsed configuration data as an associative array.
     *
     * The method determines the file extension to decide which loader method to use.
     * Throws exceptions for unsupported file formats and invalid configurations.
     */
    public function loadConfigFile(string $filePath) : array
    {
        // Ensure the file exists before attempting to load it.
        $this->ensureFileExists(filePath: $filePath);

        // Determine the file extension to identify the appropriate loading method.
        $extension = $this->getFileExtension(filePath: $filePath);

        // Use the appropriate method to load the file based on its extension.
        $config = match ($extension) {
            'php'   => $this->loadPhpFile(filePath: $filePath),
            'json'  => $this->loadJsonFile(filePath: $filePath),
            default => throw new RuntimeException(message: 'Unsupported configuration file format: ' . $extension),
        };

        // Ensure the loaded content is an array.
        $this->ensureIsArray(config: $config, filePath: $filePath);

        return $config;
    }

    /**
     * Ensure the given file path exists.
     *
     * @param string $filePath The path to the configuration file.
     *
     * @throws RuntimeException if the file does not exist.
     */
    private function ensureFileExists(string $filePath) : void
    {
        if (! file_exists($filePath)) {
            throw new RuntimeException(message: 'Configuration file not found: ' . $filePath);
        }
    }

    /**
     * Get the file extension of the provided file path.
     *
     * @param string $filePath The path to the configuration file.
     *
     * @return string The file extension.
     */
    private function getFileExtension(string $filePath) : string
    {
        return pathinfo($filePath, PATHINFO_EXTENSION);
    }

    /**
     * Load a configuration from a PHP file.
     *
     * @param string $filePath The path to the PHP configuration file.
     *
     * @return array The configuration as an associative array.
     *
     * Assumes the PHP file returns an array.
     */
    private function loadPhpFile(string $filePath) : array
    {
        return require $filePath;
    }

    /**
     * Load a configuration from a JSON file.
     *
     * @param string $filePath The path to the JSON configuration file.
     *
     * @return array The configuration as an associative array.
     * @throws RuntimeException if the JSON is invalid.
     */
    private function loadJsonFile(string $filePath) : array
    {
        $config = json_decode(file_get_contents($filePath), true);

        // Check for and handle JSON decoding errors.
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new RuntimeException(message: 'Invalid JSON format in file: ' . $filePath);
        }

        return $config;
    }

    /**
     * Ensure the given configuration is an array.
     *
     * @param mixed  $config   The loaded configuration data.
     * @param string $filePath The path to the configuration file.
     *
     * @throws RuntimeException if the configuration is not an array.
     */
    private function ensureIsArray(mixed $config, string $filePath) : void
    {
        if (! is_array($config)) {
            throw new RuntimeException(message: 'Invalid configuration format in file: ' . $filePath);
        }
    }
}

=== Config/Configurator/FileLoader/ConfigLoaderInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Config\Configurator\FileLoader;

/**
 * This interface defines the contract for loading configuration files.
 * Classes that implement this interface should provide a mechanism to
 * load and parse configuration data from a given file path.
 */
interface ConfigLoaderInterface
{
    /**
     * Load and parse the configuration from the specified file path.
     *
     * @param string $filePath The path to the configuration file.
     *
     * @return array Parsed configuration data as an associative array.
     *
     * The method signature implies that the implementation should:
     * - Handle potential file reading errors.
     * - Parse the file content appropriately (e.g., JSON, YAML).
     * - Return an empty array if the file is empty or parsing fails gracefully.
     */
    public function loadConfigFile(string $filePath) : array;
}

=== Container/Attributes/AttributeInjector.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Gemini\Container\Containers\DependencyInjector;
use Gemini\Container\Exceptions\InvalidInjectionException;
use ReflectionClass;
use ReflectionProperty;

/**
 * AttributeInjector is responsible for resolving and injecting dependencies
 * marked with the #[Inject] attribute into the properties of an object at runtime.
 * This class leverages constructor promotion for clean and expressive instantiation.
 *
 * The class ensures:
 * - Only properties with #[Inject] are processed.
 * - Properties without a proper type or with builtin types are invalid for injection.
 * - Dependencies are fetched from the provided DependencyInjector container.
 */
final readonly class AttributeInjector
{
    /**
     * Constructor for AttributeInjector.
     *
     * @param DependencyInjector $container The dependency injection container responsible for
     *                                      resolving instances required by the object properties.
     */
    public function __construct(private DependencyInjector $container) {}

    /**
     * Traverses and injects dependencies into the properties of the given object
     * that are marked with the #[Inject] attribute.
     *
     * @template T of object
     *
     * @param object $object The target object whose injectable properties need to be processed.
     *
     * @return object The same object instance with dependencies injected into its properties.
     *
     * @throws InvalidInjectionException If the type of a property to be injected is missing or invalid.
     */
    public function inject(object $object) : object
    {
        // Create a reflection of the given object to analyze its properties and metadata.
        $reflection = new ReflectionClass(objectOrClass: $object);

        // Iterate over all properties of the object.
        foreach ($reflection->getProperties() as $property) {
            // Process and attempt to inject dependency for the current property.
            $this->processProperty(object: $object, property: $property);
        }

        // Return the object after injection processing.
        return $object;
    }

    /**
     * Inspects and injects a property of the given object if it is marked with #[Inject].
     *
     * This method ensures:
     * - Properties that are already initialized are skipped.
     * - Only properties with #[Inject] are processed.
     * - A valid dependency type is required for successful resolution.
     *
     * @param object             $object   The target object that owns the property to be injected.
     * @param ReflectionProperty $property The reflection instance of the property to analyze and inject.
     *
     * @throws InvalidInjectionException If the property lacks a valid type hint or its type is builtin.
     */
    private function processProperty(object $object, ReflectionProperty $property) : void
    {
        // Skip properties that are already initialized to avoid overriding existing values.
        if ($property->isInitialized(object: $object)) {
            return;
        }

        // Retrieve attributes of the property, specifically looking for #[Inject].
        $attributes = $property->getAttributes(name: Inject::class);

        // If the #[Inject] attribute isn't present, skip further processing for this property.
        if (empty($attributes)) {
            return;
        }

        // Retrieve the type of the property to validate its suitability for injection.
        $type = $property->getType();

        // Ensure the property has a valid type and is not a built-in PHP type.
        // Injection is only applicable for custom or class types.
        if (! $type || $type->isBuiltin()) {
            throw new InvalidInjectionException(
                property: $property,
                message : "Cannot inject property '{$property->getName()}': Missing or invalid type hint."
            );
        }

        // Resolve the dependency instance using the container based on the property’s type name.
        $dependency = $this->container->get(id: $type->getName());

        // Enable modification of the property value, even if it is private or protected.
        /** @noinspection PhpExpressionResultUnusedInspection */
        $property->setAccessible(accessible: true);

        // Inject the resolved dependency into the property's value.
        $property->setValue(objectOrValue: $object, value: $dependency);
    }
}
=== Container/Attributes/Contextual.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Contextual
{
    public function __construct(
        public string      $target,
        public string|null $dependency = null
    ) {}
}
=== Container/Attributes/Inject.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_PROPERTY)]
final class Inject {}
=== Container/Attributes/Lazy.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_PROPERTY)]
final readonly class Lazy {}
=== Container/Attributes/Scope.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Scope
{
    public function __construct(public string $name) {}
}
=== Container/Attributes/ServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS)]
final class ServiceProvider {}
=== Container/Attributes/Singleton.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS)]
final class Singleton {}
=== Container/Attributes/Tag.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Tag
{
    public function __construct(public string $name) {}
}
=== Container/Containers/Application.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Gemini\Logging\ErrorHandler;
use Throwable;

/**
 * Class Application
 *
 * Final class ensures that the Application cannot be inherited from,
 * promoting design integrity and stability.
 * This class orchestrates the application lifecycle, managing bootstrapping,
 * request handling, and error management.
 */
final readonly class Application
{
    /**
     * Run the application lifecycle.
     *
     * Bootstrap the container and register services.
     * Handle incoming requests. Any uncaught exceptions are passed to the error handler.
     * Using a Container instance to manage dependencies and configurations.
     *
     */
    public function run() : void
    {
        try {
            /* @var Kernel $kernel */
            $kernel = app()->get(id: Kernel::class);
            $kernel->handleHttpRequest(); // Initiates the main request-response lifecycle via the Kernel
        } catch (Throwable $throwable) {
            // Delegates error handling to the ErrorHandler
            // The app function should be an IoC container lookup to get the ErrorHandler instance
            app()->get(id: ErrorHandler::class)->handle($throwable);
        }
    }
}
=== Container/Containers/Bootstrapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Exception;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\Facade\Facades\Storage;
use Spatie\Ignition\Ignition;

/**
 * The Bootstrapper class initializes the application's core settings and dependencies.
 * This includes loading environment variables, helper functions, routes, and setting up error handling.
 * It is the entry point for configuring the application during the bootstrap process.
 */
readonly class Bootstrapper
{
    /**
     * File permissions required for the view cache directory.
     */
    private const int REQUIRED_PERMISSIONS = 0755;

    /**
     * @param string $envFilePath     Path to the environment variables file.
     * @param string $helpersFilePath Path to the helper functions file.
     */
    public function __construct(
        private string $envFilePath,
        private string $helpersFilePath,
    ) {}

    /**
     * Initializes the core components of the application.
     *
     * This method performs all essential boot-time logic required for the framework to operate:
     *
     * - Applies hardened session cookie configuration for secure session lifecycle.
     * - Loads environment variables from the configured `.env.php` bootstrap file.
     * - Loads global helper functions required across application layers.
     * - Registers the core Dependency Injection container instance globally.
     * - Initializes Spatie Ignition for enhanced exception reporting and IDE integration.
     * - Ensures the view cache directory exists with proper permissions, and clears any residual cache.
     *
     * This method MUST be called before handling any HTTP requests, session startup, or rendering views.
     * It guarantees that the runtime environment, security context, and application state are properly initialized.
     *
     * @param ContainerInterface $container The dependency injection container instance.
     *
     * @throws Exception If any of the following fail:
     *                   - Environment or helper boot file is missing
     *                   - View cache directory cannot be created or cleared
     *                   - File system permission errors
     */
    public function bootstrap(ContainerInterface $container) : void
    {
        $this->initializeSessionSecurity();
        $this->loadConfiguration(container: $container);
        $this->initializeErrorHandling();
        $this->initializeViewCacheDirectory();
    }

    /**
     * Configures secure PHP session cookie parameters.
     *
     * Applies hardened security settings for session cookies,
     * including secure transport, HTTP-only access, and SameSite enforcement.
     * This method MUST be called before session_start().
     */
    private function initializeSessionSecurity() : void
    {
        session_set_cookie_params(
            [
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]
        );
    }

    /**
     * Loads the configuration settings for the application.
     *
     * This includes environment variables and helper functions necessary for the application's operation.
     *
     * @throws \Exception
     */
    private function loadConfiguration(ContainerInterface $container) : void
    {
        $this->loadEnvironmentVariables();
        $this->loadHelperFunctions();
        appInstance(instance: $container);
    }

    /**
     * Loads environment variables from the specified file.
     */
    private function loadEnvironmentVariables() : void
    {
        require_once $this->envFilePath;
    }

    /**
     * Loads helper functions from the specified file.
     *
     * @throws \Exception
     */
    private function loadHelperFunctions() : void
    {
        if (! file_exists($this->helpersFilePath)) {
            throw new Exception(message: 'Helpers file not found: ' . $this->helpersFilePath);
        }

        require_once $this->helpersFilePath;
    }

    /**
     * Initializes error handling using the Spatie Ignition library.
     */
    private function initializeErrorHandling() : void
    {
        Ignition::make()
            ->shouldDisplayException(
                shouldDisplayException: env(key: 'APP_DEBUG') === 'true' || config(key: 'app.debug', default: false)
            ) // Display only in debug mode
            ->setTheme(theme: 'dark')
            ->register();
    }

    /**
     * Initializes the view cache directory.
     *
     * Ensures the view cache directory exists, has the correct permissions, and clears any existing cached files.
     * If the directory does not exist, it creates it with the necessary permissions.
     *
     * @throws Exception If the directory cannot be created, permissions cannot be set, or it cannot be cleared.
     */
    private function initializeViewCacheDirectory() : void
    {
        $viewCachePath = AppPath::getRoot() . 'storage/views';

        if (Storage::exists(path: $viewCachePath)) {
            $this->ensureDirectoryPermissions(path: $viewCachePath);
            $this->clearCacheDirectory(path: $viewCachePath);
        } else {
            $this->createViewCacheDirectory(path: $viewCachePath);
        }
    }

    /**
     * Ensures the specified directory has the required permissions.
     *
     * @param string $path The path to the directory.
     *
     * @throws Exception If permissions cannot be set.
     */
    private function ensureDirectoryPermissions(string $path) : void
    {
        if (! Storage::hasPermission(path: $path, permissions: self::REQUIRED_PERMISSIONS)
            && ! Storage::setPermissions(path: $path, permissions: self::REQUIRED_PERMISSIONS)) {
            throw new Exception(
                message: "Failed to set permissions for directory at " . $path . ". Check file system permissions."
            );
        }
    }

    /**
     * Clears the specified cache directory.
     *
     * @param string $path The path to the cache directory.
     *
     * @throws Exception If the directory cannot be cleared.
     */
    private function clearCacheDirectory(string $path) : void
    {
        if (! Storage::clear(directory: $path)) {
            throw new Exception(message: "Failed to clear cache in the view cache directory at " . $path . ".");
        }
    }

    /**
     * Creates the specified view cache directory with the necessary permissions.
     *
     * @param string $path The path to the view cache directory.
     *
     * @throws Exception If the directory cannot be created or permissions set.
     */
    private function createViewCacheDirectory(string $path) : void
    {
        if (! Storage::createDirectory(directory: $path)
            || ! Storage::setPermissions(path: $path, permissions: self::REQUIRED_PERMISSIONS)) {
            throw new Exception(message: "Failed to create directory at " . $path . " with the necessary permissions.");
        }
    }

}

=== Container/Containers/DependencyInjector.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Closure;
use Gemini\Cache\InMemoryCache;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Containers\Proxy\LazyProxy;
use Gemini\Container\Containers\Registry\Bindings;
use Gemini\Container\Containers\Registry\Deferred;
use Gemini\Container\Containers\Registry\Instances;
use Gemini\Container\Containers\Registry\LifecycleHooks;
use Gemini\Container\Containers\Registry\ScopedInstances;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\Container\Exceptions\AutoResolveException;
use Gemini\Container\Exceptions\CircularDependencyException;
use Gemini\Container\Exceptions\ServiceNotFoundException;
use Gemini\Container\Exceptions\UnresolvableDependencyException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use InvalidArgumentException;
use League\Container\Exception\ContainerException;
use ReflectionClass;
use ReflectionException;
use ReflectionNamedType;
use ReflectionParameter;
use RuntimeException;
use Throwable;

/**
 * DependencyInjector
 *
 * A production-ready PSR-11 compatible service container.
 * Responsibilities:
 * - Dependency injection
 * - Singleton and scoped services
 * - Lifecycle hooks (INIT, SHUTDOWN, ERROR)
 * - In-memory caching
 *
 * This class adheres to SOLID principles and Clean Architecture guidelines.
 */
final class DependencyInjector implements ContainerInterface
{
    /**
     * Tracks the currently active scope context.
     * Used to isolate scoped service resolution per logical group (e.g. request, tenant).
     */
    private string $activeScope = 'default';

    /**
     * Indicates whether autowiring fallback is allowed.
     * When strict mode is enabled, only explicitly registered services can be resolved.
     */
    private bool $strictMode = false;


    private readonly Arrhae $contextualBindings;

    /**
     * Stores all registered bindings within the container.
     * This includes mappings of abstract types to concrete implementations.
     */
    private readonly Bindings $bindings;

    /**
     * Holds instances of singleton services that have been resolved.
     * Ensures only one instance of these services exists in the container.
     */
    private readonly Instances $instances;

    /**
     * Manages instances scoped to specific lifetimes or contexts.
     * Allows fine-grained control over the lifecycle of certain services.
     */
    private readonly ScopedInstances $scopedInstances;

    /**
     * Stores deferred bindings that will be resolved lazily.
     * Useful for optimizing performance by delaying the instantiation of services.
     */
    private readonly Deferred $deferred;

    /**
     * Tracks lifecycle hooks such as INIT, SHUTDOWN, and ERROR.
     * Enables executing custom logic during specific phases of the container's lifecycle.
     */
    private readonly LifecycleHooks $lifecycleHooks;

    /**
     * In-memory caching mechanism for storing resolved services or data.
     * Provides fast access to frequently used instances or configurations.
     */
    private readonly InMemoryCache $inMemoryCache;

    /**
     * Tracks the resolution stack during dependency resolution.
     * Used to detect and handle circular dependencies.
     */
    private array           $resolutionStack = [];

    private readonly Arrhae $scopedInstancesByScope;

    private readonly Arrhae $tagBindings;

    private readonly Arrhae $lazyBindings;

    /**
     * Constructor for the dependency injection container.
     *
     * @param int $cacheTTL Time-to-live (TTL) for the in-memory cache, in seconds.
     */
    public function __construct(private readonly int $cacheTTL = 3600)
    {
        $this->bindings               = new Bindings();
        $this->instances              = new Instances();
        $this->scopedInstances        = new ScopedInstances();
        $this->deferred               = new Deferred();
        $this->lifecycleHooks         = new LifecycleHooks();
        $this->inMemoryCache          = new InMemoryCache();
        $this->scopedInstancesByScope = new Arrhae();
        $this->contextualBindings     = new Arrhae();
        $this->tagBindings            = new Arrhae();
        $this->lazyBindings           = new Arrhae();
    }

    /**
     * Enables strict mode: disables fallback to autoResolve() for unknown services.
     *
     * This should be enabled in production for maximum control and security.
     */
    public function enableStrictMode() : void
    {
        $this->strictMode = true;
    }

    /**
     * Disables strict mode: allows fallback to reflection-based autowiring.
     */
    public function disableStrictMode() : void
    {
        $this->strictMode = false;
    }

    /**
     * Returns whether strict mode is currently active.
     *
     */
    public function isStrictMode() : bool
    {
        return $this->strictMode;
    }

    /**
     * Registers service providers specified in the configuration file.
     */
    public function registerProviders() : void
    {
        // Path to the configuration file containing the list of service providers.
        $providers = include AppPath::CONFIG->get() . '/services.php';

        foreach ($providers as $providerClass) {
            $provider = new $providerClass($this); // Pass DependencyInjector to the provider.
            $provider->register(); // Call register() to bind services.
            $provider->boot(); // Call boot() for additional setup.
        }
    }

    /**
     * Resolves a service from the container.
     */
    public function get(string $id) : mixed
    {
        if ($this->has(id: $id)) {
            return $this->resolve(abstract: $id);
        }

        // ✅ Strict mode blocks fallback resolution
        if ($this->strictMode) {
            $this->triggerHook(
                lifecycleHook: LifecycleHook::ERROR,
                args         : [new ServiceNotFoundException(serviceId: $id), $this]
            );
            throw new ServiceNotFoundException(serviceId: $id);
        }

        // ✅ Fallback to autowiring in dev/test
        if (class_exists($id)) {
            return $this->autoResolve(class: $id);
        }

        $this->triggerHook(
            lifecycleHook: LifecycleHook::ERROR,
            args         : [new ServiceNotFoundException(serviceId: $id), $this]
        );

        throw new ServiceNotFoundException(serviceId: $id);
    }

    /**
     * Checks if the container has a service registered.
     */
    public function has(string $id) : bool
    {
        if ($this->bindings->has(key: $id) || $this->instances->has(key: $id)) {
            return true;
        }

        return $this->deferred->has(key: $id);
    }

    /**
     * Resolves a service binding or auto-resolves a class.
     */
    private function resolve(string $abstract) : mixed
    {
        if (in_array($abstract, $this->resolutionStack, true)) {
            $circularDependencyException = new CircularDependencyException(
                serviceId      : $abstract,
                resolutionStack: $this->resolutionStack
            );

            $this->triggerHook(lifecycleHook: LifecycleHook::ERROR, args: [$circularDependencyException, $this]);
            throw $circularDependencyException;
        }

        $this->resolutionStack[] = $abstract;

        try {
            // ✅ Check for scoped instances first
            if ($this->scopedInstances->has(key: $abstract)) {
                $scoped = $this->scopedInstances->get(key: $abstract);

                if (! isset($scoped['instance'])) {
                    $instance           = $this->instantiate(concrete: $scoped['concrete']);
                    $scoped['instance'] = $instance;
                    $this->scopedInstances->set(key: $abstract, value: $scoped);
                }

                return $scoped['instance'];
            }

            // ✅ Check singleton cache
            if ($this->instances->has(key: $abstract)) {
                return $this->instances->get(key: $abstract);
            }

            // ✅ Check in-memory cache
            if ($cached = $this->inMemoryCache->get(key: $abstract)) {
                return $cached;
            }

            // ✅ Fallback to binding or autowiring
            $instance = $this->resolveBindingOrAutoResolve(abstract: $abstract);

            // ✅ Save singleton and cache if needed
            if ($this->bindings->get(key: $abstract)['singleton'] ?? false) {
                $this->instances->set(key: $abstract, value: $instance);
                $this->inMemoryCache->set(key: $abstract, value: $instance, ttl: $this->cacheTTL);
            }

            return $instance;
        } finally {
            array_pop($this->resolutionStack);
        }
    }

    /**
     * Triggers a lifecycle hook.
     */
    private function triggerHook(LifecycleHook $lifecycleHook, array $args = []) : void
    {
        $this->lifecycleHooks->trigger($lifecycleHook, $args);
    }

    /**
     * Instantiates a service using its concrete definition.
     */
    private function instantiate(Closure|string $concrete) : mixed
    {
        return $concrete instanceof Closure ? $concrete($this) : $this->autoResolve(class: $concrete);
    }

    /**
     * Automatically resolves a class using reflection.
     */
    private function autoResolve(string $class) : object
    {
        try {
            $reflectionClass = new ReflectionClass(objectOrClass: $class);

            if (! $reflectionClass->isInstantiable()) {
                throw new AutoResolveException(className: $class);
            }

            $constructor = $reflectionClass->getConstructor();

            if ($constructor === null) {
                return new $class();
            }

            $dependencies = array_map(
                fn(ReflectionParameter $reflectionParameter) : mixed => $this->resolveDependency(
                    reflectionParameter: $reflectionParameter
                ),
                $constructor->getParameters()
            );

            return $reflectionClass->newInstanceArgs(args: $dependencies);
        } catch (ReflectionException $reflectionException) {
            throw new AutoResolveException(className: $class, previous: $reflectionException);
        }
    }

    /**
     * Resolves a constructor dependency parameter.
     */
    private function resolveDependency(ReflectionParameter $reflectionParameter) : mixed
    {
        $type = $reflectionParameter->getType();

        // ✅ Must be a class type
        if ($type instanceof ReflectionNamedType && ! $type->isBuiltin()) {
            $dependency     = $type->getName();
            $declaringClass = $reflectionParameter->getDeclaringClass()?->getName();

            // ✅ Check for contextual binding override
            if (
                $declaringClass !== null &&
                isset($this->contextualBindings[$declaringClass][$dependency])
            ) {
                $contextual = $this->contextualBindings[$declaringClass][$dependency];

                return $this->instantiate(concrete: $contextual);
            }

            // ✅ Default resolve via container
            return $this->resolve(abstract: $dependency);
        }

        // ✅ Fallback to default value if available
        if ($reflectionParameter->isDefaultValueAvailable()) {
            return $reflectionParameter->getDefaultValue();
        }

        throw new UnresolvableDependencyException(reflectionParameter: $reflectionParameter);
    }

    /**
     * Resolves a service binding or auto-resolves a class.
     */
    private function resolveBindingOrAutoResolve(string $abstract) : mixed
    {
        if ($this->bindings->has(key: $abstract)) {
            return $this->instantiate(concrete: $this->bindings->get(key: $abstract)['concrete']);
        }

        return $this->autoResolve(class: $abstract);
    }

    /**
     * Registers any application services.
     */
    public function register() : void
    {
        $this->registerProviders();
    }

    /**
     * Boots the container after services are registered.
     */
    public function boot() : void
    {
        $this->triggerHook(lifecycleHook: LifecycleHook::INIT);
    }

    /**
     * Validates all registered bindings by resolving them.
     *
     * Useful in production to detect misconfigured services before runtime.
     *
     */
    public function validateBindings() : void
    {
        $errors = [];

        foreach ($this->allBindings() as $abstract => $_) {
            try {
                $this->get($abstract);
            } catch (Throwable $e) {
                $errors[] = "[{$abstract}] => " . $e::class . ': ' . $e->getMessage();
            }
        }

        if ($errors !== []) {
            throw new AutoResolveException(
                className: 'Container',
                previous : new RuntimeException(implode("\n", $errors))
            );
        }
    }

    /**
     * Retrieve all bindings registered in the container.
     *
     * @return array An associative array of all bindings.
     */
    public function allBindings() : array
    {
        return $this->bindings->all();
    }

    /**
     * Registers a singleton service in the container.
     */
    public function singleton(string $abstract, Closure|string $concrete) : void
    {
        $this->bind(abstract: $abstract, concrete: $concrete, singleton: true);
    }

    /**
     * Registers a service binding in the container.
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function bind(string $abstract, Closure|string|callable $concrete, bool $singleton = false) : void
    {
        if (! is_callable($concrete) && ! class_exists($concrete)) {
            throw new InvalidArgumentException(
                message: "Concrete for " . $abstract . " must be callable or a valid class."
            );
        }

        $this->bindings->set(key: $abstract, value: ['concrete' => $concrete, 'singleton' => $singleton]);
        $this->invalidateCache(id: $abstract);
        $this->rebuildDependencyGraph();
    }

    /**
     * Invalidates a specific service's cache.
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    private function invalidateCache(string $id) : void
    {
        $this->inMemoryCache->delete(key: $id);
    }

    /**
     * Rebuilds the dependency graph.
     */
    private function rebuildDependencyGraph() : void {}

    /**
     * Shuts down the application lifecycle and triggers the SHUTDOWN hook.
     */
    public function shutdown() : void
    {
        $this->triggerHook(lifecycleHook: LifecycleHook::SHUTDOWN, args: [$this]);
    }

    /**
     * Combines and returns all bindings, instances, and scoped instances.
     *
     * @return array The combined array of all bindings, instances, and scoped instances.
     */
    public function everything() : array
    {
        return array_merge($this->allBindings(), $this->allInstances(), $this->allScopedInstances());
    }

    /**
     * Retrieve all resolved singleton instances.
     *
     * @return array An associative array of all resolved singleton instances.
     */
    public function allInstances() : array
    {
        return $this->instances->all();
    }

    /**
     * Retrieve all scoped instances.
     *
     * @return array An associative array of all scoped instances.
     */
    public function allScopedInstances() : array
    {
        return $this->scopedInstances->all();
    }

    /**
     * Registers a scoped binding in the container.
     *
     * This method establishes a scoped service registration within the Dependency Injection Container.
     * Scoped services are instantiated once per scope and reused within that scope boundary.
     *
     * @param string          $abstract The abstract type/interface to be bound
     * @param \Closure|string $concrete The concrete implementation or factory closure
     * @param string|null     $scope    The scope identifier (defaults to current active scope)
     *
     * @throws \RuntimeException When scope operations fail
     *
     * @throws \InvalidArgumentException When abstract or concrete are invalid
     */
    public function scoped(
        string         $abstract,
        Closure|string $concrete,
        string|null    $scope = null
    ) : void {
        // Determine the effective scope, fallback to active scope if none provided
        $scope = $scope ?? $this->activeScope;

        // Register the concrete implementation in the scoped instances collection
        // Using dot notation to create a unique scope-specific binding key
        $this->scopedInstancesByScope->set(
            key  : "$scope.$abstract",
            value: ['concrete' => $concrete]
        );
    }

    /**
     * Flushes all scoped instance bindings from the container.
     *
     * This method is crucial for maintaining a clean dependency injection container state
     * by removing all scoped instance registrations. It's particularly useful during:
     * - Testing scenarios where a fresh container state is needed
     * - Request lifecycle completion
     * - Manual container state management
     *
     * @throws ContainerException When clearing operation fails due to internal state corruption
     */
    public function flushScope(string|null $scope = null) : void
    {
        if ($scope === null) {
            $this->scopedInstancesByScope->clear();
        } else {
            $keysToForget = array_filter(
                $this->scopedInstancesByScope->keys(),
                static fn(string $key) => str_starts_with($key, "{$scope}.")
            );

            foreach ($keysToForget as $key) {
                $this->scopedInstancesByScope->forget($key);
            }
        }
    }


    public function beginScope(string $scope) : void
    {
        $this->activeScope = $scope;

        if (! $this->scopedInstancesByScope->has($scope)) {
            $this->scopedInstancesByScope->set($scope, []);
        }
    }

    /**
     * Begins contextual binding declaration using a fluent builder pattern.
     *
     * @param string $consumer The fully qualified class name of the consumer (e.g., Controller)
     *
     * @return object Anonymous context binder builder
     */
    public function when(string $consumer) : object
    {
        /**
         * Creates an anonymous readonly configuration class for contextual dependency binding.
         * Implements the Fluent Interface pattern for intuitive dependency configuration.
         *
         * @param DependencyInjector $di       The dependency injector instance
         * @param string             $consumer The consuming class identifier
         *
         * @return object                      Anonymous readonly configuration class
         */
        return new readonly class($this, $consumer) {
            /**
             * Initializes a new configuration context with dependency injection capabilities.
             * Uses constructor promotion for clean and maintainable property declaration.
             *
             * @param DependencyInjector $di       Core dependency injection service
             * @param string             $consumer Fully qualified name of the consuming class
             */
            public function __construct(
                private DependencyInjector $di,
                private string             $consumer
            ) {}

            /**
             * Initiates the dependency configuration chain for a specific dependency.
             * Creates a fluent interface for defining contextual bindings.
             *
             * @param string $dependency Fully qualified name of the required dependency
             *
             * @return object           Anonymous readonly configuration class for binding definition
             */
            public function needs(string $dependency) : object
            {
                /**
                 * Anonymous readonly class providing the final step in dependency configuration.
                 * Implements the Builder pattern for constructing contextual bindings.
                 */
                return new readonly class(
                    $this->di,
                    $this->consumer,
                    $dependency
                ) {
                    /**
                     * Initializes the binding configuration context.
                     * Uses constructor promotion for maintaining clean code principles.
                     *
                     * @param DependencyInjector $di         Core dependency injection service
                     * @param string             $consumer   Fully qualified name of the consuming class
                     * @param string             $dependency Fully qualified name of the dependency being bound
                     */
                    public function __construct(
                        private DependencyInjector $di,
                        private string             $consumer,
                        private string             $dependency
                    ) {}

                    /**
                     * Finalizes the contextual binding configuration.
                     * Registers the implementation for the specified dependency in the given context.
                     *
                     * @param Closure|string $implementation Concrete implementation or factory for the dependency
                     */
                    public function give(Closure|string $implementation) : void
                    {
                        $this->di->addContextualBinding(
                            consumer      : $this->consumer,
                            dependency    : $this->dependency,
                            implementation: $implementation
                        );
                    }
                };
            }
        };
    }

    /**
     * Adds a contextual binding to the container for dependency injection.
     *
     * Establishes a relationship between a consumer class and its dependencies,
     * allowing for specific implementation bindings in different contexts.
     * This enables flexible dependency resolution based on the consumer's context.
     *
     * @param string         $consumer       The fully qualified class name of the consuming service
     * @param string         $dependency     The abstract type or interface being bound
     * @param Closure|string $implementation The concrete implementation or factory closure
     *
     * @throws InvalidArgumentException When invalid binding parameters are provided
     */
    public function addContextualBinding(
        string         $consumer,
        string         $dependency,
        Closure|string $implementation
    ) : void {
        // Constructs a unique binding key using dot notation and registers the implementation
        $this->contextualBindings->set(
            key  : "{$consumer}.{$dependency}",
            value: $implementation
        );
    }

    /**
     * Registers a lazy-loading binding in the container.
     *
     * This method enables dependency injection with deferred resolution through a closure.
     * The binding will only be resolved when the abstract type is actually requested,
     * providing better performance through lazy initialization.
     *
     * @param string  $abstract The abstract type or interface to be resolved
     * @param Closure $resolver The closure that defines how to resolve the binding
     *
     * @throws InvalidArgumentException When the abstract parameter is invalid
     */
    public function lazy(
        string  $abstract,
        Closure $resolver
    ) : void {
        // Register the lazy binding resolver in the container's lazy bindings collection
        $this->lazyBindings->set($abstract, static fn() => new LazyProxy($resolver));
    }

    /**
     * Associates multiple services with a specific tag identifier
     *
     * This method establishes a many-to-one relationship between services and a tag,
     * enabling service discovery through tag-based lookup.
     *
     * @param string $tag      The tag identifier to associate services with
     * @param array  $services Array of service identifiers to be tagged
     *
     * @throws InvalidArgumentException If the tag name is invalid
     */
    public function tag(string $tag, array $services) : void
    {
        $this->tagBindings->set(key: $tag, value: $services);
    }

    /**
     * Retrieves all services associated with a specific tag
     *
     * Returns an array of service identifiers that were previously tagged
     * with the specified tag. Returns an empty array if no services are found.
     *
     * @param string $tag The tag identifier to look up
     *
     * @return array<int, string> Array of service identifiers associated with the tag
     */
    public function tagged(string $tag) : array
    {
        return $this->tagBindings->get(key: $tag, default: []);
    }

    /**
     * Resolves a lazy-loaded binding from the container.
     *
     * This method is part of the Dependency Injection Container's lazy loading mechanism,
     * implementing the Service Locator pattern for improved performance through deferred
     * instantiation of dependencies.
     *
     * @param string $abstract The abstract identifier to resolve from lazy bindings
     *
     * @return mixed The resolved instance or null if no lazy binding exists
     *
     * @throws \InvalidArgumentException When the abstract identifier is invalid
     * @throws \RuntimeException When the lazy binding closure fails to execute
     */
    private function resolveLazy(string $abstract) : mixed
    {
        // Check if a lazy binding exists for the given abstract and execute its closure if found
        return $this->lazyBindings->has(key: $abstract)
            // Execute the lazy binding closure to instantiate the dependency
            ? ($this->lazyBindings->get(key: $abstract))()
            // Return null if no lazy binding exists for the given abstract
            : null;
    }

    /**
     * Resolves a scoped instance from the container based on the current active scope.
     *
     * This method implements the Scope Pattern to manage instance lifecycles within defined boundaries.
     * It ensures proper isolation of instances between different scopes while maintaining
     * singleton-like behavior within the same scope.
     *
     * @param string $abstract The abstract identifier to resolve from the container
     *
     * @return mixed The resolved instance or null if not found in current scope
     *
     * @throws AutoResolveException When unable to instantiate the concrete implementation
     */
    private function resolveScoped(string $abstract) : mixed
    {
        // Construct the unique scope key by combining active scope and abstract identifier
        $scopeKey = $this->activeScope . '.' . $abstract;

        // Early return if no entry exists for the given scope key
        if (! $this->scopedInstancesByScope->has(key: $scopeKey)) {
            return null;
        }

        // Retrieve the scoped entry containing concrete implementation and optional instance
        $entry = $this->scopedInstancesByScope->get(key: $scopeKey);

        // Lazy instantiation of the concrete implementation if the instance doesn't exist
        if (! isset($entry['instance'])) {
            // Create a new instance using the stored concrete implementation
            $entry['instance'] = $this->instantiate(concrete: $entry['concrete']);
            // Update the scope registry with the newly created instance
            $this->scopedInstancesByScope->set(key: $scopeKey, value: $entry);
        }

        // Return the resolved scoped instance
        return $entry['instance'];
    }
}

=== Container/Containers/Kernel.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Gemini\Exceptions\ValidationException;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\RouterInterface;
use Gemini\Logging\ErrorHandler;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * Class Kernel
 *
 * Handles the HTTP request lifecycle, from middleware resolution to request dispatching
 * and error handling.
 * Encapsulates all logic required to process a web request.
 */
final class Kernel
{
    /**
     * @var array<callable> $middlewares
     */
    private array $middlewares = [];

    public function __construct(
        private readonly RouterInterface $router,
        private readonly ErrorHandler    $errorHandler,
    ) {}

    /**
     * Executes the complete HTTP lifecycle: request creation, middleware, routing and response.
     *
     * @throws \JsonException
     */
    public function handleHttpRequest() : void
    {
        $request = Request::createFromGlobals();

        try {
            $this->registerMiddlewares();
            $response = $this->generateResponse(request: $request);
            $this->sendResponse(response: $response);
        } catch (Throwable $throwable) {
            $this->handleException(throwable: $throwable);
        }
    }

    /**
     * Registers global middleware defined in configuration.
     */
    private function registerMiddlewares() : void
    {
        $this->middlewares = $this->resolveConfiguredMiddlewares();
    }

    /**
     * Resolves middleware from configuration and dependency container.
     *
     * @return array<callable> Resolved middleware handlers
     */
    private function resolveConfiguredMiddlewares() : array
    {
        $middlewareClasses = config(key: 'middleware.global');

        return array_map(
            static fn(string $middlewareClass) => app()->get($middlewareClass),
            $middlewareClasses
        );
    }

    /**
     * Builds the middleware stack and dispatches the request to the router.
     *
     * @param Request $request
     *
     * @return ResponseInterface
     */
    private function generateResponse(Request $request) : ResponseInterface
    {
        $handler = fn(Request $request) : ResponseInterface => $this->router->resolve($request);
        foreach (array_reverse($this->middlewares) as $middleware) {
            $currentHandler = $handler;
            $handler        = static fn(Request $request) : ResponseInterface => $middleware->handle(
                $request,
                $currentHandler
            );
        }

        return $handler($request);
    }

    /**
     * Sends a fully formed PSR-7 response to the client.
     *
     * @param ResponseInterface $response
     */
    private function sendResponse(ResponseInterface $response) : void
    {
        if (! headers_sent()) {
            http_response_code($response->getStatusCode());

            foreach ($response->getHeaders() as $name => $values) {
                foreach ($values as $value) {
                    header(header: "{$name}: {$value}", replace: false);
                }
            }
        } else {
            error_log(message: '⚠️ Headers already sent, unable to modify HTTP response headers.');
        }

        echo (string) $response->getBody();
    }

    /**
     * Handles any uncaught exceptions and renders a proper error response.
     *
     * @param Throwable $throwable
     *
     * @throws \JsonException
     */
    private function handleException(Throwable $throwable) : void
    {
        if ($throwable instanceof ValidationException) {
            $response = $this->errorHandler->render(throwable: $throwable);
            $this->sendResponse(response: $response->toResponse());

            return;
        }

        $this->errorHandler->handle(throwable: $throwable);
    }

    /**
     * Allows runtime appending of additional middleware.
     *
     * @param array<callable> $middlewares
     */
    public function addMiddlewares(array $middlewares) : void
    {
        $this->middlewares = array_merge($this->middlewares, $middlewares);
    }
}

=== Container/Containers/LifecycleHook.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

enum LifecycleHook: string
{
    /**
     * Called when the container is initialized.
     */
    case INIT = 'init';

    /**
     * Called when the container is shutting down.
     */
    case SHUTDOWN = 'shutdown';

    /**
     * Called when an error occurs within the container.
     */
    case ERROR = 'error';

    /**
     * Get all available lifecycle hook types.
     *
     * @return array<string> List of lifecycle hook values.
     */
    public static function all() : array
    {
        return array_map(static fn(self $hook) : string => $hook->value, self::cases());
    }

    /**
     * Check if a given value is a valid lifecycle hook.
     *
     * @param string $value The value to check.
     *
     * @return bool True if the value is a valid lifecycle hook, false otherwise.
     */
    public static function isValid(string $value) : bool
    {
        return in_array($value, self::all(), true);
    }
}

=== Container/Containers/Proxy/LazyProxy.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Proxy;

use Closure;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * Implements a lazy loading proxy pattern for deferred object initialization.
 * This proxy delays the creation of expensive objects until they are actually needed,
 * optimizing resource utilization and improving application performance.
 *
 * @template T of object
 * @final
 */
final class LazyProxy
{
    /**
     * Metadata container for storing the proxied instance and related information.
     * Using Arrhae for type-safe key-value storage operations.
     *
     * @var Arrhae<string, T>
     */
    private Arrhae $meta;

    /**
     * Initializes a new lazy proxy instance with a resolver closure.
     * Implements constructor promotion for cleaner dependency injection.
     *
     * @param Closure(): T $resolver Factory closure that creates the actual instance when needed
     */
    public function __construct(private readonly Closure $resolver)
    {
        $this->meta = new Arrhae();
    }

    /**
     * Dynamically forwards method calls to the proxied instance.
     * Ensures instance initialization before method invocation.
     *
     * @param string            $method The method name being called
     * @param array<int, mixed> $args   Arguments passed to the method
     *
     * @return mixed The result of the method call on the proxied instance
     */
    public function __call(string $method, array $args) : mixed
    {
        $this->init();

        return $this->meta->get(key: 'instance')->$method(...$args);
    }

    /**
     * Initializes the proxied instance if it hasn't been created yet.
     * Uses a lazy initialization pattern to defer object creation.
     */
    private function init() : void
    {
        if (! $this->meta->has(key: 'instance')) {
            $this->meta->set(key: 'instance', value: ($this->resolver)());
        }
    }

    /**
     * Dynamically forwards property access to the proxied instance.
     * Ensures instance initialization before property access.
     *
     * @param string $prop The property name being accessed
     *
     * @return mixed The value of the property from the proxied instance
     */
    public function __get(string $prop) : mixed
    {
        $this->init();

        return $this->meta->get(key: 'instance')->$prop;
    }

    /**
     * Resets the proxy by removing the cached instance.
     * Allows for re-initialization of the proxied object if needed.
     */
    public function reset() : void
    {
        $this->meta->forget(key: 'instance');
    }

    /**
     * Checks if the proxied instance has been initialized.
     *
     * @return bool True if the instance exists, false otherwise
     */
    public function hasInstance() : bool
    {
        return $this->meta->has(key: 'instance');
    }

    /**
     * Retrieves the proxied instance directly.
     * Note: This method doesn't ensure initialization.
     *
     * @return object|null The proxied instance if initialized, null otherwise
     */
    public function getInstance() : object|null
    {
        return $this->meta->get(key: 'instance');
    }
}
=== Container/Containers/Registry/Bindings.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Bindings extends Arrhae {}
=== Container/Containers/Registry/ChildContainers.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class ChildContainers extends Arrhae {}
=== Container/Containers/Registry/DeferredContainerRegistry.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Deferred extends Arrhae {}
=== Container/Containers/Registry/Deferred.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Deferred extends Arrhae {}
=== Container/Containers/Registry/DependencyGraph.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class DependencyGraph extends Arrhae {}
=== Container/Containers/Registry/Instances.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Instances extends Arrhae {}
=== Container/Containers/Registry/LifecycleHooks.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\Container\Containers\LifecycleHook;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * LifecycleHooks
 *
 * A specialized registry for managing lifecycle hooks, leveraging Arrhae for array-like behavior.
 *
 * This class inherits from Arrhae to use its array-like operations and provides functionality
 * to register, trigger, and clear lifecycle hooks. Each lifecycle hook corresponds to a set
 * of callbacks that are executed when the hook is triggered.
 */
class LifecycleHooks extends Arrhae
{
    /**
     * Initialize the registry with keys for each lifecycle hook.
     *
     * The constructor ensures that every possible lifecycle hook is
     * initialized with an empty array to avoid key existence checks later.
     */
    public function __construct()
    {
        parent::__construct();
        // Ensure every LifecycleHook is initialized with an empty array
        foreach (LifecycleHook::cases() as $hook) {
            $this[$hook->value] = [];
        }
    }

    /**
     * Register a callback for a specific lifecycle hook.
     *
     * The registered callback will be executed when the corresponding
     * lifecycle hook is triggered.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to register the callback for.
     * @param callable      $callback The callback function to be executed.
     */
    public function register(LifecycleHook $lifecycleHook, callable $callback) : void
    {
        $this[$lifecycleHook->value][] = $callback;
    }

    /**
     * Trigger a lifecycle hook.
     *
     * Executes all registered callbacks for the specified hook. This method
     * passes any provided arguments to the callback functions.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to trigger.
     * @param mixed         ...$args Arguments passed to the callbacks.
     */
    public function trigger(LifecycleHook $lifecycleHook, mixed ...$args) : void
    {
        $callbacks = $this[$lifecycleHook->value] ?? [];
        foreach ($callbacks as $callback) {
            $callback(...$args);
        }
    }

    /**
     * Clear all callbacks for a specific lifecycle hook.
     *
     * This method removes all registered callbacks for the given lifecycle hook,
     * effectively resetting it.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to clear callbacks for.
     */
    public function clear(LifecycleHook $lifecycleHook) : void
    {
        $this[$lifecycleHook->value] = [];
    }
}
=== Container/Containers/Registry/ScopedInstances.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * Manages scoped instance registry within the dependency injection container.
 *
 * This registry maintains a collection of instances that are bound to a specific
 * container scope. It provides functionality to manage the lifecycle of these
 * instances, ensuring proper scope isolation and memory management.
 *
 * @template TKey of string
 * @template TValue of object
 * @extends Arrhae<TKey, TValue>
 *
 * @immutable
 * @final
 */
class ScopedInstances extends Arrhae
{
    /**
     * Clears all registered instances from the current scope.
     *
     * This operation ensures proper cleanup of scoped instances by iterating
     * through all registered entries and removing them individually. This
     * method is crucial for preventing memory leaks when a scope is terminated.
     *
     * @throws \RuntimeException If unable to clear instances due to internal state corruption
     *
     */
    public function clear() : void
    {
        // Iterate through all registered instances in the current scope
        foreach ($this->all() as $key => $value) {
            // Remove each instance individually to ensure proper cleanup
            $this->forget($key);
        }
    }
}
=== Container/Contracts/ContainerInterface.php ===
<?php
declare(strict_types=1);

namespace Gemini\Container\Contracts;

/**
 * Interface defining the contract for a dependency injection container.
 *
 * Extends the PSR-11 ContainerInterface to provide additional methods for
 * registering, bootstrapping, and binding services. This interface is
 * essential for the application's dependency management and lifecycle.
 */
interface ContainerInterface extends \Psr\Container\ContainerInterface
{
    /**
     * Register any application services.
     *
     * This method is called once during the application's bootstrapping process.
     * Use this method to bind any essential services or classes to the container.
     */
    public function register() : void;

    /**
     * Bootstrap any application services.
     *
     * Called after service providers are registered. It is meant for initializing
     * middleware, event listeners, and deferred services before handling requests.
     */
    public function boot() : void;

    /**
     * Bind a service to the container.
     *
     * This method binds a concrete implementation or a closure to an abstract class
     * or interface. This allows the container to resolve it when requested,
     * facilitating dependency injection.
     *
     * @param string $abstract         The abstract name or interface.
     * @param callable|string $concrete The concrete implementation or closure.
     */
    public function bind(string $abstract, callable|string $concrete) : void;

    /**
     * Retrieve a service from the container.
     *
     * This method will fetch the service associated with the given identifier.
     *
     * @param string $id The identifier of the service.
     * @return mixed The instance of the service, or throws an exception if the id is not known to the container.
     */
    public function get(string $id): mixed;

    /**
     * Check if the container has a service for the given identifier.
     *
     * Returns true if the container can return an entry for the given identifier,
     * false otherwise.
     *
     * @param string $id The identifier of the service.
     * @return bool Whether the service exists in the container.
     */
    public function has(string $id): bool;
}
=== Container/Exceptions/AutoResolveException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use Throwable;

/**
 * Thrown when automatic resolution of a class or dependency fails.
 */
class AutoResolveException extends \RuntimeException
{
    public function __construct(string $className, Throwable|null $previous = null)
    {
        $detailedMessage = $this->generateDetailedMessage($className, $previous);

        parent::__construct(
            message: $detailedMessage,
            code: 0,
            previous: $previous
        );
    }

    /**
     * Generates a detailed error message with file, line, stack trace, and previous exception details.
     *
     * @param string $className The name of the class that failed to resolve.
     * @param Throwable|null $previous The previous exception, if any.
     * @return string The detailed error message.
     */
    private function generateDetailedMessage(string $className, Throwable|null $previous): string
    {
        $message = sprintf("Failed to automatically resolve the class '%s'. Check the class dependencies.", $className);

        if ($previous instanceof \Throwable) {
            $file = $previous->getFile();
            $line = $previous->getLine();
            $prevMessage = $previous->getMessage();
            $stackTrace = $previous->getTraceAsString();

            $message .= PHP_EOL
                        . "Previous exception details:" . PHP_EOL
                        . ('  File: ' . $file) . PHP_EOL
                        . ('  Line: ' . $line) . PHP_EOL
                        . sprintf("  Message: '%s'", $prevMessage) . PHP_EOL
                        . "  Stack trace:" . PHP_EOL
                        . $stackTrace;
        }

        return $message;
    }
}

=== Container/Exceptions/CircularDependencyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use ReflectionClass;
use ReflectionException;
use RuntimeException;
use Throwable;

/**
 * Thrown when a circular dependency is detected during resolution.
 */
class CircularDependencyException extends RuntimeException
{
    public function __construct(
        string         $serviceId,
        array          $resolutionStack,
        int            $code = 0,
        Throwable|null $previous = null
    ) {
        $formattedStack  = implode(' -> ', $resolutionStack);
        $reflectionHints = self::generateDebugHints($resolutionStack);
        $suggestions     = self::suggestFix($serviceId);

        $message = <<<TEXT
            ❌ Circular dependency detected while resolving service: '$serviceId'
            🌀 Resolution stack:
              $formattedStack
            
            🔍 Debug hints:
            $reflectionHints
            
            💡 Suggestions:
            $suggestions
            TEXT;

        parent::__construct(message: $message, code: $code, previous: $previous);
    }

    /**
     * Generate reflection-based debug output.
     *
     * @param string[] $resolutionStack
     *
     * @return string
     */
    private static function generateDebugHints(array $resolutionStack) : string
    {
        $lines = [];

        foreach ($resolutionStack as $class) {
            try {
                $r    = new ReflectionClass($class);
                $file = $r->getFileName();
                $line = $r->getStartLine();

                $lines[] = "• {$class}  (defined in {$file}:{$line})";
            } catch (ReflectionException) {
                $lines[] = "• {$class}  (could not locate source)";
            }
        }

        return implode("\n", $lines);
    }

    /**
     * Suggest common ways to break circular dependency.
     */
    private static function suggestFix(string $serviceId) : string
    {
        return <<<SUGGEST
            - Use constructor injection only for stable leaf services.
            - Break cycle by:
                • Introducing a factory/service locator for one of the deps.
                • Using an interface or abstract class with deferred resolution.
                • Lazy loading with Closure or `fn() => app()->get(...)`.
            
            - Check if $serviceId is indirectly requiring itself.
            SUGGEST;
    }
}

=== Container/Exceptions/ClassNotInstantiableException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

/**
 * Thrown when attempting to instantiate a class that is not instantiable.
 */
class ClassNotInstantiableException extends \RuntimeException
{
    public function __construct(string $className, int $code = 0, \Throwable|null $previous = null)
    {
        parent::__construct(
            message: sprintf("Class '%s' is not instantiable. Ensure it is not abstract or an interface.", $className),
            code: $code,
            previous: $previous
        );
    }
}
=== Container/Exceptions/FrameworkContainerException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use Exception;

/**
 * This exception class represents errors specific to the framework's dependency injection container.
 * Extending from the base Exception class provides a standardized way to handle these errors.
 */
class FrameworkContainerException extends Exception
{
    /**
     * Default error message given when no specific message is provided.
     */
    private const string DEFAULT_MESSAGE = 'A container exception has occurred.';

    /**
     * Constructs the FrameworkContainerException.
     *
     * @param string         $message  Custom error message that describes the exception.
     * @param int            $code     Optional error code for the exception.
     * @param Exception|null $previous Optional previous exception for chaining exceptions.
     */
    public function __construct(string $message = self::DEFAULT_MESSAGE, int $code = 0, Exception|null $previous = null)
    {
        // Calling the parent constructor to ensure proper exception handling.
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== Container/Exceptions/InvalidInjectionException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use ReflectionProperty;
use RuntimeException;

/**
 * Exception thrown when an invalid property injection is detected.
 *
 * This exception is designed to communicate issues related to injecting dependencies into
 * a class property. It provides additional context about the problematic property for
 * debugging and resolution purposes.
 *
 * @package Gemini\Container\Exception
 */
class InvalidInjectionException extends RuntimeException
{
    /**
     * The name of the property where injection failed.
     *
     * This property stores the exact name of the class property that caused the injection
     * error, aiding in debugging and resolution.
     *
     * @var string
     */
    private string $propertyName;

    /**
     * Constructs a new InvalidInjectionException instance.
     *
     * This constructor accepts a `ReflectionProperty` representing the property
     * where the injection failed and a custom error message.
     *
     * @param ReflectionProperty $property The reflection of the property where injection failed.
     * @param string             $message  A detailed descriptive error message explaining the cause.
     */
    public function __construct(ReflectionProperty $property, string $message)
    {
        // Assigns the problematic property's name to the private property for future reference.
        $this->propertyName = $property->getName();

        // Calls the parent RuntimeException constructor with a named argument for the error message.
        parent::__construct(message: $message);
    }

    /**
     * Retrieves the name of the property causing the injection error.
     *
     * This method provides clients with access to the name of the property that caused
     * the exception, allowing for targeted debugging or error reporting.
     *
     * @return string The name of the problematic property.
     */
    public function getPropertyName() : string
    {
        return $this->propertyName;
    }
}
=== Container/Exceptions/ServiceNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use RuntimeException;
use Throwable;

/**
 * Thrown when a requested service cannot be found in the container.
 */
class ServiceNotFoundException extends RuntimeException
{
    public function __construct(string $serviceId, int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct(
            message : sprintf("Action '%s' not found in the container.", $serviceId),
            code    : $code,
            previous: $previous
        );
    }
}
=== Container/Exceptions/UnresolvableDependencyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

/**
 * Thrown when a dependency cannot be resolved due to missing type hints or invalid configuration.
 */
class UnresolvableDependencyException extends \RuntimeException
{
    public function __construct(\ReflectionParameter $reflectionParameter, int $code = 0, \Throwable|null $previous = null)
    {
        $message = sprintf(
            "Cannot resolve dependency '%s' in parameter '%s' of function/method '%s'.",
            $reflectionParameter->getType()?->getName() ?? 'unknown type',
            $reflectionParameter->getName(),
            $reflectionParameter->getDeclaringFunction()->getName() ?? 'unknown function'
        );

        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}
=== Container/ServiceProviders/Contracts/ServiceProviderInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Contracts;

/**
 * ServiceProviderInterface
 *
 * Defines the basic contract for service providers, including
 * methods for registering and booting services in the application container.
 */
interface ServiceProviderInterface
{
    /**
     * Registers services into the container.
     *
     * This is where bindings and singleton instances should be added
     * to make them available for dependency injection.
     */
    public function register() : void;

    /**
     * Boots registered services.
     *
     * Called after all services have been registered. Used to perform any
     * additional setup or configuration for services.
     */
    public function boot() : void;
}

=== Container/ServiceProviders/Providers/AuthenticationServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;


use Gemini\Auth\Application\Action\LoginAction;
use Gemini\Auth\Application\Action\LogoutAction;
use Gemini\Auth\Application\Action\RegisterUserAction;
use Gemini\Auth\Application\Service\AuthenticationService;
use Gemini\Auth\Application\UseCase\API\ApiLoginUseCase;
use Gemini\Auth\Application\UseCase\API\ApiLogoutUseCase;
use Gemini\Auth\Application\UseCase\API\ApiRegisterUseCase;
use Gemini\Auth\Application\UseCase\Web\LoginUseCase;
use Gemini\Auth\Application\UseCase\Web\RetrieveCurrentUserUseCase;
use Gemini\Auth\Application\UseCases\Web\LogoutUseCase;
use Gemini\Auth\Application\UseCases\Web\RegisterUseCase;
use Gemini\Auth\Contracts\AuthenticationServiceInterface;
use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\Domain\ValueObject\Credentials;
use Gemini\Auth\Infrastructure\Identity\Session\SessionIdentity;
use Gemini\Auth\Infrastructure\Security\PasswordHasher;
use Gemini\Auth\Infrastructure\User\DB\User;
use Gemini\Auth\Interface\HTTP\Middleware\AuthenticationMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\PermissionMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\RoleMiddleware;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Gemini\HTTP\Security\CsrfTokenManager;

/**
 * Action provider for authentication services.
 *
 * This class handles the registration of dependencies related to the authentication
 * system within the service container. Each dependency is registered as a singleton,
 * meaning the same instance will be reused throughout the application lifecycle.
 */
class AuthenticationServiceProvider extends ServiceProvider
{

    /**
     * Register authentication-related services and their dependencies.
     *
     * This method binds various authentication-related classes and interfaces to the service container,
     * ensuring that they are instantiated properly and are available for dependency injection.
     *
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(abstract: PasswordHasher::class, concrete: PasswordHasher::class);
        $this->dependencyInjector->singleton(abstract: CredentialsInterface::class, concrete: Credentials::class);

        // Register the UserRegistrationService
        $this->dependencyInjector->singleton(
            abstract: RegisterUserAction::class,
            concrete: fn() => new RegisterUserAction(
                userProvider: $this->dependencyInjector->get(UserSourceInterface::class)
            )
        );

        // Register the RegisterUseCase
        $this->dependencyInjector->singleton(
            abstract: RegisterUseCase::class,
            concrete: fn() => new RegisterUseCase(
                registerService: $this->dependencyInjector->get(RegisterUserAction::class)
            )
        );


        $this->dependencyInjector->singleton(
            abstract: AuthenticationServiceInterface::class,
            concrete: fn() => new AuthenticationService(
                identity: $this->dependencyInjector->get(SessionIdentity::class)
            )
        );


        $this->dependencyInjector->singleton(abstract: IdentityInterface::class, concrete: fn(
        ) : SessionIdentity => new SessionIdentity(
            session     : $this->dependencyInjector->get(id: Session::class),
            userProvider: $this->dependencyInjector->get(id: User::class)
        ));
        $this->dependencyInjector->singleton(
            abstract: UserSourceInterface::class,
            concrete: fn() : User => new User(
                queryBuilder  : $this->dependencyInjector->get(id: QueryBuilder::class),
                passwordHasher: $this->dependencyInjector->get(PasswordHasher::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: AuthenticationMiddleware::class,
            concrete: AuthenticationMiddleware::class
        );
        $this->dependencyInjector->singleton(
            abstract: PermissionMiddleware::class,
            concrete: PermissionMiddleware::class
        );
        $this->dependencyInjector->singleton(abstract: RoleMiddleware::class, concrete: RoleMiddleware::class);
        $this->dependencyInjector->singleton(
            abstract: ApiLoginUseCase::class,
            concrete: ApiLoginUseCase::class
        );
        $this->dependencyInjector->singleton(abstract: ApiLogoutUseCase::class, concrete: ApiLogoutUseCase::class);
        $this->dependencyInjector->singleton(abstract: ApiRegisterUseCase::class, concrete: ApiRegisterUseCase::class);

        $this->dependencyInjector->singleton(
            abstract: LoginUseCase::class,
            concrete: fn() => new LoginUseCase(
                loginAction: $this->dependencyInjector->get(LoginAction::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: LogoutAction::class,
            concrete: fn() => new LogoutAction(
                authenticationService: $this->dependencyInjector->get(AuthenticationService::class),
                csrfTokenManager     : $this->dependencyInjector->get(CsrfTokenManager::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: LogoutUseCase::class,
            concrete: fn() => new LogoutUseCase(
                logoutService: $this->dependencyInjector->get(LogoutAction::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: RetrieveCurrentUserUseCase::class,
            concrete: RetrieveCurrentUserUseCase::class
        );
    }

    /**
     * Additional bootstrapping logic for authentication services.
     *
     * This method can be used to initialize additional configurations or dependencies required
     * for the authentication services after all services have been registered.
     */
    public function boot() : void
    {
        // Additional boot logic for auth services if required
    }
}
=== Container/ServiceProviders/Providers/BootstrapServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Containers\Application;
use Gemini\Container\Containers\Bootstrapper;
use Gemini\Container\Containers\Kernel;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Router\Router;
use Gemini\Logging\ErrorHandler;

/**
 * Class BootstrapServiceProvider
 *
 * This service provider is responsible for registering core services into the service container.
 * It follows the Dependency Inversion Principle, ensuring high-level modules depend on abstractions
 * rather than concrete implementations, enhancing flexibility and testability.
 */
class BootstrapServiceProvider extends ServiceProvider
{
    /**
     * Registers the necessary services into the service container.
     *
     * This method defines how services or configurations should be registered
     * within the service container, making them available for dependency injection
     * and use throughout the application.
     *
     */
    public function register() : void
    {
        // Register Bootstrapper singleton with required dependencies.
        $this->dependencyInjector->singleton(
            abstract: Bootstrapper::class,
            concrete: fn() : Bootstrapper => new Bootstrapper(
                envFilePath    : AppPath::getRoot() . 'env.php', // Dynamically resolves the env file path.
                helpersFilePath: AppPath::HELPERS_PATH->get(), // Dynamically resolves the helpers file path.
            )
        );

        // Register Application singleton with Kernel dependency.
        $this->dependencyInjector->singleton(
            abstract: Application::class,
            concrete: static fn() : Application => new Application()
        );

        // Register Kernel singleton with Router and ErrorHandler dependencies.
        $this->dependencyInjector->singleton(
            abstract: Kernel::class,
            concrete: fn() : Kernel => new Kernel(
                router      : $this->dependencyInjector->get(Router::class),
                errorHandler: $this->dependencyInjector->get(ErrorHandler::class)
            )
        );
    }

    /**
     * Starts the boot process for the class.
     * This method can be optionally overridden by derived classes to implement specific boot logic.
     *
     * @throws \Exception
     */
    public function boot() : void
    {
        /** @var Bootstrapper $bootstrapper */
        $bootstrapper = $this->dependencyInjector->get(Bootstrapper::class);
        $bootstrapper->bootstrap($this->dependencyInjector);
    }
}
=== Container/ServiceProviders/Providers/CommandServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Commands\App\MakeControllerCommand;
use Gemini\Commands\App\MakeEntityCommand;
use Gemini\Commands\App\MakeRepositoryCommand;
use Gemini\Commands\App\MakeServiceCommand;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Design\Mapper\FluentFieldToDslMapper;
use Gemini\Database\Migration\Runner\Commands\{ValidateStubsCommand};
use Gemini\Database\Migration\Runner\Commands\MakeMigrationCommand;
use Gemini\Database\Migration\Runner\Generators\{Repository\RepositoryGenerator};
use Gemini\Database\Migration\Runner\Generators\Controller\ControllerGenerator;
use Gemini\Database\Migration\Runner\Generators\DTO\DtoGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityQueryBuilderGenerator;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Gemini\Database\Migration\Runner\Manifest\ManifestStoreInterface;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\SchemaBuilder;
use Gemini\Database\Migration\Runner\Service\MigrationExecution;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Psr\Log\LoggerInterface;

class CommandServiceProvider extends ServiceProvider
{
    /**
     * Registers all services and commands into the container.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: Column::class,
            concrete: static fn() => new Column()
        );

        $this->dependencyInjector->singleton(
            abstract: FieldToDslMapperInterface::class,
            concrete: static fn() => new FluentFieldToDslMapper()
        );

        $this->dependencyInjector->singleton(
            abstract: MigrationGenerator::class,
            concrete: fn() => new MigrationGenerator(
                mapper       : $this->dependencyInjector->get(FieldToDslMapperInterface::class),
                manifestStore: $this->dependencyInjector->get(ManifestStoreInterface::class),
            )
        );

        $this->dependencyInjector->singleton(
            abstract: EntityGenerator::class,
            concrete: static fn() => new EntityGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: EntityQueryBuilderGenerator::class,
            concrete: static fn() => new EntityQueryBuilderGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: DtoGenerator::class,
            concrete: static fn() => new DtoGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: RepositoryGenerator::class,
            concrete: static fn() => new RepositoryGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: ServiceGenerator::class,
            concrete: static fn() => new ServiceGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: ControllerGenerator::class,
            concrete: static fn() => new ControllerGenerator()
        );

        // Register the MigrationExecution
        $this->dependencyInjector->singleton(
            abstract: MigrationRepositoryInterface::class,
            concrete: fn() => new MigrationExecution(
                queryBuilder: $this->dependencyInjector->get(QueryBuilder::class),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MigrationExecution::class,
            concrete: MigrationExecution::class
        );

        // Bind migration state manager
        $this->dependencyInjector->singleton(
            abstract: MigrationStateManager::class,
            concrete: fn() => new MigrationStateManager(
                migrationRepository: $this->dependencyInjector->get(MigrationExecution::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        // Schema builder and transaction manager
        $this->dependencyInjector->singleton(
            abstract: SchemaBuilder::class,
            concrete: fn() => new SchemaBuilder(
                queryBuilder: $this->dependencyInjector->get(QueryBuilder::class),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        // Bind each command to the container
        $this->dependencyInjector->singleton(
            abstract: MakeMigrationCommand::class,
            concrete: fn() => new MakeMigrationCommand(
                migrationGenerator         : $this->dependencyInjector->get(MigrationGenerator::class),
                entityGenerator            : $this->dependencyInjector->get(EntityGenerator::class),
                entityQueryBuilderGenerator: $this->dependencyInjector->get(EntityQueryBuilderGenerator::class),
                dtoGenerator               : $this->dependencyInjector->get(DtoGenerator::class),
                repositoryGenerator        : $this->dependencyInjector->get(RepositoryGenerator::class),
                serviceGenerator           : $this->dependencyInjector->get(ServiceGenerator::class),
                migrationStateManager      : $this->dependencyInjector->get(MigrationStateManager::class),
                logger                     : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );


        $this->dependencyInjector->singleton(
            abstract: MakeControllerCommand::class,
            concrete: fn() => new MakeControllerCommand(
                controllerGenerator: $this->dependencyInjector->get(ControllerGenerator::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeEntityCommand::class,
            concrete: fn() => new MakeEntityCommand(
                entityGenerator: $this->dependencyInjector->get(EntityGenerator::class),
                logger         : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeRepositoryCommand::class,
            concrete: fn() => new MakeRepositoryCommand(
                repositoryGenerator: $this->dependencyInjector->get(RepositoryGenerator::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeServiceCommand::class,
            concrete: fn() => new MakeServiceCommand(
                serviceGenerator: $this->dependencyInjector->get(ServiceGenerator::class),
                logger          : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: ValidateStubsCommand::class,
            concrete: fn() => new ValidateStubsCommand(
                stubResolver: $this->dependencyInjector->get('stubResolver'),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );
    }

    /**
     * Boots the services (if needed).
     *
     * @throws \Exception
     * @throws \Throwable
     */
    public function boot() : void {}
}

=== Container/ServiceProviders/Providers/ConfigurationServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Config\Configurator\FileLoader\ConfigFileLoader;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Infrastructure\Config\Service\Config;

class ConfigurationServiceProvider extends ServiceProvider
{
    /**
     * Registers configuration-related services in the IoC container.
     *
     * This approach ensures that the application configuration is
     * only instantiated once and shared across the entire application lifecycle.
     *
     */
    public function register() : void
    {
        // Register ConfigFileLoader as a singleton to make sure
        // it is used consistently across the application.
        $this->dependencyInjector->singleton(abstract: ConfigFileLoader::class, concrete: ConfigFileLoader::class);

        // Register Config as a singleton and use a closure to lazy-load it,
        // injecting the ConfigFileLoader instance as a dependency dynamically.
        $this->dependencyInjector->singleton(
            abstract: Config::class,
            concrete: fn() : Config => new Config(
                configLoader: $this->dependencyInjector->get(id: ConfigFileLoader::class)
            )
        );
    }

    /**
     * Starts the boot process for the class. This method can be optionally
     * overridden by derived classes to implement specific boot logic.
     * It outputs a default boot message.
     */
    public function boot() : void
    {
        // TODO: Implement boot() method.
    }
}
=== Container/ServiceProviders/Providers/DatabaseServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\{Connection\ConnectionPool, DatabaseConnection, QueryBuilder\QueryBuilder, QueryBuilder\UnitOfWork};
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class DatabaseServiceProvider
 *
 * Registers and configures database-related services inside the dependency injection (DI) container.
 *
 * - ✅ **Connection Pool**: Manages database connections efficiently.
 * - ✅ **Database Connection**: Fetches connections from the pool.
 * - ✅ **Unit of Work**: Handles batch transactions.
 * - ✅ **Query Builder**: Provides a fluent API for building and executing queries.
 */
class DatabaseServiceProvider extends ServiceProvider
{
    /**
     * Registers database services in the DI container.
     */
    public function register() : void
    {
        // ✅ Regis  ter ConnectionPool
        $this->dependencyInjector->singleton(
            abstract: ConnectionPool::class,
            concrete: fn() : ConnectionPool => new ConnectionPool(
                config        : [
                                    'connections' => [
                                        'mysql' => [
                                            'connection' => config(key: 'database.connections.mysql.connection'),
                                            'username'   => config(key: 'database.connections.mysql.username'),
                                            'password'   => config(key: 'database.connections.mysql.password'),
                                            'options'    => config(
                                                key:     'database.connections.mysql.options',
                                                default: []
                                            ),
                                        ],
                                    ],
                                ],
                logger        : $this->dependencyInjector->get(LoggerInterface::class),
                maxConnections: 10
            )
        );

        // ✅ Register DatabaseConnection
        $this->dependencyInjector->singleton(
            abstract: DatabaseConnection::class,
            concrete: fn() : DatabaseConnection => new DatabaseConnection(
                connectionPool: $this->dependencyInjector->get(id: ConnectionPool::class),
                logger        : $this->dependencyInjector->get(id: LoggerInterface::class)
            )
        );

        // ✅ Register UnitOfWork (MUST be shared across multiple QueryBuilder instances)
        $this->dependencyInjector->singleton(
            abstract: UnitOfWork::class,
            concrete: fn() : UnitOfWork => new UnitOfWork(
                databaseConnection: $this->dependencyInjector->get(id: DatabaseConnection::class)
            )
        );

        // ✅ Register QueryBuilder
        $this->dependencyInjector->singleton(
            abstract: QueryBuilder::class,
            concrete: fn() : QueryBuilder => new QueryBuilder(
                databaseConnection: $this->dependencyInjector->get(id: DatabaseConnection::class),
                unitOfWork        : $this->dependencyInjector->get(id: UnitOfWork::class),
                logger            : $this->dependencyInjector->get(id: LoggerInterface::class)
            )
        );
    }

    /**
     * Performs an optional database connectivity test during boot.
     *
     * Ensures that the database is accessible before usage.
     */
    public function boot() : void
    {
        try {
            $this->dependencyInjector->get(id: DatabaseConnection::class)->testConnection();
        } catch (Throwable $throwable) {
            // ❌ Log database connection errors
            $logger = $this->dependencyInjector->get(id: LoggerInterface::class);
            $logger->error(
                'Database connection failed in DatabaseServiceProvider::boot() : ' .
                $throwable->getMessage()
            );
        }
    }
}

=== Container/ServiceProviders/Providers/FilesystemServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\Migration\Runner\Manifest\ManifestDB;
use Gemini\Database\Migration\Runner\Manifest\ManifestDBInterface;
use Gemini\Database\Migration\Runner\Manifest\ManifestStore;
use Gemini\Database\Migration\Runner\Manifest\ManifestStoreInterface;
use Gemini\Filesystem\Storage\FileStorageInterface;
use Gemini\Filesystem\Storage\Filesystem;
use Gemini\Filesystem\Storage\LocalFileStorage;

/**
 * Service Provider responsible for filesystem-related dependency registrations.
 *
 * This provider manages the registration of filesystem services and their dependencies,
 * including local storage implementations, filesystem abstractions, and migration manifest
 * storage components. It follows the Repository pattern for data access abstraction and
 * supports the Domain-Driven Design principles through clear boundary definitions.
 *
 * @package Gemini\Container\ServiceProviders\Providers
 * @final   This class is not intended for inheritance
 */
final class FilesystemServiceProvider extends ServiceProvider
{
    /**
     * Registers filesystem-related services in the dependency injection container.
     *
     * This method implements the registration of core filesystem services following
     * the Interface Segregation Principle (ISP) and Dependency Inversion Principle (DIP).
     * It establishes the necessary bindings for:
     * - File storage implementations
     * - Filesystem abstraction layer
     * - Migration manifest storage system
     *
     * @return void
     *
     */
    public function register() : void
    {
        // Bind the file storage interface to its local implementation
        // This provides the foundational storage capabilities
        $this->dependencyInjector->singleton(
            abstract: FileStorageInterface::class,
            concrete: LocalFileStorage::class
        );

        // Register the filesystem service with its storage dependency
        // Creates a new Filesystem instance with proper storage injection
        $this->dependencyInjector->singleton(
            abstract: Filesystem::class,
            concrete: fn() : Filesystem => new Filesystem(
                fileStorage: $this->dependencyInjector->get(id: FileStorageInterface::class)
            )
        );

        // Establish an alias 'Storage' for easier access to the Filesystem service
        // This maintains backward compatibility and provides a convenient access point
        $this->dependencyInjector->singleton(
            abstract: 'Storage',
            concrete: fn() : mixed => $this->dependencyInjector->get(
                id: Filesystem::class
            )
        );

        // Register-manifest-related services for migration tracking
        $this->registerManifestServices();
    }

    /**
     * Registers manifest-related services for migration management.
     *
     * Creates and configures the manifest storage system used for tracking
     * database migrations. This includes both the low-level storage implementation
     * and the higher-level manifest management interface.
     *
     * @return void
     *
     */
    private function registerManifestServices() : void
    {
        // Bind the manifest database interface to its concrete implementation
        // Configures the storage location for migration manifests
        $this->dependencyInjector->singleton(
            abstract: ManifestDBInterface::class,
            concrete: static fn() : ManifestDB => new ManifestDB(
                storagePath: storage_path(path: 'manifest')
            )
        );

        // Register the manifest store service with its database dependency
        // Provides the high-level interface for manifest operations
        $this->dependencyInjector->singleton(
            abstract: ManifestStoreInterface::class,
            concrete: fn() : ManifestStore => new ManifestStore(
                db: $this->dependencyInjector->get(id: ManifestDBInterface::class)
            )
        );
    }

    /**
     * Performs any post-registration boot operations.
     *
     * Currently, this method has no implementation as no boot-time operations
     * are required for filesystem services. Reserved for future use.
     *
     * @return void
     */
    public function boot() : void
    {
        // No boot operations required for filesystem services
    }
}
=== Container/ServiceProviders/Providers/HttpClientServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\HttpClient\Config\Clients\Guzzle\GuzzleClient;
use Gemini\HTTP\HttpClient\Config\Clients\Guzzle\HttpClient;
use Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats\RetryPolicyInterface;
use Gemini\HTTP\HttpClient\Config\Middleware\Policies\ServerErrorRetryPolicy;
use Gemini\HTTP\HttpClient\Config\Middleware\RetryMiddleware;
use Gemini\HTTP\Response\ResponseFactory;
use GuzzleHttp\Client;
use GuzzleHttp\HandlerStack;
use Psr\Http\Message\UriInterface;
use Psr\Log\LoggerInterface;

/**
 * Class HttpClientServiceProvider
 *
 * Registers HTTP client-related services in the container.
 */
class HttpClientServiceProvider extends ServiceProvider
{
    /**
     * Registers the necessary services into the service container.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: RetryPolicyInterface::class,
            concrete: static fn() : ServerErrorRetryPolicy => new ServerErrorRetryPolicy() // TODO: double check
        );

        // Register RetryMiddleware
        $this->dependencyInjector->singleton(
            abstract: RetryMiddleware::class,
            concrete: fn() : RetryMiddleware => new RetryMiddleware(
                logger    : $this->dependencyInjector->get(LoggerInterface::class),
                maxRetries: 3, // Configurable retry wait time in ms
            )
        );

        // Register HttpClient
        $this->dependencyInjector->singleton(
            abstract: HttpClient::class,
            concrete: fn() : HttpClient => new HttpClient(
                retryMiddleware: $this->dependencyInjector->get(RetryMiddleware::class),
                logger         : $this->dependencyInjector->get(LoggerInterface::class),
                baseUri        : $this->dependencyInjector->get(UriInterface::class) // Inject base API URL
            )
        );

        // Register GuzzleClient
        $this->dependencyInjector->singleton(
            abstract: GuzzleClient::class,
            concrete: fn() : GuzzleClient => new GuzzleClient(
                httpClient     : $this->dependencyInjector->get(HttpClient::class),
                dataLogger     : $this->dependencyInjector->get(LoggerInterface::class),
                responseFactory: $this->dependencyInjector->get(ResponseFactory::class)
            )
        );

        // Optional: Register Guzzle HandlerStack
        $this->dependencyInjector->singleton(
            abstract: HandlerStack::class,
            concrete: static fn() : HandlerStack => HandlerStack::create()
        );

        // Optional: Register Guzzle Client
        $this->dependencyInjector->singleton(
            abstract: Client::class,
            concrete: fn() : Client => new Client(
                ['handler' => $this->dependencyInjector->get(HandlerStack::class)]
            )
        );
    }

    /**
     * Starts the boot process for the class.
     */
    public function boot() : void
    {
        // Optionally add bootstrapping logic if necessary
        // This could include preloading configurations or resolving dependencies
    }
}

=== Container/ServiceProviders/Providers/HTTPServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\Classes\{Response, Stream, StreamFactory};
use Gemini\HTTP\Response\ResponseFactory;
use Gemini\HTTP\URI\UriBuilder;
use Psr\Http\Message\{ResponseFactoryInterface,
    ResponseInterface,
    ServerRequestInterface,
    StreamFactoryInterface,
    StreamInterface,
    UriInterface};
use RuntimeException;
use Throwable;

class HTTPServiceProvider extends ServiceProvider
{
    /**
     * Registers HTTP-related services in the container as singletons.
     *
     * - StreamInterface is configured to use a temporary stream.
     * - StreamFactoryInterface, ResponseFactoryInterface, and UriInterface are registered for dependency injection.
     * - ResponseInterface uses the configured StreamInterface.
     */
    public function register() : void
    {
        // Register StreamInterface with a temporary stream
        $this->dependencyInjector->singleton(abstract: StreamInterface::class, concrete: static function () : Stream {
            $streamResource = fopen('php://temp', 'rw+');
            if ($streamResource === false) {
                throw new RuntimeException(message: "Failed to create temporary stream.");
            }

            return new Stream(stream: $streamResource);
        });

        // Register StreamFactoryInterface
        $this->dependencyInjector->singleton(abstract: StreamFactoryInterface::class, concrete: StreamFactory::class);

        // Register ResponseInterface
        $this->dependencyInjector->singleton(abstract: ResponseInterface::class, concrete: function () : Response {
            try {
                $stream = $this->dependencyInjector->get(id: StreamInterface::class);
            } catch (Throwable $throwable) {
                throw new RuntimeException(
                    message : "Failed to resolve StreamInterface for ResponseInterface.",
                    code    : 0,
                    previous: $throwable
                );
            }

            return new Response(stream: $stream);
        });

        // Register ResponseFactoryInterface
        $this->dependencyInjector->singleton(abstract: ResponseFactoryInterface::class, concrete: function (
        ) : ResponseFactory {
            try {
                $streamFactory = $this->dependencyInjector->get(id: StreamFactoryInterface::class);
                $response      = $this->dependencyInjector->get(id: ResponseInterface::class);
            } catch (Throwable $throwable) {
                throw new RuntimeException(
                    message : "Failed to resolve dependencies for ResponseFactoryInterface.",
                    code    : 0,
                    previous: $throwable
                );
            }

            return new ResponseFactory(streamFactory: $streamFactory, response: $response);
        });


        // Response factory
        $this->dependencyInjector->singleton(
            abstract: ResponseFactory::class,
            concrete: static fn($container) => $container->get(ResponseFactoryInterface::class)
        );

        // Register UriInterface
        $this->dependencyInjector->singleton(
            abstract: UriInterface::class,
            concrete: static fn() : UriBuilder => UriBuilder::createFromString(
                env(key: 'APP_URL', default: 'http://localhost')
            )
        );

        // Request
        $this->dependencyInjector->singleton(
            abstract: ServerRequestInterface::class,
            concrete: static fn($container) : Request => Request::createFromGlobals()
        );

        // Request facade
        $this->dependencyInjector->singleton(
            abstract: 'Request',
            concrete: fn() : mixed => $this->dependencyInjector->get(id: ServerRequestInterface::class)
        );
    }

    /**
     * Placeholder for HTTP service bootstrapping logic.
     */
    public function boot() : void {}

}

=== Container/ServiceProviders/Providers/LoggingServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Session\Contracts\SessionLoggerInterface;
use Gemini\Logging\ErrorHandler;
use Gemini\Logging\LoggerFactory;
use Psr\Log\LoggerInterface;
use RuntimeException;

class LoggingServiceProvider extends ServiceProvider
{
    /**
     * Registers all necessary services related to logging.
     *
     * @throws \Exception
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: LoggerFactory::class,
            concrete: static fn() : LoggerFactory => new LoggerFactory()
        );

        $this->dependencyInjector->singleton(
            abstract: LoggerInterface::class,
            concrete: fn() : LoggerInterface => $this->resolveDependency(abstract: LoggerFactory::class)->create()
        );

        $this->dependencyInjector->singleton(
            abstract: ErrorHandler::class,
            concrete: fn() : ErrorHandler => new ErrorHandler(
                logger: $this->resolveDependency(abstract: LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: SessionLoggerInterface::class,
            concrete: fn() => $this
                ->resolveDependency(abstract: LoggerFactory::class)
                ->createLoggerFor(channel: 'session')
        );
    }

    /**
     * Resolves a dependency from the container with additional validation.
     *
     * @template T
     * @param class-string<T> $abstract The class name of the dependency.
     *
     * @return T
     */
    private function resolveDependency(string $abstract) : mixed
    {
        if (! $this->dependencyInjector->has(id: $abstract)) {
            throw new RuntimeException(message: sprintf("Action '%s' is not registered in the container.", $abstract));
        }

        return $this->dependencyInjector->get(id: $abstract);
    }

    public function boot() : void {}
}

=== Container/ServiceProviders/Providers/MiddlewareServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Auth\Interface\HTTP\Middleware\AuthenticationMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\PermissionMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\RoleMiddleware;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Middleware\CorsMiddleware;
use Gemini\HTTP\Middleware\CSRF\CsrfMiddleware;
use Gemini\HTTP\Middleware\ExceptionHandlerMiddleware;
use Gemini\HTTP\Middleware\JsonResponseMiddleware;
use Gemini\HTTP\Middleware\MiddlewareGroupResolver;
use Gemini\HTTP\Middleware\MiddlewarePipeline;
use Gemini\HTTP\Middleware\MiddlewarePipelineLogger;
use Gemini\HTTP\Middleware\MiddlewareResolver;
use Gemini\HTTP\Middleware\RateLimiterMiddleware;
use Gemini\HTTP\Middleware\RequestLoggerMiddleware;
use Gemini\HTTP\Middleware\SecurityHeadersMiddleware;
use Gemini\HTTP\Middleware\SessionLifecycleMiddleware;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Log\LoggerInterface;

/**
 * Registers and configures middleware components used throughout the application.
 *
 * This provider ensures centralized and DI-compliant binding of all middleware, middleware groups,
 * and the core pipeline orchestration infrastructure.
 */
final class MiddlewareServiceProvider extends ServiceProvider
{
    /**
     * Registers all middleware-related services into the container.
     */
    public function register() : void
    {
        $this->registerPipelineInfrastructure();
        $this->registerMiddlewareCore();
        $this->registerIndividualMiddlewares();
        $this->registerResolver();
        $this->registerGroupResolver();
    }

    /**
     * Registers the core pipeline and middleware manager infrastructure.
     */
    private function registerPipelineInfrastructure() : void
    {
        $this->dependencyInjector->singleton(
            abstract: MiddlewarePipeline::class,
            concrete: static fn() : MiddlewarePipeline => new MiddlewarePipeline()
        );

        $this->dependencyInjector->singleton(
            abstract: MiddlewarePipelineLogger::class,
            concrete: fn() => new MiddlewarePipelineLogger(
                logger: $this->dependencyInjector->get(LoggerInterface::class)
            )
        );
    }

    /**
     * Registers middlewares that require dependency injection manually.
     */
    private function registerMiddlewareCore() : void
    {
        $this->dependencyInjector->singleton(
            abstract: ExceptionHandlerMiddleware::class,
            concrete: fn() => new ExceptionHandlerMiddleware(
                logger:          $this->dependencyInjector->get(LoggerInterface::class),
                responseFactory: $this->dependencyInjector->get(ResponseFactory::class)
            )
        );
    }

    /**
     * Registers stateless singleton middleware instances with no required dependencies.
     */
    private function registerIndividualMiddlewares() : void
    {
        $middlewares = [
            AuthenticationMiddleware::class,
            PermissionMiddleware::class,
            RoleMiddleware::class,
            CorsMiddleware::class,
            CsrfMiddleware::class,
            JsonResponseMiddleware::class,
            RateLimiterMiddleware::class,
            RequestLoggerMiddleware::class,
            SecurityHeadersMiddleware::class,
            SessionLifecycleMiddleware::class,
        ];

        foreach ($middlewares as $middleware) {
            $this->dependencyInjector->singleton(abstract: $middleware, concrete: $middleware);
        }
    }

    /**
     * Registers a singleton instance of the middleware resolver.
     * The resolver is responsible for resolving middleware groups and handles their configuration dependencies.
     *
     * @return void
     */
    private function registerResolver() : void
    {
        $this->dependencyInjector->singleton(
            abstract: MiddlewareResolver::class,
            concrete: fn() => new MiddlewareResolver(
                groupResolver: $this->dependencyInjector->get(MiddlewareGroupResolver::class)
            )
        );
    }

    /**
     * Registers the `MiddlewareGroupResolver` class as a singleton in the dependency injector.
     *
     * This method ensures that only one instance of `MiddlewareGroupResolver` is created
     * during the application's lifecycle while managing its dependency injection.
     */
    private function registerGroupResolver() : void
    {
        // Registering MiddlewareGroupResolver as a singleton within the DependencyInjector,
        // ensuring that a single instance of the resolver is shared across the application's lifecycle.
        $this->dependencyInjector->singleton(
        // The abstract class or interface to bind to.
            abstract: MiddlewareGroupResolver::class,

            // The concrete implementation or closure defining how to resolve the abstract type.
            // In this case, an anonymous function creates and returns a new instance of MiddlewareGroupResolver.
            concrete: static fn() => new MiddlewareGroupResolver(
            // Injecting the configuration array for middleware groups, loaded from the middleware configuration file.
                config: require AppPath::CONFIG->get() . '/' . 'middleware.php'
            )
        );
    }

    /**
     * Boots global and grouped middleware for runtime execution.
     */
    public function boot() : void {}
}

=== Container/ServiceProviders/Providers/RouterServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Dispatcher\ControllerDispatcher;
use Gemini\HTTP\Middleware\MiddlewareResolver;
use Gemini\HTTP\Router\Bootstrap\RouteBootstrapper;
use Gemini\HTTP\Router\Cache\RouteCacheCompiler;
use Gemini\HTTP\Router\Cache\RouteCacheLoader;
use Gemini\HTTP\Router\Kernel\RouterKernel;
use Gemini\HTTP\Router\Router;
use Gemini\HTTP\Router\RouterInterface;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;
use Gemini\HTTP\Router\Routing\RouteGroupRegistrar;
use Gemini\HTTP\Router\Routing\RoutePipelineFactory;
use Gemini\HTTP\Router\Support\HeadRequestFallback;
use Gemini\HTTP\Router\Validation\RouteConstraintValidator;
use Psr\Log\LoggerInterface;

/**
 * Service Provider for setting up the routing services.
 * This class is responsible for registering and booting the necessary services related to routing.
 */
class RouterServiceProvider extends ServiceProvider
{
    /**
     * Register routing-related services in the container.
     * Using singleton to ensure a single instance of these classes is used throughout the application.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: RouterInterface::class,
            concrete: fn() => $this->dependencyInjector->get(Router::class)
        );

        $this->dependencyInjector->singleton(
            abstract: RouteConstraintValidator::class,
            concrete: static fn() => new RouteConstraintValidator()
        );

        $this->dependencyInjector->singleton(
            abstract: HttpRequestRouter::class,
            concrete: fn() : HttpRequestRouter => new HttpRequestRouter(
                constraintValidator: $this->dependencyInjector->get(RouteConstraintValidator::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: ControllerDispatcher::class,
            concrete: fn() : ControllerDispatcher => new ControllerDispatcher(
                container: $this->dependencyInjector
            )
        );

        $this->dependencyInjector->singleton(
            abstract: HeadRequestFallback::class,
            concrete: fn() => new HeadRequestFallback(
                router: $this->dependencyInjector->get(id: HttpRequestRouter::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RoutePipelineFactory::class,
            concrete: fn() => new RoutePipelineFactory(
                container         : $this->dependencyInjector,
                dispatcher        : $this->dependencyInjector->get(ControllerDispatcher::class),
                middlewareResolver: $this->dependencyInjector->get(MiddlewareResolver::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouterKernel::class,
            concrete: fn() : RouterKernel => new RouterKernel(
                httpRequestRouter  : $this->dependencyInjector->get(id: HttpRequestRouter::class),
                pipelineFactory    : $this->dependencyInjector->get(id: RoutePipelineFactory::class),
                headRequestFallback: $this->dependencyInjector->get(id: HeadRequestFallback::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteConstraintValidator::class,
            concrete: static fn() => new RouteConstraintValidator()
        );

        $this->dependencyInjector->singleton(
            abstract: Router::class,
            concrete: fn() : Router => new Router(
                httpRequestRouter: $this->dependencyInjector->get(id: HttpRequestRouter::class),
                kernel           : $this->dependencyInjector->get(id: RouterKernel::class),
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteGroupRegistrar::class,
            concrete: static fn() : RouteGroupRegistrar => new RouteGroupRegistrar()
        );

        // Optional alias
        $this->dependencyInjector->singleton(
            abstract: 'Route',
            concrete: fn() => $this->dependencyInjector->get(id: Router::class)
        );

        $this->dependencyInjector->singleton(
            abstract: RouteCacheCompiler::class,
            concrete: static fn() => new RouteCacheCompiler()
        );

        $this->dependencyInjector->singleton(
            abstract: RouteCacheLoader::class,
            concrete: fn() => new RouteCacheLoader(
                router: $this->dependencyInjector->get(Router::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteBootstrapper::class,
            concrete: fn() => new RouteBootstrapper(
                routeCacheLoader : $this->dependencyInjector->get(RouteCacheLoader::class),
                httpRequestRouter: $this->dependencyInjector->get(HttpRequestRouter::class),
                logger           : $this->dependencyInjector->get(LoggerInterface::class),
            )
        );
    }

    /**
     * Boot the router service provider, ensuring configuration settings are loaded.
     *
     * @throws \Throwable
     */
    public function boot() : void
    {
        /** @var RouteBootstrapper $bootstrapper */
        $bootstrapper = $this->dependencyInjector->get(RouteBootstrapper::class);
        $bootstrapper->bootstrap();
    }
}
=== Container/ServiceProviders/Providers/SecurityServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Auth\Application\Service\AccessControl\AccessControlService;
use Gemini\Auth\Application\Service\RateLimiterService;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Security\CsrfTokenManager;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Psr\Log\LoggerInterface;

/**
 * Service provider for security-related services.
 *
 * Registers security services and components,
 * specifically the CsrfTokenManager, with the application container.
 */
class SecurityServiceProvider extends ServiceProvider
{

    /**
     * Register services into the container.
     *
     * This method registers the CsrfTokenManager as a singleton in the container.
     * It ensures a single instance is used throughout the application lifecycle.
     *
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: CsrfTokenManager::class,
            concrete: fn() : CsrfTokenManager => new CsrfTokenManager(
            // Injecting SessionInterface dependency into CsrfTokenManager,
            // indicating the necessity of session management for CSRF token handling.
                session: $this->dependencyInjector->get(id: SessionInterface::class),
                logger : $this->dependencyInjector->get(id: LoggerInterface::class),
            )
        );

        $this->dependencyInjector->singleton(
            abstract: AccessControlService::class,
            concrete: AccessControlService::class
        );

        $this->dependencyInjector->singleton(abstract: RateLimiterService::class, concrete: fn(
        ) : RateLimiterService => new RateLimiterService(
            session: $this->dependencyInjector->get(id: SessionInterface::class)
        ));
    }

    /**
     * Perform additional bootstrapping for security.
     *
     * Intended for any security-related initialization that
     * might be required after the service registration.
     */
    public function boot() : void
    {
        // Additional bootstrapping for security if necessary
    }
}
=== Container/ServiceProviders/Providers/SessionServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Session\Contracts\{Factories\BagRegistryFactoryInterface,
    SessionBuilderInterface,
    SessionInterface,
    SessionManagerInterface,
    SessionStoreInterface};
use Gemini\HTTP\Session\Drivers\NativeSession;
use Gemini\HTTP\Session\SessionBuilder;
use Gemini\HTTP\Session\SessionContext;
use Gemini\HTTP\Session\SessionManager;
use Gemini\HTTP\Session\Stores\NativeSessionStore;
use Gemini\HTTP\Session\Support\Factories\BagRegistryFactory;

final class SessionServiceProvider extends ServiceProvider
{
    /**
     * @throws \Random\RandomException
     */
    public function register() : void
    {
        $this->bindSingleton(abstract: SessionStoreInterface::class, concrete: NativeSessionStore::class);
        $this->bindSingleton(abstract: BagRegistryFactoryInterface::class, concrete: BagRegistryFactory::class);

        // Main SessionInterface (deferred registry via closure)
        $this->dependencyInjector->bind(
            abstract: SessionInterface::class,
            concrete: static fn($c) => new NativeSession(
                store          : $c->get(SessionStoreInterface::class),
                registryFactory: static fn(SessionInterface $session) => $c
                    ->get(BagRegistryFactoryInterface::class)
                    ->create($session)
            )
        );

        // Use session->getRegistry() directly wherever needed
        $this->dependencyInjector->singleton(
            abstract: SessionBuilderInterface::class,
            concrete: fn() => new SessionBuilder(
                session : $this->resolve(abstract: SessionInterface::class),
                registry: $this->resolve(abstract: SessionInterface::class)->getRegistry(),
                context : new SessionContext(namespace: 'default')
            )
        );

        $this->dependencyInjector->singleton(
            abstract: SessionManagerInterface::class,
            concrete: fn() => new SessionManager(
                session: $this->resolve(abstract: SessionInterface::class),
                bags   : $this->resolve(abstract: SessionInterface::class)->getRegistry()
            )
        );
    }

    private function bindSingleton(string $abstract, string $concrete) : void
    {
        $this->dependencyInjector->singleton(
            abstract: $abstract,
            concrete: static fn() => new $concrete()
        );
    }

    private function resolve(string $abstract) : mixed
    {
        return $this->dependencyInjector->get(id: $abstract);
    }

    public function boot() : void {}
}

=== Container/ServiceProviders/Providers/ViewServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\View\BladeTemplateEngine;
use Infrastructure\Config\Service\Config;

class ViewServiceProvider extends ServiceProvider
{
    public function register() : void
    {
//        $this->dependencyInjector->singleton(
//            abstract: TemplateEngine::class,
//            concrete: fn() => new TemplateEngine(
//                templatePath: $this->dependencyInjector->get(Config::class)->get('views.views_path'),
//                compiledPath: $this->dependencyInjector->get(Config::class)->get('views.cache_path')
//            )
//        );

        $this->dependencyInjector->singleton(
            abstract: BladeTemplateEngine::class,
            concrete: fn() : BladeTemplateEngine => new BladeTemplateEngine(
                viewsPath: $this->dependencyInjector->get(Config::class)->get('views.views_path'),
                cachePath: $this->dependencyInjector->get(Config::class)->get('views.cache_path')
            )
        );
    }

    public function boot() : void
    {
        // Optional: Additional view-related logic
    }
}

=== Container/ServiceProviders/ServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders;

use Gemini\Container\Containers\DependencyInjector;
use Gemini\Container\ServiceProviders\Contracts\ServiceProviderInterface;

/**
 * Class ServiceProvider
 *
 * The base class for all service providers.
 */
abstract class ServiceProvider implements ServiceProviderInterface
{
    /**
     * Constructor method for initializing the class with an application container.
     *
     * @param DependencyInjector $dependencyInjector The application container for managing dependencies.
     */
    public function __construct(protected DependencyInjector $dependencyInjector) {}

    /**
     * Registers the necessary services into the service container.
     */
    abstract public function register(): void;

    /**
     * Starts the boot process for the class.
     */
    abstract public function boot(): void;
}

=== Database/Connection/ConnectionPool.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Connection;

use Exception;
use Gemini\Database\Connection\Contracts\ConnectionPoolInterface;
use PDO;
use Psr\Log\LoggerInterface;
use RuntimeException;

/**
 * Class ConnectionPool
 *
 * Manages a pool of PDO connections to improve efficiency and reuse within an application.
 * Implements the ConnectionPoolInterface to allow for consistent connection handling.
 *
 * Features:
 * - Supports named database connections (`mysql`, `pgsql`, `sqlite`, `sqlsrv`).
 * - Automatically initializes and pools connections.
 * - Efficiently reuses available connections.
 * - Ensures that connections are alive before reuse.
 * - Implements exception handling and logging.
 */
class ConnectionPool implements ConnectionPoolInterface
{
    /** @var array<string, PDO> Active connections stored by name. */
    private array $connections = [];

    /** @var array<string, array> Configuration settings for all connections. */
    private array           $config;

    private LoggerInterface $logger;

    private int             $maxConnections;

    /**
     * ConnectionPool constructor.
     *
     * @param array           $config         Database configuration array.
     * @param LoggerInterface $logger         Logger for handling errors and connection issues.
     * @param int             $maxConnections Maximum number of connections allowed per database.
     */
    public function __construct(
        array           $config,
        LoggerInterface $logger,
        int             $maxConnections = 5
    ) {
        $this->config         = $config['connections'] ?? [];
        $this->logger         = $logger;
        $this->maxConnections = $maxConnections;
    }

    /**
     * Retrieves an available database connection by name.
     *
     * @param string|null $connectionName The database connection to retrieve.
     *
     * @return PDO The active PDO connection.
     *
     * @throws RuntimeException If the requested connection is not configured.
     */
    public function getConnection(string|null $connectionName = null) : PDO
    {
        $connectionName ??= config(key: 'database.default', default: 'mysql');

        if (! isset($this->config[$connectionName])) {
            throw new RuntimeException(message: "Database connection '{$connectionName}' is not configured.");
        }

        if (isset($this->connections[$connectionName])
            && $this->isConnectionAvailable(pdo: $this->connections[$connectionName])
        ) {
            return $this->connections[$connectionName];
        }

        if (count($this->connections) < $this->maxConnections) {
            return $this->initializeConnection(connectionName: $connectionName);
        }

        throw new RuntimeException(message: "Connection pool limit reached for '{$connectionName}'.");
    }

    /**
     * Checks if the given PDO connection is still available and functional.
     *
     * @param PDO $pdo The PDO connection instance to check.
     *
     * @return bool Returns true if the connection is valid, false otherwise.
     */
    private function isConnectionAvailable(PDO $pdo) : bool
    {
        try {
            return $pdo->query(query: 'SELECT 1') !== false;
        } catch (Exception) {
            return false;
        }
    }

    /**
     * Initializes a new database connection.
     *
     * @param string $connectionName The name of the database connection.
     *
     * @return PDO The newly created PDO connection.
     *
     * @throws RuntimeException If connection fails.
     */
    private function initializeConnection(string $connectionName) : PDO
    {
        try {
            $config = $this->config[$connectionName];

            $pdo = new PDO(
                dsn     : $config['connection'],
                username: $config['username'] ?? null,
                password: $config['password'] ?? null,
                options : $config['options'] ?? []
            );

            $pdo->setAttribute(attribute: PDO::ATTR_ERRMODE, value: PDO::ERRMODE_EXCEPTION);
            $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

            $this->connections[$connectionName] = $pdo;

            $this->logger->info(message: "Successfully connected to '{$connectionName}' database.");

            return $pdo;
        } catch (Exception $e) {
            $this->logger->error(message: "Failed to connect to '{$connectionName}': {$e->getMessage()}");
            throw new RuntimeException(message: "Database connection failed: {$e->getMessage()}", previous: $e);
        }
    }

    /**
     * Releases a connection back into the pool.
     *
     * @param PDO $pdo The PDO connection to release.
     */
    public function releaseConnection(PDO $pdo) : void
    {
        foreach ($this->connections as $name => $connection) {
            if ($connection === $pdo) {
                $this->logger->info(message: "Releasing connection for '{$name}' back to the pool.");

                return;
            }
        }

        $this->logger->warning(message: 'Attempted to release an unknown connection.');
    }
}
=== Database/Connection/Contracts/ConnectionPoolInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Connection\Contracts;

use PDO;

interface ConnectionPoolInterface
{
    /**
     * Retrieves a database connection by name.
     *
     * @param string|null $connectionName The name of the database connection.
     *
     * @return PDO The active PDO connection.
     */
    public function getConnection(string|null $connectionName = null) : PDO;

    /**
     * Releases a connection back to the pool.
     *
     * @param PDO $pdo The PDO connection instance.
     */
    public function releaseConnection(PDO $pdo) : void;
}

=== Database/DatabaseConnection.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database;

use Gemini\Database\Connection\Contracts\ConnectionPoolInterface;
use PDO;
use Psr\Log\LoggerInterface;
use RuntimeException;
use Throwable;

/**
 * **DatabaseConnection**
 *
 * Manages secure and optimized database connections using a connection pool.
 *
 * ✅ **Key Features**
 * - Connection Pooling for optimal performance.
 * - Secure Connection Handling (Prevents leaks).
 * - Enterprise-Grade Logging & Error Handling.
 * - Enforces `PDO::ATTR_EMULATE_PREPARES = false` to prevent SQL Injection.
 * - Read/Write Connection Support.
 *
 * 🏆 **Best Practices Implemented**
 * - **SRP (Single Responsibility Principle)** → Only manages database connections.
 * - **DIP (Dependency Inversion Principle)** → Uses an interface for loose coupling.
 * - **Fail-Fast Principle** → Throws exceptions immediately on failures.
 * - **Security Best Practices** → Prevents SQL Injection, connection leaks, and enforces strict error handling.
 *
 * Usage:
 * ```
 * $databaseConnection = new DatabaseConnection($connectionPool, $logger);
 * $pdo = $databaseConnection->getConnection('mysql');
 * $databaseConnection->releaseConnection($pdo);
 * ```
 */
readonly class DatabaseConnection
{
    /**
     * Initializes the database connection manager.
     *
     * @param ConnectionPoolInterface $connectionPool The connection pool instance.
     * @param LoggerInterface         $logger         The logger for structured logging.
     */
    public function __construct(
        private ConnectionPoolInterface $connectionPool,
        private LoggerInterface         $logger
    ) {}

    /**
     * Releases a database connection back into the pool.
     *
     * ✅ **Ensures Proper Resource Management**
     * - Avoids connection leaks by returning the connection to the pool.
     * - Logs successful release operations.
     *
     * @param PDO $pdo The connection to release.
     */
    public function releaseConnection(PDO $pdo) : void
    {
        $this->connectionPool->releaseConnection(pdo: $pdo);
        $this->logger->info(message: "Database connection successfully released.");
    }

    /**
     * Checks if the database connection is alive.
     *
     * ✅ **Fail-Fast Design**
     * - Executes a lightweight `SELECT 1` query to test the connection.
     * - Logs failures for monitoring.
     *
     * @param string|null $connectionName Optional connection name.
     *
     * @return bool `true` if the connection is active, `false` otherwise.
     */
    public function testConnection(string|null $connectionName = null) : bool
    {
        try {
            $pdo = $this->getConnection(connectionName: $connectionName);
            $pdo->query(query: 'SELECT 1');

            return true;
        } catch (Throwable $exception) {
            $this->logger->warning(
                message: "Database connection test failed.",
                context: [
                             'connection' => $connectionName,
                             'error'      => $exception->getMessage(),
                         ]
            );

            return false;
        }
    }

    /**
     * Retrieves a secure database connection from the pool.
     *
     * ✅ **Security Enhancements**
     * - Enforces `PDO::ATTR_EMULATE_PREPARES = false` to prevent SQL Injection.
     * - Ensures only valid connection names are used.
     *
     * @param string|null $connectionName Optional connection name (default: primary connection).
     *
     * @return PDO A secure, pooled database connection.
     *
     * @throws RuntimeException If the connection cannot be established.
     */
    public function getConnection(string|null $connectionName = null) : PDO
    {
        try {
            // Retrieve a database connection from the connection pool.
            // The variable `$connectionName` specifies the name of the database connection to use.
            $pdo = $this->connectionPool->getConnection(connectionName: $connectionName);
            // ✅ Security Hardening – Ensure emulated prepares are disabled to prevent SQL Injection.
            $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

            return $pdo;
        } catch (Throwable $exception) {
            $this->logger->error(
                message: "Database connection error: " . $exception->getMessage(),
                context: [
                             'connection' => $connectionName,
                             'trace'      => $exception->getTraceAsString(),
                         ]
            );

            throw new RuntimeException(message: "Failed to establish a secure database connection.");
        }
    }
}

=== Database/Migration/Design/Column/Builder/ColumnAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Builder;

use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Represents an immutable value object for column metadata in database migrations.
 *
 * This class encapsulates database column attributes in a strongly-typed, immutable
 * structure, providing a clean interface for accessing column properties. It serves
 * as a read-only facade over the underlying ColumnAttributesDTO data.
 *
 * @property string                     $name
 * @property ColumnType                 $type
 * @property int|null                   $length
 * @property int|null                   $precision
 * @property int|null                   $scale
 * @property bool|null                  $nullable
 * @property bool|null                  $unsigned
 * @property bool|null                  $autoIncrement
 * @property bool|null                  $primary
 * @property bool|null                  $unique
 * @property string|int|float|bool|null $default
 * @property array<string>|null         $enum
 * @property string|null                $generated
 * @property string|null                $after
 * @property bool|null                  $useCurrent
 * @property bool|null                  $useCurrentOnUpdate
 * @property string|null                $alias
 * @property string|null                $comment
 * @property array<string, mixed>       $foreign
 * @property array<string, mixed>       $columns
 *
 * @final     This class is not designed for inheritance
 * @immutable This class represents an immutable value object
 * @pattern   Value Object - Encapsulates column attributes in an immutable structure
 */
final class ColumnAttributes
{
    /**
     * Stores the internal attribute collection extracted from the DTO.
     *
     * The properties array maintains a key-value mapping of all column attributes,
     * providing O(1) access time for attribute lookups while maintaining
     * encapsulation of the underlying data structure.
     *
     * @var array<string, mixed> Key-value pairs of column attributes
     */
    private array $properties;

    /**
     * Constructs a new immutable ColumnAttributes instance.
     *
     * Uses constructor property promotion for concise initialization
     * while maintaining clean code principles through explicit type declarations
     * and validation at instantiation.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column metadata
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $fromDto          = $this->dto;
        $this->properties = get_object_vars($fromDto);
    }

    /**
     * Creates a minimal column definition with essential attributes.
     *
     * Factory method implementing the named parameters pattern for improved
     * readability and maintainability. Provides a convenient way to create
     * basic column definitions without full DTO instantiation.
     *
     * @param string     $name The logical identifier for the column
     * @param ColumnType $type The SQL data type specification
     *
     * @return self New instance with minimal column configuration
     * @throws \ReflectionException When DTO instantiation fails
     */
    public static function make(
        string     $name,
        ColumnType $type
    ) : self {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Provides dynamic access to column attributes via property syntax.
     *
     * Implements magic getter following clean code principles by providing
     * clear error messages and type-safe access to internal properties.
     *
     * @param string $name The attribute name to retrieve
     *
     * @return mixed The value of the requested attribute
     * @throws RuntimeException When accessing undefined attributes
     */
    public function __get(string $name) : mixed
    {
        if (! array_key_exists($name, $this->properties)) {
            throw new RuntimeException(
                message: sprintf('Column attribute "%s" does not exist.', $name)
            );
        }

        return $this->properties[$name];
    }

    /**
     * Supports PHP's isset() and empty() operations on attributes.
     *
     * Provides a clean interface for attribute existence checking while
     * maintaining encapsulation of internal property storage.
     *
     * @param string $name The attribute name to check
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function __isset(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Explicitly verifies the existence of a column attribute.
     *
     * Provides a more semantic alternative to isset() for attribute checking,
     * following clean code principles with clear method naming.
     *
     * @param string $name The attribute name to verify
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function has(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Retrieves an attribute value with optional default fallback.
     *
     * Implements null coalescing operator for safe attribute access,
     * following defensive programming practices.
     *
     * @param string     $name    The attribute name to retrieve
     * @param mixed|null $default The fallback value if attribute doesn't exist
     *
     * @return mixed The attribute value or default
     */
    public function get(string $name, mixed $default = null) : mixed
    {
        return $this->properties[$name] ?? $default;
    }

    /**
     * Exports all column attributes as an associative array.
     *
     * Provides a clean interface for serialization while maintaining
     * immutability of the internal property collection.
     *
     * @return array<string, mixed> Complete map of column attributes
     */
    public function toArray() : array
    {
        return $this->properties;
    }
}

=== Database/Migration/Design/Column/Column.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLDefaults;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Factory and macro layer for fluent column construction.
 *
 * Delegates schema building to ColumnDefinition while also exposing
 * DDD-safe shortcuts like `id()`, `timestamps()`, etc.
 *
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final readonly class Column
{
    use ColumnDSLDefaults;

    /**
     * Creates a ColumnDefinition via a DSL method call
     *
     * This method dynamically interprets the method name (e.g., `string`, `decimal`)
     * and maps it to an enum `ColumnType`, while applying appropriate DSL parameters.
     *
     * DSL-idiomatic:
     * - $table->string('name', 255)
     * - $table->decimal('price', 10, 2)
     * - $table->enum('type', ['free', 'paid'])
     *
     * @param string            $method    The column type method (e.g., 'string', 'decimal')
     * @param array<int, mixed> $arguments DSL arguments passed (name, length/precision/etc.)
     *
     * @return ColumnDefinition Returns a fully constructed column schema node
     *
     * @throws RuntimeException If the first argument (column name) is missing or invalid
     * @throws \ReflectionException
     */
    public function create(string $method, array $arguments) : ColumnDefinition
    {
        /**
         * Destructure the DSL arguments for clarity and DSL alignment.
         *
         * - $name: Column name (required)
         * - $size: Size, length, precision (optional)
         * - $details: Enum options or scale (optional)
         */
        [$name, $size, $details] = array_pad($arguments, 3, null);

        // Defensive: Fail early if column name is not provided
        if (empty($name) || ! is_string($name)) {
            throw new RuntimeException(message: "Missing or invalid column name for method: '{$method}'");
        }

        // Normalize method to ColumnType Enum (via alias support)
        $type = ColumnType::map(input: $method);

        // Dynamically collect any additional DSL parameters
        $attributes = match ($type) {
            ColumnType::VARCHAR,
            ColumnType::CHAR  => ['length' => $size ?? 255],

            ColumnType::DECIMAL,
            ColumnType::DOUBLE,
            ColumnType::FLOAT => [
                'precision' => $size ?? 10,
                'scale'     => $details ?? 2,
            ],

            ColumnType::ENUM,
            ColumnType::SET   => ['enum' => is_array($size) ? $size : []],

            default           => []
        };

        // Wrap all attributes in a strict, validated DTO
        $dto = new ColumnAttributesDTO(
            data: array_merge(
                      ['name' => $name, 'type' => $type],
                      $attributes
                  )
        );

        // Create immutable column node using named constructor
        return ColumnDefinition::make(
            name: $dto->name,
            type: $dto->type
        );
    }

}
=== Database/Migration/Design/Column/DSL/ColumnDefinition.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLKeyConstraints;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLSemantics;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLTypeAttributes;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use InvalidArgumentException;

/**
 * Represents a fluent interface for defining database column schemas.
 *
 * This value object encapsulates the definition of a database column using a Domain-Specific Language (DSL)
 * approach. It implements the Builder pattern through a fluent interface, allowing for expressive
 * and type-safe column definitions.
 *
 * @package   Gemini\Database\Migration\Design\Column\DSL
 * @final     This class is not intended for extension
 * @immutable This class represents an immutable value object
 *
 *
 * ```php
 * $column = ColumnDefinition::make('user_id', ColumnType::INTEGER)
 *     ->unsigned()
 *     ->notNull()
 *     ->primary();
 * ```
 */
final class ColumnDefinition
{
    use ColumnDSLSemantics;
    use ColumnDSLKeyConstraints;
    use ColumnDSLTypeAttributes;

    /**
     * Encapsulates the internal state of the column definition.
     *
     * This property maintains the complete state of the column definition
     * through a dedicated value object, ensuring immutability and encapsulation
     * of the column attributes.
     *
     * @var ColumnAttributes
     */
    private ColumnAttributes $builder;

    /**
     * Initializes a new column definition instance.
     *
     * Constructs the column definition from a validated DTO containing
     * the essential column attributes. Uses constructor promotion for
     * clean and efficient initialization.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column attributes
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $this->builder = new ColumnAttributes(dto: $dto);
    }

    /**
     * Creates a new column definition using a fluent interface.
     *
     * Factory method implementing the Named Constructor pattern to provide
     * a more expressive way of creating column definitions.
     *
     * @param string     $name The logical name of the column
     * @param ColumnType $type The SQL data type for the column
     *
     * @return self New column definition instance
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public static function make(string $name, ColumnType $type) : self
    {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Renders the column definition as an SQL string.
     *
     * Delegates the actual rendering to a dedicated renderer class,
     * following the Single Responsibility Principle.
     *
     * @return string The complete SQL column definition
     */
    public function __toString() : string
    {
        return ColumnSQLRenderer::render(column: $this->getBuilder());
    }

    /**
     * Retrieves the internal column attributes builder.
     *
     * Provides access to the underlying value object containing
     * the complete column definition state.
     *
     * @return ColumnAttributes The immutable column attributes value object
     */
    public function getBuilder() : ColumnAttributes
    {
        return $this->builder;
    }

    /**
     * Gets the logical name of the column.
     *
     * Provides direct access to the column's identifier without
     * exposing the internal builder implementation.
     *
     * @return string The column's identifier
     */
    public function columnName() : string
    {
        return $this->builder->name;
    }

    /**
     * Modifies the column definition by adding or updating column specifications.
     *
     * This method implements the immutable modification pattern, creating a new
     * instance with updated column specifications while preserving the original
     * definition. It follows the immutability principle essential for maintaining
     * a predictable state in domain-driven design.
     *
     * @param array<string, mixed> $columns New column specifications to be applied
     *
     * @return self New instance with updated column specifications
     * @throws \ReflectionException When reflection fails during DTO construction
     */

    public function columns(array $columns) : self
    {
        if (empty($columns)) {
            throw new InvalidArgumentException(message: 'Column names array cannot be empty.');
        }

        $this->validateColumnNames($columns);

        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Validates the integrity of column names in a database schema definition.
     *
     * This method ensures that the provided column names meet the following criteria:
     * - Must be provided as a sequential array (list)
     * - Each element must be a non-empty string
     *
     * Part of the database schema validation layer that maintains data structure integrity.
     *
     * @param array<int, string> $columnNames Sequential array of column identifiers
     *
     * @throws InvalidArgumentException When validation fails due to invalid format or content
     */
    private function validateColumnNames(array $columnNames) : void
    {
        // Validate that the array is a sequential list and all elements are strings
        if (! array_is_list($columnNames)
            || array_filter($columnNames, static fn(mixed $column) : bool => ! is_string($column))
        ) {
            throw new InvalidArgumentException(
                message: 'All column names must be non-empty strings.'
            );
        }
    }
}
=== Database/Migration/Design/Column/DSL/FluentModifiers/ColumnDSLDefaults.php ===
<?php

declare(strict_types=1);

/**
 * Domain-Specific Language (DSL) for Database Schema Design.
 *
 * This namespace encapsulates the column definition DSL components,
 * providing a fluent interface for database schema manipulation.
 */

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Domain-Specific Column Definition Defaults Trait.
 *
 * Provides a collection of standardized column definitions following Domain-Driven Design principles.
 * This trait encapsulates common database schema patterns, offering a semantic layer
 * above raw SQL definitions to express business domain concepts.
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 * @since   1.0.0
 */
trait ColumnDSLDefaults
{
    /**
     * Defines a standardized auto-incrementing primary key identifier.
     *
     * Implements the Identity Field pattern using a BIGINT type to ensure
     * sufficient capacity for large datasets. This follows the ubiquitous
     * language principle of DDD by providing a clear, domain-focused identifier.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function id() : ColumnDefinition
    {
        // Create a primary key column with auto-increment capability
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::BIGINT
        )
            ->primary()
            ->autoIncrement();
    }

    /**
     * Establishes temporal tracking for entity lifecycle events.
     *
     * Implements the Audit Trail pattern through timestamp columns that automatically
     * track entity creation and modification times. This supports both auditing
     * requirements and temporal queries within the domain.
     *
     * @return array{ColumnDefinition, ColumnDefinition} An array containing created_at and updated_at columns
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function timestamps() : array
    {
        // Define creation timestamp column
        $createdAt = ColumnDefinition::make(
            name: 'created_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Define update timestamp column
        $updatedAt = ColumnDefinition::make(
            name: 'updated_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Return both columns as a tuple
        return [
            $createdAt,
            $updatedAt,
        ];
    }

    /**
     * Implements the Soft Delete pattern for logical record deletion.
     *
     * Creates a nullable timestamp column that enables logical deletion without
     * a physical record removal, supporting data recovery and maintaining referential integrity.
     * This pattern is essential for maintaining audit trails and implementing undo operations.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function softDeletes() : ColumnDefinition
    {
        // Create a nullable timestamp column for soft deletes
        return ColumnDefinition::make(
            name: 'deleted_at',
            type: ColumnType::TIMESTAMP
        )->nullable();
    }

    /**
     * Establishes a UUID-based primary key for distributed systems.
     *
     * Implements a distributed-friendly primary key strategy using UUIDs,
     * enabling reliable unique identification across distributed systems
     * without central coordination. This pattern supports horizontal scaling
     * and microservices architecture.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function uuidPrimary() : ColumnDefinition
    {
        // Create a UUID-based primary key column
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::UUID
        )->primary();
    }

    /**
     * @throws \ReflectionException
     */
    public function char(string $name, int $length = 255) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::CHAR)
            ->length(length: $length);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function longText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::LONGTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function ipAddress(string $name = 'ip_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 45);
    }

    /**
     * @throws \ReflectionException
     */
    public function macAddress(string $name = 'mac_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 17);
    }

    /**
     * @throws \ReflectionException
     */
    public function vector(string $name, int $dimensions = 1536) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VECTOR)
            ->length(length: $dimensions);
    }

    /**
     * @throws \ReflectionException
     */
    public function geography(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::GEOGRAPHY);
    }
}
=== Database/Migration/Design/Column/DSL/FluentModifiers/ColumnDSLKeyConstraints.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Enums\ReferentialAction;

/**
 * Trait ColumnDSLKeyConstraints
 *
 * Provides fluent methods for defining column-level constraints.
 * Applies strict immutability via DTO-based state mutation.
 */
trait ColumnDSLKeyConstraints
{
    /**
     * Shortcut for setting column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function pk() : ColumnDefinition
    {
        return $this->primary();
    }

    /**
     * Marks the column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function primary() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['primary' => true]);
    }

    /**
     * Shortcut for setting AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function inc() : ColumnDefinition
    {
        return $this->autoIncrement();
    }

    /**
     * Marks column as AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function autoIncrement() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['autoIncrement' => true]);
    }

    /**
     * Defines a FOREIGN KEY constraint
     *
     * @param string $references Referenced column
     * @param string $onTable    Target table
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function foreignKey(string $references, string $onTable) : ColumnDefinition
    {
        return $this->withModifiedAttributes(
            [
                'type'    => ColumnType::FOREIGN_KEY,
                'foreign' => [
                    'references' => $references,
                    'on'         => $onTable,
                ],
            ]
        );
    }

    /**
     * Sets ON DELETE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onDelete(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onDelete' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Sets ON UPDATE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onUpdate(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onUpdate' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Defines INDEX constraint
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::INDEX)
            ->columns($columns);
    }

    /**
     * Defines UNIQUE constraint
     *
     * @param string        $name    Constraint name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::UNIQUE)
            ->columns($columns);
    }

    /**
     * Defines FULLTEXT index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::FULLTEXT)
            ->columns($columns);
    }

    /**
     * Defines SPATIAL index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatial(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::SPATIAL)
            ->columns($columns);
    }
}

=== Database/Migration/Design/Column/DSL/FluentModifiers/ColumnDSLSemantics.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use InvalidArgumentException;

/**
 * Trait ColumnDSLSemantics
 *
 * Domain-Specific Language (DSL) fluent modifiers for expressive schema definitions.
 *
 * Each method adheres to value object principles by avoiding direct mutation.
 * Instead, modifications are applied via a `withModifiedAttributes()` builder contract,
 * ensuring immutability and enabling composability of modifiers.
 *
 * @see     ColumnDefinition
 * @see     ColumnDefinition::withModifiedAttributes()
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 */
trait ColumnDSLSemantics
{
    /**
     * Defines an ENUM type column with a fixed set of string values.
     *
     * @param array<int, string> $values Acceptable string values for ENUM constraint
     *
     * @return ColumnDefinition New column instance with ENUM type
     *
     * @throws InvalidArgumentException When the $values array is empty
     * @throws \ReflectionException
     */
    public function enum(array $values) : ColumnDefinition
    {
        if (empty($values)) {
            throw new InvalidArgumentException(message: "Enum values cannot be empty.");
        }

        return $this->withModifiedAttributes(
            [
                'type' => ColumnType::ENUM,
                'enum' => $values,
            ]
        );
    }

    /**
     * Contract: Fluent modifier mutation through immutability contract.
     *
     * @param array<string, mixed> $attributes New values to apply to builder state
     *
     * @return ColumnDefinition Mutated copy with applied attributes
     */
    abstract protected function withModifiedAttributes(array $attributes) : ColumnDefinition;

    /**
     * Defines a STORED generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated and persisted
     *
     * @return ColumnDefinition New column with stored generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function storedAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) STORED"]);
    }

    /**
     * Defines a VIRTUAL generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated on read
     *
     * @return ColumnDefinition New column with virtual generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function virtualAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) VIRTUAL"]);
    }

    /**
     * Specifies the placement of the column relative to another column.
     *
     * @param string $column Name of the reference column
     *
     * @return ColumnDefinition Column with `AFTER` clause applied
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function after(string $column) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['after' => $column]);
    }

    /**
     * Sets the default value to CURRENT_TIMESTAMP for temporal columns.
     *
     * @return ColumnDefinition Column with default timestamp behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrent() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrent' => true]);
    }

    /**
     * Enables ON UPDATE CURRENT_TIMESTAMP behavior for automatic updates.
     *
     * @return ColumnDefinition Column with auto-update timestamp logic
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrentOnUpdate() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrentOnUpdate' => true]);
    }

    /**
     * Sets the compound index column list for multi-column indexes.
     *
     * @param array<int, string> $columns Array of column names to index together
     *
     * @return ColumnDefinition Column with compound index config
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function columns(array $columns) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Assigns an alias to the column for use in views or generated columns.
     *
     * @param string $name Alias identifier
     *
     * @return ColumnDefinition Column with alias assigned
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function alias(string $name) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['alias' => $name]);
    }

    /**
     * Attaches a comment to the column definition for metadata purposes.
     *
     * @param string $text SQL comment text
     *
     * @return ColumnDefinition Column with comment metadata
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function comment(string $text) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['comment' => $text]);
    }

    /**
     * Sets a default value to be applied during insert operations.
     *
     * @param string|int|float|bool|null $value Default value to apply
     *
     * @return ColumnDefinition Column with default constraint
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function default(string|int|float|bool|null $value) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['default' => $value]);
    }
}

=== Database/Migration/Design/Column/DSL/FluentModifiers/ColumnDSLTypeAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use InvalidArgumentException;
use ReflectionException;

/**
 * Provides a fluent interface for column-type-specific attribute modifications.
 *
 * This trait encapsulates the type-specific modifiers for database column definitions,
 * implementing an immutable fluent interface pattern. It handles common column attributes
 * such as length, precision, scale, nullability, and unsigned specifications.
 *
 * @internal This trait is intended for internal use within the column definition system
 * @api      Exposes fluent interface methods for column type modifications
 *
 * @since    1.0.0
 */
trait ColumnDSLTypeAttributes
{
    /**
     * Defines the maximum length for character-based column types.
     *
     * Immutably creates a new column definition with the specified length attribute.
     * Commonly used for VARCHAR and CHAR column types.
     *
     * @param int<1, max> $length The maximum length of the column content
     *
     * @return ColumnDefinition A new immutable instance with the length attribute
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function length(int $length) : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['length' => $length]);
    }

    /**
     * Creates a new column definition with modified attributes.
     *
     * Internal helper method implementing the immutable modification pattern.
     * Clones the current state and applies new modifications to create a fresh instance.
     *
     * @param array<string, mixed> $modifiers Key-value pairs of attributes to modify
     *
     * @return ColumnDefinition A new immutable instance with applied modifications
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    protected function withModifiedAttributes(array $modifiers) : ColumnDefinition
    {
        // Extract current state as array
        $data = $this->getBuilder()->toArray();

        // Apply new modifications
        foreach ($modifiers as $key => $value) {
            $data[$key] = $value;
        }

        // Create a new immutable instance
        return new ColumnDefinition(dto: new ColumnAttributesDTO(data: $data));
    }

    /**
     * Configures precision and scale for decimal number columns.
     *
     * Creates a new column definition with specified numeric precision attributes.
     * Ensures proper relationship between precision and scale values.
     *
     * @param positive-int $precision Total number of significant digits
     * @param positive-int $scale     Number of digits after decimal point
     *
     * @return ColumnDefinition A new immutable instance with precision settings
     * @throws ReflectionException If reflection fails during DTO instantiation
     * @throws InvalidArgumentException If precision is less than scale
     */
    public function decimal(int $precision, int $scale) : ColumnDefinition
    {
        if ($precision < $scale) {
            throw new InvalidArgumentException(
                message: 'Precision must be greater than or equal to scale.'
            );
        }

        return $this->withModifiedAttributes(
            modifiers: [
                           'precision' => $precision,
                           'scale'     => $scale,
                       ]
        );
    }

    /**
     * Marks a numeric column as unsigned.
     *
     * Creates a new column definition with the unsigned flag set.
     * Applicable only to numeric column types.
     *
     * @return ColumnDefinition A new immutable instance marked as unsigned
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function unsigned() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['unsigned' => true]);
    }

    /**
     * Marks a column as nullable.
     *
     * Creates a new column definition that allows NULL values.
     * This is a schema-level nullability setting.
     *
     * @return ColumnDefinition A new immutable instance marked as nullable
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function nullable() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['nullable' => true]);
    }

    /**
     * Sets the precision (total number of digits) for numeric data types.
     *
     * This method follows the immutable modification pattern, creating a new instance
     * with the specified precision while preserving the original column definition.
     * Particularly useful for decimal, numeric, and floating-point data types.
     *
     * @param int $precision The total number of digits the column can store
     *
     * @return ColumnDefinition New immutable instance with updated precision
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function precision(int $precision) : ColumnDefinition
    {
        // Create new immutable instance with updated precision attribute
        return $this->withModifiedAttributes(['precision' => $precision]);
    }

    /**
     * Sets the scale (number of decimal places) for numeric data types.
     *
     * This method implements the immutable modification pattern, creating a new instance
     * with the specified scale while maintaining immutability. Essential for decimal
     * and numeric data types where decimal precision is required.
     *
     * @param int $scale The number of digits after the decimal point
     *
     * @return ColumnDefinition New immutable instance with updated scale
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function scale(int $scale) : ColumnDefinition
    {
        // Create a new immutable instance with updated scale attribute
        return $this->withModifiedAttributes(['scale' => $scale]);
    }

}
=== Database/Migration/Design/Column/DTO/ColumnAttributesDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DTO;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Enum;
use Gemini\DataHandling\Validation\Attributes\Rules\Filled;

/**
 * Data Transfer Object representing database column attributes within the migration context.
 *
 * This immutable value object encapsulates the complete set of attributes that define
 * a database column's structure and behavior. It provides a type-safe way to transfer
 * column definitions between different layers of the application.
 *
 * @template-extends AbstractDTO<ColumnAttributesDTO>
 * @final
 */
final class ColumnAttributesDTO extends AbstractDTO
{
    /**
     * @var string The column identifier in the database schema
     */
    #[Filled]
    public string $name;

    /**
     * @var ColumnType The SQL data type of the column
     */
    #[Enum(ColumnType::class)]
    public ColumnType $type;

    /**
     * @var int|null The maximum length for string-based column types
     */
    public int|null $length = null;

    /**
     * @var int|null The total number of digits for numeric column types
     */
    public int|null $precision = null;

    /**
     * @var int|null The number of digits after the decimal point for numeric types
     */
    public int|null $scale = null;

    /**
     * @var bool|null Indicates if the column can contain NULL values
     */
    public bool|null $nullable = false;

    /**
     * @var bool|null Specifies if numeric column should be unsigned
     */
    public bool|null $unsigned = false;

    /**
     * @var bool|null Determines if column value should auto-increment
     */
    public bool|null $autoIncrement = false;

    /**
     * @var bool|null Indicates if column is part of primary key
     */
    public bool|null $primary = false;

    /**
     * @var bool|null Specifies if column values must be unique
     */
    public bool|null $unique = false;

    /**
     * @var string|int|float|bool|null Default value for the column
     */
    public string|int|float|bool|null $default = null;

    /**
     * @var array<string>|null Possible values for ENUM type columns
     */
    public array|null $enum = null;

    /**
     * @var string|null Expression for generated columns
     */
    public string|null $generated = null;

    /**
     * @var string|null Column name after which this column should be placed
     */
    public string|null $after = null;

    /**
     * @var bool|null Use current timestamp for temporal columns
     */
    public bool|null $useCurrent = false;

    /**
     * @var bool|null Update temporal columns on record modification
     */
    public bool|null $useCurrentOnUpdate = false;

    /**
     * @var string|null Alternative name for the column
     */
    public string|null $alias = null;

    /**
     * @var string|null Documentation or description for the column
     */
    public string|null $comment = null;

    /**
     * @var array<string, mixed> Foreign key relationship configuration
     */
    public array $foreign = [];

    /**
     * @var array<string, mixed> Nested column definitions for complex types
     */
    public array $columns = [];
}
=== Database/Migration/Design/Column/Enums/ColumnType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Enum representing standardized SQL column types.
 *
 * Provides type-safe mapping to SQL-compatible type strings.
 * Improves reliability and prevents typos in column definitions.
 */
enum ColumnType: string
{
    /**
     * Uses the SupportsCaseMappedEnum trait to enable case-insensitive enum value mapping with alias support.
     *
     * This trait provides functionality for mapping string inputs to enum cases in a case-insensitive manner,
     * with support for custom aliases. It's particularly useful in Domain-Driven Design (DDD) when working
     * with value objects and enums that need flexible input handling.
     *
     * @template-implements SupportsCaseMappedEnum<static>
     *
     * @see   BackedEnum For backed enum compatibility
     * @since 8.3.0
     */
    use SupportsCaseMappedEnum;

    /**
     * Standard 4-byte integer type supporting values from -2^31 to 2^31-1
     */
    case INT = 'INT';

    /**
     * Represents an INTEGER column type in the database schema.
     *
     * This type is used for storing whole numbers without decimal points.
     * Typically used for primary keys, foreign keys, and numerical data that
     * doesn't require decimal precision.
     *
     * @var string
     * @since 1.0.0
     * @immutable
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::isNumeric()
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::requiresLength()
     */
    case INTEGER = 'INTEGER';

    /**
     * Large 8-byte integer type supporting values from -2^63 to 2^63-1
     */
    case BIGINT = 'BIGINT';

    /**
     * Small 2-byte integer type supporting values from -32,768 to 32,767
     */
    case SMALLINT = 'SMALLINT';

    /**
     * Medium 3-byte integer type supporting values from -8,388,608 to 8,388,607
     */
    case MEDIUMINT = 'MEDIUMINT';

    /**
     * Tiny 1-byte integer type supporting values from -128 to 127
     */
    case TINYINT = 'TINYINT';

    /**
     * Fixed-point decimal number with configurable precision and scale
     */
    case DECIMAL = 'DECIMAL';

    /**
     * Single-precision floating-point number (4 bytes)
     */
    case FLOAT = 'FLOAT';

    /**
     * Double-precision floating-point number (8 bytes)
     */
    case DOUBLE = 'DOUBLE';

    /**
     * Variable-length string type with a maximum length specification
     */
    case VARCHAR = 'VARCHAR';

    /**
     * Fixed-length string type, padded with spaces to specified length
     */
    case CHAR = 'CHAR';

    /**
     * Variable-length text type with a maximum size of 65,535 bytes
     */
    case TEXT = 'TEXT';

    /**
     * Variable-length text type with maximum size of 4GB
     */
    case LONGTEXT = 'LONGTEXT';

    /**
     * Variable-length text type with maximum size of 16MB
     */
    case MEDIUMTEXT = 'MEDIUMTEXT';

    /**
     * Variable-length text type with maximum size of 255 bytes
     */
    case TINYTEXT = 'TINYTEXT';

    /**
     * Date type storing year, month, and day
     */
    case DATE = 'DATE';

    /**
     * Date and time type with microsecond precision
     */
    case DATETIME = 'DATETIME';

    /**
     * Timestamp type for tracking record modifications
     */
    case TIMESTAMP = 'TIMESTAMP';

    /**
     * Time type storing hours, minutes, seconds
     */
    case TIME = 'TIME';

    /**
     * Year type storing values from 1901 to 2155
     */
    case YEAR = 'YEAR';

    /**
     * JSON document type with validation and indexing capabilities
     */
    case JSON = 'JSON';

    /**
     * Binary JSON type optimized for indexing and querying
     */
    case JSONB = 'JSONB';

    /**
     * Binary large object type for storing binary data
     */
    case BLOB = 'BLOB';

    /**
     * Enumerated type with predefined set of valid values
     */
    case ENUM = 'ENUM';

    /**
     * Set type allowing multiple values from predefined options
     */
    case SET = 'SET';

    /**
     * Vector type for AI/ML applications and similarity searches
     */
    case VECTOR = 'VECTOR';

    /**
     * Geographic spatial data type for location-based features
     */
    case GEOGRAPHY = 'GEOGRAPHY';

    /**
     * UUID type for globally unique identifiers (36 chars)
     */
    case UUID = 'UUID';

    /**
     * ULID type for sortable unique identifiers (26 chars)
     */
    case ULID = 'ULID';

    /**
     * Boolean type typically implemented as TINYINT(1)
     */
    case BOOLEAN = 'BOOLEAN';

    /**
     * Foreign key constraint type for referential integrity
     */
    case FOREIGN_KEY = 'FOREIGN KEY';

    /**
     * Standard index type for query optimization
     */
    case INDEX = 'INDEX';

    /**
     * Unique constraint index type ensuring value uniqueness
     */
    case UNIQUE = 'UNIQUE';

    /**
     * Full-text search index type for text search optimization
     */
    case FULLTEXT = 'FULLTEXT';

    /**
     * Spatial index type for geographic data queries
     */
    case SPATIAL = 'SPATIAL';

    /**
     * Resolves a ColumnType enum from a DSL method name.
     *
     * @param string $method The DSL method name (e.g., 'string', 'text', 'uuid')
     *
     * @return self The corresponding ColumnType enum
     *
     * @throws \InvalidArgumentException If the method is not recognized
     */
    public static function fromDslMethod(string $method) : self
    {
        return self::map(input: $method);
    }


    /**
     * Returns a mapping of DSL (Domain-Specific Language) column type aliases to their corresponding database types.
     * This method establishes a unified type system across the domain model and persistence layer.
     *
     * @return array<string, string> Associative array mapping DSL type aliases to concrete database column types
     */
    public static function dslAliases() : array
    {
        // String-based column type mappings
        return [
            // Standard string variations for flexible text storage
            'string'     => self::VARCHAR,    // Variable-length character string, default choice for text
            'varchar'    => self::VARCHAR,    // Alternative notation for VARCHAR type
            'char'       => self::CHAR,       // Fixed-length character string

            // Text storage variations with different capacity limits
            'text'       => self::TEXT,       // Standard text type for larger string storage
            'longText'   => self::LONGTEXT,   // Maximum capacity text storage
            'mediumText' => self::MEDIUMTEXT, // Medium capacity text storage
            'tinyText'   => self::TINYTEXT,   // Minimal capacity text storage

            // Unique identifier types
            'uuid'       => self::UUID,       // Universally Unique Identifier (128-bit)
            'ulid'       => self::ULID,       // Universally Unique Lexicographically Sortable Identifier

            // JSON data types
            'json'       => self::JSON,       // Standard JSON storage type
            'jsonb'      => self::JSONB,      // Binary JSON storage (PostgreSQL specific)

            // Integer-based numeric types
            'int'        => self::INTEGER,    // Standard integer type
            'integer'    => self::INTEGER,    // Alternative notation for INTEGER
            'bigint'     => self::BIGINT,     // Large-range integer type
            'smallint'   => self::SMALLINT,   // Small-range integer type
            'tinyint'    => self::TINYINT,    // Minimal-range integer type

            // Decimal number types
            'decimal'    => self::DECIMAL,    // Exact decimal number type
            'float'      => self::FLOAT,      // Floating-point number type
            'double'     => self::DOUBLE,     // Double precision floating-point type

            // Boolean type aliases
            'boolean'    => self::BOOLEAN,    // Standard boolean type
            'bool'       => self::BOOLEAN,    // Alternative notation for BOOLEAN

            // Date and time types
            'date'       => self::DATE,       // Date storage without time
            'datetime'   => self::DATETIME,   // Combined date and time storage
            'timestamp'  => self::TIMESTAMP,  // Timestamp with timezone awareness
            'time'       => self::TIME,       // Time storage without date
            'year'       => self::YEAR,       // Year storage only

            'foreign'     => self::FOREIGN_KEY,
            'foreignKey'  => self::FOREIGN_KEY,
            'foreign_key' => self::FOREIGN_KEY,
            'foreign key' => self::FOREIGN_KEY,
        ];
    }

    /**
     * Returns only the raw SQL type string for this column, without metadata.
     *
     * Useful for quick compatibility checks, logging, or fallback rendering.
     *
     * Delegates to toSqlTypeDefinition() and extracts the base SQL type.
     *
     * @return string SQL-compatible column type name (e.g., "CHAR", "TINYINT")
     */
    public function toSqlType() : string
    {
        return $this->toSqlTypeDefinition()->type;
    }

    /**
     * Returns the physical SQL type representation for the current ColumnType,
     * including fixed-length or precision information when relevant.
     *
     * This is critical for type-safe schema generation (e.g. CHAR(36) for UUID).
     *
     * @return SqlTypeDefinition Full SQL type contract with constraints
     */
    public function toSqlTypeDefinition() : SqlTypeDefinition
    {
        return match ($this) {
            self::UUID    => new SqlTypeDefinition(type: 'CHAR', length: 36),
            self::ULID    => new SqlTypeDefinition(type: 'CHAR', length: 26),
            self::BOOLEAN => new SqlTypeDefinition(type: 'TINYINT', length: 1),
            self::VARCHAR => new SqlTypeDefinition(type: 'VARCHAR', length: 255),
            self::CHAR    => new SqlTypeDefinition(type: 'CHAR', length: 255),
            self::DECIMAL => new SqlTypeDefinition(type: 'DECIMAL', precision: 10, scale: 2),
            self::FLOAT,
            self::DOUBLE  => new SqlTypeDefinition(type: $this->value, precision: 10, scale: 2),
            default       => new SqlTypeDefinition(type: $this->value),
        };
    }

    /**
     * Determines whether the current column type represents an index type.
     *
     * @return bool True if the type is an index type, false otherwise
     */
    public function isIndex() : bool
    {
        return match ($this) {
            self::INDEX,
            self::UNIQUE,
            self::FULLTEXT,
            self::SPATIAL => true,
            default       => false,
        };
    }

    /**
     * Determines whether the column type requires a length specification.
     *
     * @return bool True if length is required, false otherwise
     */
    public function requiresLength() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::UUID,
            self::ULID,
            self::VECTOR => true,
            default      => false,
        };
    }

    /**
     * Determines if the column type supports precision and scale parameters.
     *
     * @return bool True if precision/scale are supported, false otherwise
     */
    public function supportsPrecision() : bool
    {
        return match ($this) {
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Indicates whether the column type is temporal (timestamp/datetime/etc).
     *
     * @return bool
     */
    public function isTemporal() : bool
    {
        return match ($this) {
            self::TIMESTAMP,
            self::DATETIME,
            self::DATE,
            self::TIME,
            self::YEAR => true,
            default    => false,
        };
    }

    /**
     * Determines if the type is string-compatible.
     *
     * @return bool
     */
    public function isString() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::TEXT,
            self::LONGTEXT,
            self::MEDIUMTEXT,
            self::TINYTEXT,
            self::UUID,
            self::ULID => true,
            default    => false,
        };
    }

    /**
     * Returns the default length for types that require it.
     *
     * @return int|null Default length or null
     */
    public function defaultLength() : int|null
    {
        return match ($this) {
            self::UUID    => 36,
            self::ULID    => 26,
            self::CHAR,
            self::VARCHAR => 255,
            self::VECTOR  => 1536,
            default       => null,
        };
    }

    /**
     * Determines if the type is numeric.
     *
     * @return bool True if numeric
     */
    public function isNumeric() : bool
    {
        return match ($this) {
            self::INT,
            self::BIGINT,
            self::SMALLINT,
            self::MEDIUMINT,
            self::TINYINT,
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Retrieves the primary DSL method alias for the current schema type.
     *
     * This method returns the first (most preferred) method name from the available
     * DSL method aliases. It's particularly useful in fluent schema definitions
     * where a consistent primary method name is required.
     *
     * @return string The primary DSL method alias for the current schema type
     * @see   preferredDslMethods() For the complete list of available DSL method aliases
     * @since 8.3
     */
    public function getPreferredAlias() : string
    {
        // Retrieve the first (primary) DSL method alias from the available methods
        return $this->preferredDslMethods()[0];
    }

    /**
     * Reverse map to prefer DSL-friendly names (e.g. use `string()` instead of `varchar()`).
     * Returns an array of preferred DSL (Domain Specific Language) method names for the current field type.
     *
     * This method maps enumeration cases to their corresponding fluent schema builder methods,
     * facilitating a more expressive and domain-driven database schema definition.
     *
     * @return array<int, string> Array of method names available for this field type
     * @throws never
     * @api
     * @since 1.0.0
     */
    public function preferredDslMethods() : array
    {
        // Match expression provides exhaustive type mapping for schema builder methods
        return match ($this) {
            // Maps VARCHAR type to both 'string' and 'varchar' method names for flexibility
            self::VARCHAR     => ['string', 'varchar'],

            // Boolean type supports both full and short method names
            self::BOOLEAN     => ['boolean', 'bool'],

            // Integer type supports both full and short method names
            self::INTEGER     => ['integer', 'int'],

            // Text type maps to the 'text' schema builder method
            self::TEXT        => ['text'],

            // LongText type maps to the camelCase 'longText' method
            self::LONGTEXT    => ['longText'],

            // Char type maps directly to the 'char' method
            self::CHAR        => ['char'],

            // Enum type maps to the 'enum' schema builder method
            self::ENUM        => ['enum'],

            self::FOREIGN_KEY => ['foreign', 'foreignKey', 'foreign_key'],


            // Fallback for any undefined types, converts enum case name to lowercase
            default           => [strtolower($this->name)],
        };
    }
}

=== Database/Migration/Design/Column/Enums/ReferentialAction.php ===
<?php

/**
 * ReferentialAction Enum for Database Foreign Key Constraints
 *
 * This enum defines the possible actions that can be taken when a referenced
 * record is deleted or updated in a foreign key relationship.
 *
 * @package Gemini\Database\Migration\Table\Column
 * @since   1.0.0
 * @immutable
 */
declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

enum ReferentialAction: string
{
    /**
     * Automatically delete or update related records when the referenced record is deleted/updated
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Set the foreign key column value to NULL when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Prevent deletion/update of referenced record if it has related records
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Similar to RESTRICT, prevents changes that would violate referential integrity
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Set the foreign key column to its default value when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_DEFAULT = 'SET DEFAULT';
}
=== Database/Migration/Design/Column/Enums/SqlTypeDefinition.php ===
<?php

/**
 * Strict type declaration for enhanced type safety and better performance.
 */
declare(strict_types=1);

/**
 * Namespace declaration following PSR-4 autoloading standards.
 * Contains value objects related to SQL column type definitions in the migration context.
 */

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Represents an immutable Value Object encapsulating SQL column type definition parameters.
 *
 * This class follows Domain-Driven Design principles by representing a concept from
 * the ubiquitous language of database schema design. It is marked as final to prevent
 * inheritance and ensure immutability through the readonly modifier.
 *
 * @package Gemini\Database\Migration\Design\Column\Enums
 * @final
 * @readonly
 */
final readonly class SqlTypeDefinition
{
    /**
     * Constructs a new SQL type definition with its associated parameters.
     *
     * Uses constructor property promotion for concise and expressive initialization
     * of the value object's properties.
     *
     * @param string   $type      The SQL data type identifier (e.g., 'VARCHAR', 'DECIMAL')
     * @param int|null $length    Optional length parameter for types that support it (e.g., VARCHAR(255))
     * @param int|null $precision Optional precision for numeric types (total number of significant digits)
     * @param int|null $scale     Optional scale for numeric types (number of digits after decimal point)
     */
    public function __construct(
        public string   $type,
        public int|null $length = null,
        public int|null $precision = null,
        public int|null $scale = null,
    ) {}
}
=== Database/Migration/Design/Column/Enums/SupportsCaseMappedEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

use BackedEnum;
use LogicException;
use ValueError;

/**
 * A trait that provides sophisticated case-mapped enum support with DSL capabilities.
 *
 * This trait enhances backed enums with case-insensitive mapping functionality,
 * supporting both direct enum value/name matching and custom DSL aliases.
 *
 * @template T of BackedEnum
 *
 * @author AI Assistant <ai@example.com>
 * @since  1.0.0
 */
trait SupportsCaseMappedEnum
{
    /**
     * Error message for empty or whitespace-only input validation.
     *
     * @var string Constant representing the error message for empty input scenarios
     */
    private const string ERROR_EMPTY_INPUT = "Enum mapping input cannot be empty or whitespace.";

    /**
     * Error message template for invalid alias mapping scenarios.
     *
     * @var string Constant representing the error message for invalid alias configurations
     */
    private const string ERROR_INVALID_ALIAS = 'Invalid alias mapping for "%s". Expected instance of %s, got %s.';

    /**
     * Error message template for unmatched enum cases.
     *
     * @var string Constant representing the error message when no matching enum case is found
     */
    private const string ERROR_NO_MATCH = 'No matching enum case found for "%s". Valid inputs: [%s]';

    /**
     * Determines if the provided input string can be mapped to an enum case.
     *
     * @param string $input The input string to validate for mapping possibility
     *
     * @return bool True if mapping is possible, false otherwise
     */
    public static function canMap(string $input) : bool
    {
        return static::tryMap(input: $input) !== null;
    }

    /**
     * Attempts to map the input string to an enum case, returning null on failure.
     *
     * @param string $input The input string to attempt mapping
     *
     * @return static|null The mapped enum case or null if mapping fails
     */
    public static function tryMap(string $input) : static|null
    {
        try {
            return static::map(input: $input);
        } catch (ValueError) {
            return null;
        }
    }

    /**
     * Maps the input string to an enum case or throws an exception on failure.
     *
     * @param string $input The input string to map to an enum case
     *
     * @return static The successfully mapped enum case
     * @throws ValueError When mapping fails or input is invalid
     */
    public static function map(string $input) : static
    {
        // Validate input for emptiness
        if (trim($input) === '') {
            throw new ValueError(message: self::ERROR_EMPTY_INPUT);
        }

        // Normalize input for case-insensitive comparison
        $normalized = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $input)); // camelCase → snake_case → lower

        // Attempt to find a match through various strategies
        $matchedCase = self::findMatchInAliases($normalized)
                       ?? self::findMatchByValue($normalized)
                          ?? self::findMatchByName($normalized);

        if ($matchedCase !== null) {
            return $matchedCase;
        }

        // No match found, throw a detailed exception
        throw new ValueError(
            message: sprintf(
                         self::ERROR_NO_MATCH,
                         $input,
                         self::getValidInputsString($normalized)
                     )
        );
    }

    /**
     * Attempts to find a matching enum case through configured aliases.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     * @throws LogicException When alias mapping is invalid
     */
    private static function findMatchInAliases(string $normalized) : static|null
    {
        // Check if DSL aliases are supported
        if (! method_exists(static::class, 'dslAliases')) {
            return null;
        }

        $aliases = static::dslAliases();

        // Check if normalized input exists in aliases
        if (! array_key_exists($normalized, $aliases)) {
            return null;
        }

        $aliasTarget = $aliases[$normalized];

        // Validate alias target type
        if (! ($aliasTarget instanceof static)) {
            throw new LogicException(
                message: sprintf(
                             self::ERROR_INVALID_ALIAS,
                             $normalized,
                             static::class,
                             get_debug_type($aliasTarget)
                         )
            );
        }

        return $aliasTarget;
    }

    /**
     * Provides DSL aliases for enum cases. Override this method to define custom mappings.
     *
     * @return array<string, static> Array of alias => enum case mappings
     */
    protected static function dslAliases() : array
    {
        return [];
    }

    /**
     * Attempts to find a matching enum case by its value.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByValue(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->value) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Attempts to find a matching enum case by its name.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByName(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->name) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Generates a string of all valid input values for error messaging.
     *
     * @param string $normalized The normalized input string (unused but kept for consistency)
     *
     * @return string Comma-separated list of valid inputs
     */
    protected static function getValidInputsString(string $normalized) : string
    {
        $cases   = static::cases();
        $aliases = method_exists(static::class, 'dslAliases') ? static::dslAliases() : [];

        $valid = array_merge(
            array_keys($aliases),
            array_map(static fn($c) => strtolower($c->value), $cases),
            array_map(static fn($c) => strtolower($c->name), $cases)
        );

        return implode(', ', array_unique($valid));
    }
}
=== Database/Migration/Design/Column/Renderer/ColumnDSLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;

/**
 * Renders column definitions into Gemini migration DSL format.
 *
 * This final class is responsible for converting column attributes into
 * syntactically correct Laravel migration method chains. It follows DDD principles
 * by encapsulating all column DSL rendering logic in a dedicated service.
 *
 * @final
 */
final class ColumnDSLRenderer
{
    /**
     * Formats column attributes into a Laravel migration DSL string.
     *
     * This method transforms the domain model (ColumnAttributes) into a valid
     * Laravel migration method chain, handling type-specific formatting,
     * modifiers, and defaults according to Laravel's schema builder syntax.
     *
     * @param ColumnAttributes $column The column attributes to format
     *
     * @return string The formatted Laravel migration DSL statement
     */
    public function format(ColumnAttributes $column) : string
    {
        // Retrieves the preferred Domain-Specific Language (DSL) method mapping for the column type.
        $type = $column->type->getPreferredAlias();

        // Prepare base arguments starting with the column name
        $args = [$column->name];

        // Add length parameter for string-based column types
        if ($column->type->requiresLength() && $column->length !== null) {
            $args[] = $column->length;
        }

        // Add precision and scale for numeric types
        if ($column->type->supportsPrecision()) {
            $args[] = $column->precision ?? 10; // Default precision if isn't specified
            $args[] = $column->scale ?? 2;      // Default scale if isn't specified
        }

        // Construct the base column definition
        $dsl = sprintf(
            '$table->%s(%s)',
            $type,
            implode(', ', array_map(static fn($a) => var_export($a, true), $args))
        );

        // Define available column modifiers with their corresponding method names
        $modifiers = [
            'nullable'           => 'nullable',
            'unsigned'           => 'unsigned',
            'autoIncrement'      => 'autoIncrement',
            'primary'            => 'primary',
            'unique'             => 'unique',
            'useCurrent'         => 'useCurrent',
            'useCurrentOnUpdate' => 'useCurrentOnUpdate',
        ];

        // Apply modifiers if their corresponding attributes are true
        foreach ($modifiers as $attr => $method) {
            if ($column->{$attr} === true) {
                $dsl .= "->{$method}()";
            }
        }

        // Add default value if specified
        if ($column->default !== null) {
            $escaped = is_string($column->default) ? "'{$column->default}'" : var_export($column->default, true);
            $dsl     .= "->default({$escaped})";
        }

        // Terminate the statement with semicolon
        return $dsl . ';';
    }
}
=== Database/Migration/Design/Column/Renderer/ColumnSQLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

final class ColumnSQLRenderer
{
    /**
     * Static entrypoint for rendering a column definition.
     *
     * @param ColumnAttributes $column The column to render
     *
     * @return string SQL representation of the column
     */
    public static function render(ColumnAttributes $column) : string
    {
        return (new self())->format($column);
    }

    public function format(ColumnAttributes $column) : string
    {
        return match (true) {
            $column->type === ColumnType::FOREIGN_KEY => $this->buildForeignKey($column),
            $column->type->isIndex()                  => $this->buildIndex($column),
            default                                   => $this->buildColumn($column),
        };
    }

    private function buildForeignKey(ColumnAttributes $c) : string
    {
        $sql = sprintf(
            'FOREIGN KEY (`%s`) REFERENCES `%s`(`%s`)',
            $c->name,
            $c->foreign['on'] ?? 'unknown_table',
            $c->foreign['references'] ?? 'id'
        );

        if (! empty($c->foreign['onDelete'])) {
            $sql .= ' ON DELETE ' . $c->foreign['onDelete'];
        }

        if (! empty($c->foreign['onUpdate'])) {
            $sql .= ' ON UPDATE ' . $c->foreign['onUpdate'];
        }

        return $sql;
    }

    private function buildIndex(ColumnAttributes $c) : string
    {
        return strtoupper($c->type->toSqlType()) . " `{$c->name}` (" . implode(', ', $c->columns) . ")";
    }

    private function buildColumn(ColumnAttributes $c) : string
    {
        $sql = "`{$c->name}` " . $this->typeDeclaration($c);

        $sql .= $c->unsigned ? ' UNSIGNED' : '';
        $sql .= $c->nullable ? ' NULL' : ' NOT NULL';
        $sql .= $this->defaultClause($c);
        $sql .= $c->autoIncrement ? ' AUTO_INCREMENT' : '';
        $sql .= $c->unique ? ' UNIQUE' : '';
        $sql .= $c->primary ? ' PRIMARY KEY' : '';
        $sql .= $c->generated ? " {$c->generated}" : '';
        $sql .= $c->after ? " AFTER `{$c->after}`" : '';
        $sql .= $c->alias !== null ? " AS `{$c->alias}`" : '';

        return trim($sql);
    }

    private function typeDeclaration(ColumnAttributes $c) : string
    {
        if ($c->type === ColumnType::ENUM && $c->enum !== null) {
            $quoted = array_map(static fn(string $v) : string => "'{$v}'", $c->enum);

            return 'ENUM(' . implode(', ', $quoted) . ')';
        }

        return match (true) {
            $c->type === ColumnType::DECIMAL                  =>
                "DECIMAL(" . ($c->precision ?? 8) . ", " . ($c->scale ?? 2) . ")",
            $c->type->requiresLength() && $c->length !== null =>
                $c->type->toSqlType() . "({$c->length})",
            default                                           => $c->type->toSqlType(),
        };
    }

    private function defaultClause(ColumnAttributes $c) : string
    {
        if ($c->default !== null) {
            $escaped = match (true) {
                is_string($c->default) => "'{$c->default}'",
                $c->default === true   => '1',
                $c->default === false  => '0',
                default                => $c->default
            };

            return " DEFAULT {$escaped}";
        }

        if ($c->useCurrent) {
            return ' DEFAULT CURRENT_TIMESTAMP';
        }

        return '';
    }
}

=== Database/Migration/Design/Mapper/FieldToDslMapperInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;

/**
 * Defines the contract for mapping field data transfer objects to database schema DSL.
 *
 * This interface is part of the database migration domain and implements the Strategy pattern,
 * allowing for flexible field-to-DSL mapping strategies. It serves as a crucial component
 * in translating field definitions into concrete database schema specifications.
 *
 * Key responsibilities:
 * - Translates FieldDTO objects into table schema modifications
 * - Ensures consistent field mapping across different database platforms
 * - Maintains single responsibility principle for field transformation logic
 *
 * @package Gemini\Database\Migration\Design\Mapper
 * @since   8.3.0
 */
interface FieldToDslMapperInterface
{
    /**
     * Applies the field mapping strategy to transform a FieldDTO into table schema modifications.
     *
     * This method implements the core mapping logic, taking a table instance and field DTO
     * as input and applying the necessary schema modifications through the table's DSL.
     *
     * @param Table    $table The target table to apply the field mapping to
     * @param FieldDTO $field The field data transfer object containing the field definition
     *
     * @return void
     *
     * @throws \InvalidArgumentException If the field definition is invalid
     * @throws \RuntimeException If the mapping operation fails
     */
    public function apply(Table $table, FieldDTO $field) : void;
}
=== Database/Migration/Design/Mapper/FluentFieldToDslMapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Enums\ReferentialAction;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;
use Throwable;

/**
 * Maps database field specifications to fluent DSL expressions in the schema builder.
 *
 * This mapper translates abstract field definitions (FieldDTO) into concrete database schema
 * declarations using a fluent interface. It encapsulates the complexity of mapping various
 * field types, their modifiers, and foreign key relationships.
 *
 * @final   This class is not designed for extension as per Interface Segregation Principle
 *
 * @package Gemini\Database\Migration\Design\Mapper
 * @version 1.0.0
 * @since   8.3
 */
final class FluentFieldToDslMapper implements FieldToDslMapperInterface
{
    /**
     * Transforms a field specification into its corresponding database schema representation.
     *
     * This method serves as the primary entry point for field-to-schema mapping operations.
     * It orchestrates the process of:
     * 1. Type resolution and column creation
     * 2. Foreign key relationship configuration (if applicable)
     * 3. Column modifier application
     *
     * @param Table    $table The schema builder table instance to modify
     * @param FieldDTO $field The field specification to transform
     *
     * @throws RuntimeException When column creation fails or invalid specifications are provided
     */
    public function apply(Table $table, FieldDTO $field) : void
    {
        try {
            // Map the field type to a concrete ColumnType enum
            $typeEnum = ColumnType::map(input: $field->type->value);

            // Create the base column definition
            $column = $this->createColumn(table: $table, typeEnum: $typeEnum, field: $field);

            // Apply foreign key specific configurations if applicable
            if ($typeEnum === ColumnType::FOREIGN_KEY) {
                $column = $this->applyForeignKeyActions(column: $column, field: $field);
            }

            // Apply any additional modifiers to the column
            $this->applyModifiers(
                table     : $table,
                column    : $column,
                modifiers : $field->attributes ?? [],
                typeMethod: strtolower($typeEnum->name)
            );
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : sprintf("Column creation failed for method '%s': %s", $field->type->value, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Creates a column instance based on the specified type and field configuration.
     *
     * @param Table      $table    The table blueprint instance
     * @param ColumnType $typeEnum The enumerated column type
     * @param FieldDTO   $field    The field specification
     *
     * @return object The created column instance
     */
    private function createColumn(Table $table, ColumnType $typeEnum, FieldDTO $field) : object
    {
        $args = $this->resolveColumnArguments(typeEnum: $typeEnum, field: $field);

        return $typeEnum === ColumnType::FOREIGN_KEY
            ? $table->foreignKey(...$args)
            : $table->{strtolower($typeEnum->name)}(...$args);
    }

    /**
     * Resolves constructor arguments for column creation based on type and field specification.
     *
     * Maps different column types to their required constructor arguments, handling default values
     * and mandatory parameters for each type.
     *
     * @param ColumnType $typeEnum The type of column being created
     * @param FieldDTO   $field    The field specification containing the parameters
     *
     * @return array<int, mixed> Resolved constructor arguments
     *
     * @throws RuntimeException When required foreign key parameters are missing
     * @noinspection PhpFeatureEnvyLocalInspection
     */
    private function resolveColumnArguments(ColumnType $typeEnum, FieldDTO $field) : array
    {
        return match ($typeEnum) {
            ColumnType::VARCHAR, ColumnType::CHAR                      => [
                $field->name,
                $field->length ?? 255,
            ],
            ColumnType::DECIMAL, ColumnType::FLOAT, ColumnType::DOUBLE => [
                $field->name,
                ...$this->hasPrecisionScale($field)
                    ? [$field->total, $field->places]
                    : throw new RuntimeException(
                        sprintf(
                            "Invalid precision/scale for '%s': total=%s, places=%s",
                            $field->name,
                            var_export($field->total, true),
                            var_export($field->places, true)
                        )
                    ),
            ],

            ColumnType::ENUM, ColumnType::SET                          => [
                $field->name,
                $field->enum ?? [],
            ],
            ColumnType::FOREIGN_KEY                                    => [
                $field->columns[0] ?? throw new RuntimeException(message: "Missing local column name for foreign key."),
                $field->references ?? throw new RuntimeException(message: "Missing 'references' for foreign key."),
                $field->on ?? throw new RuntimeException(message: "Missing 'on' (referenced table) for foreign key."),
            ],
            default                                                    => [$field->name],
        };
    }

    /**
     * Validates numeric precision and scale parameters for decimal-type columns.
     *
     * Ensures that the precision (total digits) and scale (decimal places) are valid
     * and logically consistent.
     *
     * @param FieldDTO $field The field specification to validate
     *
     * @return bool True if the precision/scale combination is valid
     */
    private function hasPrecisionScale(FieldDTO $field) : bool
    {
        return is_int($field->total)
               && is_int($field->places)
               && $field->total >= $field->places;
    }

    /**
     * Configures referential actions for foreign key constraints.
     *
     * @param object   $column The foreign key column instance
     * @param FieldDTO $field  The field specification containing referential actions
     *
     * @return object The modified column instance
     */
    private function applyForeignKeyActions(object $column, FieldDTO $field) : object
    {
        if (is_string($field->onDelete)) {
            $column = $column->onDelete(
                ReferentialAction::tryFrom(value: strtoupper(trim($field->onDelete)))
            );
        }

        if (is_string($field->onUpdate)) {
            $column = $column->onUpdate(
                ReferentialAction::tryFrom(value: strtoupper(trim($field->onUpdate)))
            );
        }

        return $column;
    }

    /**
     * Applies a sequence of modifiers to a column definition.
     *
     * Validates and applies each modifier in sequence, ensuring the modifier exists
     * for the given column type.
     *
     * @param Table  $table      The table blueprint instance
     * @param object $column     The column instance to modify
     * @param array  $modifiers  List of modifiers to apply
     * @param string $typeMethod The column type method name
     *
     * @throws RuntimeException When an invalid modifier is specified
     */
    private function applyModifiers(Table $table, object $column, array $modifiers, string $typeMethod) : void
    {
        foreach ($modifiers as $modifier) {
            if (! method_exists($column, $modifier)) {
                throw new RuntimeException(
                    message: sprintf(
                                 "Column modifier '%s' is not available on column type '%s'.",
                                 $modifier,
                                 $typeMethod
                             )
                );
            }
            $column = $column->{$modifier}();
            $table->replaceColumn(column: $column);
        }
    }
}
=== Database/Migration/Design/Table/Alter/AlterTable.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Closure;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddForeignKeyDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddIndexDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\RenameColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use InvalidArgumentException;
use ReflectionException;
use RuntimeException;

/**
 * Provides a fluent Domain-Specific Language (DSL) for database table alterations.
 *
 * This value object encapsulates the complete specification for altering database tables,
 * following Domain-Driven Design principles. It provides an immutable, type-safe interface
 * for defining structural changes to database tables.
 *
 * Example usage:
 * ```
 * $alter = AlterTable::for('users')
 *     ->addColumn('email', 'string')
 *     ->modifyColumn('status', fn(Column $column) => $column->enum(['active', 'inactive']))
 *     ->dropColumn('deprecated_field');
 * ```
 *
 * @final This class is not intended for inheritance
 */
final class AlterTable
{
    /**
     * Represents an immutable collection of atomic table alteration operations.
     *
     * This property maintains the ordered sequence of modifications that will be
     * applied to the database table. The order is significant as certain operations
     * may have dependencies on previous alterations.
     *
     * Operations are executed in FIFO (First-In-First-Out) order, ensuring
     * predictable schema modification behavior.
     *
     * @var list<AlterOperation> $operations A strictly typed list of atomic table modifications
     *                                       where each operation represents a single schema change
     */
    private array $operations = [];

    /**
     * Initializes a new immutable table alteration specification.
     *
     * @param string $tableName The canonical name of the database table to be altered
     *                          Must be a valid identifier according to database naming conventions
     *
     * @throws InvalidArgumentException If the table name is empty or contains invalid characters
     */
    private function __construct(private readonly string $tableName) {}

    /**
     * Creates a new table alteration specification following the named constructor pattern.
     * This factory method provides a more expressive and semantic way to initiate table alterations.
     *
     * @param string $tableName The identifier of the table to alter
     *
     * @return self A new immutable instance of TableAlteration
     *
     * @throws InvalidArgumentException If table name validation fails
     *
     * @api
     */
    public static function for(string $tableName) : self
    {
        return new self(tableName: $tableName);
    }

    /**
     * Adds a new column to the table with specified characteristics.
     *
     * @param string               $name   The identifier for the new column
     * @param string               $type   The SQL data type for the column
     * @param array<string, mixed> $params Additional column attributes
     *
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function addColumn(string $name, string $type, array $params = []) : self
    {
        $definition = $this->createColumnDefinition(
            method   : 'create',
            arguments: [$name, ...$params]
        );

        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Factory method for creating column definitions with specific configurations.
     *
     * @param string $method    The method name representing the column operation
     * @param array  $arguments Configuration parameters for the column
     *
     * @throws ReflectionException
     */
    private function createColumnDefinition(string $method, array $arguments) : ColumnDefinition
    {
        return (new Column())->create(method: $method, arguments: $arguments);
    }

    /**
     * Modifies an existing column's definition using a callback.
     *
     * @param string                            $name                     The identifier of the column to modify
     * @param Closure(Column): ColumnDefinition $columnDefinitionCallback Configuration callback
     *
     * @throws RuntimeException When callback returns an invalid definition
     */
    public function modifyColumn(string $name, Closure $columnDefinitionCallback) : self
    {
        $column     = new Column();
        $definition = $columnDefinitionCallback($column);

        if (! $definition instanceof ColumnDefinition) {
            throw new RuntimeException(
                message: 'Column definition callback must return a ColumnDefinition instance'
            );
        }

        $this->operations[] = new AlterOperation(
            type      : AlterType::MODIFY_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Renames an existing column in the table.
     *
     * This method creates a rename operation for an existing column while maintaining
     * referential integrity and schema consistency.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     *
     * @return self Fluent interface for method chaining
     *
     */
    public function renameColumn(string $from, string $to) : self
    {
        $this->operations[] = new AlterOperation(
            type      : AlterType::RENAME_COLUMN,
            target    : $from,
            definition: new RenameColumnDefinition(from: $from, to: $to)
        );

        return $this;
    }


    /**
     * Removes a column from the table structure.
     *
     * This operation permanently removes the specified column and its data.
     * It Should be used with caution as it's irreversible in production.
     *
     * @param string $column The name of the column to be dropped
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When column definition cannot be created
     */
    public function dropColumn(string $column) : self
    {
        // Create a column definition for the drop operation
        $definition = $this->createColumnDefinition(method: 'drop', arguments: [$column]);

        // Register the drop column operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_COLUMN,
            target    : $column,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes an index from the table.
     *
     * Handles the removal of an existing index while ensuring
     * database performance implications are considered.
     *
     * @param string $indexName The name of the index to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When index definition cannot be created
     */
    public function dropIndex(string $indexName) : self
    {
        // Create a column definition for the drop index operation
        $definition = $this->createColumnDefinition(method: 'dropIndex', arguments: [$indexName]);

        // Register the drop index operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_INDEX,
            target    : $indexName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes a foreign key constraint from the table.
     *
     * This operation removes the referential integrity constraint while
     * maintaining the underlying column and its data.
     *
     * @param string $foreignKeyName The name of the foreign key constraint to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When a foreign key definition cannot be created
     */
    public function dropForeign(string $foreignKeyName) : self
    {
        // Create a column definition for the drop foreign key operation
        $definition = $this->createColumnDefinition(method: 'dropForeign', arguments: [$foreignKeyName]);

        // Register the drop foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_FOREIGN,
            target    : $foreignKeyName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Adds a new index definition to the table alteration operations queue.
     *
     * This method follows Domain-Driven Design principles by encapsulating index
     * creation logic within the aggregate root's context. It ensures type safety
     * through strict parameter typing and immutable operation queuing.
     *
     * @param string                    $name    The unique identifier for the index within the table's scope
     * @param array<int|string, string> $columns List of column names to be included in the index
     * @param string                    $type    The index type specification (defaults to 'INDEX')
     *                                           Supported values: 'INDEX', 'UNIQUE', 'FULLTEXT', 'SPATIAL'
     *
     * @return self Returns the current instance for method chaining (fluent interface)
     *
     * @throws InvalidArgumentException When invalid index type is provided
     */
    public function addIndex(
        string $name,
        array  $columns,
        string $type = 'INDEX'
    ) : self {
        // Append new alter operation to the operations collection using constructor promotion
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_INDEX,        // Specifies the operation type as index addition
            target    : $name,                     // Sets the index name as the operation target
            definition: new AddIndexDefinition( // Creates immutable index definition
                            name   : $name,                   // Index identifier
                            columns: $columns,             // Columns to be indexed
                            type   : $type                    // Index type specification
                        )
        );

        // Return self for method chaining capability
        return $this;
    }

    /**
     * Retrieves the immutable table identifier from the migration context.
     *
     * This method provides access to the protected table name property, maintaining
     * encapsulation while exposing the necessary information for SQL generation.
     * Following Domain-Driven Design principles, it represents a crucial part of
     * the domain model's identity.
     *
     * @return string The fully qualified, immutable table identifier
     *
     * @throws never This method guarantees no exceptions will be thrown
     *
     * @api       This method is part of the public API contract
     * @since     1.0.0
     * @immutable This method always returns the same value for the same instance
     */
    public function getTable() : string
    {
        // Return the immutable table identifier stored during object construction
        return $this->tableName;
    }

    /**
     * Retrieves the collection of pending alter operations.
     *
     * @return list<AlterOperation> Ordered a sequence of table modifications
     */
    public function getOperations() : array
    {
        return $this->operations;
    }

    /**
     * Adds a foreign key constraint to establish referential integrity between tables.
     *
     * This domain operation ensures data consistency by creating a relationship between
     * the current table and a referenced table. It supports customizable referential
     * actions for maintaining data integrity during updates and deletions.
     *
     * @param string      $name       The identifier for the foreign key constraint
     * @param array       $columns    Local columns participating in the relationship
     * @param string      $refTable   The referenced table name
     * @param array       $refColumns Referenced columns in the target table
     * @param string|null $onDelete   Action to take when a referenced record is deleted
     * @param string|null $onUpdate   Action to take when a referenced record is updated
     *
     * @return self Fluent interface for method chaining
     *
     * @throws InvalidArgumentException When constraint parameters are invalid
     */
    public function addForeignKey(
        string      $name,       // Constraint identifier
        array       $columns,    // Source columns in the current table
        string      $refTable,   // Referenced table name
        array       $refColumns, // Target columns in the referenced table
        string|null $onDelete = null, // Optional deletion behavior
        string|null $onUpdate = null  // Optional update behavior
    ) : self
    {
        // Register a new foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_FOREIGN,      // Specify an operation type as a foreign key addition
            target    : $name,                       // Set the constraint name as the target
            definition: new AddForeignKeyDefinition( // Define the foreign key specifics
                            name             : $name,
                            columns          : $columns,
                            referencedTable  : $refTable,
                            referencedColumns: $refColumns,
                            onDelete         : $onDelete,
                            onUpdate         : $onUpdate
                        )
        );

        return $this; // Enable method chaining
    }
}
=== Database/Migration/Design/Table/Alter/AlterTableRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use RuntimeException;

/**
 * Class AlterTableRenderer
 *
 * Renders valid SQL ALTER TABLE statements from structured DSL operations.
 * Encapsulates the rendering logic for each supported operation, delegating
 * to the proper rendering strategies or SQL renderers depending on a definition type.
 *
 * @final
 */
final class AlterTableRenderer
{
    /**
     * Renders an ALTER TABLE SQL statement from a structured table alteration specification.
     *
     * This service method transforms a domain-specific AlterTable object into a valid SQL ALTER TABLE
     * statement. It ensures proper SQL syntax and escaping while maintaining database schema integrity.
     *
     * @param AlterTable $alter The domain model representing table alterations
     *
     * @return string The fully formed SQL ALTER TABLE statement
     * @throws RuntimeException When attempting to render an empty alteration set
     *
     * @example
     * $SQL = SQLRenderer::render(
     *     AlterTable::for('users')->addColumn('email', 'VARCHAR(255)')
     * );
     */
    public static function render(AlterTable $alter) : string
    {
        // Retrieve the collection of atomic table operations from the alteration specification
        $operations = $alter->getOperations();

        // Validate that at least one operation has been defined
        if (empty($operations)) {
            throw new RuntimeException(
                message: "No ALTER TABLE operations defined for table '{$alter->getTable()}'."
            );
        }

        // Transform each operation into its corresponding SQL representation
        $segments = [];
        foreach ($operations as $operation) {
            $segments[] = self::renderOperation(operation: $operation);
        }

        // Compose the final ALTER TABLE statement with a proper table name escaping
        return sprintf(
            'ALTER TABLE `%s` %s;',
            $alter->getTable(),
            implode(', ', $segments)
        );
    }

    /**
     * Renders a single database alteration operation into its SQL representation.
     *
     * This method implements the Strategy pattern by mapping AlterType enum values
     * to their corresponding SQL syntax. It ensures type-safety through PHP 8.3's
     * enhanced type system and match expressions.
     *
     * @param AlterOperation $operation The alteration operation value object
     *
     * @return string                  The SQL fragment representing the operation
     * @throws RuntimeException        When encountering unsupported operation types
     */
    private static function renderOperation(AlterOperation $operation) : string
    {
        // Use match expression for type-safe operation mapping
        return match ($operation->type) {
            // Handle column addition with proper SQL syntax
            AlterType::ADD_COLUMN    => sprintf(
                'ADD COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column modification maintaining schema consistency
            AlterType::MODIFY_COLUMN => sprintf(
                'MODIFY COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column renaming with a proper identifier escaping
            AlterType::RENAME_COLUMN => sprintf(
                'RENAME COLUMN `%s` TO `%s`',
                $operation->target,
                self::assertColumnRenameTarget(operation: $operation)
            ),

            // Handle column removal with a proper identifier escaping
            AlterType::DROP_COLUMN   => sprintf(
                'DROP COLUMN `%s`',
                $operation->target
            ),

            // Handle index removal with a proper identifier escaping
            AlterType::DROP_INDEX    => sprintf(
                'DROP INDEX `%s`',
                $operation->target
            ),

            // Handle foreign key constraint removal
            AlterType::DROP_FOREIGN  => sprintf(
                'DROP FOREIGN KEY `%s`',
                $operation->target
            ),

            // Handle index and foreign key additions through definition renderer
            AlterType::ADD_INDEX,
            AlterType::ADD_FOREIGN   => self::renderDefinition(operation: $operation),

            // Handle unsupported operations with a descriptive exception
            default                  => throw new RuntimeException(
                message: "Unsupported ALTER operation type: {$operation->type->value}"
            ),
        };
    }

    /**
     * Renders an SQL definition from an AlterOperation using polymorphic behavior.
     *
     * This method implements the Strategy pattern by dynamically selecting the appropriate
     * rendering approach based on the definition type. It handles both direct column
     * definitions and SQL-renderable objects through a uniform interface.
     *
     * @param AlterOperation $operation The operation containing the definition to render
     *
     * @return string                   The SQL-safe string representation
     * @throws RuntimeException         When definition is missing or unsupported
     */
    private static function renderDefinition(AlterOperation $operation) : string
    {
        // Extract definition from operation for validation and processing
        $definition = $operation->definition;

        // Ensure definition exists before attempting to render
        if ($definition === null) {
            throw new RuntimeException(
                message: "Definition missing for operation type: {$operation->type->value}"
            );
        }

        // Handle ColumnDefinition using a dedicated renderer for complex column structures
        if ($definition instanceof ColumnDefinition) {
            return ColumnSQLRenderer::render(column: $definition->getBuilder());
        }

        // Process objects implementing SQL rendering capabilities through toSql() method
        if (method_exists($definition, 'toSql')) {
            return $definition->toSql();
        }

        // Throw exception for unsupported definition types
        throw new RuntimeException(
            message: sprintf(
                         'Cannot render alter operation [%s]: definition is not renderable.',
                         $operation->type->value
                     )
        );
    }

    /**
     * Validates and extracts the target column name for a rename operation.
     *
     * This method ensures type safety and semantic correctness of column rename operations
     * by validating that the provided operation contains a valid ColumnDefinition.
     * Following Domain-Driven Design principles, it enforces invariants at the domain boundary.
     *
     * @param AlterOperation $operation The alter operation containing the rename definition
     *
     * @return string The validated target column name
     * @throws RuntimeException When the operation definition is not a valid ColumnDefinition
     */
    private static function assertColumnRenameTarget(AlterOperation $operation) : string
    {
        // Extract the definition from the operation for validation
        $definition = $operation->definition;

        // Ensure type safety through runtime assertion of the definition type
        if (! ($definition instanceof ColumnDefinition)) {
            throw new RuntimeException(
                message: "Invalid rename operation definition – expected ColumnDefinition."
            );
        }

        // Extract and return the validated target column name
        return $definition->columnName();
    }
}

=== Database/Migration/Design/Table/Alter/Definitions/AddForeignKeyDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a foreign key creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create foreign key constraints. It follows immutable design principles
 * to ensure consistency during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddForeignKeyDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the AddForeignKeyDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name              The name of the foreign key constraint
     * @param array<string> $columns           The local columns participating in the foreign key
     * @param string        $referencedTable   The referenced table name
     * @param array<string> $referencedColumns The columns in the referenced table
     * @param string|null   $onDelete          The ON DELETE behavior (CASCADE, SET NULL, etc.)
     * @param string|null   $onUpdate          The ON UPDATE behavior (CASCADE, SET NULL, etc.)
     */
    public function __construct(
        public string      $name,
        public array       $columns,
        public string      $referencedTable,
        public array       $referencedColumns,
        public string|null $onDelete = null,
        public string|null $onUpdate = null
    ) {}

    /**
     * Generates the SQL statement for the foreign key creation operation.
     *
     * Produces a standardized SQL ADD CONSTRAINT statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in table and column names.
     *
     * @return string The complete SQL statement for creating the foreign key constraint
     */
    public function toSql() : string
    {
        // Transform column names arrays into properly escaped column identifiers
        $columns = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->columns));
        $refs    = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->referencedColumns));

        // Construct the base foreign key constraint SQL
        $sql = "ADD CONSTRAINT `{$this->name}` FOREIGN KEY ({$columns}) REFERENCES `{$this->referencedTable}` ({$refs})";

        // Append ON DELETE clause if specified
        if ($this->onDelete) {
            $sql .= " ON DELETE {$this->onDelete}";
        }

        // Append ON UPDATE clause if specified
        if ($this->onUpdate) {
            $sql .= " ON UPDATE {$this->onUpdate}";
        }

        return $sql;
    }
}
=== Database/Migration/Design/Table/Alter/Definitions/AddIndexDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents an index creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create various types of database indexes (standard, unique, fulltext).
 * It follows immutable design principles to ensure consistency during
 * the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddIndexDefinition extends AlterColumnDefinition
{
    /**
     * Valid index types supported by this definition.
     *
     * @var array<string>
     */
    private const array VALID_INDEX_TYPES = ['INDEX', 'UNIQUE', 'FULLTEXT'];

    /**
     * Initializes a new instance of the AddIndexDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name    The name of the index to be created
     * @param array<string> $columns The columns to be included in the index
     * @param string        $type    The type of index (INDEX, UNIQUE, FULLTEXT)
     */
    public function __construct(
        public string $name,
        public array  $columns,
        public string $type = 'INDEX'
    ) {
        assert(
            in_array($type, self::VALID_INDEX_TYPES, true),
            sprintf('Invalid index type. Must be one of: %s', implode(', ', self::VALID_INDEX_TYPES))
        );
    }

    /**
     * Generates the SQL statement for the index creation operation.
     *
     * Produces a standardized SQL CREATE INDEX statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column and index names.
     *
     * @return string The complete SQL statement for creating the index
     */
    public function toSql() : string
    {
        // Transform column names array into properly escaped column identifiers
        $columns = implode(
            ', ',
            array_map(
                static fn(string $col) : string => "`{$col}`",
                $this->columns
            )
        );

        // Construct the final SQL statement using the defined format
        return sprintf(
            '%s `%s` (%s)',
            strtoupper($this->type),
            $this->name,
            $columns
        );
    }
}
=== Database/Migration/Design/Table/Alter/Definitions/Base/AlterColumnDefinition.php ===
<?php

/**
 * Provides base functionality for SQL column alteration definitions.
 *
 * This abstract class serves as a foundation for implementing various column
 * alteration strategies in database migrations, following the Domain-Driven Design
 * pattern and Single Responsibility Principle.
 *
 * @category Database
 * @package  Gemini\Database\Migration\Design\Table\Alter\Definitions\Base
 * @author   Development Team
 * @version  1.0.0
 * @since    1.0.0
 */
declare(strict_types=1);

/**
 * Base abstract class representing a column alteration definition.
 *
 * This class serves as a blueprint for defining SQL representation of
 * a column alteration in a database migration. It provides an abstract
 * method that subclasses must implement to define specific
 * SQL generation logic for altering database table columns.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions\Base;

abstract readonly class AlterColumnDefinition
{
    /**
     * Converts the column alteration definition to its SQL representation.
     *
     * This method must be implemented by concrete classes to provide specific SQL
     * generation logic for different types of column alterations.
     *
     * @return string The SQL statement representing the column alteration
     *
     * @throws \RuntimeException When SQL generation fails
     */
    abstract public function toSql() : string;
}
=== Database/Migration/Design/Table/Alter/Definitions/RenameColumnDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a column renaming operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to rename database columns. It's immutable by design to ensure data integrity
 * during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class RenameColumnDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the RenameColumnDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     */
    public function __construct(
        public string $from,
        public string $to
    ) {}

    /**
     * Generates the SQL statement for the column renaming operation.
     *
     * Produces a standardized SQL RENAME COLUMN statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column names.
     *
     * @return string The complete SQL statement for renaming the column
     */
    public function toSql() : string
    {
        return sprintf('RENAME COLUMN `%s` TO `%s`', $this->from, $this->to);
    }
}
=== Database/Migration/Design/Table/Alter/DTO/AlterOperation.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\DTO;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;

/**
 * Represents an immutable value object for table alteration operations.
 *
 * This DTO encapsulates the essential information needed to perform
 * structural modifications to database tables, ensuring type safety
 * and immutability in the domain model.
 *
 * @final    Prevents extension to maintain invariants
 * @readonly Ensures immutability of the value object
 */
final readonly class AlterOperation
{
    /**
     * Constructs a new AlterOperation instance using constructor promotion.
     *
     * Encapsulates the complete state required for a table alteration
     * operation through immutable properties, following DDD value object patterns.
     *
     * @param AlterType                                   $type                                                                                                       The
     *                                                                                                                                                                perform
     * @param string                                      $target                                                                                                     The
     *                                                                                                                                                                identifier
     * @param ColumnDefinition|AlterColumnDefinition|null $definition                                                                                                 The
     *                                                                                                                                                                specification
     */
    public function __construct(
        public AlterType                                   $type,
        public string                                      $target,
        public ColumnDefinition|AlterColumnDefinition|null $definition = null
    ) {}
}
=== Database/Migration/Design/Table/Alter/Enums/AlterType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\Enums;

/**
 * Enum AlterType
 *
 * Defines all supported ALTER TABLE operation types.
 * Used in conjunction with AlterOperation to describe mutations to a table schema.
 *
 * @immutable
 * @psalm-immutable
 */
enum AlterType: string
{
    /**
     * Adds a new column to a table.
     *
     * Example: ALTER TABLE users ADD COLUMN age INT;
     */
    case ADD_COLUMN = 'ADD_COLUMN';

    /**
     * Modifies an existing column.
     *
     * Example: ALTER TABLE users MODIFY COLUMN name VARCHAR(255) NOT NULL;
     */
    case MODIFY_COLUMN = 'MODIFY_COLUMN';

    /**
     * Renames a column.
     *
     * Example: ALTER TABLE users RENAME COLUMN old_name TO new_name;
     */
    case RENAME_COLUMN = 'RENAME_COLUMN';

    /**
     * Drops a column.
     *
     * Example: ALTER TABLE users DROP COLUMN deprecated_field;
     */
    case DROP_COLUMN = 'DROP_COLUMN';

    /**
     * Drops an index.
     *
     * Example: ALTER TABLE users DROP INDEX idx_email;
     */
    case DROP_INDEX = 'DROP_INDEX';

    /**
     * Drops a foreign key constraint.
     *
     * Example: ALTER TABLE orders DROP FOREIGN KEY fk_user_id;
     */
    case DROP_FOREIGN = 'DROP_FOREIGN';

    /**
     * Represents an operation to add a new index to a table.
     *
     * This operation allows the creation of different types of indexes (regular INDEX,
     * UNIQUE, FULLTEXT, SPATIAL) to optimize query performance and enforce data integrity.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE users ADD INDEX idx_email (email);
     *     ALTER TABLE users ADD UNIQUE INDEX idx_username (username);
     */
    case ADD_INDEX = 'ADD_INDEX';

    /**
     * Represents an operation to add a new foreign key constraint to a table.
     *
     * This operation establishes referential integrity between tables by creating
     * a foreign key relationship with configurable ON DELETE and ON UPDATE behaviors.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE orders
     *     ADD CONSTRAINT fk_user_id
     *     FOREIGN KEY (user_id)
     *     REFERENCES users(id)
     *     ON DELETE CASCADE
     *     ON UPDATE CASCADE;
     */
    case ADD_FOREIGN = 'ADD_FOREIGN';
}

=== Database/Migration/Design/Table/Enum/FieldModifierEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enumeration: FieldModifierEnum
 *
 * This enum provides a type-safe way to define and manage field modifiers
 * used in database migrations for the Gemini system.
 * Each enumerated case represents a specific modifier,
 * ensuring maintainability and reducing duplication across the codebase.
 *
 * Following Domain-Driven Design (DDD), it encapsulates behavior related
 * to its enumeration, ensuring that valid operations are directly associated
 * with the definition itself.
 */
enum FieldModifierEnum: string
{
    /**
     * Represents the "nullable" field modifier.
     *
     * This modifier allows the associated database column to accept NULL values.
     *
     * @var string
     */
    case NULLABLE = 'nullable';

    /**
     * Represents the "unique" field modifier.
     *
     * This modifier ensures that all values in the associated database column
     * are unique and no duplicates are allowed.
     *
     * @var string
     */
    case UNIQUE = 'unique';

    /**
     * Represents the "primary" field modifier.
     *
     * This modifier signifies that the database column serves as a primary key,
     * which uniquely identifies each row in the table.
     *
     * @var string
     */
    case PRIMARY = 'primary';

    /**
     * Represents the "index" field modifier.
     *
     * This modifier designates the creation of an index for the associated column
     * to improve query performance.
     *
     * @var string
     */
    case INDEX = 'index';

    /**
     * Check if the provided value is a valid case for this enum.
     *
     * This method ensures that the given value matches one of the enum's predefined
     * cases, improving type safety and reducing unexpected errors during runtime.
     *
     * @param string $value The value to validate against the enum cases.
     *
     * @return bool Returns `true` if the value exists in the enum, otherwise `false`.
     */
    public static function isValid(string $value) : bool
    {
        // Validate if the provided value exists within the enum's list of values using strict comparison.
        return in_array($value, self::values(), true);
    }

    /**
     * Retrieve all string values of the enum cases.
     *
     * This method provides a centralized way to access the raw underlying values
     * of the defined enum cases. This is particularly useful when the raw values
     * need to be passed to external systems or stored in a database.
     *
     * @return array<int, string> An indexed array of the string values of all cases.
     */
    public static function values() : array
    {
        // Use PHP 8.1+ `cases()` method to get all enum cases and extract their `value` property.
        return array_column(self::cases(), 'value');
    }

    /**
     * Safely attempts to retrieve an enum instance from a given value. If the value is null
     * or invalid, it returns null instead of throwing an error.
     *
     * This method wraps around PHP's built-in `tryFrom()` to provide a safe and null-tolerant
     * implementation that prevents exceptions when handling dynamic inputs.
     *
     * @param string|null $value The value to convert to an enum instance, or `null`.
     *
     * @return self|null Returns the enum instance for the corresponding value, or `null` if the value is invalid.
     */
    public static function fromOrNull(string|null $value) : self|null
    {
        // Ensure type-safety by checking if the input is a string before attempting conversion.
        return is_string($value) ? self::tryFrom($value) : null;
    }
}
=== Database/Migration/Design/Table/Enum/FieldTypeEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum FieldTypeEnum
 *
 * This enum serves as a representation of valid Gemini-compatible column types.
 * It ensures type safety and provides a centralized definition for managing
 * the various database field types used in migrations in a Domain-Driven Design (DDD) context.
 */
enum FieldTypeEnum: string // Enum declaration with an underlying string type, ensuring type-safety for the enum values.
{
    /**
     * Represents a variable-length string column in the database.
     * Suitable for shorter text or character data, defined by Gemini's `string` type.
     *
     * @var string
     */
    case STRING = 'string';

    /**
     * Represents an integer column in the database.
     * Suitable for whole numbers, defined as `integer` in Gemini migrations.
     *
     * @var string
     */
    case INTEGER = 'integer';

    /**
     * Represents a big integer column in the database.
     * Useful for storing larger whole numbers, as defined by Gemini's `bigInteger` type.
     *
     * @var string
     */
    case BIGINT = 'bigInteger';

    /**
     * Represents a boolean column in the database.
     * Used to store true/false values, as defined by Gemini's `boolean` type.
     *
     * @var string
     */
    case BOOLEAN = 'boolean';

    /**
     * Represents a decimal column in the database.
     * Suitable for storing precise numeric values with defined precision and scale.
     *
     * @var string
     */
    case DECIMAL = 'decimal';

    /**
     * Represents a float column in the database.
     * Useful for storing approximate numeric values with floating-point precision.
     *
     * @var string
     */
    case FLOAT = 'float';

    /**
     * Represents an enum column in the database.
     * Allows for a fixed set of predefined string values, common for constrained fields.
     *
     * @var string
     */
    case ENUM = 'enum';

    /**
     * Represents a text column in the database.
     * Suitable for storing large textual content, as defined by Gemini's `text` type.
     *
     * @var string
     */
    case TEXT = 'text';

    /**
     * Represents a timestamp column in the database.
     * Typically used for storing date and time information with precision.
     *
     * @var string
     */
    case TIMESTAMP = 'timestamp';

    /**
     * Represents a universally unique identifier (UUID) column in the database.
     * Useful for storing UUIDs for globally unique identification purposes.
     *
     * @var string
     */
    case UUID = 'uuid';

    /**
     * Represents a foreign key column in the database.
     * Primarily used for establishing relationships between tables in a relational database.
     *
     * @var string
     */
    case FOREIGN = 'foreign';

    /**
     * Represents an indexed column in the database.
     * Commonly used for columns that require quick lookups or unique constraints.
     *
     * @var string
     */
    case INDEX = 'index';

    /**
     * Represents a full-text search index column in the database.
     * Typically used for performing full-text search operations on textual data within Gemini.
     *
     * @var string
     */
    case FULLTEXT = 'fulltext';


    /**
     * Returns a list of all enum values.
     *
     * This method provides a centralized way to retrieve the values of all the cases defined in the enum.
     * It utilizes PHP 8.1+ `cases()` enumeration feature to dynamically return the `value` property
     * of each case, ensuring type-safety and simplicity when needing the raw string representations of the cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Uses array_column to extract the 'value' property of each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Database/Migration/Design/Table/Enum/ForeignActionEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum ForeignActionEnum
 *
 * This enum represents possible actions to be taken on foreign key constraints
 * when certain events occur in the referenced table, such as row deletions or updates.
 *
 * In the context of database migrations, this enum simplifies handling of foreign key behaviors
 * by providing a strongly typed definition for actions like cascade, restrict, or no action.
 * It enhances type-safety, readability, and ensures centralized management of foreign key options.
 *
 * Designed using PHP 8.1+ enums, this class leverages modern features for expressive and reliable
 * definition of constants.
 */
enum ForeignActionEnum: string // Enum declaration with 'string' type to ensure type safety for the defined cases.
{
    /**
     * Indicates cascading behavior for foreign keys.
     * When the referenced row is updated or deleted, the change cascades to the dependent rows.
     *
     * Example: If a parent record is removed, all associated child records are also removed.
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Indicates behavior to set foreign key columns to NULL.
     * When the referenced row is deleted, dependent foreign key columns in related rows are set to NULL.
     *
     * Example: If a parent record is deleted, the foreign key in child records will be nullified.
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Restricts changes to the referenced row.
     * Prevents any changes (such as deletion) to a parent row when there are dependencies on it.
     *
     * Example: Trying to delete a parent record with dependent child records will raise an error.
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Indicates no action should be taken on foreign key constraints.
     * It simply allows the database to raise an error if the integrity rules are violated.
     *
     * Example: If a parent record is targeted for deletion but a child record exists, the operation fails.
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Retrieves an array of all values defined by the enum cases.
     *
     * This method provides a centralized, type-safe way to access the raw string values
     * of all enum cases. It is useful when generating lists of possible options for migrations
     * or when working with foreign key actions dynamically.
     *
     * Uses PHP's built-in `cases()` method, introduced in PHP 8.1+, to retrieve the values of all cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Leverages `array_column` to extract the 'value' property from each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Database/Migration/Design/Table/Table.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table;

use BadMethodCallException;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Traits\FieldMappingTrait;
use Gemini\Database\Migration\Design\Table\Traits\IndexDefinitionsTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderDslTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderSqlTrait;
use RuntimeException;

/**
 * @internal Auto-generated from ColumnType enum
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final class Table
{
    /**
     * Import the IndexDefinitionsTrait which provides robust database index management capabilities.
     *
     * This trait encapsulates the domain logic for defining and managing various types of database indexes:
     * - Standard indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     * - Composite indexes (COMPOSITE)
     *
     * @see   \IndexDefinitionsTrait For complete index management functionality
     * @since 8.3.0
     */
    use IndexDefinitionsTrait;

    /**
     * Imports TableRenderSqlTrait, which provides SQL generation capabilities for table definitions.
     *
     * This trait is responsible for converting table definitions into valid SQL CREATE TABLE statements.
     * It works in conjunction with column definitions and rendering logic to produce
     * properly formatted SQL strings.
     *
     * @see TableRenderSqlTrait::toSql() For the main SQL generation method
     * @see ColumnSQLRenderer For the column-specific SQL rendering
     *
     * @api
     */
    use TableRenderSqlTrait;

    /**
     * Incorporates table rendering capabilities via Domain-Specific Language (DSL).
     *
     * This trait provides DSL generation functionality for database table definitions,
     * enabling fluent and declarative table schema specifications. It transforms
     * column definitions into a standardized DSL format suitable for database migrations.
     *
     * @see     ColumnDSLRenderer For the underlying DSL formatting logic
     * @see     ColumnAttributes For the column attribute specifications
     *
     * @author  Your Name <your.email@domain.com>
     * @package Database\Schema
     * @version 1.0.0
     */
    use TableRenderDslTrait;

    /**
     * Imports the FieldMappingTrait which provides essential field mapping capabilities for database schema
     * definitions.
     *
     * This trait encapsulates domain logic for mapping FieldDTO objects to table schema DSL,
     * implementing a flexible and extensible field mapping strategy pattern.
     *
     * Key responsibilities:
     * - Manages field-to-DSL mapper injection
     * - Provides fluent interface for field application
     * - Handles both single and batch field mapping operations
     *
     * @see   FieldToDslMapperInterface For the mapping strategy contract
     * @see   FieldDTO For the field data transfer object structure
     *
     * @since 8.3.0
     * @api
     */
    use FieldMappingTrait;

    /**
     * Collection of column definitions indexed by column name.
     *
     * Maintains the ordered set of columns that define the table structure,
     * ensuring column name uniqueness through associative array keys.
     *
     * @var array<string, ColumnDefinition>
     */
    private array $columns = [];

    /**
     * Constructs a new Table instance with the specified name.
     *
     * Uses constructor promotion for lean initialization of the immutable name property.
     */
    private function __construct(private readonly string $name) {}

    /**
     * Dynamic column type handler implementing the Schema DSL.
     *
     * Provides a fluent interface for column definition by delegating to the Column factory.
     * Method name becomes the column type, the first argument is expected to be the column name.
     *
     * @param string            $method    The column types to create
     * @param array<int, mixed> $arguments The column definition arguments
     *
     * @return ColumnDefinition              The created column definition
     * @throws BadMethodCallException        When a column type is invalid
     * @throws RuntimeException|\ReflectionException             When column creation fails
     */
    public function __call(string $method, array $arguments) : ColumnDefinition
    {
        $column = (new Column())->create(
            method   : $method,
            arguments: $arguments
        );

        return $this->addColumn(column: $column);
    }

    /**
     * Named constructor implementing the factory pattern for Table creation.
     *
     * Provides a semantic way to instantiate new Table objects while encapsulating
     * construction details.
     *
     * @param string $name The logical name of the table
     *
     * @return self       The constructed Table instance
     */
    public static function create(string $name) : self
    {
        return new self(name: $name);
    }

    /**
     * Adds a column definition to the table schema.
     *
     * Maintains the column collection while supporting method chaining for the fluent interface.
     *
     * @param ColumnDefinition $column The column definition to add
     *
     * @return ColumnDefinition        The added column definition
     */
    public function addColumn(ColumnDefinition $column) : ColumnDefinition
    {
        $this->columns[$column->columnName()] = $column;

        return $column;
    }

    /**
     * Replaces or adds a column definition in the schema.
     *
     * This method ensures atomic column replacement within the schema definition,
     * maintaining schema consistency and integrity. It follows the Single
     * Responsibility Principle by focusing solely on column replacement logic.
     *
     * @param ColumnDefinition $column The column definition to replace or add
     *
     * @return void
     * @throws RuntimeException When attempting to replace with an invalid column
     */
    public function replaceColumn(ColumnDefinition $column) : void
    {
        // Extract the column name from the definition for validation and indexing
        $name = $column->columnName();

        // Ensure column name validity to maintain schema integrity
        if (! $name) {
            throw new RuntimeException(
                message: "Column name must not be empty for replacement."
            );
        }

        // Perform atomic column replacement in the schema definition
        $this->columns[$name] = $column;
    }

    /**
     * Retrieves the table name.
     *
     * Value object accessor for the immutable table name property.
     *
     * @return string The logical table name
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * Retrieves all column definitions.
     *
     * Provides read-only access to the complete collection of column definitions.
     *
     * @return array<string, ColumnDefinition> Column definitions indexed by name
     */
    public function getColumns() : array
    {
        return $this->columns;
    }

    /**
     * Retrieves all defined table indexes.
     *
     * This method provides access to the collection of indexes that have been
     * defined for the current table schema.
     * The indexes can include various types such as:
     * - Regular indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     *
     * @return array<string, ColumnDefinition> Array of index definitions keyed by index name
     *
     * @since 1.0.0
     * @api
     */
    public function getIndexes() : array
    {
        // Return the protected collection of index definitions
        return $this->indexes;
    }
}
=== Database/Migration/Design/Table/Traits/FieldMappingTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;

/**
 * Provides field mapping capabilities for database schema definitions.
 *
 * This trait implements the Strategy pattern to enable dynamic field-to-DSL mapping
 * in database table definitions. It serves as a bridge between FieldDTO objects
 * and the table's DSL methods.
 *
 * Key Features:
 * - Implements a Strategy pattern for flexible field mapping
 * - Supports both single and batch field operations
 * - Provides fluent interface for method chaining
 * - Maintains loose coupling through dependency injection
 *
 * @template T of object
 * @author YourName <your@email.com>
 * @since  8.3.0
 */
trait FieldMappingTrait
{
    /**
     * Field-to-DSL mapper implementation.
     *
     * Responsible for transforming FieldDTO objects into table column definitions
     * using the fluent DSL. Implements the Strategy pattern to allow runtime
     * mapping behavior modification.
     *
     * @var FieldToDslMapperInterface|null
     */
    private FieldToDslMapperInterface|null $mapper = null;

    /**
     * Configures the field mapping strategy.
     *
     * Injects the mapper implementation that will be used for converting FieldDTO
     * objects into table column definitions via the fluent DSL.
     *
     * @param FieldToDslMapperInterface $mapper The field mapping strategy to use
     *
     * @return T The trait using instance for method chaining
     */
    public function useMapper(FieldToDslMapperInterface $mapper) : self
    {
        $this->mapper = $mapper;

        return $this;
    }

    /**
     * Applies multiple field definitions to the table schema.
     *
     * Batch processes an array of FieldDTO objects, applying each one to the table
     * schema using the configured mapper.
     *
     * @param array<int, FieldDTO> $fields Collection of field definitions to apply
     *
     * @return T The trait using instance for method chaining
     */
    public function applyMany(array $fields) : self
    {
        foreach ($fields as $field) {
            $this->apply(field: $field);
        }

        return $this;
    }

    /**
     * Applies a single field definition to the table schema.
     *
     * Delegates the field-to-column mapping to the injected mapper strategy,
     * enforcing the requirement for a configured mapper.
     *
     * @param FieldDTO $field The field definition to apply
     *
     * @return T The trait using instance for method chaining
     * @throws RuntimeException When no mapper has been configured
     */
    public function apply(FieldDTO $field) : self
    {
        if (! $this->mapper) {
            throw new RuntimeException(message: 'No FieldToDslMapperInterface injected into Table.');
        }

        $this->mapper->apply(table: $this, field: $field);

        return $this;
    }
}
=== Database/Migration/Design/Table/Traits/IndexDefinitionsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Trait IndexDefinitionsTrait
 *
 * Provides fluent DSL methods for defining table-level indexes.
 */
trait IndexDefinitionsTrait
{
    /**
     * @var array<string, ColumnDefinition> Indexes keyed by index name
     */
    protected array $indexes = [];

    /**
     * Adds a general-purpose INDEX.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::INDEX, columns: $columns, indexName: $indexName);
    }

    /**
     * Internal helper to create and register an index ColumnDefinition.
     *
     * @param ColumnType                $type
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    private function addIndex(ColumnType $type, string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        $cols = (array) $columns;
        $name = $indexName ?? strtolower($type->value) . '_' . implode('_', $cols);

        $definition = ColumnDefinition::make(name: $name, type: $type)
            ->columns($cols);

        $this->indexes[$name] = $definition;

        return $definition;
    }

    /**
     * Adds a FULLTEXT index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::FULLTEXT, columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a SPATIAL index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatialIndex(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::SPATIAL, columns: $columns, indexName: $indexName);
    }

    /**
     * Alias for unique composite keys.
     *
     * @param array<int, string> $columns
     * @param string|null        $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function uniqueComposite(array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->unique(columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a UNIQUE index with optional composite support.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::UNIQUE, columns: $columns, indexName: $indexName);
    }
}

=== Database/Migration/Design/Table/Traits/SpatialColumnsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\ColumnBuilder;

trait SpatialColumnsTrait
{
    public function geometry(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRY', name: $name);
    }

    public function point(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POINT', name: $name);
    }

    public function lineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'LINESTRING', name: $name);
    }

    public function polygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POLYGON', name: $name);
    }

    public function multiPoint(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOINT', name: $name);
    }

    public function multiLineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTILINESTRING', name: $name);
    }

    public function multiPolygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOLYGON', name: $name);
    }

    public function geometryCollection(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRYCOLLECTION', name: $name);
    }
}
=== Database/Migration/Design/Table/Traits/TablePropertiesTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

/**
 * Trait TablePropertiesTrait
 *
 * Provides methods for defining table-level properties such as storage engine, character set, collation, and comments.
 * These properties allow for fine-grained control over database table configurations, ensuring optimal performance and
 * compatibility.
 *
 * Supported properties:
 * - Storage engine (e.g., InnoDB, MyISAM)
 * - Character set (e.g., utf8, utf8mb4)
 * - Collation (e.g., utf8_general_ci, utf8mb4_unicode_ci)
 * - Table-level comments for documentation and indexing purposes
 *
 * Usage Example:
 * ```
 * $blueprint->engine('InnoDB');
 * $blueprint->charset('utf8mb4');
 * $blueprint->collation('utf8mb4_unicode_ci');
 * $blueprint->comment('User table storing authentication details');
 * ```
 *
 * @package Gemini\Database\Migration\Table\Traits
 */
trait TablePropertiesTrait
{
    /**
     * Sets the storage engine for the table.
     *
     * @param string $engine The storage engine (e.g., 'InnoDB', 'MyISAM').
     *
     * @return \Gemini\Database\Migration\Design\Table\Table|\Gemini\Database\Migration\Design\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->engine('InnoDB');
     * ```
     */
    public function engine(string $engine) : self
    {
        $this->tableEngine = $engine;

        return $this;
    }

    /**
     * Sets the character set for the table.
     *
     * @param string $charset The character set (e.g., 'utf8mb4', 'utf8').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->charset('utf8mb4');
     * ```
     */
    public function charset(string $charset) : self
    {
        $this->charset = $charset;

        return $this;
    }

    /**
     * Sets the collation for the table.
     *
     * @param string $collation The collation (e.g., 'utf8mb4_unicode_ci', 'utf8_general_ci').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->collation('utf8mb4_unicode_ci');
     * ```
     */
    public function collation(string $collation) : self
    {
        $this->collation = $collation;

        return $this;
    }

    /**
     * Sets a comment for the table.
     *
     * @param string $text The comment text.
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->comment('Stores user authentication data');
     * ```
     */
    public function comment(string $text) : self
    {
        $this->tableComment = addslashes($text);

        return $this;
    }
}

=== Database/Migration/Design/Table/Traits/TableRenderDslTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnDSLRenderer;

/**
 * Trait TableRenderDslTrait
 *
 * Provides Domain-Specific Language (DSL) rendering capabilities for database table definitions.
 * Implement the Single Responsibility Principle by focusing solely on DSL generation logic.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 *
 * @since   1.0.0
 */
trait TableRenderDslTrait
{
    /**
     * Converts the table definition into a DSL representation.
     *
     * Transforms the internal column collection into a formatted DSL string using
     * the ColumnDSLRenderer. Follows the Command Query Separation principle by
     * performing a pure transformation operation.
     *
     * @return string The generated DSL representation of the table structure
     */
    public function toDsl() : string
    {
        // Initialize collection for DSL line storage
        $lines = [];

        // Transform each column definition into its DSL representation
        foreach ($this->getColumns() as $column) {
            // Delegate rendering responsibility to a specialized renderer
            $lines[] = (new ColumnDSLRenderer())->format(column: $column->getBuilder());
        }

        // Join DSL lines with proper indentation
        return implode(
            separator: PHP_EOL . '            ',
            array    : $lines
        );
    }
}
=== Database/Migration/Design/Table/Traits/TableRenderSqlTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use RuntimeException;

/**
 * Trait TableRenderSqlTrait
 *
 * Provides SQL rendering capabilities for table definitions in the database migration context.
 * Implements Domain-Driven Design principles for table schema representation.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 */
trait TableRenderSqlTrait
{
    /**
     * Generates the SQL CREATE TABLE statement for the current table definition.
     *
     * Transforms the abstract table representation into a valid SQL statement,
     * handling both simple and nested column definitions. Ensures proper SQL
     * formatting with indentation and newlines for improved readability.
     *
     * @return string Complete SQL CREATE TABLE statement
     * @throws RuntimeException When no columns are defined for the table
     */
    public function toSql() : string
    {
        // Retrieve all column definitions from the table schema
        $columns = $this->getColumns();

        // Validate that the table has at least one column defined
        if (empty($columns)) {
            throw new RuntimeException(
                message: sprintf('No columns defined for table [%s]', $this->getName())
            );
        }

        // Initialize collection for SQL column definitions
        $lines = [];

        // Process each column definition, handling both single and nested columns
        foreach ($columns as $col) {
            if (is_array($col)) {
                // Handle nested column definitions (e.g., for compound indexes)
                foreach ($col as $nested) {
                    $lines[] = ColumnSQLRenderer::render(column: $nested->getBuilder());
                }
            } else {
                // Process single column definition
                $lines[] = ColumnSQLRenderer::render(column: $col->getBuilder());
            }
        }

        // Construct the complete CREATE TABLE statement with proper formatting
        $sql = sprintf(
            "CREATE TABLE `%s` (\n    %s\n)",
            $this->getName(),
            implode(",\n    ", $lines)
        );

        // Append semicolon to complete the SQL statement
        return $sql . ';';
    }
}
=== Database/Migration/Runner/CliInput.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

class CliInput
{
    public function __construct(private readonly array $rawArguments) {}

    /**
     * Check if a specific key exists in the arguments.
     */
    public function has(string $key) : bool
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get the value of a specific key.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                [$k, $value] = explode('=', (string) $rawArgument, 2) + [1 => $default];

                return $value;
            }
        }

        return $default;
    }

    /**
     * Retrieve a raw argument by index.
     */
    public function getRawArgument(int $index) : string|null
    {
        return $this->rawArguments[$index] ?? null;
    }

    /**
     * Get all remaining arguments (after the command).
     */
    public function getRemainingArguments() : array
    {
        return array_slice($this->rawArguments, 2);
    }
}

=== Database/Migration/Runner/Commands/Commands.php ===
<?php

declare(strict_types=1);

/**
 * Represents a container for database migration commands.
 */

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The Commands class is responsible for managing and organizing available commands
 * within the application.
 *
 * It initializes and retrieves a collection of commands during instantiation.
 */
class Commands
{
    private Arrhae $commands;

    public function __construct()
    {
        $this->commands = $this->getCommands();
    }

    private function getCommands() : Arrhae
    {
        return Arrhae::make(
            items: [
                       //'install'          => new InstallCommand(),
                       'create:migration' => new MigrationGenerator(),
                   ]
        );
    }
}
=== Database/Migration/Runner/Commands/Defined/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Defined;

/**
 * Class Migration
 *
 * This class defines a set of migration commands and their corresponding aliases.
 * It helps in standardizing the command names for various migration operations.
 */
class Migration
{
    /**
     * Get the list of migration commands and their aliases.
     *
     * This method returns an associative array mapping custom command names to
     * their actual migration command counterparts. The intent is to provide a
     * simpler and more standardized way to refer to common migration operations.
     *
     * @return array<string, string> Returns an associative array of command aliases.
     */
    public static function definedCommandAliases() : array
    {
        return [
            'migrate:up'       => 'migrate',
            'migrate:down'     => 'migrate:rollback',
            'migrate:reapply'  => 'migrate:refresh',
            'migrate:clean'    => 'migrate:fresh',
            'create:migration' => 'make:migration',
        ];
    }
}
=== Database/Migration/Runner/Commands/InstallCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\MigrationException;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\SchemaBuilder;
use Psr\Log\LoggerInterface;
use RuntimeException;
use Throwable;

use function readline;
use function strtolower;
use function trim;

/**
 * InstallCommand handles the initial application setup.
 *
 * This final class is made readonly to ensure immutability after instantiation,
 * which enhances reliability and predictability in its behavior.
 */
final readonly class InstallCommand implements CommandInterface
{
    /**
     * The name of the migrations table used to track migrations.
     */
    private const string MIGRATIONS_TABLE = 'migrations';

    /**
     * Constructor for InstallCommand.
     *
     * @param SchemaBuilder                $schemaBuilder       Builder for database schemas.
     * @param LoggerInterface              $logger              Logger instance for logging events.
     * @param MigrationRepositoryInterface $migrationRepository Repository for handling migration records.
     */
    public function __construct(
        private SchemaBuilder                $schemaBuilder,
        private LoggerInterface              $logger,
        private MigrationRepositoryInterface $migrationRepository
    ) {}

    /**
     * Executes the command to set up the initial database and migrations.
     *
     * @param array $arguments Key-value array of arguments for the command.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in the process fails.
     */
    public function execute(array $arguments = []) : void
    {
        $database = $this->getDatabaseName(arguments: $arguments);
        $this->prepareDatabase(database: $database);
        $this->ensureMigrationsTableSetup();
        $this->recordSelfAsFirstMigration();
    }

    /**
     * Retrieves the database name from arguments or environment variables.
     *
     * Throws an exception if the database name is not found.
     *
     * @param array $arguments The command-line arguments passed to the script.
     *
     * @return string The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database name is not provided.
     */
    private function getDatabaseName(array $arguments) : string
    {
        $database = $arguments['database'] ?? env(key: 'DB_NAME') ?? null;
        if (! $database) {
            $this->logAndThrowMigrationException(message: 'Database name is required but was not provided.');
        }

        $this->logger->info(message: 'Preparing installation for database: ' . $database);

        return $database;
    }

    /**
     * Logs an error message and throws a MigrationException.
     *
     * This ensures that each failure point provides a consistent error handling strategy.
     *
     * @param string          $message  The error message to log and throw.
     * @param \Throwable|null $previous The previous exception for chaining, if any.
     *
     * @throws MigrationException Always thrown after logging the error.
     */
    private function logAndThrowMigrationException(string $message, Throwable|null $previous = null) : never
    {
        $this->logger->error(message: $message);
        throw new MigrationException(message: $message, previous: $previous);
    }

    /**
     * Prepares the database for the installation.
     *
     * Checks the database connection and ensures the existence of the database.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in preparation fails.
     */
    private function prepareDatabase(string $database) : void
    {
        $this->checkDatabaseConnection(database: $database);
        $this->ensureDatabaseExists(database: $database);
    }

    /**
     * Checks if the connection to the database is healthy.
     *
     * Throws an exception if the connection is not healthy, to ensure database operations are safe to proceed.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database connection is unhealthy.
     */
    private function checkDatabaseConnection(string $database) : void
    {
        if (! $this->schemaBuilder->isConnectionHealthy(database: $database)) {
            $this->logAndThrowMigrationException(
                message: sprintf("Failed to establish a healthy connection to the database '%s'.", $database)
            );
        }
    }

    /**
     * Ensures that the database exists, creating it if it does not.
     *
     * Logs and provides feedback to the user accordingly.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the database fails.
     */
    private function ensureDatabaseExists(string $database) : void
    {
        if (! $this->schemaBuilder->databaseExists(database: $database)) {
            $this->logger->info(message: sprintf("Database '%s' does not exist. Creating database...", $database));
            $this->schemaBuilder->createDatabase(database: $database);
            echo "Database '" . $database . "' created successfully.\n";
        } else {
            echo "Database '" . $database . "' already exists.\n";
        }
    }

    /**
     * Ensures the migrations table is set up correctly.
     *
     * This method handles the creation or recreation of the migrations table, providing feedback and
     * handling exceptions to maintain consistency in the setup process.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if setting up the migrations table fails.
     */
    private function ensureMigrationsTableSetup() : void
    {
        try {
            if (! $this->schemaBuilder->tableExists(table: self::MIGRATIONS_TABLE)) {
                $this->createMigrationsTable();
            } else {
                $this->promptRecreateMigrationsTable();
            }

            echo "Migration install completed.\n";
        } catch (RuntimeException $runtimeException) {
            $this->logAndThrowMigrationException(
                message : "Failed to set up migrations table: " . $runtimeException->getMessage(),
                previous: $runtimeException
            );
        }
    }

    /**
     * Creates the migrations table with the necessary columns.
     *
     * The table structure is defined within a callback to ensure consistent setup.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the migrations table fails.
     */
    private function createMigrationsTable() : void
    {
        try {
            $this->schemaBuilder->create(table: self::MIGRATIONS_TABLE, callback: static function ($table) : void {
                $table->id();
                $table->string('migration');
                $table->string('executable');
                $table->integer('batch');
                $table->timestamp('executed_at')->useCurrent();
            });
            $this->logger->info(message: 'Migrations table created successfully.');
            echo "Migrations table created successfully.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to create migrations table: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Prompts the user to recreate the migration table if it already exists.
     *
     * Provides options to drop and recreate the table or to skip this step.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if user opts to recreate and the operation
     *                                                                  fails.
     */
    private function promptRecreateMigrationsTable() : void
    {
        $choice = strtolower(
            trim(readline("The 'migrations' table already exists. Do you want to recreate it? [yes/no]: "))
        );
        if (in_array($choice, ['yes', 'y'], true)) {
            $this->schemaBuilder->drop(table: self::MIGRATIONS_TABLE);
            $this->logger->info(message: 'Old migrations table dropped.');
            echo "Old 'migrations' table dropped.\n";
            $this->createMigrationsTable();
        } else {
            echo "Skipped creating the 'migrations' table.\n";
        }
    }

    /**
     * Records this InstallCommand as the first migration in the migrations table.
     *
     * This method ensures that InstallCommand is logged as the first entry,
     * establishing the provenance of the migration system installation.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if saving the record fails.
     */
    private function recordSelfAsFirstMigration() : void
    {
        try {
            $this->migrationRepository->save(
                migration : 'CreateMigrationsTable',
                executable: self::class,
                batch     : 1
            );
            $this->logger->info(message: 'Recorded InstallCommand as the first migration.');
            echo "Recorded InstallCommand as the first migration.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to record the InstallCommand migration: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}
=== Database/Migration/Runner/Commands/MakeMigrationCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\{Repository\RepositoryGenerator};
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\DTO\DtoGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityQueryBuilderGenerator;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MakeMigrationCommand
 *
 * This class manages the creation of migrations and optionally generates
 * related components like Entity, DTO, Repository, etc.
 */
final readonly class MakeMigrationCommand implements CommandInterface
{
    private const string        ERROR_MISSING_ARGUMENTS = "Migration name and table name are required.";

    private const        string ERROR_INVALID_FIELDS    = "Invalid fields format. Expected format: 'name:type:attr1,attr2'.";

    public function __construct(
        private MigrationGenerator          $migrationGenerator,
        private EntityGenerator             $entityGenerator,
        private EntityQueryBuilderGenerator $entityQueryBuilderGenerator,
        private DtoGenerator                $dtoGenerator,
        private RepositoryGenerator         $repositoryGenerator,
        private ServiceGenerator            $serviceGenerator,
        private MigrationStateManager       $migrationStateManager,
        private LoggerInterface             $logger
    ) {}

    /**
     * Executes the MakeMigration command.
     *
     * @param array $arguments Command-line arguments.
     */
    public function execute(array $arguments) : void
    {
        try {
            $input = new Arrhae($arguments);

            // Check for presence
            if (! $input->has(key: 'name') || ! $input->has(key: 'table')) {
                $this->reportError(message: self::ERROR_MISSING_ARGUMENTS);

                return;
            }

            $name  = $input->get(key: 'name');
            $table = $input->get(key: 'table');

            $fieldsInput = $input->get(key: 'fields', default: '');
            $fields      = $this->extractFields(fieldsInput: $fieldsInput);

            $this->generateMigration(name: $name, table: $table, fields: $fields);

            if ($input->get(key: 'entity', default: false)) {
                $this->generateEntity(name: $table, fields: $fields);
            }
            if ($input->get(key: 'entity-qb', default: false)) {
                $this->generateQueryBuilder(name: $table, table: $table, fields: $fields);
            }
            if ($input->get(key: 'dto', default: false)) {
                $this->generateDto(name: $table, fields: $fields);
            }
            if ($input->get(key: 'repository', default: false)) {
                $this->generateRepository(name: $table, fields: $fields);
            }
            if ($input->get(key: 'service', default: false)) {
                $this->generateService(name: $table);
            }
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    /**
     * Reports an error to the logger and echoes it.
     *
     * @param string $message The error message.
     */
    private function reportError(string $message) : void
    {
        $this->logger->error(message: $message);
        echo "Error: " . $message . "\n";
    }

    private function extractFields(string $fieldsInput) : array
    {
        // Wrap the fields into an Arrhae instance
        return (new Arrhae(items: explode(',', $fieldsInput)))
            ->filter(callback: fn($field) => ! empty($field)) // Filter out empty fields
            ->map(callback: function ($field) {
                $parts = explode(':', $field);
                if (count($parts) < 2) {
                    throw new InvalidArgumentException(message: self::ERROR_INVALID_FIELDS);
                }

                $name       = $parts[0];
                $type       = $parts[1];
                $attributes = array_slice($parts, 2);

                return $this->parseField(name: $name, type: $type, attributes: $attributes);
            })
            ->toArray(); // Convert back to a standard array
    }

    private function parseField(string $name, string $type, array $attributes) : array
    {
        // Wrap attributes in Arrhae for simplified handling
        return (new Arrhae(items: $attributes))
            ->reduce(
                callback: fn($fieldData, $attribute) => match (true) {
                    str_contains($attribute, 'default:') => array_merge(
                        $fieldData,
                        [
                            'default' => str_replace(
                                'default:',
                                '',
                                $attribute
                            ),
                        ]
                    ),
                    $attribute === 'unique'              => array_merge($fieldData, ['unique' => true]),
                    $attribute === 'nullable'            => array_merge($fieldData, ['nullable' => true]),
                    default                              => $fieldData
                },
                initial : ['name' => $name, 'type' => $type]
            );
    }

    private function generateMigration(string $name, string $table, array $fields) : void
    {
        try {
            $this->migrationGenerator->writeMigrationFile(name: $name, table: $table, fields: $fields);
            $this->migrationStateManager->migrate(availableMigrations: [$name]);
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    private function handleException(Throwable $e) : void
    {
        $errorMessage = sprintf(
            'Error: %s in %s on line %d',
            $e->getMessage(),
            $e->getFile(),
            $e->getLine()
        );
        $this->logger->error(message: $errorMessage);
        echo $errorMessage . "\n";
    }

    private function generateEntity(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('Entity %s created successfully.', $name)
        );
    }

    private function executeSafely(callable $operation, string $successMessage) : void
    {
        try {
            $operation();
            $this->logger->info(message: $successMessage);
            echo $successMessage . "\n";
        } catch (Throwable $throwable) {
            $this->handleException(e: $throwable);
        }
    }

    private function generateQueryBuilder(string $name, string $table, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityQueryBuilderGenerator->create(
                name  : $name,
                table : $table,
                fields: $fields
            ),
            successMessage: sprintf('Entity QueryBuilder %s created successfully.', $name)
        );
    }

    private function generateDto(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->dtoGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('DTO %s created successfully.', $name)
        );
    }

    private function generateRepository(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->repositoryGenerator->create(
                tableName: $name,
                entity   : $name,
                fields   : $fields
            ),
            successMessage: sprintf('Repository %s created successfully.', $name)
        );
    }

    private function generateService(string $name) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->serviceGenerator->create(name: $name),
            successMessage: sprintf('Service %s created successfully.', $name)
        );
    }
}

=== Database/Migration/Runner/Commands/Middlewares/LoggingMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;

/**
 * Middleware for logging command execution.
 *
 * This middleware logs the execution of migration commands, both at the start and at the
 * completion of the command's execution. It helps to track command activities, useful for
 * debugging and auditing purposes.
 */
class LoggingMiddleware
{
    /**
     * Handles the command execution with logging.
     *
     * Logs the start and end of command execution, providing insights into command activities.
     *
     * @param array    $input                                               The input parameters for the command.
     * @param callable $next                                                The next middleware or the actual command
     *                                                                      execution.
     *
     */
    public function handle(CommandInterface $command, array $input, callable $next) : void
    {
        // Log the start of the command execution.
        logger(message: 'Executing command: ' . $command::class, context: $input, level: 'debug');

        // Proceed to the next middleware or actual command execution.
        $next();

        // Log the end of the command execution.
        logger(message: 'Command execution finished: ' . $command::class, context: [], level: 'debug');
    }
}
=== Database/Migration/Runner/Commands/Middlewares/MiddlewareStack.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * A stack of middleware functions to be executed as a pipeline.
 *
 * - Extends Arrhae to manage the internal collection of middleware functions.
 * - Allows pushing middleware functions onto the stack.
 * - Executes the middleware functions in sequence, passing control to the `next` middleware.
 */
class MiddlewareStack extends Arrhae
{
    /**
     * Adds a middleware callable to the stack.
     *
     * This method allows chaining by returning the instance.
     *
     * @param callable $middleware The middleware to add.
     *
     * @return self The instance itself for method chaining.
     */
    public function push(callable $middleware) : self
    {
        $this->add($middleware);

        return $this;
    }

    /**
     * Executes the command by passing it through the middleware stack.
     *
     * - The method applies each middleware function to the command.
     * - Ensures that the `next` callable is eventually called.
     *
     * @param CommandInterface $command   The command to execute.
     * @param array            $arguments The arguments for the command.
     * @param callable         $next      The next middleware callable.
     */
    public function execute(
        CommandInterface $command,
        array            $arguments,
        callable         $next
    ) : void {
        // Middleware logic here, last middleware will eventually call $next()
        $next();
    }
}
=== Database/Migration/Runner/Commands/MigrateCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MigrateCommand
 *
 * A final immutable class responsible for executing the migration process.
 * Implements CommandInterface to standardize command execution.
 *
 * The class is marked as readonly to enforce immutability ensuring
 * that its state cannot be altered after instantiation, adding robustness
 * and thread-safety.
 */
final readonly class MigrateCommand implements CommandInterface
{
    /**
     * MigrateCommand constructor.
     *
     * @param MigrationStateManager        $migrationStateManager Service to manage the state of migrations.
     * @param MigrationRepositoryInterface $migrationRepository   Repository to fetch available migrations.
     * @param LoggerInterface              $logger                Logger for recording operational events.
     */
    public function __construct(
        private MigrationStateManager        $migrationStateManager,
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface              $logger
    ) {}

    /**
     * Executes the migration process.
     *
     * This method orchestrates the entire migration process, logging important steps
     * and handling exceptions to ensure smooth operation.
     *
     * @param array $arguments CLI arguments or configuration parameters.
     *
     * @throws MigrationException If the migration process encounters an error.
     */
    public function execute(array $arguments = []) : void
    {
        try {
            $this->logger->info(message: 'Starting migration process.');
            echo "Starting migration process...\n";

            $availableMigrations = $this->fetchAvailableMigrations();
            $this->migrationStateManager->migrate(availableMigrations: $availableMigrations);

            $this->logger->info(message: 'Migration process completed successfully.');
            echo "Migration process completed successfully.\n";
        } catch (MigrationException $migrationException) {
            // Handle known migration-specific errors.
            $this->handleError(migrationException: $migrationException);
        } catch (Throwable $throwable) {
            // Handle unexpected errors that do not fall under MigrationException.
            $this->handleUnexpectedError(throwable: $throwable);
        }
    }

    /**
     * Fetches available migrations directly from the database.
     *
     * This encapsulates the retrieval logic from the repository, ensuring a single responsibility
     * and making it easy to modify data fetching strategy if required.
     *
     * @return array List of fully qualified migration class names.
     */
    private function fetchAvailableMigrations() : array
    {
        $migrations          = $this->migrationRepository->getAll();
        $availableMigrations = array_column($migrations, 'executable');

        $this->logger->info(message: 'Fetched available migrations.', context: ['migrations' => $availableMigrations]);

        return $availableMigrations;
    }

    /**
     * Handles migration-specific errors gracefully.
     *
     * This function centralizes error handling for migration exceptions, ensuring consistent
     * logging and error reporting which makes debugging easier.
     *
     * @param MigrationException $migrationException Exception to handle.
     */
    private function handleError(MigrationException $migrationException) : void
    {
        $this->logger->error(
            message: 'Migration process failed.',
            context: ['error' => $migrationException->getMessage()]
        );

        echo sprintf('Migration process failed: %s%s', $migrationException->getMessage(), PHP_EOL);
    }

    /**
     * Handles unexpected errors gracefully.
     *
     * Centralizes the handling of unknown or unexpected errors, ensuring that critical failures
     * are logged and reported consistently, making it easier to track issues.
     *
     * @param Throwable $throwable Exception to handle.
     */
    private function handleUnexpectedError(Throwable $throwable) : void
    {
        $this->logger->critical(
            message: 'An unexpected error occurred during the migration process.',
            context: ['error' => $throwable->getMessage()]
        );

        echo sprintf('Unexpected error: %s%s', $throwable->getMessage(), PHP_EOL);
    }
}
=== Database/Migration/Runner/Commands/MigrateFreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateFreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Running fresh migrations...\n";
            $this->logger->info("Fresh migrations executed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error running fresh migrations: ' . $throwable->getMessage());
        }
    }
}
=== Database/Migration/Runner/Commands/MigrateRefreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRefreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Refreshing migrations...\n";
            $this->logger->info("Migrations refreshed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error refreshing migrations: ' . $throwable->getMessage());
        }
    }
}
=== Database/Migration/Runner/Commands/MigrateRollbackCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRollbackCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Rolling back migrations...\n";
            $this->logger->info("Migrations rolled back successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error rolling back migrations: ' . $throwable->getMessage());
        }
    }
}
=== Database/Migration/Runner/Commands/MigrateStatusCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;

final readonly class MigrateStatusCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        echo "Migration status:\n";
        echo "[✓] Migration_001\n";
        echo "[✓] Migration_002\n";
        $this->logger->info("Migration status retrieved successfully.");
    }
}
=== Database/Migration/Runner/Commands/ValidateStubsCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\StubResolver;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * ValidateStubsCommand Class
 *
 * Validates the existence and readability of stub files in the specified directory.
 */
readonly class ValidateStubsCommand implements CommandInterface
{
    public function __construct(
        private StubResolver    $stubResolver,
        private LoggerInterface $logger
    ) {}

    /**
     * Executes the stub validation command.
     *
     * @param array $arguments List of stub file names to validate.
     */
    public function execute(array $arguments) : void
    {
        if ($arguments === []) {
            $this->logger->error(message: "No stub files provided for validation.");
            echo "Error: No stub files provided for validation.\n";

            return;
        }

        foreach ($arguments as $argument) {
            try {
                // Attempt to read the stub file
                $this->stubResolver->read(stubName: $argument);

                // Log and output success message
                $this->logger->info(message: sprintf('Stub "%s" is valid.', $argument));
                echo sprintf("Stub \"%s\" is valid.\n", $argument);
            } catch (Throwable $e) {
                // Log and output error message
                $this->logger->error(
                    message: sprintf(
                                 'Stub "%s" validation failed: %s',
                                 $argument,
                                 $e->getMessage()
                             )
                );
                echo sprintf(
                    "Error: Stub \"%s\" validation failed: %s\n",
                    $argument,
                    $e->getMessage()
                );
            }
        }
    }
}

=== Database/Migration/Runner/Console/CLI.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Console;

use Exception;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The CLI class handles command-line interactions for database migrations.
 * It utilizes the Arrhae collection class for managing commands and arguments,
 * providing enhanced flexibility and powerful data manipulation capabilities.
 *
 * Example Usage:
 * php gemini create:migration --name=CreateUsersTable
 */
class CLI
{
    /**
     * @var Arrhae The collection of available commands.
     */
    private Arrhae $commands;

    /**
     * CLI constructor.
     *
     * Initializes the commands collection using the Arrhae::make() factory method.
     */
    public function __construct()
    {
        // Initialize the command collection with Arrhae
        $this->commands = Arrhae::make(
            items: [
                       'make:migration' => new MigrationGenerator(),
                   ]
        );
    }

    /**
     * Executes the CLI command based on provided arguments.
     *
     * @param array $argv Command-line arguments.
     *
     * @return void
     */
    public function run(array $argv) : void
    {
        // Wrap the $argv array into an Arrhae collection for enhanced manipulation
        $args = Arrhae::make(items: $argv);

        // Check if at least one command is provided
        if ($args->count() < 2) {
            $this->displayUsage();
            exit(1);
        }

        // Retrieve the command name (second argument)
        $commandName = $args->get(key: 1);

        // Format the arguments using the Arrhae-based method
        $arguments = $this->formatArguments(args: $args->slice(offset: 2));

        // Check if the command exists in the collection
        if (! $this->commands->has(key: $commandName)) {
            echo "Command not found: {$commandName}\n";
            $this->suggestSimilarCommands(commandName: $commandName);
            exit(1);
        }

        // Retrieve the command instance
        $command = $this->commands->get(key: $commandName);

        // Ensure the command is executable
        if (! method_exists($command, 'execute')) {
            echo "Command '{$commandName}' is not executable.\n";
            exit(1);
        }

        // Execute the command with the formatted arguments
        try {
            $command->execute($arguments->toArray());
        } catch (Exception $e) {
            echo "Error executing command '{$commandName}': " . $e->getMessage() . "\n";
            exit(1);
        }
    }

    /**
     * Displays the usage instructions for the CLI.
     *
     * @return void
     */
    private function displayUsage() : void
    {
        echo "Usage: php gemini <command> [options]\n";
        echo "Available Commands:\n";
        echo $this->commands->keys()->map(static fn($command) => "  - {$command}")->implode("\n") . "\n";
    }

    /**
     * Formats command-line arguments into a structured Arrhae collection.
     *
     * This method parses arguments to handle both flag-style (e.g., --key=value)
     * and positional arguments, assigning the first positional argument to 'name'.
     *
     * @param Arrhae $args Raw command-line arguments (excluding script name and command name).
     *
     * @return Arrhae Formatted arguments as an Arrhae collection.
     */
    private function formatArguments(Arrhae $args) : Arrhae
    {
        // Use Arrhae's filtering and mapping capabilities to parse arguments
        return $args
            ->filter(callback: static fn($arg, $key) => is_string($arg) && $key !== 0) // Exclude script name
            ->mapWithKeys(callback: static function ($arg) {
                if (str_starts_with($arg, '--')) {
                    // Parse --key=value arguments
                    $keyValue = substr($arg, 2);
                    $parts    = explode('=', $keyValue, 2);

                    $key = $parts[0];
                    $value = $parts[1] ?? true; // Assign true if no value is provided

                    return [$key => $value];
                } elseif (! str_starts_with($arg, '--') && ! isset($arg)) {
                    // Assign the first positional argument to 'name'
                    return ['name' => $arg];
                }

                return [];
            })
            // Ensure 'name' is set if a positional argument exists
            ->when(
                condition: $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'))->count() > 0,
                callback : function ($collection) use ($args) {
                    $positionalArgs = $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'));

                    return $collection->set('name', $positionalArgs->first());
                }
            );
    }

    /**
     * Suggests similar commands if the provided command is not found.
     *
     * @param string $commandName The command name that was not found.
     *
     * @return void
     */
    private function suggestSimilarCommands(string $commandName) : void
    {
        // Wrap the keys into an Arrhae instance to use fuzzyMatch
        $similarCommands = Arrhae::make(items: $this->commands->keys())
            ->fuzzyMatch(query: $commandName, threshold: 60)
            ->toArray();

        if (! empty($similarCommands)) {
            echo "Did you mean:\n";
            echo Arrhae::make(items: $similarCommands)
                     ->map(callback: fn($cmd) => "  - {$cmd}")
                     ->implode("\n") . "\n";
        }
    }
}

=== Database/Migration/Runner/DTO/FieldDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Gemini\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationArrayRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldAttributesRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldTypeRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationForeignActionRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationIntegerRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationStringRule;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;
use InvalidArgumentException;

final class FieldDTO extends AbstractDTO
{
    #[Required]
    #[Trimmed]
    #[StringType]
    public string                 $name;

    #[MigrationFieldTypeRule]
    public FieldTypeEnum|null     $type       = null;

    #[MigrationIntegerRule]
    public int|null               $length     = null;

    #[MigrationIntegerRule]
    public int|null               $total      = null;

    #[MigrationIntegerRule]
    public int|null               $places     = null;

    #[MigrationArrayRule]
    public array|null             $values     = null;

    public mixed                  $default    = null;

    #[MigrationFieldAttributesRule]
    public array|null             $attributes = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $comment    = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $references = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $on         = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onDelete   = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onUpdate   = null;

    #[ArrayType]
    public array|null             $columns    = null;

    public function __construct(array|object $data)
    {
        $data = (array) $data;

        if (isset($data['name'], $data['type'])) {
            parent::__construct(data: $data);

            return;
        }

        $fieldName  = array_key_first($data);
        $definition = (array) ($data[$fieldName] ?? []);

        if (! isset($definition['type'])) {
            throw new InvalidArgumentException("Missing required 'type' key for field '{$fieldName}'");
        }

        $definition['name'] = $fieldName;
        parent::__construct(data: $definition);
    }
}

=== Database/Migration/Runner/DTO/MigrationDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\DTOObjectOf;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;

/**
 * Data Transfer Object (DTO) for handling migration creation requests.
 *
 * This class acts as an intermediate structure for carrying data between
 * different layers/domain boundaries. It validates input data and ensures all
 * necessary properties conform to their expected types or constraints.
 *
 * Each property of the DTO is initialized and validated through the parent
 * `AbstractDTO` class's constructor.
 *
 * @package Application\DTO
 */
class MigrationDTO extends AbstractDTO
{
    /**
     * The name of the migration class (in PascalCase format).
     *
     * - This represents the high-level name of the migration and is expected to follow coding standards.
     * - This property is subject to trimming and validation rules for string-based input.
     *
     * Example:
     * ```
     * $migrationDTO->name = 'CreateUsersTable';
     * ```
     *
     * @var string Represents the name of the migration class.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be of type string.
    #[Required]
    public string $name;

    /**
     * The name of the database table being targeted or created by the migration.
     *
     * - This represents the physical table name in the database schema.
     * - It undergoes trimming and validation (must be a non-empty string).
     *
     * Example:
     * ```
     * $migrationDTO->table = 'users';
     * ```
     *
     * @var string Represents the target database table for the migration.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be a non-empty string.
    #[Required]
    public string $table;

    /**
     * The schema property representing a complex structure for validation.
     *
     * @var SchemaDTO A data transfer object containing structured schema information.
     */
    #[Required]
    #[DTOObjectOf(SchemaDTO::class)]
    public SchemaDTO $schema;

    public function __construct(array $data = [])
    {
        parent::__construct($data);
    }
}
=== Database/Migration/Runner/DTO/MigrationRecordDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Integer;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * DTO representing a single migration record.
 *
 * Used to transfer structured migration metadata (name, SQL, batch, time).
 */
final class MigrationRecordDTO extends AbstractDTO
{
    #[Required(message: 'Migration name is required.')]
    #[StringType(message: 'Migration must be a string.')]
    public string $migration;

    #[Required(message: 'Executable is required.')]
    #[StringType(message: 'Executable must be a string.')]
    public string $executable;

    #[Required(message: 'Batch ID is required.')]
    #[Integer(message: 'Batch must be an integer.')]
    public int    $batch;

    #[Required(message: 'Execution time is required.')]
    #[StringType(message: 'Execution time must be a valid datetime string.')]
    public string $executed_at;
}

=== Database/Migration/Runner/DTO/SchemaDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object (DTO) representing a database schema.
 *
 * Primary purpose:
 * - Facilitates the consistent and strongly typed representation of schema-related data throughout the system.
 * - Encapsulates and validates an array of fields, where each field is defined by an instance of `FieldDTO`.
 *
 * Leveraging DDD Practices:
 * - Serves as a Boundary Data Design for interaction between application layers.
 * - Ensures domain consistency by enforcing attribute-based validations (e.g., `#[Required]`, `#[ArrayType]`).
 *
 * @package Application\DTO
 */
class SchemaDTO extends AbstractDTO
{
    /**
     * A list of field definitions forming a database schema.
     *
     * - Represents the core building blocks of a database schema (e.g., columns, field attributes).
     * - Each field within the array is strongly typed as `FieldDTO`, ensuring schema integrity.
     *
     * Validation Requirements:
     * - **Required:** `fields` must be present and cannot be `null`.
     * - **ArrayType:** It must be an array of well-formed `FieldDTO` instances.
     *
     * @var \Gemini\Database\Migration\Runner\DTO\FieldDTO[] $fields
     *
     */
    #[Required]
    #[ArrayType]
    public array $fields;
}
=== Database/Migration/Runner/Entity/Migration.php ===
<?php

declare(strict_types=1);

/**
 * Class Migration
 *
 * This class represents a Migration entity in the domain layer. It encapsulates:
 * - The name of the migration.
 * - The date and time when the migration was executed.
 *
 * Responsibilities:
 * - Store and provide access to migration-related data.
 * - Offer additional utilities for validation and serialization.
 *
 * Adheres to:
 * - Single Responsibility Principle (SRP): Only holds migration-specific data and logic.
 * - Immutability: The properties are set at construction and cannot be changed afterward.
 */

namespace Gemini\Database\Migration\Runner\Entity;

use DateTimeImmutable;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use JsonSerializable;

/**
 * The Migration class represents a database migration.
 * It stores the migration's name and the date/time of its execution.
 *
 * Features:
 * - Provides methods to retrieve migration details.
 * - Implements validation for robust handling of migration data.
 * - Supports JSON serialization for external APIs or storage.
 */
class Migration implements JsonSerializable
{
    /**
     * Constructor for the Migration class.
     *
     * @param string            $migrationName The name of the migration (must be non-empty).
     * @param DateTimeImmutable $executedAt    The date and time the migration was executed.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    public function __construct(
        protected string            $migrationName,
        protected DateTimeImmutable $executedAt,
        protected QueryBuilder      $queryBuilder
    ) {
        $this->validateMigrationName(migrationName: $migrationName);
    }

    /**
     * Validates the migration name.
     *
     * @param string $migrationName The name of the migration.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    private function validateMigrationName(string $migrationName) : void
    {
        if (trim($migrationName) === '') {
            throw new InvalidArgumentException(message: 'Migration name cannot be empty.');
        }

        if (strlen($migrationName) > 255) {
            throw new InvalidArgumentException(message: 'Migration name cannot exceed 255 characters.');
        }
    }

    /**
     * Creates a Migration instance from an array of data.
     *
     * @param array $data An associative array containing 'migration_name' and 'executed_at' keys.
     *
     * @return static A new Migration instance created from the provided data.
     * @throws \InvalidArgumentException If required, data is missing or invalid.
     */
    public static function fromArray(array $data) : self
    {
        if (! isset($data['migration_name'], $data['executed_at'])) {
            throw new InvalidArgumentException(message: 'Missing required keys: "migration_name" and "executed_at".');
        }

        $executedAt = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', $data['executed_at']);
        if ($executedAt === false) {
            throw new InvalidArgumentException(
                message: 'Invalid date format for "executed_at". Expected "Y-m-d H:i:s".'
            );
        }

//        return new self(
//            migrationName: $data['migration_name'],
//            executedAt   : $executedAt,
//            queryBuilder : $this->queryBuilder
//        );
    }

    /**
     * Alias for `getMigrationName`, used for compatibility with other systems.
     *
     * @return string The name of the migration.
     */
    public function getName() : string
    {
        return $this->getMigrationName();
    }

    /**
     * Retrieves the name of the migration.
     *
     * @return string The name of the migration.
     */
    public function getMigrationName() : string
    {
        return $this->migrationName;
    }

    /**
     * Gets the date and time when the migration was executed.
     *
     * @return DateTimeImmutable The datetime representing when the migration was executed.
     */
    public function getExecutedAt() : DateTimeImmutable
    {
        return $this->executedAt;
    }

    /**
     * Prepares the migration instance for JSON serialization.
     *
     * @return array The migration data ready for JSON encoding.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Converts the migration instance to an associative array.
     *
     * @return array The migration data as an associative array.
     */
    public function toArray() : array
    {
        return [
            'migration_name' => $this->migrationName,
            'executed_at'    => $this->executedAt->format(format: 'Y-m-d H:i:s'),
        ];
    }
}

=== Database/Migration/Runner/Enum/MigrationStatus.php ===
<?php

/**
 * Migration Status Value Object
 *
 * This file is part of the Gemini Database Migration System.
 *
 * @copyright Gemini Team 2024
 */

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Enum;

/**
 * MigrationStatus Value Object represents the lifecycle states of a database migration.
 *
 * This immutable enum encapsulates all possible states a migration can transition through
 * during its lifecycle, ensuring type safety and domain integrity. Each state represents
 * a distinct phase in the migration process, making the domain model explicit and enforcing
 * business rules through type constraints.
 *
 * @api
 * @final
 * @since   1.0.0
 * @package Gemini\Database\Migration
 */
enum MigrationStatus: string
{
    /**
     * Represents a migration that is scheduled but not yet executed.
     * This is the initial state of any new migration.
     */
    case Pending = 'pending';

    /**
     * Represents a migration that has been successfully applied to the database.
     * Transitions from Pending state after successful execution.
     */
    case Executed = 'executed';

    /**
     * Represents a migration that has been reversed to its previous state.
     * Only migrations in Executed state can transition to RolledBack.
     */
    case RolledBack = 'rolled_back';

    /**
     * Represents a migration that encountered an error during execution or rollback.
     * Can transition from any state when an operation fails.
     */
    case Failed = 'failed';

    /**
     * Determines if the migration can be executed.
     *
     * @return bool True if the migration is in a state where it can be executed
     */
    public function canBeExecuted() : bool
    {
        return $this === self::Pending || $this === self::RolledBack;
    }

    /**
     * Determines if the migration can be rolled back.
     *
     * @return bool True if the migration is in a state where it can be rolled back
     */
    public function canBeRolledBack() : bool
    {
        return $this === self::Executed;
    }
}
=== Database/Migration/Runner/Exception/MigrationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Exception;

use RuntimeException;
use Throwable;

/**
 * MigrationException
 *
 * Represents errors that occur during the migration process.
 * Extends RuntimeException to provide context-specific information for migration failures.
 */
class MigrationException extends RuntimeException
{
    /**
     * Constructor for the MigrationException.
     *
     * @param string         $message  The error message describing the issue.
     * @param int            $code     An optional error code for categorizing the error.
     * @param Throwable|null $previous Optional previous exception for chained exceptions.
     */
    public function __construct(string $message, int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Provides a string representation of the exception for debugging purposes.
     *
     * @return string A detailed message including the exception class and message.
     */
    public function __toString() : string
    {
        return sprintf(
            "[%s]: %s in %s on line %d\nStack trace:\n%s",
            static::class,
            $this->getMessage(),
            $this->getFile(),
            $this->getLine(),
            $this->getTraceAsString()
        );
    }
}

=== Database/Migration/Runner/Execution/MigrationExecutionServiceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

/**
 * Interface MigrationExecutionServiceInterface
 *
 * Defines high-level operations for applying, rolling back,
 * and previewing schema migrations in a transactional and declarative manner.
 */
interface MigrationExecutionServiceInterface
{
    /**
     * Executes all pending migrations in order.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function executeUp() : void;

    /**
     * Rolls back the most recent batch of migrations.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function rollbackBatch() : void;

    /**
     * Simulates execution and returns SQL preview.
     *
     * @return array<string>
     */
    public function pretend() : array;
}

=== Database/Migration/Runner/Execution/MigrationExecutionService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

use Gemini\Database\Migration\Runner\Migration;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Concrete implementation for executing migration logic.
 */
final readonly class MigrationExecutionService implements MigrationExecutionServiceInterface
{
    public function __construct(private LoggerInterface $logger) {}

    /**
     * @throws \Throwable
     */
    public function runUp(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration UP: " . $migration::class);
            $migration->executeUp();
            $this->logger->info(message: "Migration UP completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration UP failed: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * @throws \Throwable
     */
    public function runDown(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration DOWN: " . $migration::class);
            $migration->executeDown();
            $this->logger->info(message: "Migration DOWN completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration DOWN failed: " . $e->getMessage());
            throw $e;
        }
    }
}

=== Database/Migration/Runner/Generators/AbstractGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Facade\Facades\Storage;
use RuntimeException;

/**
 * AbstractGenerator
 *
 * Provides reusable foundational logic for migration file generation.
 * Adheres to Clean Architecture and modern DSL philosophy.
 */
abstract class AbstractGenerator
{
    /**
     * Retrieves the contents of a stub file used as a template.
     *
     * @param string $stubName The name of the stub file to retrieve (e.g., 'create.stub').
     *
     * @return string The contents of the stub.
     * @throws RuntimeException If the stub file is missing.
     */
    protected function getStub(string $stubName) : string
    {
        $stubPath = $this->resolveStubPath(stubName: $stubName);

        if (! Storage::exists($stubPath)) {
            throw new RuntimeException(message: sprintf('Stub "%s" not found at path: %s', $stubName, $stubPath));
        }

        return Storage::read($stubPath);
    }

    /**
     * Resolves the absolute path to the specified stub file.
     *
     * @param string $stubName The filename of the stub.
     *
     * @return string The resolved absolute path.
     */
    private function resolveStubPath(string $stubName) : string
    {
        return AppPath::STUBS_PATH->get() . $stubName;
    }

    /**
     * Replaces all placeholders in a stub string with provided values.
     *
     * @param string                $stub         The original stub content.
     * @param array<string, string> $placeholders Array of placeholders and replacement values.
     *
     * @return string The updated stub content.
     */
    protected function replacePlaceholders(string $stub, array $placeholders) : string
    {
        foreach ($placeholders as $placeholder => $value) {
            $stub = str_replace(sprintf('{{%s}}', $placeholder), $value, $stub);
        }

        return $stub;
    }

    /**
     * Writes content to a file and applies secure permissions.
     *
     * @param string $path    The absolute file path.
     * @param string $content The content to write to disk.
     *
     * @throws RuntimeException On write or permission failure.
     */
    protected function writeToFile(string $path, string $content) : void
    {
        $directory = dirname($path);

        // Create a directory if it doesn't exist
        if (! Storage::exists($directory)) {
            Storage::createDirectory($directory);
        }

        // Throws if writing to a file fails
        if (! Storage::write($path, $content)) {
            throw new RuntimeException(message: 'Failed to write file at path: ' . $path);
        }

        $permissions = config(key: 'app.filePermissions', default: 0666);

        if (! Storage::setPermissions($path, $permissions)) {
            throw new RuntimeException(message: 'Failed to set permissions for file: ' . $path);
        }

        $this->setFileOwnership($path);
    }

    /**
     * Ensures the file has appropriate ownership metadata for local development.
     *
     * @param string $path Absolute path of the file.
     */
    private function setFileOwnership(string $path) : void
    {
        if (PHP_OS_FAMILY === 'Linux' || PHP_OS_FAMILY === 'Darwin') {
            $uid = getmyuid() ?: getenv('UID') ?: 1000;
            $gid = getmygid() ?: getenv('GID') ?: 1000;

            shell_exec(sprintf('chown %d:%d %s', $uid, $gid, escapeshellarg($path)));
        }
    }

    /**
     * Resolves the appropriate filesystem path for a given namespace.
     *
     * @param string $namespace The target namespace.
     * @param string $name      The base class name (without extension).
     *
     * @return string Fully qualified file path.
     * @throws RuntimeException If no config path is found for the namespace.
     */
    protected function resolvePath(string $namespace, string $name) : string
    {
        $type = array_keys(config(key: 'app.namespaces'), $namespace, true)[0] ?? null;
        $path = config(key: 'app.paths.' . $type);

        if (! $path) {
            throw new RuntimeException(
                message: sprintf('Path for %s is not defined in app.php configuration.', $namespace)
            );
        }

        return rtrim(base_path(), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . rtrim((string) $path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . ($name . '.php');
    }
}
=== Database/Migration/Runner/Generators/Code/BlueprintCodeGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Code;

use Gemini\Database\Migration\Design\Table\Table;
use RuntimeException;

/**
 * Class BlueprintCodeGenerator
 *
 * Responsible for converting an instance of the Table class into
 * syntactically valid PHP schema definition statements (e.g. `$table->string('name')...`).
 *
 * This class is used during migration stub rendering to inject generated code
 * for table schema directly from the domain blueprint object.
 *
 * @package Gemini\Database\Migration\Generators\Code
 */
final readonly class BlueprintCodeGenerator
{
    /**
     * Indentation used for formatting output.
     *
     * @var string
     */
    private const string INDENT = '            ';

    /**
     * Generates formatted PHP code lines from the given Table object.
     *
     * @param Table $blueprint The domain object containing table column definitions.
     *
     * @return string Fully formatted PHP schema definition lines suitable for migration stub.
     *
     * @throws RuntimeException If blueprint contains invalid structures or unsupported definitions.
     */
    public function generate(Table $blueprint) : string
    {
        // Retrieve all raw column definitions from the Table instance.
        $columns = $blueprint->getRawColumnDefinitions();

        // Check for an empty schema and return a placeholder comment if needed.
        if (empty($columns)) {
            return self::INDENT . '// No schema defined in Table.';
        }

        // Map each raw SQL/DSL definition into a properly indented PHP statement.
        $lines = array_map(
            static fn(string $line) : string => self::INDENT . '$table->addColumn(' . var_export($line, true) . ');',
            $columns
        );

        // Join all formatted lines into a single block.
        return implode(PHP_EOL, $lines);
    }
}

=== Database/Migration/Runner/Generators/CommandInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

/**
 * Interface CommandInterface
 *
 * Describes a blueprint for CLI commands in the Gemini framework.
 * Any CLI command in the Gemini system should implement this interface to ensure consistency.
 */
interface CommandInterface
{
    /**
     * Executes the command with provided arguments.
     *
     * The method signature enforces strict typing by using `array` for arguments and
     * `void` for the return type, which aligns with the goals of type safety and clarity.
     *
     * @param array $arguments Arguments passed to the command.
     *
     * Important to note:
     * - The method does not return anything (`void`), reflecting that CLI commands typically
     *   produce their outcome directly via output or side effects (like writing to a file).
     * - This interface ensures any implementing class will provide its own specific logic
     *   for executing commands, maintaining a standard method signature for execution.
     */
    public function execute(array $arguments) : void;
}
=== Database/Migration/Runner/Generators/Controller/ControllerGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Controller;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * ControllerGenerator Class
 *
 * This final class is responsible for generating RESTful controllers based on a given name.
 * It inherits from AbstractGenerator, ensuring reusable code for common generator functionalities.
 */
final class ControllerGenerator extends AbstractGenerator
{
    /**
     * Creates a RESTful controller class file.
     *
     * @param string $name The name of the controller to be generated.
     *
     * This method constructs a namespace and path for controller files using
     * configuration variables. If these configurations are missing, it throws an exception.
     * The class name is generated, and a stub file is loaded and customized with placeholders.
     * Finally, the customized stub is written to the appropriate file path.
     *
     * @throws RuntimeException If the namespace or path configuration is missing, or if file operations fail.
     */
    public function create(string $name) : void
    {
        // Retrieve the namespace and path for controllers from the configuration
        $namespace = config(key: 'app.namespaces.Controllers');
        $path      = config(key: 'app.paths.Controllers');

        // Ensure both namespace and path are configured
        if ($namespace === null || $path === null) {
            throw new RuntimeException(message: 'Controllers namespace or path is not configured.');
        }

        // Generate the class name for the controller
        $className = $this->generateMigrationClassName(tableName: $name, type: 'controller');

        // Load the controller stub and replace placeholders
        $stub = $this->getStub(stubName: 'controller.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'ControllerName' => $className,
            'namespace'      => $namespace,
        ]);

        // Resolve the file path for the new controller and write the customized stub content
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Database/Migration/Runner/Generators/DTO/DtoGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\DTO;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Class DtoGenerator
 *
 * A final class responsible for generating DTO (Data Transfer Object)
 * classes based on a given table name and its fields.
 *
 * @package Gemini\Database\Migration\Generators
 */
final class DtoGenerator extends AbstractGenerator
{
    /**
     * Generate and create a DTO class file based on provided table name and fields.
     *
     * @param string $tableName The name of the table to generate the DTO for.
     * @param array  $fields    An associative array of fields where 'type' and 'name' are defined.
     *
     * @throws RuntimeException If DTO paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Retrieve DTO namespace and path from configuration
        $namespace = config(key: 'app.namespaces.DTO');
        $path      = config(key: 'app.paths.DTO');

        // Ensure namespace and path are configured
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'DTO paths or namespaces are not configured correctly.');
        }

        // Generate the class name using the AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'dto');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'dto.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'DTOName'    => $className,
            'Namespace'  => $namespace,
            'Properties' => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate formatted properties for the DTO class.
     *
     * @param array $fields An array of fields with 'type' and 'name'.
     *
     * @return string Formatted properties as strings.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    public %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types.
     *
     * @param string $type The database type (e.g., 'string', 'int').
     *
     * @return string The corresponding PHP type (e.g., 'string', 'int') or 'mixed' if not mapped.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Database/Migration/Runner/Generators/Entity/EntityGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Final class for generating entity classes based on table schema.
 * Extends the AbstractGenerator for reusing the generator logic.
 */
final class EntityGenerator extends AbstractGenerator
{
    /**
     * Create an entity class file for the given table and fields.
     *
     * @param string $tableName The name of the table.
     * @param array  $fields    The fields' definitions of the table.
     *
     * @throws RuntimeException If paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Load namespace and path from configuration.
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');

        // If a namespace or path is not configured, throw an exception.
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method.
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'  => $className,
            'Namespace'   => $namespace,
            'Properties'  => $this->generateProperties(fields: $fields),
            'Constructor' => $this->generateConstructor(fields: $fields),
            'Methods'     => $this->generateMethods(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate class properties for the given fields.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Convert database field types to corresponding PHP types.
     *
     * @param string $type The database field type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }

    /**
     * Generate constructor method for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated constructor.
     */
    private function generateConstructor(array $fields) : string
    {
        // Arguments for the constructor.
        $args = implode(
            ', ',
            array_map(
                fn($field) : string => sprintf(
                    '%s|null $%s = null',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );

        // Property assignments in the constructor.
        $assignments = implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf('        $this->%s = $%s;', $field['name'], $field['name']),
                $fields
            )
        );

        return <<<PHP
            public function __construct({$args})
            {
                {$assignments}
            }
            PHP;
    }

    /**
     * Generate getter and setter methods for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated methods.
     */
    private function generateMethods(array $fields) : string
    {
        $methods = array_map(function (array $field) : string {
            // Generating getter method.
            $getter = <<<PHP
                public function get{$this->camelCase(name: $field['name'])}(): ?{$this->mapType(type: $field['type'])}
                {
                    return \$this->{$field['name']};
                }
                PHP;

            // Generating setter method.
            $setter = <<<PHP
                                                            public function set{$this->camelCase(
                    name: $field['name']
                )}({$this->mapType(
                    type: $field['type']
                )} \${$field['name']}): self
                                                            {
                                                                \$this->{$field['name']} = \${$field['name']};
                                                                return \$this;
                                                            }
                PHP;

            return "{$getter}\n\n{$setter}";
        }, $fields);

        return implode(PHP_EOL, $methods);
    }

    /**
     * Convert snake_case to CamelCase.
     *
     * @param string $name The string in snake_case.
     *
     * @return string The string converted to CamelCase.
     */
    private function camelCase(string $name) : string
    {
        return ucfirst(
            str_replace(
                ' ',
                '',
                ucwords(
                    str_replace('_', ' ', $name)
                )
            )
        );
    }
}
=== Database/Migration/Runner/Generators/Entity/EntityQueryBuilderGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * EntityQueryBuilderGenerator Class
 *
 * Generates PHP entity classes with integrated query builder functionality.
 * Designed to automate generation of entity classes with standard CRUD operations.
 */
final class EntityQueryBuilderGenerator extends AbstractGenerator
{
    /**
     * Create a new entity class with integrated query builder methods.
     *
     * @param string $name   The name of the entity class to create.
     * @param string $table  The name of the database table associated with the entity.
     * @param array  $fields The fields to include in the entity class.
     *
     * @throws RuntimeException if necessary configuration is missing.
     */
    public function create(string $name, string $table, array $fields) : void
    {
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name based on the table and entity type.
        $className = $this->generateMigrationClassName(tableName: $table, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity-querybuilder.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'   => $className,
            'TableName'    => $table,
            'Namespace'    => $namespace,
            'QueryMethods' => $this->generateQueryMethods(),
            'Properties'   => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate standard query methods for the entity.
     *
     * @return string The PHP code for query methods.
     *
     * Methods include common CRUD operations to make entity management straightforward.
     */
    private function generateQueryMethods() : string
    {
        return <<<PHP
            public function find(int \$id): ?self
            {
                \$result = \$this->where('id', '=', \$id)->first();
                return \$result ? (new static())->fillFromArray(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->get();
                return array_map(fn(array \$data) => (new static())->fillFromArray(\$data), \$results);
            }
            
            public function save(): bool
            {
                \$data = get_object_vars(\$this);
                if (!empty(\$data['id'])) {
                    return \$this->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->insertGetId(\$data);
                if (\$id) {
                    \$this->id = \$id;
                    return true;
                }
            
                return false;
            }
            
            public function delete(): bool
            {
                if (empty(\$this->id)) {
                    throw new \RuntimeException('Cannot delete an unsaved entity.');
                }
                return \$this->where('id', '=', \$this->id)->delete();
            }
            
            public function fillFromArray(array \$data): self
            {
                foreach (\$data as \$key => \$value) {
                    if (property_exists(\$this, \$key)) {
                        \$this->{\$key} = \$value;
                    }
                }
                return \$this;
            }
            PHP;
    }

    /**
     * Generate properties for the entity class based on given fields.
     *
     * @param array $fields The fields to include in the entity class.
     *
     * @return string The PHP code for entity properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn(array $field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types for entity properties.
     *
     * @param string $type The database type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Database/Migration/Runner/Generators/Migration/MigrationGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Migration;

use DateTimeImmutable;
use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use Gemini\Database\Migration\Runner\DTO\MigrationDTO;
use Gemini\Database\Migration\Runner\Enum\MigrationStatus;
use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;
use Gemini\Database\Migration\Runner\Manifest\ManifestStoreInterface;
use RuntimeException;

/**
 * Generates migration classes using Gemini's Domain-Specific Language (DSL).
 *
 * This generator is responsible for transforming structured migration metadata (DTOs)
 * into concrete PHP migration classes. It implements a robust templating system
 * to ensure consistent and maintainable migration file generation.
 *
 * @final    This class is final to prevent inheritance and maintain encapsulation
 * @package  Gemini\Database\Migration\Runner\Generators\Migration
 * @since    8.3.0
 */
final class MigrationGenerator extends AbstractGenerator
{
    /**
     * Template file name used for generating migration classes.
     *
     * This constant defines the stub file that serves as a template for all
     * generated migration classes.
     *
     * @var string
     */
    private const string MIGRATION_STUB = 'anonymous-migration.stub';

    /**
     * Constructs a new instance of the migration generator.
     *
     * This constructor implements the Constructor Promotion pattern (PHP 8.0+) for a cleaner,
     * more maintainable dependency injection. It follows Domain-Driven Design principles
     * by accepting a mapper strategy that encapsulates the field-to-DSL mapping logic.
     *
     * @param FieldToDslMapperInterface $mapper Strategy pattern implementation responsible for
     *                                          mapping field definitions to DSL representations
     *
     * @throws \InvalidArgumentException If the mapper implementation is invalid
     *
     * @since 8.3.0
     */
    public function __construct(
        private readonly FieldToDslMapperInterface $mapper,
        private readonly ManifestStoreInterface    $manifestStore,
    ) {}

    /**
     * Orchestrates the creation of a new database migration file.
     *
     * This method serves as the primary entry point for migration generation,
     * implementing the Command pattern through DTO-based input. It delegates the
     * actual file writing to specialized private methods, maintaining separation
     * of concerns.
     *
     * @param MigrationDTO $dto Data Transfer Object containing migration specifications
     *                          including name, table, and schema information
     *
     * @return void
     * @throws \ReflectionException
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */

    public function generateMigration(MigrationDTO $dto) : void
    {
        // Step 1: Generate migration file and obtain its full path
        $filePath = $this->writeMigrationFile(
            fileName: $dto->name,
            table   : $dto->table,
            fields  : $dto->schema->fields
        );

        // Step 2: Build Manifest Entry DTO
        $manifestEntryDTO = new CreateManifestEntryDTO(
            [
                'migration'      => $dto->name,
                'file'           => basename($filePath),
                'status'         => MigrationStatus::Pending->value,
                'hash'           => hash_file('sha256', $filePath),
                'batch'          => null,
                'executed_at'    => null,
                'rolled_back_at' => null,
                'tenant_id'      => null,
                'tags'           => [],
                'logs'           => [],
                'created_at'     => new DateTimeImmutable(),
            ]
        );

        // Step 3: Store manifest entry
        $this->manifestStore->createEntry($manifestEntryDTO);

        // Step 4: Provide user feedback
        echo "🛠️ Migration '{$dto->name}' and manifest entry created successfully.\n";
    }


    /**
     * Handles the core migration file generation process.
     *
     * This method orchestrates the complete workflow of creating a new database migration file:
     * 1. Validates and retrieves configuration settings
     * 2. Generates the necessary file naming parts
     * 3. Prepares content placeholders
     * 4. Generates and writes the final migration file
     *
     * @param string     $fileName The base name for the migration class (PascalCase)
     * @param string     $table    The target database table name
     * @param FieldDTO[] $fields   Collection of field specifications for table schema
     *
     */
    private function writeMigrationFile(
        string $fileName,
        string $table,
        array  $fields
    ) : string {
        // Retrieve critical configuration settings for migration generation
        $namespace = config(key: 'app.namespaces.Migrations');
        $path      = config(key: 'app.paths.Migrations');

        // Validate configuration presence to ensure proper setup
        if (! ($namespace && $path)) {
            throw new RuntimeException(
                message: "Migration paths or namespaces are misconfigured."
            );
        }

        // Generate timestamp for unique migration file naming
        $timestamp = $this->generateTimestamp();

        // Transform file name into appropriate formats for different uses
        $className = ucfirst($fileName);
        $snakeName = $this->toSnakeCase(string: $fileName);

        // Prepare template placeholders with migration-specific values
        $placeholders = [
            'MigrationName' => $className,
            'Namespace'     => $namespace,
            'TableName'     => $table,
            'Fields'        => $this->generateMigrationTableFields(fields: $fields),
        ];

        // Generate migration content by applying placeholders to the template
        $stubContent = $this->replacePlaceholders(
            stub        : $this->getStub(stubName: self::MIGRATION_STUB),
            placeholders: $placeholders
        );

        // Construct the final file path for the migration
        $finalPath = $this->resolvePath(
            namespace: $namespace,
            name     : "{$timestamp}_{$snakeName}"
        );

        // Write the migration file to the filesystem
        $this->writeToFile(
            path   : $finalPath,
            content: $stubContent
        );

        // Store the generated file name important for manifest entry
        return $finalPath;
    }

    /**
     * Generates a UTC-based timestamp for migration naming.
     *
     * Creates a standardized timestamp format used in migration file names
     * to ensure proper ordering and uniqueness.
     *
     * @return string Formatted timestamp (YmdHis)
     */
    private function generateTimestamp() : string
    {
        return (new DateTimeImmutable())->format(format: 'YmdHis');
    }

    /**
     * Converts PascalCase/camelCase strings to snake_case.
     *
     * Implements a robust string transformation algorithm that handles:
     * - PascalCase to snake_case
     * - camelCase to snake_case
     * - Special character replacement
     *
     * @param string $string The input string to convert
     *
     * @return string The snake_case representation
     */
    private function toSnakeCase(string $string) : string
    {
        $string = preg_replace('/([a-z])([A-Z])/', '$1_$2', $string);
        $string = preg_replace('/[^a-zA-Z0-9]/', '_', $string);

        return strtolower(trim((string) $string, '_'));
    }

    /**
     * Generates the migration table DSL lines using the Table DSL Renderer.
     *
     * Uses a temporary Table blueprint to apply FieldDTO definitions via the fieldMapper,
     * and renders them as `$table->...` PHP migration code lines suitable for stub injection.
     *
     * @param array<int, FieldDTO> $fields Validated list of field DTOs
     *
     * @return string DSL-compatible PHP migration body
     *
     * @throws RuntimeException When the field collection is empty or rendering fails
     */
    private function generateMigrationTableFields(array $fields) : string
    {
        // Create blueprint with injected mapper (injected earlier in MigrationGenerator)
        $table = Table::create(name: 'temporary')
            ->useMapper($this->mapper)
            ->applyMany($fields);

        // Render DSL output
        return $table->toDsl();
    }

}
=== Database/Migration/Runner/Generators/Repository/RepositoryGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Repository;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * RepositoryGenerator Class
 *
 * This class is responsible for generating repository classes with predefined methods for database operations.
 * It extends from AbstractGenerator and leverages its methods to handle stubs and file writing.
 */
final class RepositoryGenerator extends AbstractGenerator
{
    /**
     * Create a repository class for a given table and entity.
     *
     * @param string $tableName The name of the database table.
     * @param string $entity    The name of the entity class.
     * @param array  $fields    Additional fields used in repository methods. (Default: empty array).
     *
     * @throws RuntimeException If repository paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, string $entity, array $fields = []) : void
    {
        $namespace = config(key: 'app.namespaces.Repositories');
        $path      = config(key: 'app.paths.Repositories');

        // Ensure namespace and path configuration exists
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Repository paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'repository');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'repository.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'RepositoryName' => $className,
            'Namespace'      => $namespace,
            'EntityName'     => $entity,
            'Methods'        => $this->generateMethods(entity: $entity),
        ]);

        // Determine the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate method stubs for the repository class.
     *
     * @param string $entity The name of the entity class.
     *
     * @return string The generated methods as a string.
     */
    private function generateMethods(string $entity) : string
    {
        return <<<PHP
            public function find(int \$id): ?{$entity}
            {
                \$result = \$this->queryBuilder()->where('id', '=', \$id)->first();
                return \$result ? new {$entity}(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->queryBuilder()->get();
                return array_map(fn(\$data) => new {$entity}(\$data), \$results);
            }
            
            public function save({$entity} \$entity): bool
            {
                \$data = get_object_vars(\$entity);
            
                if (!empty(\$data['id'])) {
                    return \$this->queryBuilder()->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->queryBuilder()->insertGetId(\$data);
                if (\$id) {
                    \$entity->setId(\$id);
                    return true;
                }
            
                return false;
            }
            
            public function delete(int \$id): bool
            {
                return \$this->queryBuilder()->where('id', '=', \$id)->delete();
            }
            PHP;
    }
}
=== Database/Migration/Runner/Generators/Service/ServiceGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Service;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Service Generator
 *
 * This generator creates service classes with basic scaffolding.
 * It extends AbstractGenerator to leverage shared utilities for file generation.
 */
final class ServiceGenerator extends AbstractGenerator
{
    /**
     * Creates a new service class.
     *
     * This method uses a stub file as a template, replaces placeholders
     * with actual values, and writes the generated content to a destination path.
     *
     * @param string $name The name of the service class to be generated.
     */
    public function create(string $name) : void
    {
        // Load the namespace and path from configuration
        // Rationale: Allow configuration to dictate the location and structure of generated files
        $namespace = config(key: 'app.namespaces.Services');
        $path      = config(key: 'app.paths.Services');

        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Service namespace or path is not configured correctly.');
        }

        // Generate the class name using AbstractGenerator's method
        // Intent: Create standardized class names based on provided table name
        $className = $this->generateMigrationClassName(tableName: $name, type: 'service');

        // Load the service stub file
        // Rationale: Use a template to maintain consistent structure across generated service classes
        $stub = $this->getStub(stubName: 'service.stub');

        // Replace placeholders in the stub
        // Intent: Dynamically insert the class name and namespace into the template
        $stub = $this->replacePlaceholders(
            stub:         $stub,
            placeholders: [
                              'ServiceName' => $className,
                              'Namespace'   => $namespace,
                          ]
        );

        // Resolve the file path
        // Rationale: Ensure the new class is placed in the correct directory based on namespace
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);

        // Write the generated content to the file
        // Rationale: Finalize the service class creation by writing the populated template to the file system
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Database/Migration/Runner/Generators/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Exception;
use Psr\Log\LoggerInterface;

/**
 * StubResolver Class
 *
 * This class is responsible for handling the location, validation, and reading of stub files
 * used in code generation. It ensures that the directory containing stub files exists and is readable,
 * and it supports reading specific stub files for use in other applications.
 */
readonly class StubResolver
{
    /**
     * @param string          $stubDirectory The directory where stub files are stored.
     * @param LoggerInterface $logger        The logger instance for logging errors and information.
     *
     * @throws Exception If the stub directory is invalid upon instantiation.
     */
    public function __construct(
        private string          $stubDirectory,
        private LoggerInterface $logger
    ) {
        $this->validateStubDirectory();
    }

    /**
     * Validates that the stub directory exists and is readable.
     *
     * Throws an exception if the directory does not exist or is not readable, and logs a critical error.
     * This check is crucial for ensuring that later file operations do not fail due to
     * an invalid directory path.
     *
     * @throws Exception If the stub directory is invalid.
     */
    private function validateStubDirectory() : void
    {
        if (! is_dir($this->stubDirectory) || ! is_readable($this->stubDirectory)) {
            // Log the critical issue that the directory is invalid.
            $this->logger->critical(
                sprintf('Invalid stub directory: "%s".', $this->stubDirectory)
            );

            throw new Exception(
                sprintf(
                    'Stub directory "%s" does not exist or is not readable.',
                    $this->stubDirectory
                )
            );
        }
    }

    /**
     * Reads the contents of a stub file.
     *
     * This method resolves the full path of the stub file and attempts to read its contents.
     * If reading fails, it logs an error and throws an exception.
     * Successfully read content is logged for auditing purposes.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The content of the stub file.
     * @throws Exception If the stub file cannot be read.
     */
    public function read(string $stubName) : string
    {
        // Resolve a full path for the specified stub file.
        $stubPath = $this->resolve($stubName);

        $content = file_get_contents($stubPath);
        if ($content === false) {
            // Log the error if reading the file fails.
            $this->logger->error(
                sprintf('Failed to read content of stub file: "%s" at "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Failed to read stub file: "%s".', $stubName));
        }

        // Log successful read for future reference.
        $this->logger->info(
            sprintf('Successfully read stub file: "%s" from path: "%s".', $stubName, $stubPath)
        );

        return $content;
    }

    /**
     * Resolves the full path of a stub file.
     *
     * This method constructs the full path to the stub file within the stub directory.
     * It checks for the file's existence and readability, logging warnings and throwing exceptions as necessary.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The resolved path of the stub file.
     * @throws Exception If the stub file does not exist or is unreadable.
     */
    public function resolve(string $stubName) : string
    {
        $stubPath = rtrim($this->stubDirectory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $stubName;

        // Check that the file exists and is readable before progressing.
        if (! file_exists($stubPath) || ! is_readable($stubPath)) {
            // Log a warning if the file is missing or not accessible.
            $this->logger->warning(
                sprintf('Stub file "%s" not found or unreadable at path: "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Stub file "%s" not found or unreadable.', $stubName));
        }

        return $stubPath;
    }
}
=== Database/Migration/Runner/Manifest/DTO/CreateManifestEntryDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest\DTO;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object for creating a Manifest Entry.
 *
 * Provides validated, casted, and serializable structure for manifest metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest\DTO
 *
 * @final
 */
final class CreateManifestEntryDTO extends AbstractDTO
{
    /**
     * Logical migration name (e.g., CreateProductsTable).
     */
    #[Required]
    public string $migration;

    /**
     * Physical file name (e.g., 20250428120300_create_products_table.php).
     */
    #[Required]
    public string $file;

    /**
     * Migration execution status (pending, executed, rolled_back, failed).
     */
    #[Required]
    public string $status;

    /**
     * SHA-256 hash of the migration file.
     */
    #[Required]
    public string $hash;

    /**
     * Optional batch ID assigned during migration execution.
     */
    public string|null $batch = null;

    /**
     * UTC ISO8601 timestamp of execution completion.
     */
    public string|null $executed_at = null;

    /**
     * UTC ISO8601 timestamp if migration was rolled back.
     */
    public string|null $rolled_back_at = null;

    /**
     * Optional tenant identifier for multi-tenant schemas.
     */
    public string|null $tenant_id = null;

    /**
     * Categorization tags for grouping migrations.
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs attached to the migration.
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Manifest creation timestamp.
     */
    #[Required]
    public DateTimeImmutable $created_at;
}

=== Database/Migration/Runner/Manifest/ManifestDBInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

/**
 * Represents the persistence contract for migration manifest entries.
 *
 * This interface defines the repository contract for managing migration manifest records
 * in a persistence store. It follows the Repository Pattern from DDD and ensures
 * a consistent way to handle migration metadata across different storage implementations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestDBInterface
{
    /**
     * Persists a new migration manifest entry to the storage.
     *
     * This method is responsible for creating a new record in the persistence layer.
     * It encapsulates the storage-specific implementation details while maintaining
     * a consistent interface for manifest entry creation.
     *
     * @param array<string, mixed> $data The manifest entry data to persist
     *
     * @return array<string, mixed> The persisted manifest entry with any storage-generated metadata
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When provided data is invalid
     * @throws \SleekDB\Exceptions\JsonException When JSON serialization fails
     * @throws \SleekDB\Exceptions\IdNotAllowedException When ID field conflicts occur
     */
    public function insert(array $data) : array;

    /**
     * Retrieves manifest entries matching specified criteria.
     *
     * Implements specification pattern for flexible querying of manifest entries.
     * Supports complex query conditions while abstracting storage-specific query syntax.
     *
     * @param array<int, array<string|array>> $conditions Query specifications for filtering entries
     *
     * @return array<int, array<string, mixed>> Collection of manifest entries matching the conditions
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When query conditions are invalid
     */
    public function find(array $conditions) : array;

    /**
     * Retrieves all manifest entries from the storage.
     *
     * Provides a way to access the complete migration history. Use with caution
     * in large datasets as it may impact performance.
     *
     * @return array<int, array<string, mixed>> Complete collection of manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When internal query fails
     */
    public function findAll() : array;

    /**
     * Updates existing manifest entries matching the specified criteria.
     *
     * Supports atomic updates of manifest entries based on matching conditions.
     * Implements bulk update capability for efficient batch processing.
     *
     * @param array<int, array<string|array>> $conditions Specifications for identifying entries to update
     * @param array<string, mixed>            $newData    Updated data to apply to matching entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When conditions or data are invalid
     */
    public function update(array $conditions, array $newData) : void;
}
=== Database/Migration/Runner/Manifest/ManifestDB.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Concrete implementation of ManifestDBInterface using SleekDB.
 *
 * @final
 */
final class ManifestDB implements ManifestDBInterface
{
    /**
     * The underlying SleekDB store instance.
     *
     * @var Store
     */
    private Store $store;

    /**
     * ManifestDB constructor.
     *
     * @param string $storagePath Path where a manifest database is located.
     *
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function __construct(string $storagePath)
    {
        $this->store = new Store(
            storeName    : 'migrations',
            databasePath : $storagePath,
            configuration: ['timeout' => false]
        );
    }


    /**
     * Insert a new manifest record.
     *
     * @param array<string, mixed> $data
     *
     * @return array<string, mixed>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function insert(array $data) : array
    {
        return $this->store->insert($data);
    }

    /**
     * Find manifest records matching given conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function find(array $conditions) : array
    {
        return $this->store->findBy($conditions);
    }

    /**
     * Retrieve all manifest records.
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function findAll() : array
    {
        return $this->store->findAll();
    }

    /**
     * Update manifest records matching conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     * @param array<string, mixed>             $newData
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function update(array $conditions, array $newData) : void
    {
        $this->store
            ->createQueryBuilder()
            ->where($conditions)
            ->getQuery()
            ->update($newData);
    }
}

=== Database/Migration/Runner/Manifest/ManifestStoreInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Defines the contract for managing migration manifest entries in the application.
 *
 * This service interface abstracts the business operations for migration manifest management,
 * providing a clean boundary between the domain logic and persistence layer. It follows
 * the Service Pattern from DDD to encapsulate complex migration tracking operations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestStoreInterface
{
    /**
     * Creates a new migration manifest entry in the store.
     *
     * Processes and validates the migration entry data through a DTO before persistence.
     * Ensures data integrity and consistent state transitions for new migrations.
     *
     * @param CreateManifestEntryDTO $dto Value object containing validated migration entry data
     *
     * @throws \SleekDB\Exceptions\IOException When a storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When entry data is invalid
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void;

    /**
     * Retrieves all migration manifest entries from the store.
     *
     * Provides a complete view of the migration history for audit and management purposes.
     * Results are ordered by creation timestamp to maintain execution sequence.
     *
     * @return array<int, array<string, mixed>> Collection of all migration manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When retrieval operation fails
     */
    public function fetchAll() : array;

    /**
     * Retrieves all pending migrations that haven't been executed.
     *
     * Identifies migrations that need to be processed in the next migration run.
     * Filters entries based on execution status and ordering constraints.
     *
     * @return array<int, array<string, mixed>> Collection of pending migration entries
     *
     * @throws \SleekDB\Exceptions\IOException When the query operation fails
     */
    public function findPending() : array;

    /**
     * Performs rollback operations for migrations in a specific batch.
     *
     * Manages the state transition of migrations during a rollback process.
     * Updates manifest entries to reflect rollback status and timing.
     *
     * @param string $batch Identifier for the batch of migrations to rollback
     *
     * @throws \SleekDB\Exceptions\IOException When the rollback operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When batch identifier is invalid
     */
    public function rollbackBatch(string $batch) : void;

    /**
     * Locates a specific migration entry by its unique name.
     *
     * Provides direct access to individual migration metadata for verification
     * and state management purposes.
     *
     * @param string $migrationName Unique identifier/name of the migration
     *
     * @return array<string, mixed>|null Migration entry if found, null otherwise
     *
     * @throws \SleekDB\Exceptions\IOException When lookup operation fails
     */
    public function findByMigrationName(string $migrationName) : array|null;
}
=== Database/Migration/Runner/Manifest/ManifestStore.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Service that manages manifest operations.
 */
final readonly class ManifestStore implements ManifestStoreInterface
{
    public function __construct(private ManifestDBInterface $db) {}

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\JsonException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \ReflectionException
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void
    {
        $this->db->insert($dto->toArray());
    }

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function fetchAll() : array
    {
        return $this->db->findAll();
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findPending() : array
    {
        return $this->db->find(
            [
                ['status', '=', 'pending'],
            ]
        );
    }

    public function rollbackBatch(string $batch) : void
    {
        $this->db->update(
            [['batch', '=', $batch]],
            ['status' => 'rolled_back', 'rolled_back_at' => (new DateTimeImmutable())->format(DATE_ATOM)]
        );
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findByMigrationName(string $migrationName) : array|null
    {
        $found = $this->db->find(
            [
                ['migration', '=', $migrationName],
            ]
        );

        return $found[0] ?? null;
    }
}
=== Database/Migration/Runner/Manifest/MigrationManifestEntry.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\DateFormat;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * Represents an immutable manifest entry for database migrations within the system.
 *
 * This Value Object encapsulates all metadata related to a single database migration,
 * including its execution status, timing information, and associated metadata. It follows
 * the immutability principle to ensure data consistency throughout the migration process.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 * @final   This class is immutable and must not be extended to maintain invariants
 */
final class MigrationManifestEntry extends AbstractDTO
{
    /**
     * The unique identifier/name of the migration.
     *
     * @var string Represents the unique name used to identify this migration
     */
    #[Required]
    #[StringType]
    public string $migrationName;

    /**
     * The physical file name containing the migration code.
     *
     * @var string The actual filename on the filesystem containing migration logic
     */
    #[Required]
    #[StringType]
    public string $fileName;

    /**
     * Current status of the migration (e.g., 'pending', 'executed', 'failed').
     *
     * @var string Indicates the current state of migration execution
     */
    #[Required]
    #[StringType]
    public string $status;

    /**
     * Cryptographic hash of the migration content for integrity verification.
     *
     * @var string SHA-256 hash (or similar) of the migration file content
     */
    #[Required]
    #[StringType]
    public string $hash;

    /**
     * Optional batch identifier grouping related migrations.
     *
     * @var string|null Identifier for grouping migrations in execution batches
     */
    public string|null $batch = null;

    /**
     * Timestamp when the migration was successfully executed.
     *
     * @var string|null ISO-8601 formatted datetime string of execution
     */
    public string|null $executedAt = null;

    /**
     * Timestamp when the migration was rolled back.
     *
     * @var string|null ISO-8601 formatted datetime string of rollback
     */
    public string|null $rolledBackAt = null;

    /**
     * Optional tenant identifier for multi-tenant environments.
     *
     * @var string|null Unique identifier of the tenant this migration applies to
     */
    public string|null $tenantId = null;

    /**
     * Collection of tags for migration categorization and filtering.
     *
     * @var array<string> List of tags associated with this migration
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs and debug information.
     *
     * @var array<string, mixed> Collection of log entries related to migration execution
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Timestamp when this manifest entry was created.
     *
     * @var DateTimeImmutable Immutable datetime representing creation timestamp
     */
    #[Required]
    #[DateFormat('Y-m-d H:i:s')]
    public DateTimeImmutable $createdAt;
}
=== Database/Migration/Runner/Manifest/MigrationManifestService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Service for managing the Migration Manifest entries.
 *
 * Handles creation, retrieval, updating, and validation of migration metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 *
 * @final   This class is immutable and must not be extended.
 */
final class MigrationManifestService
{
    /**
     * SleekDB Store instance for Manifest storage.
     *
     * @var Store
     */
    private Store $store;

    /**
     * Constructor.
     *
     * Initializes the SleekDB Store directly.
     *
     * @param string $manifestPath Absolute path to the manifest storage directory.
     *
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     */
    public function __construct(string $manifestPath)
    {
        $this->store = new Store(
            storeName    : 'manifest',
            databasePath : $manifestPath,
            configuration: ['auto_cache' => true]
        );
    }

    /**
     * Creates a new Manifest entry.
     *
     * @param MigrationManifestEntry $entry Data Transfer Object representing the migration manifest.
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function createEntry(MigrationManifestEntry $entry) : void
    {
        $this->store->insert(
            [
                'migration'      => $entry->migrationName,
                'file'           => $entry->fileName,
                'status'         => $entry->status,
                'hash'           => $entry->hash,
                'batch'          => $entry->batch,
                'executed_at'    => $entry->executedAt,
                'rolled_back_at' => $entry->rolledBackAt,
                'tenant_id'      => $entry->tenantId,
                'tags'           => $entry->tags,
                'logs'           => $entry->logs,
                'created_at'     => $entry->createdAt->format(DATE_ATOM),
            ]
        );
    }

    /**
     * Retrieves all Manifest entries.
     *
     * @return array<int, array<string, mixed>> List of all migration manifest entries.
     */
    public function all() : array
    {
        return $this->store->fetch();
    }

    /**
     * Finds a specific migration entry by its migration name.
     *
     * @param string $migrationName Logical name of the migration.
     *
     * @return array<string, mixed>|null The matching manifest entry or null if not found.
     */
    public function find(string $migrationName) : array|null
    {
        $result = $this->store
            ->where('migration', '=', $migrationName)
            ->fetch();

        return $result[0] ?? null;
    }
}

=== Database/Migration/Runner/MigrationException.php ===
<?php

declare(strict_types=1);

/**
 * Class MigrationException
 *
 * Exceptions class to handle migration-specific errors within the Gemini database migration context.
 *
 * This class extends the base Exceptions class to provide custom error handling for
 * database migrations, encapsulating the message, error code, and the previous exception.
 *
 * Example usage:
 * <code>
 * throw new MigrationException("Migration failed due to XYZ reason");
 * </code>
 *
 * @package Gemini\Database\Migration
 */

namespace Gemini\Database\Migration\Runner;

use Exception;
use Throwable;

/**
 * MigrationException is a custom exception that is thrown during migration operations.
 *
 * The MigrationException class extends the base Exceptions class and provides additional contextual
 * information specifically related to database migration errors. This exception should be used
 * to indicate issues encountered during the process of migrating database schemas or related data.
 *
 * Usage example:
 * throw new MigrationException("Migration failed due to XYZ reason.");
 *
 * @package Gemini\Database\Migration
 */
class MigrationException extends Exception
{
    /**
     * Constructs a new MigrationException.
     *
     * @param string          $message  The Exceptions message to throw.
     * @param int             $code     The Exceptions code.
     * @param \Throwable|null $previous The previous throwable used for the exception chaining.
     */
    public function __construct(
        string         $message = '',
        int            $code = 0,
        Throwable|null $previous = null,
    ) {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== Database/Migration/Runner/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Service\MigrationExecution;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Abstract Migration Base Class
 *
 * Provides the foundation for creating database migrations in the Gemini framework.
 * Supports transactional, auditable, API-driven migration execution with up/down lifecycle.
 */
abstract readonly class Migration
{
    /**
     * Message template for successful operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_SUCCESS = 'Successfully executed: %s';

    /**
     * Message template for failed operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_FAILURE = 'Failed to execute: %s. Error: %s';

    /**
     * Message template for exception escalation during migration.
     *
     * @var string
     */
    protected const string MIGRATION_ERROR = 'Migration error during: %s. Details: %s';

    /**
     * Dependency for schema creation and modification.
     *
     * @var SchemaBuilder
     */
    protected SchemaBuilder $schemaBuilder;

    /**
     * Action for managing migration registration and persistence.
     *
     * @var MigrationExecution
     */
    protected MigrationExecution $migrationService;

    /**
     * Optional logger for structured output.
     *
     * @var LoggerInterface|null
     */
    protected LoggerInterface|null $logger;

    /**
     * Constructs the Migration base.
     *
     * @param SchemaBuilder        $schemaBuilder    DSL engine for table/column mutation.
     * @param MigrationExecution   $migrationService Action to persist execution records.
     * @param LoggerInterface|null $logger           Optional logger.
     */
    public function __construct(
        SchemaBuilder        $schemaBuilder,
        MigrationExecution   $migrationService,
        LoggerInterface|null $logger = null
    ) {
        $this->schemaBuilder    = $schemaBuilder;
        $this->migrationService = $migrationService;
        $this->logger           = $logger;
    }

    /**
     * Executes the "up" migration lifecycle.
     *
     * @throws MigrationException
     * @throws \Throwable
     */
    final public function executeUp() : void
    {
        $name  = $this->getMigrationName();
        $batch = $this->migrationService->getLatestBatch() + 1;

        $this->logInfo(message: sprintf("🔼 Starting migration '%s' (up)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->up(),
                description: sprintf("Applying migration '%s'", $name)
            );

            $this->migrationService->save(
                migration : $name,
                executable: 'up()',
                batch     : $batch
            );

            $this->logInfo(message: sprintf("🧱 Migration '%s' completed successfully (up).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Migration '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Resolves the class-based migration name.
     *
     * @return string
     */
    private function getMigrationName() : string
    {
        return static::class;
    }

    /**
     * Logs a message if logger is available.
     *
     * @param string $message
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Wraps any logic in try/catch, logs success/failure, escalates errors.
     *
     * @param callable $operation
     * @param string   $description
     *
     * @throws MigrationException
     */
    private function executeSafely(callable $operation, string $description) : void
    {
        // Begin a try block to handle potential errors during operation execution.
        try {
            // Execute the passed operation.
            // Any exception thrown here will be caught by the catch block below.
            $operation();

            $this->logInfo(message: sprintf(self::LOG_OPERATION_SUCCESS, $description));
        } catch (Throwable $e) {
            $this->logError(message: sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Log the failure of the operation with the error message for debugging or auditing purposes.
            $this->logError(sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Throw a MigrationException to escalate the issue while providing context for the failure.
            throw new MigrationException(
                message : sprintf(self::MIGRATION_ERROR, $description, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Logs an error if logger is available.
     *
     * @param string $message
     */
    private function logError(string $message) : void
    {
        $this->logger?->error(message: $message);
    }

    /**
     * Abstract method to be implemented by concrete migrations.
     *
     * @return void
     */
    abstract protected function up() : void;

    /**
     * Executes the "down" rollback lifecycle.
     *
     * @throws MigrationException
     */
    final public function executeDown() : void
    {
        $name = $this->getMigrationName();

        $this->logInfo(message: sprintf("🔽 Starting migration '%s' (down)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->down(),
                description: sprintf("Reverting migration '%s'", $name)
            );

            $this->migrationService->delete(migration: $name);

            $this->logInfo(message: sprintf("🗑️ Migration '%s' completed successfully (down).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Rollback for '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Abstract method for rollback.
     *
     * @return void
     */
    abstract protected function down() : void;
}

=== Database/Migration/Runner/Repository/MigrationRepositoryInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Repository;

/**
 * Interface MigrationRepositoryInterface
 *
 * Defines a contract for managing database migrations.
 * This interface abstracts migration management to ensure consistent migration operations across different
 * implementations.
 */
interface MigrationRepositoryInterface
{
    /**
     * Registers a migration with specified details into the database.
     *
     * @param string $migration  The name or identifier of the migration.
     * @param string $executable The class- or identifier-responsible for executing the migration.
     * @param int    $batch      The batch number that groups this migration with others.
     *
     * The `save` method is crucial for keeping a record of applied migrations
     * along with their batch number to allow rollback or re-execution of specific batches.
     */
    public function save(string $migration, string $executable, int $batch) : void;

    /**
     * Removes a specific migration entry from the database.
     *
     * @param string $migration The name or identifier of the migration to be deleted.
     *
     * Use `delete` to remove the record of a migration, especially if it was applied
     * erroneously or if it needs to be reapplied from scratch.
     */
    public function delete(string $migration) : void;

    /**
     * Checks if a certain migration is recorded in the database.
     *
     * @param string $migration The name or identifier of the migration.
     *
     * @return bool Returns true if the migration exists, otherwise false.
     *
     * The `has` method helps to verify if a migration has already been applied
     * to avoid duplicate application of the same migration.
     */
    public function has(string $migration) : bool;

    /**
     * Retrieves all migration records that have been executed.
     *
     * @return array An array containing details of all executed migrations.
     *
     * The `getAll` method provides a comprehensive list of all migrations that
     * have been executed, useful for audits and tracking the history of migrations.
     */
    public function getAll() : array;

    /**
     * Fetches migrations belonging to a specific batch.
     *
     * @param int $batch The batch number to filter migrations by.
     *
     * @return array An array of migrations under the given batch.
     *
     * The `getMigrationsByBatch` method is useful for operations that need to
     * target specific groups of migrations, such as rolling back a single batch.
     */
    public function getMigrationsByBatch(int $batch) : array;

    /**
     * Gets the highest batch number currently in use.
     *
     * @return int The highest batch number.
     *
     * The `getLatestBatch` method is essential for determining the most recent
     * group of migrations that were applied, often used to target the latest set
     * of migrations for rollbacks.
     */
    public function getLatestBatch() : int;

    /**
     * Removes all migration records, effectively resetting the migration state.
     *
     * Using `dropAllMigrations` prepares the system for a fresh start of migrations,
     * useful in scenarios where the entire migration history needs to be cleared.
     */
    public function dropAllMigrations() : void;

    /**
     * Returns all unexpected (pending) migrations from the database.
     *
     * @return array<int, array<string, mixed>>
     */
    public function allPending() : array;

    /**
     * Deletes all migrations associated with a given batch ID.
     *
     * @param int $batch The batch number to delete.
     */
    public function removeByBatch(int $batch) : void;

    /**
     * Retrieves all migrations for a specific batch in reverse order.
     *
     * @param int $batch The batch to search.
     *
     * @return array<int, array<string, mixed>>
     */
    public function findByBatch(int $batch) : array;

}
=== Database/Migration/Runner/SchemaBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Closure;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * SchemaBuilder
 *
 * Infrastructure facade for declaratively managing database schema via Domain-Specific Language (DSL).
 *
 * This class is responsible for all Data Definition Language (DDL) operations related to schema evolution,
 * such as table creation, deletion, renaming, and connectivity checks. It wraps these operations in
 * transaction-safe boundaries and provides centralized logging, exception normalization, and
 * semantic mapping from domain-oriented blueprints to raw SQL statements.
 *
 * It uses:
 * - QueryBuilder for driver-agnostic query execution
 * - Table DSL for semantic schema construction
 * - LoggerInterface for audit logging and observability
 *
 * It provides:
 * - Transactional safety for destructive operations
 * - Health check APIs for deployment probes
 * - Domain-safe exception boundaries for orchestration code
 *
 * This class belongs to the Infrastructure Layer of a Clean Architecture system,
 * and is intentionally readonly and immutable for safety in concurrent and async environments.
 *
 * @package Gemini\Database\Migration\Runner
 * @readonly
 * @final
 */
final readonly class SchemaBuilder
{
    /**
     * Constructor for initializing the QueryBuilder and LoggerInterface dependencies.
     *
     * @param QueryBuilder    $queryBuilder An instance of QueryBuilder to handle database queries.
     * @param LoggerInterface $logger       An instance of LoggerInterface for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private QueryBuilder    $queryBuilder,
        private LoggerInterface $logger
    ) {}

    /**
     * Determines whether a physical table exists in the active database schema.
     *
     * This check queries the `information_schema.tables` system view using the current
     * database context. It ensures compatibility with multi-tenant schemas and provides
     * fault-tolerant behavior on driver-level errors.
     *
     * @param non-empty-string $table The fully qualified table name to inspect
     *
     * @return bool True if the table exists, false otherwise
     * @throws \Random\RandomException
     */
    public function tableExists(string $table) : bool
    {
        // ✅ Guard against empty table names (domain invariant)
        if (trim($table) === '') {
            return false;
        }

        try {
            return $this->queryBuilder
                ->table(tableName: 'information_schema.tables')
                ->where(column: 'table_schema', value: $this->queryBuilder->raw(sql: 'DATABASE()'))
                ->where(column: 'table_name', value: $table)
                ->exists();
        } catch (QueryBuilderException $e) {
            // ❌ Defensive: driver-level failures shouldn't propagate upward
            $this->logger->error(
                message: 'Failed to verify table existence.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: $e->getMessage(), type: 'warning');

            return false;
        }
    }

    /**
     * Handles message output formatting based on the execution context (CLI or API/HTTP).
     *
     * This method implements the Single Responsibility Principle by managing output
     * formatting and delivery based on the application's runtime environment.
     *
     * @param string $message The message content to be output
     * @param string $type    The message type for color coding (success|warning|error|info)
     *
     * @return string|null Returns null for CLI context (direct output) or string for HTTP context
     */
    public function output(string $message, string $type = 'info') : string|null
    {
        // Determine if we're running in a CLI environment
        if (php_sapi_name() === 'cli') {
            // Define ANSI color codes for different message types in CLI
            $color = match ($type) {
                'success' => "\033[32m", // Green signifies successful operations
                'warning' => "\033[33m", // Yellow indicates warnings or cautions
                'error'   => "\033[31m", // Red represents errors or failures
                default   => "\033[0m",  // Default color for informational messages
            };

            // Output the colored message with reset code and line ending
            echo $color . $message . "\033[0m" . PHP_EOL;

            // CLI context doesn't need return value as output is immediate
            return '';
        }

        // For HTTP/API context, return the raw message
        return $message;
    }

    /**
     * Creates a new database table using a fluent Domain-Specific Language (DSL) schema definition.
     *
     * This method allows declarative schema construction by accepting a user-defined DSL callback.
     * Internally, it ensures atomic DDL execution via transactional encapsulation and logs all operations.
     *
     * @param non-empty-string $table    The name of the table to be created
     * @param Closure          $callback Closure defining the table schema using the fluent DSL
     *
     */
    public function create(string $table, Closure $callback) : bool
    {
        // ✅ Defensive: enforce a table name contract
        if (trim($table) === '') {
            $this->logger->warning(
                message: 'Table name is empty.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table name is empty.', type: 'warning');

            return false;
        }

        try {
            // ✅ Construct new Table schema blueprint using domain factory
            $blueprint = Table::create(name: $table);

            // ✅ Delegate table schema definition to user via DSL callback
            $callback($blueprint);

            // ✅ Generate SQL from blueprint (idempotent)
            $sql = $blueprint->toSql();

            // ✅ Execute SQL within transactional boundary (atomic DDL)
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->raw(sql: $sql)->execute()
            );

            // ✅ Structured operation logging for auditability
            $this->logger->info(
                message: 'Table successfully created.',
                context: ['table' => $table, 'query' => $sql]
            );

            return true;
        } catch (Throwable $e) {
            // ❌ Translate all low-level driver/query exceptions into a domain exception
            $this->logger->error(
                message: 'Failed to create table.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Failed to create table.', type: 'error');

            return false;
        }
    }

    /**
     * Drops the specified table if it exists, using transactional guarantees.
     *
     * This operation is destructive and irreversible. It wraps the `DROP TABLE`
     * execution in a transactional context to ensure rollback capability on failure.
     * Logging is performed for observability, and domain-specific exception wrapping
     * ensures consistent error boundaries.
     *
     * @param non-empty-string $table The name of the table to drop
     *
     * @throws MigrationException On failure to drop the table
     */
    public function drop(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Drop failed: empty table name.', context: ['table' => $table]);

            $this->output(message: 'Drop failed: empty table name.', type: 'warning');

            return false;
        }

        try {
            // 💥 Atomic drop with rollback support
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder
                    ->table(tableName: $table)
                    ->drop()
            );

            // 📘 Successful audit trail
            $this->logger->info(
                message: 'Table dropped successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table dropped successfully.');

            return true;
        } catch (Throwable $e) {
            // 🚨 Surface clean domain-level failure
            $this->logger->error(
                message: 'Failed to drop table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to drop table.', type: 'error');

            return false;
        }
    }

    /**
     * Renames a table within the database schema using transactional guarantees.
     *
     * This method encapsulates the renaming of a table from its current name to a new name.
     * The operation is executed within a transaction, ensuring rollback on failure.
     * Logs are emitted to track structural changes for audit purposes.
     *
     * @param non-empty-string $oldName The current name of the table
     * @param non-empty-string $newName The desired new name for the table
     *
     * @throws MigrationException When renaming fails due to invalid names or query execution errors
     */
    public function rename(string $oldName, string $newName) : bool
    {
        if (trim($oldName) === '' || trim($newName) === '') {
            $this->logger->warning(
                message: 'Cannot rename table: source or destination name is empty.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Cannot rename table: source or destination name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🛡 Perform rename in transaction for rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->renameTable(
                    oldName: $oldName,
                    newName: $newName
                )
            );

            // 📋 Log structural schema change
            $this->logger->info(
                message: 'Table renamed successfully.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Table renamed successfully.');

            return true;
        } catch (Throwable $e) {
            // 🧱 Wrap lower-level failure in domain-safe exception
            $this->logger->warning(
                message: "Failed to rename table '{$oldName}' to '{$newName}'",
                context: [
                             'old_name'  => $oldName,
                             'new_name'  => $newName,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to rename table.', type: 'warning');

            return false;
        }
    }

    /**
     * Truncates a table, removing all data while retaining schema structure.
     *
     * This operation deletes all records from the given table without logging individual row deletions.
     * It is faster than a DELETE operation and suitable for resetting state in non-production contexts.
     * The operation is performed transactionally and wrapped in domain-safe exception boundaries.
     *
     * @param non-empty-string $table The name of the table to truncate
     *
     * @throws MigrationException If truncation fails due to SQL or driver issues
     */
    public function truncate(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Cannot truncate table: table name is empty.');
            $this->output(message: 'Cannot truncate table: table name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🚨 Run inside a transaction to ensure rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->table(tableName: $table)->truncate()
            );

            // 📢 Log action for observability and audit trail
            $this->logger->info(
                message: 'Table truncated successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table truncated successfully.');

            return true;
        } catch (Throwable $e) {
            // 🧱 Encapsulate and elevate to domain-level failure
            $this->logger->error(
                message: 'Failed to truncate table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to truncate table.', type: 'error');

            return false;
        }
    }

    /**
     * Checks whether a given database exists in the current RDBMS instance.
     *
     * Queries the `information_schema.SCHEMATA` view to determine if the specified
     * database schema is present. This method is essential for conditional migrations,
     * onboarding flows, or database provisioning orchestration.
     *
     * @param non-empty-string $database The name of the database schema to check
     *
     * @return bool True if the schema exists, false otherwise
     * @throws \Random\RandomException
     */
    public function databaseExists(string $database) : bool
    {
        // 🧱 Defensive contract enforcement
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to check database existence with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database existence: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // 📦 Query the information schema for the presence of the schema name
            return $this->queryBuilder
                ->table(tableName: 'information_schema.SCHEMATA')
                ->where(column: 'SCHEMA_NAME', value: $database)
                ->exists();
        } catch (QueryBuilderException $e) {
            // 🪵 Log error for observability and diagnostics
            $this->logger->error(
                message: 'Failed to check database existence.',
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to check database existence.', type: 'error');

            return false;
        }
    }

    /**
     * Creates a new database schema if it does not already exist.
     *
     * This method is typically used during bootstrap, provisioning, or deployment flows.
     * It ensures explicit schema creation with high observability and proper fault isolation.
     *
     * @param non-empty-string $database The name of the schema to be created
     *
     * @throws MigrationException If database creation fails
     */
    public function createDatabase(string $database) : bool
    {
        // 🧱 Domain precondition: avoid invalid names
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to create database with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot create database: database name is empty.');

            return false;
        }

        try {
            // 🛠 Execute database creation command via query builder abstraction
            $this->queryBuilder->createDatabase(database: $database);

            // 🧾 Log the successful creation event for observability
            $this->logger->info(
                message: 'Database schema successfully created.',
                context: ['database' => $database]
            );

            $this->output(message: 'Database schema successfully created.');

            return true;
        } catch (Throwable $e) {
            // 🔥 Wrap infrastructure failure in domain-specific exception
            $this->logger->warning(
                message: "Failed to create database '{$database}'",
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to create database.', type: 'error');

            return false;
        }
    }

    /**
     * Verifies database connectivity by attempting to select the given schema.
     *
     * This check is used for liveness/readiness probes, orchestration health checks,
     * and resilience features that depend on connection status with minimal overhead.
     *
     * @param non-empty-string $database The name of the database schema to check connectivity for
     *
     * @return bool True if the connection is healthy, false otherwise
     * @throws \Random\RandomException
     */
    public function isConnectionHealthy(string $database) : bool
    {
        // 🧱 Guard clause: avoid checking unnamed schemas
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Health check failed — database name was empty.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database connectivity: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🧪 Attempt to switch to target schema
            $this->queryBuilder->useDatabase(database: $database);

            // ✅ If successful, consider the connection healthy
            $this->output(message: 'Database connectivity check successful.');

            return true;
        } catch (QueryBuilderException $e) {
            // ❌ Connection or database switch failed — log failure
            $this->logger->error(
                message: 'Database connectivity check failed.',
                context: ['database' => $database, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Database connectivity check failed.', type: 'error');

            return false;
        }
    }
}

=== Database/Migration/Runner/Service/MigrationExecution.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class MigrationExecution
 *
 * Provides CRUD operations for database migrations with transactional safety and structured logging.
 * Uses a QueryBuilder abstraction to manage migration records efficiently.
 */
class MigrationExecution implements MigrationRepositoryInterface
{
    /**
     * The default table name used for storing migration data.
     */
    private const string TABLE_MIGRATIONS = 'migrations';

    /**
     * The default date and time format used for formatting and parsing dates.
     */
    private const string DATE_FORMAT = 'Y-m-d H:i:s';

    /**
     * Constructor to initialize the class with required dependencies.
     *
     * @param QueryBuilder         $queryBuilder The query builder instance for database interactions.
     * @param LoggerInterface|null $logger       Optional logger instance for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private readonly QueryBuilder    $queryBuilder,
        private readonly LoggerInterface $logger
    ) {}

    /**
     * Persists a new migration record into the database.
     *
     * @param string $migration  Name of the migration file or class.
     * @param string $executable Raw SQL or migration command executed.
     * @param int    $batch      Batch number that this migration belongs to.
     *
     * @throws InvalidArgumentException When the input is invalid.
     * @throws Throwable When the insert operation fails.
     */
    public function save(string $migration, string $executable, int $batch) : void
    {
        // Validate that both the migration name and executable are not empty.
        if (empty($migration) || empty($executable)) {
            throw new InvalidArgumentException(message: "Migration name and executable cannot be empty.");
        }

        // Validate that the batch ID is greater than 0.
        if ($batch < 1) {
            throw new InvalidArgumentException(message: "Batch ID must be greater than 0.");
        }

        // Generate the current timestamp in the defined DATE_FORMAT ('Y-m-d H:i:s').
        $timestamp = (new DateTimeImmutable())->format(format: self::DATE_FORMAT);

        // Save the migration record using a database transaction to ensure atomicity.
        $this->queryBuilder->transaction(operations: function () use ($migration, $executable, $batch, $timestamp) {
            // Specify the target database table and insert the migration data.
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS) // Set the target table to 'migrations'.
                ->insert(
                    parameters: [
                                    'migration'   => $migration,    // Name of the migration file or class.
                                    'executable'  => $executable,  // The executed SQL or migration command.
                                    'batch'       => $batch,       // Grouping number for the migration (batch).
                                    'executed_at' => $timestamp,   // Timestamp of when the migration was saved.
                                ]
                )
                ->flush(); // Commit the database operation immediately.
        });

        // Log an informational message about the saved migration if a logger is available.
        $this->logger->info(message: "Saved migration '{$migration}' in batch {$batch}.");
    }

    /**
     * Checks whether a given migration exists in the database.
     *
     * @param string $migration Name of the migration to check.
     *
     * @return bool True if migration exists, false otherwise.
     *
     * @throws Throwable If the query fails.
     */
    public function has(string $migration) : bool
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'migration', value: $migration)
            ->exists();
    }

    /**
     * Retrieves all migration records.
     *
     * @return array List of all migrations in associative array format.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getAll() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select('migration', 'executable', 'batch', 'executed_at')
            ->get()
            ->toArray();
    }

    /**
     * Retrieves all migrations associated with a specific batch.
     *
     * @param int $batch The batch number to filter migrations.
     *
     * @return array Migrations belonging to the given batch.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getMigrationsByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->get()
            ->toArray();
    }

    /**
     * Fetches the most recent batch number from the migrations table.
     *
     * @return int Latest batch number, or 0 if no migrations exist.
     *
     * @throws Throwable If the query fails.
     */
    public function getLatestBatch() : int
    {
        $result = $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select(columns: 'MAX(batch) AS batch')
            ->get()
            ->first(key: 'batch');

        return $result !== null ? (int) $result : 0;
    }

    /**
     * Removes all migration records using the built-in truncate method.
     *
     * @throws Throwable If the truncate operation fails.
     */
    public function dropAllMigrations() : void
    {
        $this->queryBuilder->transaction(operations: function () {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->truncate()
                ->flush();
        });

        $this->logger->info(message: "Dropped all migration records.");
    }

    /**
     * Returns all pending migrations (executed_at is NULL).
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function allPending() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->whereNull(column: 'executed_at')
            ->orderBy(column: 'id', direction: 'asc')
            ->get()
            ->toArray();
    }

    /**
     * Deletes all migrations in the given batch.
     *
     * @param int $batch
     *
     * @throws \Exception
     */
    public function removeByBatch(int $batch) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($batch) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'batch', value: $batch)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "🗑 Removed all migrations in batch {$batch}.");
    }

    /**
     * Removes a specific migration record from the database.
     *
     * @param string $migration Name of the migration to delete.
     *
     * @throws Throwable If deletion fails.
     */
    public function delete(string $migration) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($migration) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'migration', value: $migration)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "Deleted migration '{$migration}'.");
    }

    /**
     * Finds all migrations for a specific batch in reverse order (for rollback).
     *
     * @param int $batch
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Random\RandomException
     */
    public function findByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->orderBy(column: 'id', direction: 'desc')
            ->get()
            ->toArray();
    }

}

=== Database/Migration/Runner/Service/MigrationStateManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Manages the lifecycle of migrations, including execution, rollback, refresh, and fresh operations.
 */
final readonly class MigrationStateManager
{
    public function __construct(
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface|null         $logger = null
    ) {}

    /**
     * Refresh migrations by rolling back all and reapplying them.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If the refresh process fails.
     */
    public function refresh(array $availableMigrations) : void
    {
        try {
            $this->rollbackAll();
            $this->migrate(availableMigrations: $availableMigrations);
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to refresh migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback all migrations batch by batch.
     *
     * @throws MigrationException If rolling back migrations fails.
     */
    public function rollbackAll() : void
    {
        try {
            while ($batch = $this->migrationRepository->getLatestBatch()) {
                $this->rollbackBatch(batch: $batch);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : 'Failed to rollback all migrations: ' . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a specific batch of migrations.
     *
     * @param int $batch Batch ID to rollback.
     *
     * @throws MigrationException If rolling back the batch fails.
     */
    public function rollbackBatch(int $batch) : void
    {
        try {
            foreach ($this->migrationRepository->getMigrationsByBatch(batch: $batch) as $migration) {
                $this->rollbackMigration(migration: $migration['migration']);
                $this->migrationRepository->delete(migration: $migration['migration']);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to rollback batch " . $batch . ": " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If rolling back the migration fails.
     */
    private function rollbackMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: sprintf("Migration class '%s' not found.", $fullNamespace));
            }

            $instance = app($fullNamespace);
            if (! $instance instanceof Migration) {
                throw new MigrationException(
                    message: sprintf("Migration '%s' must extend the base Migration class.", $fullNamespace)
                );
            }

            $instance->executeDown();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : sprintf("Failed to rollback migration '%s': %s", $migration, $throwable->getMessage()),
                previous: $throwable
            );
        }
    }

    /**
     * Resolves the full namespace of the migration class.
     *
     * @param string $className The migration class name.
     *
     * @return string Fully qualified namespace of the class.
     */
    private function resolveFullNamespace(string $className) : string
    {
        $availableNamespaces = config(key: 'app.namespaces.Migrations', default: []);

        $fullNamespace = rtrim((string) $availableNamespaces, '\\') . '\\' . ltrim($className, '\\');
        if (class_exists($fullNamespace)) {
            $this->logInfo('Resolved migration namespace: ' . $fullNamespace);

            return $fullNamespace;
        }

        throw new MigrationException(message: sprintf("Unable to resolve namespace for class: '%s'.", $className));
    }

    /**
     * Log an informational message.
     *
     * @param string $message The message to log.
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Migrate all pending migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If applying migrations fails.
     */
    public function migrate(array $availableMigrations) : void
    {
        try {
            $pending = $this->getPendingMigrations(availableMigrations: $availableMigrations);

            if ($pending === []) {
                $this->logInfo(message: "No migrations to execute.");

                return;
            }

            $batchId = $this->migrationRepository->getLatestBatch() + 1;

            foreach ($pending as $migration) {
                $this->runMigration(migration: $migration);
                $this->migrationRepository->save(
                    migration : $migration,
                    executable: $this->resolveFullNamespace($migration),
                    batch     : $batchId
                );
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to execute migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Get pending migrations by comparing available with executed migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @return array List of pending migrations.
     */
    private function getPendingMigrations(array $availableMigrations) : array
    {
        $executed = array_column($this->migrationRepository->getAll(), 'migration');

        return array_diff($availableMigrations, $executed);
    }

    /**
     * Run a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If applying the migration fails.
     */
    private function runMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: "Migration class '" . $fullNamespace . "' not found.");
            }

            $instance = app($fullNamespace);

            if (! $instance instanceof Migration) {
                $this->logInfo(message: "Skipping non-migration class '" . $fullNamespace . "'.");

                return;
            }

            $instance->executeUp();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to run migration '" . $migration . "': " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}

=== Database/Migration/Runner/Stubs/anonymous-migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Anonymous database migration.
 *
 * This migration is responsible for applying and rolling back schema changes
 * within the database context, using an immutable, declarative approach.
 *
 * @package {{Namespace}}
 * @readonly Guarantees immutability of the migration object
 * @version 1.0.0
 * @since PHP 8.3
 */
return new readonly class extends Migration
{
    /**
     * Perform the forward (up) migration.
     *
     * This method creates the database structure using the SchemaBuilder DSL,
     * applying all field definitions provided during migration generation.
     *
     * @return void
     *
     * @throws MigrationException If the schema creation process encounters an error
     */
    protected function up(): void
    {
        // Create a new database table dynamically defined during migration generation
        $this->schemaBuilder->create(
            table: '{{TableName}}',
            callback: function (Table $table): void {
                // Apply dynamically generated field definitions
                {{Fields}}

                // Add default created_at and updated_at timestamp columns
                $table->timestamps();
            }
        );

        // Output success message after schema creation
        $this->schemaBuilder->output(message: "🏗️ Migration executed: Table '{{TableName}}' created successfully.");
    }

    /**
     * Perform the rollback (down) migration.
     *
     * This method drops the previously created database table, reverting
     * the schema to its prior state before this migration execution.
     *
     * @return void
     *
     * @throws MigrationException If the schema rollback process encounters an error
     */
    protected function down(): void
    {
        // Drop the database table associated with this migration
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Output success message after table deletion
        $this->schemaBuilder->output(message: "🗑️ Migration rollback executed: Table '{{TableName}}' dropped successfully.");
    }
};

=== Database/Migration/Runner/Stubs/controller.stub ===
<?php

declare(strict_types=1);

namespace {{namespace}};

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * {{ControllerName}} Controller
 *
 * RESTful Controller for managing resources.
 */
class {{ControllerName}}
{
    /**
     * Display a listing of the resource.
     *
     * @return ResponseInterface
     */
    public function index(): ResponseInterface
    {
        // Fetch all resources (dummy example data)
        $data = [
            ['id' => 1, 'name' => 'Resource 1'],
            ['id' => 2, 'name' => 'Resource 2'],
        ];

        // Return Blade view with data
        return view('resources.index', compact('data'));
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return ResponseInterface
     */
    public function create(): ResponseInterface
    {
        // Return Blade view for the create form
        return view('resources.create');
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param ServerRequestInterface $request
     * @return ResponseInterface
     */
    public function store(ServerRequestInterface $request): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Store the resource (dummy logic)
        // Example: Save to database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource created successfully.');
    }

    /**
     * Display the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function show(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view with resource data
        return view('resources.show', compact('resource'));
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function edit(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view for the edit form
        return view('resources.edit', compact('resource'));
    }

    /**
     * Update the specified resource in storage.
     *
     * @param ServerRequestInterface $request
     * @param int $id
     * @return ResponseInterface
     */
    public function update(ServerRequestInterface $request, int $id): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Update the resource (dummy logic)
        // Example: Update in database

        // Redirect to show page with success message
        return response(302, ['Location' => route('resources.show', ['id' => $id])])
            ->withHeader('X-Message', 'Resource updated successfully.');
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function destroy(int $id): ResponseInterface
    {
        // Delete the resource (dummy logic)
        // Example: Remove from database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource deleted successfully.');
    }
}

=== Database/Migration/Runner/Stubs/dto.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Data Transfer Object for {{DTOName}}.
 */
final class {{DTOName}} extends AbstractDTO
{
{{Properties}}

}

=== Database/Migration/Runner/Stubs/entity-querybuilder.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;

/**
 * Entity class with QueryBuilder integration for {{EntityName}}.
 */
class {{EntityName}} extends QueryBuilder
{
    /**
     * Table name associated with the entity.
     */
    protected string $tableName = '{{TableName}}';

{{QueryMethods}}
}

=== Database/Migration/Runner/Stubs/entity.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

/**
 * Entity class for {{EntityName}}.
 */
class {{EntityName}}
{
{{Properties}}

    {{Constructor}}

{{Methods}}
}

=== Database/Migration/Runner/Stubs/migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Database Migration Implementation for {{TableName}} Entity.
 *
 * This class represents a concrete database migration strategy implementing the schema
 * modifications for the {{TableName}} bounded context. It follows immutable design
 * principles and provides declarative schema definitions.
 *
 * @package {{Namespace}}
 * @final This class is not designed for inheritance
 * @readonly Ensures immutability of the migration definition
 * @version 1.0.0
 * @since PHP 8.3
 *
 * @template-implements Migration
 */
final readonly class {{MigrationName}} extends Migration
{
    /**
     * Executes the forward migration operation.
     *
     * Implements the schema creation logic using a fluent DSL pattern.
     * Creates the {{TableName}} table with defined columns and constraints.
     *
     * @return void
     * @throws MigrationException When schema creation fails
     *
     * @api
     */
    protected function up(): void
    {
        // Instantiate schema creation using fluent builder pattern
        $this->schemaBuilder->create(
            table: '{{TableName}}', // Named argument for better code clarity
            callback: function (Table $table): void {
                {{Fields}}

                // Adds standardized timestamp columns for entity lifecycle tracking
                $table->timestamps();
            }
        );

        // Provide feedback for migration execution monitoring
        $this->schemaBuilder->output("🏗️ Table '{{TableName}}' created successfully.");
    }

    /**
     * Executes the rollback migration operation.
     *
     * Implements the schema rollback logic by removing the {{TableName}} table
     * and all its associated constraints and indexes.
     *
     * @return void
     * @throws MigrationException When schema rollback fails
     *
     * @api
     */
    protected function down(): void
    {
        // Execute table removal using schema builder
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Provide feedback for rollback execution monitoring
       $this->schemaBuilder->output("🗑️ Table '{{TableName}}' dropped successfully.");
    }
}

=== Database/Migration/Runner/Stubs/repository.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;
use {{EntityNamespace}}\{{EntityName}};

/**
 * Repository for {{RepositoryName}}.
 */
final class {{RepositoryName}}
{
    public function __construct(private QueryBuilder $queryBuilder) {}

    public function find(int $id): ?{{EntityName}}
    {
        $result = $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->first();

        return $result ? $this->mapToEntity($result) : null;
    }

    public function save({{EntityName}} $entity): int
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->insertGetId($entity->toArray());
    }

    public function update(int $id, {{EntityName}} $entity): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->update($entity->toArray());
    }

    public function delete(int $id): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->delete();
    }

    private function mapToEntity(array $data): {{EntityName}}
    {
        return new {{EntityName}}($data);
    }
}

=== Database/Migration/Runner/Stubs/service.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Psr\Log\LoggerInterface;

/**
 * Service for {{ServiceName}}.
 */
final class {{ServiceName}}
{
    public function __construct(private LoggerInterface $logger) {}

    public function execute(array $input): array
    {
        $this->logger->info("Executing service logic for {{ServiceName}}.", ['input' => $input]);

        try {
            return $this->processLogic($input);
        } catch (\Throwable $exception) {
            $this->logger->error("Execution failed for {{ServiceName}}.", ['error' => $exception->getMessage()]);
            throw new \RuntimeException("Failed to execute service logic.", 0, $exception);
        }
    }

    private function processLogic(array $input): array
    {
        return ['status' => 'success', 'processed_data' => $input];
    }
}

=== Database/Migration/Runner/Stubs/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Stubs;

use Gemini\Gemini;
use RuntimeException;

/**
 * Resolves and loads stub files for generators.
 */
final readonly class StubResolver
{
    /**
     * Path to stub files in the framework for migrations.
     */
    private string $defaultStubPath;

    public function __construct()
    {
        // Use the Gemini enum to dynamically resolve the default stub path.
        $this->defaultStubPath = Gemini::MIGRATIONS->resolve() . 'stubs/';
    }

    /**
     * Resolves a stub file by its name.
     *
     * @param string $stubName Name of the stub file.
     *
     * @return string Content of the stub file.
     */
    public function resolve(string $stubName) : string
    {
        $filePath = $this->defaultStubPath . $stubName;

        if (! file_exists($filePath)) {
            throw new RuntimeException(message: 'Stub file not found: ' . $filePath);
        }

        return file_get_contents($filePath);
    }
}

=== Database/QueryBuilder/BaseQueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Gemini\Database\DatabaseConnection;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\Traits\BaseQueryBuilderTrait;
use InvalidArgumentException;
use PDO;
use Psr\Log\LoggerInterface;

/**
 * **BaseQueryBuilder**
 *
 * A **robust and extendable** base class for query builders, handling:
 * - 🔌 **Database connection management**
 * - 🏗 **Unit of Work for transactional operations**
 * - 📌 **Table name handling**
 * - ♻ **Reusable query logic for child classes**
 *
 * ### **Key Features**
 * - ✅ Centralized database connection logic.
 * - ✅ Ensures consistency across different query builders.
 * - ✅ Provides a **foundation** for extending advanced query-building capabilities.
 *
 * 🏗 **Design Principles:**
 * - **Separation of Concerns (SoC)** → Keeps query execution separate from the logic that builds queries.
 * - **Extensibility** → Child classes (e.g., `QueryBuilder`) can extend this for additional functionality.
 * - **Reusability** → Common logic (transactions, caching, joins, etc.) lives here.
 *
 * 🚀 **Usage Example:**
 * ```
 * class QueryBuilder extends BaseQueryBuilder
 * {
 *     // Custom query logic specific to QueryBuilder
 * }
 * ```
 */
abstract class BaseQueryBuilder
{
    use BaseQueryBuilderTrait;

    /**
     * The table name for the query.
     */
    protected string|null $tableName = null;

    /**
     * Initializes the query builder with a database connection, unit of work, and logger.
     */
    public function __construct(
        public readonly DatabaseConnection $databaseConnection,
        public readonly UnitOfWork         $unitOfWork,
        public readonly LoggerInterface    $logger
    ) {}

    /**
     * Retrieves the table name for the query.
     *
     * @throws QueryBuilderException If the table name is not set.
     */
    public function getTableName() : string
    {
        return $this->tableName ?? throw new QueryBuilderException(message: 'Table name is not set.');
    }

    /**
     * Sets the table name for the query.
     *
     * @throws QueryBuilderException If the table name is empty or invalid.
     */
    public function table(string $tableName) : static
    {
        // Trim any leading or trailing whitespace from the `$tableName` value.
        $tableName = trim($tableName);

        // Validate the table name format (OWASP Recommendation ✅)
        if ($tableName === '' || ! preg_match('/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?$/', $tableName)) {
            throw new QueryBuilderException(message: 'Invalid table name format.');
        }

        $this->tableName = $tableName;

        return $this;
    }

    /**
     * Quotes a table or column name safely.
     *
     * The provided code first checks if the identifier (`$name`) is already wrapped with the given quoting character
     * (`$quoteChar`) at both the start and end; if so, the identifier is returned as-is. If not, it sanitizes the
     * identifier by stripping away characters that are not letters, digits, underscores, dollar signs, dots, or
     * Unicode characters in the allowed range, ensuring only valid characters remain. If the sanitized result is
     * empty, it throws an exception indicating the identifier is invalid or empty. Finally, it returns the sanitized
     * identifier wrapped with the specified quoting character, ensuring the identifier is securely escaped for use,
     * such as in SQL queries.
     */
    protected function quoteIdentifier(string $name) : string
    {
        // Validate the column name to ensure it contains only safe characters (a-z, A-Z, 0-9, _).
        $this->validateColumnName(name: $name);

        // Retrieve the database driver's name (e.g., mysql, pgsql, sqlite) from the active connection.
        $driver = $this->getConnection()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);

        // Determine the proper quoting characters based on the database driver.
        $quoteChars = match ($driver) {
            // PostgreSQL and SQLite use double quotes for identifiers.
            'pgsql', 'sqlite' => ['"', '"'],
            // MySQL uses backticks for identifiers.
            'mysql'           => ['`', '`'],
            // SQL Server uses square brackets for identifiers.
            'sqlsrv'          => ['[', ']'],
            // Default fallback to double quotes if the driver is unknown.
            default           => ['"', '"'],
        };

        // Destructure the opening and closing quote characters from the determined array.
        [$openQuote, $closeQuote] = $quoteChars;

        // Split the column name by dots (.) to handle cases like schema.table or table.column.
        $parts = explode('.', $name);

        // Quote and sanitize each part of the split name (e.g., schema or table names).
        $quotedParts = array_map(static function ($part) use ($openQuote, $closeQuote) {
            // If the part is already properly quoted with the correct opening and closing quotes, leave it unchanged.
            if (
                str_starts_with($part, $openQuote)
                && str_ends_with($part, $closeQuote)
            ) {
                return $part;
            }

            // Sanitize the part, allowing only alphanumeric characters, underscores, and multibyte characters.
            $sanitized = preg_replace('/[^a-zA-Z0-9_$\x80-\xFF]/u', '', $part);
            // Validate that the sanitized part is not empty after cleaning.
            if (empty($sanitized)) {
                throw new InvalidArgumentException(message: "Invalid identifier segment: '$part'");
            }

            // Return the properly quoted and sanitized identifier part.
            return $openQuote . $sanitized . $closeQuote;
        }, $parts);

        // Combine the quoted and sanitized parts back into a single string separated by dots (schema.table format).
        return implode('.', $quotedParts);
    }

    /**
     * Validates a column name to prevent SQL injection.
     */
    protected function validateColumnName(string $name) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $name)) {
            throw new InvalidArgumentException(message: "Invalid column name: {$name}");
        }
    }

    /**
     * Retrieves the active database connection.
     */
    public function getConnection() : PDO
    {
        return $this->databaseConnection->getConnection();
    }
}

=== Database/QueryBuilder/Enums/QueryBuilderEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Enums;

/**
 * Enumeration of query builder types and supported database drivers.
 *
 * Technical Description:
 * - Defines constants for different types of query operations.
 * - Includes supported database drivers.
 * - Provides utility methods for validation and retrieval of all available types.
 *
 * Business Description:
 * - Ensures consistency in query type definitions across the application.
 * - Prevents errors by validating query types and database drivers.
 */
enum QueryBuilderEnum: string
{
    /** Query Types */
    case QUERY_TYPE_SELECT         = 'SELECT';

    case QUERY_TYPE_INSERT         = 'INSERT';

    case QUERY_TYPE_UPDATE         = 'UPDATE';

    case QUERY_TYPE_DELETE         = 'DELETE';

    case QUERY_TYPE_UPSERT         = 'UPSERT';

    case QUERY_TYPE_SOFT_DELETE    = 'SOFT DELETE';

    case QUERY_TYPE_RESTORE        = 'RESTORE';

    case QUERY_TYPE_TRUNCATE       = 'TRUNCATE';

    case QUERY_TYPE_CASCADE_DELETE = 'CASCADE DELETE';

    case QUERY_TYPE_DELETE_JOIN    = 'DELETE JOIN';

    /** Database Drivers */
    case DRIVER_MYSQL  = 'mysql';

    case DRIVER_PGSQL  = 'pgsql';

    case DRIVER_SQLITE = 'sqlite';

    case DRIVER_MSSQL  = 'sqlsrv';

    case DRIVER_ORACLE = 'oci';

    /**
     * Checks if the provided string is a valid query type.
     *
     * @param string $queryType The query type to validate.
     *
     * @return bool Returns true if the provided query type is valid; otherwise, false.
     */
    public static function isValidQueryType(string $queryType) : bool
    {
        return in_array(strtoupper($queryType), self::queryTypes(), true);
    }

    /**
     * Returns all possible query types as an array of strings.
     *
     * @return array An array containing all query types as strings.
     */
    public static function queryTypes() : array
    {
        return [
            self::QUERY_TYPE_SELECT->value,
            self::QUERY_TYPE_INSERT->value,
            self::QUERY_TYPE_UPDATE->value,
            self::QUERY_TYPE_DELETE->value,
            self::QUERY_TYPE_UPSERT->value,
            self::QUERY_TYPE_SOFT_DELETE->value,
            self::QUERY_TYPE_RESTORE->value,
            self::QUERY_TYPE_TRUNCATE->value,
            self::QUERY_TYPE_CASCADE_DELETE->value,
            self::QUERY_TYPE_DELETE_JOIN->value,
        ];
    }

    /**
     * Checks if the provided string is a valid database driver.
     *
     * @param string $driver The database driver to validate.
     *
     * @return bool Returns true if the provided driver is valid; otherwise, false.
     */
    public static function isValidDriver(string $driver) : bool
    {
        return in_array(strtolower($driver), self::drivers(), true);
    }

    /**
     * Returns all possible database drivers as an array of strings.
     *
     * @return array An array containing all supported database drivers.
     */
    public static function drivers() : array
    {
        return [
            self::DRIVER_MYSQL->value,
            self::DRIVER_PGSQL->value,
            self::DRIVER_SQLITE->value,
            self::DRIVER_MSSQL->value,
            self::DRIVER_ORACLE->value,
        ];
    }
}

=== Database/QueryBuilder/Exception/QueryBuilderException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Exception;

use Exception;
use Throwable;

class QueryBuilderException extends Exception
{
    public function __construct(
        string         $message = "",
        int            $code = 500,
        Throwable|null $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }
}
=== Database/QueryBuilder/QueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\Traits\InsertUpdateTrait;
use Gemini\Database\QueryBuilder\Traits\JoinClauseBuilderTrait;
use Gemini\Database\QueryBuilder\Traits\OrderByAndGroupByBuilderTrait;
use Gemini\Database\QueryBuilder\Traits\SelectQueryTrait;
use Gemini\Database\QueryBuilder\Traits\SoftDeleteAndDeleteTrait;
use Gemini\Database\QueryBuilder\Traits\WhereTrait;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use PDO;
use PDOException;
use PDOStatement;

/**
 * **QueryBuilder**
 *
 * A **robust and flexible SQL query builder** providing a fluent interface for constructing
 * and executing SQL queries dynamically.
 *
 * ✅ **Key Features**
 * - **Fluent API** → Allows chaining of query methods.
 * - **Fully Prepared Queries** → Prevents SQL injection.
 * - **Supports Transactions** → Uses **Unit of Work**.
 * - **Advanced Query Optimization** → Caching, indexing recommendations.
 * - **Comprehensive SQL Support** → SELECT, INSERT, UPDATE, DELETE, JOINs, WHERE, GROUP BY, ORDER BY, etc.
 *
 * 🚀 **Usage Example**
 * ```
 * $users = $queryBuilder->table('users')
 *     ->where('status', 'active')
 *     ->orderBy('created_at', 'DESC')
 *     ->limit(10)
 *     ->get();
 * ```
 */
class QueryBuilder extends BaseQueryBuilder
{
    use SelectQueryTrait;
    use InsertUpdateTrait;
    use SoftDeleteAndDeleteTrait;
    use WhereTrait;
    use JoinClauseBuilderTrait;
    use OrderByAndGroupByBuilderTrait;

    /**
     * Sets the LIMIT value for the SELECT query.
     *
     * @param int $limit Maximum number of rows to retrieve.
     *
     * @return static
     *
     * @throws QueryBuilderException
     */
    public function limit(int $limit) : static
    {
        if ($limit < 0) {
            throw new QueryBuilderException(message: 'Limit must be a non-negative integer.');
        }

        $this->limit = $limit;

        return $this;
    }

    /**
     * Sets the OFFSET value for the SELECT query.
     *
     * @param int $offset Number of rows to skip.
     *
     * @return static
     *
     * @throws QueryBuilderException
     */
    public function offset(int $offset) : static
    {
        if ($offset < 0) {
            throw new QueryBuilderException(message: 'Offset must be a non-negative integer.');
        }

        $this->offset = $offset;

        return $this;
    }

    /**
     * Registers a query for **deferred execution** using Unit of Work.
     *
     * ✅ **Best Practices**
     * - **Batch Queries** → Reduces database calls.
     * - **Ensures Atomicity** → All queries execute in **one transaction**.
     *
     * @param QueryBuilderEnum $operation  The type of query operation.
     * @param PDOStatement     $statement  The prepared statement.
     * @param array            $parameters Query parameters.
     *
     * @return static Returns the current instance.
     */
    public function registerQueryInUnitOfWork(
        QueryBuilderEnum $operation,
        PDOStatement     $statement,
        PDO              $pdo,
        array            $parameters = []
    ) : static {
        $this
            ->getUnitOfWork()
            ->registerQuery(
                operation : $operation,
                statement : $statement,
                pdo       : $pdo,
                parameters: $parameters,
            );

        return $this;
    }


    /**
     * Executes all **deferred queries** stored in the Unit of Work.
     *
     * ✅ **Why This?**
     * - **Batch execution for better performance**.
     * - **Ensures ACID compliance** (All-or-Nothing Transactions).
     *
     * @return Arrhae The results of executed queries.
     *
     * @throws QueryBuilderException If the transaction fails.
     */
    public function flush() : Arrhae
    {
        return $this->getUnitOfWork()->flush();
    }

    /**
     * Enables **DISTINCT** in queries.
     *
     * ✅ **Why?**
     * - Ensures that only **unique** results are returned.
     *
     * @return static Returns the current instance.
     */
    public function distinct() : static
    {
        $this->distinct = true;

        return $this;
    }

    /**
     * Switches the query to use the **read** database connection.
     *
     * ✅ **Why?**
     * - **Optimized for Performance** → **Read operations** should not use the **write connection**.
     *
     * @return static Returns the current instance.
     */
    public function useReadConnection() : static
    {
        $this->useReadConnection = true;

        return $this;
    }

    /**
     * Checks if a record exists in the database.
     *
     * ✅ **Why?**
     * - **Efficient Existence Check** → Uses `LIMIT 1` for **fast lookups**.
     *
     * @return bool Returns `true` if the record exists, otherwise `false`.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function exists() : bool
    {
        try {
            $stmt = $this->getConnection()->prepare(query: $this->buildSelectQuery() . ' LIMIT 1');
            $stmt->execute(params: $this->getParameters());

            return (bool) $stmt->fetch(mode: PDO::FETCH_ASSOC);
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Failed to check if record exists: " . $exception->getMessage()
            );
        }
    }

    /**
     * Executes the current query.
     *
     * ✅ **Why This Approach?**
     * - **Ensures Safe Execution** → Always uses **prepared statements**.
     * - **Centralized Query Execution** → All query execution **happens here**.
     *
     * @return array The query results.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function execute() : array
    {
        // Dynamically build the SQL query
        $query = $this->buildSelectQuery();

        // Get a PDO connection
        $pdo = $this->getConnection();

        // Prepare the statement (Prevents SQL Injection ✅)
        $stmt = $pdo->prepare(query: $query);

        try {
            // Execute with bound parameters
            $stmt->execute($this->getParameters());
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message : "Query execution failed: " . $exception->getMessage(),
                previous: $exception
            );
        }

        return $stmt->fetchAll(mode: PDO::FETCH_ASSOC);
    }

    /**
     * Retrieves the first result from the query execution.
     *
     * This method is useful for retrieving a single record from the database without iterating
     * over the entire result set. It supports extracting specific columns using **dot notation**
     * or applying a **callback function** to the first item.
     *
     * 🔥 **Key Features:**
     * - **Retrieves a single record** → Returns the first row from the result set.
     * - **Supports dot notation (`.`)** → Fetch nested values like `'address.city'`.
     * - **Supports Closure transformation** → Modify the result dynamically.
     * - **Returns a default value** → If no record is found, fallback to a default.
     *
     * ---
     * ✅ **Basic Usage**
     * ```
     * $user = QueryBuilder::table('users')->where('status', 'active')->first();
     * echo $user['name']; // Outputs: "John Doe"
     * ```
     *
     * ---
     * ✅ **Extracting a Single Column**
     * ```
     * $email = QueryBuilder::table('users')->first('email', 'No email found');
     * echo $email; // Outputs: "user@example.com"
     * ```
     *
     * ---
     * ✅ **Using Dot Notation for Nested Values**
     * ```
     * $city = QueryBuilder::table('users')->first('address.city', 'Unknown');
     * echo $city; // Outputs: "New York"
     * ```
     *
     * ---
     * ✅ **Applying a Callback Function**
     * ```
     * $userName = QueryBuilder::table('users')->first(fn($user) => strtoupper($user['name']));
     * echo $userName; // Outputs: "JOHN DOE"
     * ```
     *
     * ---
     * ✅ **Handling Empty Results Gracefully**
     * ```
     * $user = QueryBuilder::table('users')->where('id', 9999)->first();
     * if (!$user) {
     *     echo "User not found.";
     * }
     * ```
     *
     * ---
     * ✅ **Combining `first()` with `get()` for More Flexibility**
     * ```
     * $users = QueryBuilder::table('users')->where('status', 'active')->get();
     *
     * if (!$users->isEmpty()) {
     *     echo "First active user: " . $users->first('name');
     * } else {
     *     echo "No active users found.";
     * }
     * ```
     *
     * ---
     * @param string|int|Closure|null $key      Optional. The key to extract using **dot notation** or a **Closure**.
     *                                          If `null`, returns the entire first row.
     * @param mixed                   $default  The default value to return if the key does not exist or no record is
     *                                          found.
     *
     * @return mixed The **first record**, the **extracted key's value**, the **result of a Closure**, or `$default` if
     *               empty.
     */
    public function first() : ?array
    {
        // Ensure the query fetches only one result
        $this->limit = 1;

        // Execute the query and retrieve results
        $results = $this->get();

        // Return the first record, or `null` if none found
        return $results->isEmpty() ? null : $results->first();
    }


    /**
     * Drops the specified table if it exists.
     *
     * ✅ **Why?**
     * - **Safe Drop** → Prevents errors if the table doesn't exist.
     *
     * @return static Returns the current instance.
     *
     * @throws QueryBuilderException If the table name is missing.
     */
    public function drop() : static
    {
        if (! isset($this->tableName)) {
            throw new QueryBuilderException(message: "Table name is required to drop a table.");
        }

        return $this->raw(sql: "DROP TABLE IF EXISTS `{$this->tableName}`");
    }

    /**
     * Executes a raw SQL query **with parameter binding**.
     *
     * ✅ **Why?**
     * - **Safe Execution** → Always **prepared & parameterized**.
     *
     * @param string $sql        The raw SQL query.
     * @param array  $parameters Query parameters.
     *
     * @return static Returns the current instance.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function raw(string $sql, array $parameters = []) : static
    {
        try {
            $stmt = $this->getConnection()->prepare(query: $sql);
            $stmt->execute(params: $parameters);

            return $this;
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Failed to execute raw query: " . $exception->getMessage()
            );
        }
    }

    /**
     * Specifies the columns to be selected in the query.
     *
     * 🏆 **Key Features:**
     * - ✅ Allows dynamic selection of specific columns.
     * - ✅ Defaults to `SELECT *` if no columns are provided.
     * - ✅ Prevents SQL injection via strict column name validation.
     * - ✅ Ensures **readability & maintainability** through a fluent interface.
     *
     * 🔥 **Why This Matters?**
     * - Explicit column selection **reduces database load** and improves performance.
     * - Ensuring valid column names prevents **SQL injection** attacks.
     * - Defaults to `SELECT *` when called without arguments for flexibility.
     *
     * ---
     * 📌 **Usage Example**
     * ```
     * $users = $queryBuilder->table('users')
     *     ->select() // Defaults to SELECT *
     *     ->where('status', 'active')
     *     ->get();
     * ```
     * ---
     *
     * @param string ...$columns The column names to be retrieved from the database.
     *
     * @return static Returns the current instance to allow method chaining.
     */
    public function select(string ...$columns) : static
    {
        // 🏗 If no columns are provided, default to '*'
        $this->columns = empty($columns) ? ['*'] : $columns;

        // 🔍 Validate column names (if columns are explicitly provided)
        foreach ($this->columns as $column) {
            $this->validateColumnName(name: $column);
        }

        return $this;
    }

}

=== Database/QueryBuilder/Traits/BaseQueryBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

/**
 * **BaseQueryBuilderTrait**
 *
 * ✅ **Purpose:**
 * This trait acts as a **"Master Trait"**, grouping all essential traits required for a powerful, scalable,
 * and efficient **SQL Query Builder**.
 *
 * 🏗 **Design Goals:**
 * - Centralized management of all reusable query-related traits.
 * - Enables **modular, reusable, and maintainable** code structure.
 * - Ensures the **Single Responsibility Principle (SRP)** by keeping logic in separate traits.
 * - Provides a **clean and organized** way to extend the QueryBuilder functionality.
 *
 * 🛠 **Key Features (Grouped Traits):**
 * - **🔄 Database Transactions** → `DatabaseTransactionTrait`
 * - **📌 Identity Map Pattern** → `IdentityMapTrait`
 * - **📝 INSERT, UPDATE, UPSERT** → `InsertUpdateTrait`
 * - **🔗 JOIN Clause Handling** → `JoinClauseBuilderTrait`
 * - **📊 ORDER BY, GROUP BY, HAVING** → `OrderByAndGroupByBuilderTrait`
 * - **🧩 Unit of Work Pattern** → `ProvidesUnitOfWork`
 * - **⚡ Query Optimization & Indexing** → `QueryOptimizationTrait`
 * - **🔍 SELECT Queries, Caching & Pagination** → `SelectQueryTrait`
 * - **🗑 Soft Deletes & Data Deletion** → `SoftDeleteAndDeleteTrait`
 * - **🔎 WHERE Clause Handling** → `WhereTrait`
 *
 * 🏆 **Benefits of Using This Trait:**
 * - **Single inclusion point** for all QueryBuilder functionality.
 * - **Avoids trait conflicts** by defining method precedence (if needed).
 * - **Easier to maintain** when adding or modifying traits.
 * - **Improves testability** by ensuring well-structured, isolated functionalities.
 *
 * 🚀 **Usage Example in QueryBuilder Class:**
 * ```
 * class QueryBuilder
 * {
 *     use BaseQueryBuilderTrait;
 *
 *     // Additional QueryBuilder logic...
 * }
 * ```
 */
trait BaseQueryBuilderTrait
{
    use DatabaseTransactionTrait;
    use IdentityMapTrait;
    use InsertUpdateTrait;
    use JoinClauseBuilderTrait;
    use OrderByAndGroupByBuilderTrait;
    use ProvidesUnitOfWork;
    use QueryOptimizationTrait;
    use SelectQueryTrait;
    use SoftDeleteAndDeleteTrait;
    use WhereTrait;
    use SchemaQueryBuilderTrait;
}

=== Database/QueryBuilder/Traits/DatabaseTransactionTrait.php ===
<?php

declare(strict_types=1);

/**
 * Trait DatabaseTransactionTrait
 *
 * Provides utility methods for handling database transactions, supporting both
 * standard and nested transactions through savepoints. Ensures robust error handling
 * by rolling back appropriately in case of failures and logging transaction errors.
 *
 * Applicable to classes managing a PDO-based database connection and requiring
 * transactional operations.
 */

namespace Gemini\Database\QueryBuilder\Traits;

use Exception;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use PDO;

/**
 * Provides functionality for managing database transactions,
 * including support for nested transactions using savepoints.
 */
trait DatabaseTransactionTrait
{
    private const string SAVEPOINT_PREFIX = 'SAVEPOINT_';

    /**
     * Runs a series of database operations within a single transaction.
     *
     * Supports nested transactions using SAVEPOINTS.
     * If any operation fails, it rolls back to the last savepoint or the main transaction.
     *
     * @param callable $operations A callable that contains the operations to be performed within the transaction.
     *
     * @throws Exception If any operation fails, an exception is thrown, and the transaction is rolled back.
     */
    public function transaction(callable $operations) : void
    {
        $pdo = $this->getDatabaseConnection();
        $isNested = $pdo->inTransaction();

        if ($isNested) {
            $savepoint = $this->createSavepoint(pdo: $pdo);
        } else {
            $this->beginTransaction();
        }

        try {
            $operations(); // Execute the operations
            $isNested ? $this->releaseSavepoint(pdo: $pdo, savepoint: $savepoint) : $this->commit();
        } catch (Exception $exception) {
            $isNested ? $this->rollbackToSavepoint(pdo: $pdo, savepoint: $savepoint) : $this->rollbackTransaction();
            $this->logTransactionError(exception: $exception);
            throw $exception;
        }
    }

    /**
     * Gets the current database connection.
     */
    public function getDatabaseConnection() : PDO
    {
        return $this->databaseConnection->getConnection();
    }

    /**
     * Creates a savepoint for nested transactions.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function createSavepoint(PDO $pdo) : string
    {
        $savepoint = self::SAVEPOINT_PREFIX . uniqid();

        $quotedSavepoint = $pdo->quote(string: $savepoint);

        if ($quotedSavepoint === false) {
            throw new QueryBuilderException(message: "PDO::quote() failed to quote the savepoint name.");
        }

        $pdo->exec(statement: "SAVEPOINT " . $quotedSavepoint);

        return $savepoint;
    }


    /**
     * Begins a new transaction on the current database connection.
     * If a transaction is already active, it does nothing.
     */
    public function beginTransaction() : void
    {
        $pdo = $this->getDatabaseConnection();
        if (! $pdo->inTransaction()) {
            $pdo->beginTransaction();
        }
    }

    /**
     * Releases a savepoint for nested transactions.
     */
    private function releaseSavepoint(PDO $pdo, string $savepoint) : void
    {
        $stmt = $pdo->prepare(query: "RELEASE SAVEPOINT :savepoint");
        $stmt->execute(params: ['savepoint' => $savepoint]);
    }

    /**
     * Commits the current database transaction.
     */
    public function commit() : void
    {
        $pdo = $this->getDatabaseConnection();
        if ($pdo->inTransaction()) {
            $pdo->commit();
        }
    }

    /**
     * Rolls back to a savepoint in nested transactions.
     */
    private function rollbackToSavepoint(PDO $pdo, string $savepoint) : void
    {
        $stmt = $pdo->prepare(query: "ROLLBACK TO SAVEPOINT :savepoint");
        $stmt->execute(params: ['savepoint' => $savepoint]);
    }

    /**
     * Rolls back the current database transaction.
     */
    public function rollbackTransaction() : void
    {
        $pdo = $this->getDatabaseConnection();
        if ($pdo->inTransaction()) {
            try {
                $pdo->rollBack();
            } catch (Exception $e) {
                $this->logger->error(message: 'Rollback failed: ' . $e->getMessage());
            }
        }
    }

    /**
     * Logs transaction-related errors.
     */
    private function logTransactionError(Exception $exception) : void
    {
        $this->logger->error(
            message: 'Transaction failed: ' . $exception->getMessage(),
            context: ['exception' => $exception]
        );
    }
}
=== Database/QueryBuilder/Traits/IdentityMapTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **IdentityMapTrait**
 *
 * Implements the **Identity Map** pattern to cache and retrieve objects
 * within a single database transaction or request lifecycle.
 *
 * 🏆 **Benefits:**
 * - ✅ **Prevents redundant queries** by storing retrieved data in memory.
 * - ✅ **Ensures consistency** by always returning the same instance of an entity.
 * - ✅ **Improves performance** by reducing database hits.
 * - ✅ **Supports cache integrations** (Redis, APCu, etc.).
 */
trait IdentityMapTrait
{
    /**
     * Stores cached entities, indexed by their unique keys.
     *
     * @var array<string,|null mixed>
     */
    private readonly array|null $identityMap;

    /**
     * Adds an entity to the identity map.
     *
     * If an entity with the same key already exists, it will be **overwritten**.
     *
     * @param string $key   The unique identifier for the entity.
     * @param mixed  $value The entity data to be stored.
     */
    public function addToIdentityMap(string $key, mixed $value) : void
    {
        $this->identityMap[$key] = $value;
    }

    /**
     * Retrieves an entity from the identity map by its key.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @return mixed|null The stored entity if found, otherwise `null`.
     */
    public function getFromIdentityMap(string $key) : mixed
    {
        return $this->identityMap[$key] ?? null;
    }

    /**
     * Checks if an entity exists in the identity map.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @return bool Returns `true` if the entity exists, otherwise `false`.
     */
    public function hasInIdentityMap(string $key) : bool
    {
        return array_key_exists($key, $this->identityMap);
    }

    /**
     * Removes an entity from the identity map.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function removeFromIdentityMap(string $key) : void
    {
        if (! array_key_exists($key, $this->identityMap)) {
            throw new QueryBuilderException(message: "Cannot remove entity: Key '{$key}' not found in Identity Map.");
        }

        unset($this->identityMap[$key]);
    }

    /**
     * Clears all stored entities from the identity map.
     */
    public function clearIdentityMap() : void
    {
        $this->identityMap = [];
    }
}

=== Database/QueryBuilder/Traits/InsertUpdateTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use PDO;

/**
 * **InsertUpdateTrait**
 *
 * Provides transactional `INSERT`, `UPDATE`, `BATCH INSERT`, and `UPSERT` operations,
 * while integrating a **Unit of Work** mechanism to delay execution until explicitly flushed.
 *
 * **Security Enhancements:**
 * - 🛡️ **Prevents SQL Injection** with strict parameter binding.
 * - 🔒 **Ensures transactional integrity** for batch operations.
 * - 🚀 **Optimized for large datasets** (batch inserts split into smaller transactions).
 */
trait InsertUpdateTrait
{
    /**
     * Inserts multiple rows of data into the database in batches.
     *
     * This method takes an array of rows, splits them into smaller chunks, and executes
     * batch insert queries to optimize a database writes. It uses parameterized queries
     * to prevent SQL injection and works on tables with the structure defined by the
     * QueryBuilder instance.
     *
     * @param array $rows An array where each element is an associative array representing a row
     *                    to be inserted. Each row must contain the same keys, which correspond
     *                    to the column names in the database table.
     *
     * @return static Returns the current instance of the QueryBuilder to enable method chaining.
     *
     * @throws QueryBuilderException Throws an exception if the input array of rows is empty.
     */
    public function batchInsert(array $rows) : static
    {
        // Check if the input array of rows is empty
        if (empty($rows)) {
            // Throw a custom exception if no data is provided for the batch insert
            throw new QueryBuilderException(message: 'No data provided for batch insert.');
        }

        // Get the database connection instance (PDO)
        $pdo = $this->getConnection();
        // Disable emulation of prepared statements to improve security and prevent SQL injection
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // 🛡️ Prevents SQL Injection

        // Extract the column names from the first row of the input data
        $columns = array_keys($rows[0]);
        // Create a comma-separated list of column names for the SQL statement
        $columnsList = implode(', ', $columns);

        // Split the input data into smaller chunks, with each chunk containing up to 500 rows
        $chunks = array_chunk($rows, 500); // ✅ Splits into batches of 500 rows

        // Iterate over each chunk of data
        foreach ($chunks as $chunk) {
            // Initialize an array to store SQL placeholders for the values
            $placeholders = [];
            // Initialize an array to store the query parameters
            $parameters = [];

            // Iterate over each row in the current chunk
            foreach ($chunk as $index => $row) {
                // Generate placeholders for the current row's values using the column names and row index
                $rowPlaceholders = array_map(static fn($key) => ":{$key}_{$index}", $columns);
                // Combine the placeholders into a parenthesized string and add to the placeholders array
                $placeholders[] = '(' . implode(', ', $rowPlaceholders) . ')';
                // Map the row values to their corresponding placeholders
                foreach ($row as $key => $value) {
                    $parameters["{$key}_{$index}"] = $value;
                }
            }

            // Generate the SQL query for inserting the current chunk of data
            $sql = sprintf(
                'INSERT INTO %s (%s) VALUES %s',
                $this->getTableName(),      // Get the table name from the QueryBuilder instance
                $columnsList,              // The list of columns to insert data into
                implode(', ', $placeholders) // Comma-separated list of placeholders for all rows
            );

            // Prepare the SQL statement to be executed
            $statement = $pdo->prepare(query: $sql);
            // Execute the prepared statement with the mapped parameters
            $this->registerQueryInUnitOfWork(
                operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
                statement : $statement,
                pdo       : $pdo,
                parameters: $parameters
            );
        }

        // Return the current QueryBuilder instance to support method chaining
        return $this;
    }

    /**
     * Performs an upsert operation, inserting a record if it does not exist,
     * or updating the specified columns if a duplicate key is found.
     *
     * The method supports MySQL's `ON DUPLICATE KEY UPDATE` or PostgreSQL's
     * `ON CONFLICT DO UPDATE` based on the database driver.
     * Uses parameterized queries to enhance security and **prevent SQL injection**.
     *
     * @param array $values        The dataset to be inserted. Keys are column names and values are their respective
     *                             values.
     * @param array $updateColumns The column names to be updated in case of a duplicate key or conflict.
     *
     * @return static The current instance for method chaining.
     * @throws QueryBuilderException If no data is provided or if required arrays are empty.
     *
     */
    public function upsert(array $values, array $updateColumns) : static
    {
        // Check if the `$values` array or `$updateColumns` array is empty.
        // If either is empty, throw a custom `QueryBuilderException` since there is no data to perform an upsert operation.
        if (empty($values) || empty($updateColumns)) {
            throw new QueryBuilderException(message: 'No data provided for upsert.');
        }

        // Retrieve the PDO database connection using the `getConnection` method.
        $pdo = $this->getConnection();

        // Set the PDO attribute to disable emulated prepared statements.
        // This improves security by preventing SQL injection attacks.
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // 🛡️ Prevents SQL Injection

        // Create a comma-separated string of column names from the keys of the `$values` array.
        $columns = implode(', ', array_keys($values));

        // Create a comma-separated string of placeholders (e.g., `:column_name`) for prepared statements.
        $placeholders = implode(', ', array_map(static fn($key) => ":{$key}", array_keys($values)));

        // Create a comma-separated string of `column = :update_column` pairs for the ON DUPLICATE KEY UPDATE clause.
        $updates = implode(', ', array_map(static fn($col) => "{$col} = :update_{$col}", $updateColumns));

        // MySQL uses "ON DUPLICATE KEY UPDATE", while PostgreSQL uses "ON CONFLICT (...) DO UPDATE".
        // The query is dynamically adjusted based on the database driver.
        $sql = sprintf(
            'INSERT INTO %s (%s) VALUES (%s) ON DUPLICATE KEY UPDATE %s',
            $this->getTableName(), // Get the table name from the class property or throw if not set.
            $columns,              // Columns to insert data into.
            $placeholders,         // Placeholders for prepared statement values.
            $updates               // Update statement for duplicate key cases.
        );

        // Check if the current database driver is PostgreSQL using the PDO driver name.
        if ($pdo->getAttribute(attribute: PDO::ATTR_DRIVER_NAME) === QueryBuilderEnum::DRIVER_PGSQL->value) {
            // Create a comma-separated string of columns used in PostgreSQL's ON CONFLICT clause.
            $conflictColumns = implode(', ', $updateColumns);
            // Construct the SQL query string for PostgreSQL's INSERT INTO ... ON CONFLICT ... DO UPDATE statement.
            $sql = sprintf(
                'INSERT INTO %s (%s) VALUES (%s) ON CONFLICT (%s) DO UPDATE SET %s',
                $this->getTableName(),  // Get the table name from the class property or throw if not set.
                $columns,               // Columns to insert data into.
                $placeholders,          // Placeholders for prepared statement values.
                $conflictColumns,       // Columns to check for conflicts.
                $updates                // Update statement for conflict cases.
            );
        }

        // Prepare the SQL statement using the PDO `prepare` method.
        // This step ensures the query is safe to execute and supports parameterized values for security.
        $statement = $pdo->prepare(query: $sql);

        // ❗ This registers the query with the Unit of Work system, so it will be executed in a controlled batch during flush().
        // The type of operation is specified as an enum value representing the "INSERT" query type.
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
            statement : $statement,
            pdo       : $pdo,
            parameters: $values // The array of parameters to bind to the statement for execution.
        );

        // Return the current object instance, allowing method chaining.
        return $this;
    }

    /**
     * Inserts a single row into the database.
     *
     * Uses a prepared statement with parameterized queries to prevent SQL injection.
     *
     * @param array $parameters The key-value pairs representing column names and their respective values to be
     *                          inserted.
     *
     * @return static Returns the current instance for method chaining after a successful insert.
     *
     * @throws QueryBuilderException If no data is provided for the insert operation.
     */
    public function insert(array $parameters) : static
    {
        // Check if the provided parameters are empty, throw exception if true
        if (empty($parameters)) {
            throw new QueryBuilderException(message: 'No data provided for insert.');
        }

        // Retrieve the PDO database connection object
        $pdo = $this->getConnection();

        // Disable PDO's emulated prepared statements to prevent SQL Injection
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // 🛡️ Prevents SQL Injection

        // Create a comma-separated list of column names from the parameter keys
        $columns = implode(', ', array_keys($parameters));

        // Create a comma-separated list of named placeholders corresponding to the parameter keys
        $placeholders = implode(', ', array_map(static fn($key) => ":{$key}", array_keys($parameters)));

        // Build the SQL query for inserting data into the table
        $sql = sprintf('INSERT INTO %s (%s) VALUES (%s)', $this->getTableName(), $columns, $placeholders);

        // Prepare the SQL query using the PDO connection
        $statement = $pdo->prepare(query: $sql);

        // Register the query in the unit of work for consistency and potential deferred execution
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
            statement : $statement,
            pdo       : $pdo,
            parameters: $parameters
        );

        // Return the current instance for method chaining
        return $this;
    }

    /**
     * Performs an update operation on records that match the specified conditions.
     *
     * Uses parameterized queries to **prevent SQL injection**. Both the updated data
     * and the conditions must be provided to ensure a valid operation.
     *
     * @param array $values     The data to update with column-value pairs.
     * @param array $conditions The conditions to determine which records to update.
     *
     * @return static Returns the current instance for method chaining.
     * @throws QueryBuilderException If no data or conditions are provided.
     *
     */
    public function update(array $values, array $conditions) : static
    {
        // Check if either the update data ($values) or the conditions ($conditions) are empty.
        // If either is empty, throw a QueryBuilderException to ensure both are provided.
        if (empty($values) || empty($conditions)) {
            throw new QueryBuilderException(message: 'No data or conditions provided for update.');
        }

        // Obtain the database connection using the `getConnection` method.
        // This ensures we have access to the database with a valid PDO instance.
        $pdo = $this->getConnection();

        // Set the PDO attribute to disable emulated prepared statements.
        // 🛡️ This strengthens security by preventing SQL injection attacks.
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

        // Use array mapping to construct the `SET` portion of the SQL statement.
        // Each `SET` clause follows the format "column = :set_column".
        $setClauses = implode(', ', array_map(static fn($col) => "{$col} = :set_{$col}", array_keys($values)));

        // Use array mapping to construct the `WHERE` portion of the SQL statement.
        // Each condition in `WHERE` follows the format "column = :where_column".
        $whereClauses = implode(
            ' AND ',
            array_map(static fn($col) => "{$col} = :where_{$col}", array_keys($conditions))
        );

        // Create the final SQL query string using the table name, `SET` clauses, and `WHERE` clauses.
        // This forms a valid SQL UPDATE query.
        $sql = sprintf('UPDATE %s SET %s WHERE %s', $this->getTableName(), $setClauses, $whereClauses);

        // Prepare the SQL statement using the PDO instance.
        // This allows binding parameters securely before executing the query.
        $statement = $pdo->prepare(query: $sql);

        // Initialize an empty array to hold all parameters for the prepared statement.
        $parameters = [];

        // Populate the $parameters array for the `SET` part of the SQL query.
        // Prefix each key in $values with "set_" to match the placeholders in the query.
        foreach ($values as $key => $value) {
            $parameters["set_{$key}"] = $value;
        }

        // Populate the $parameters array for the `WHERE` part of the SQL query.
        // Prefix each key in $conditions with "where_" to match the placeholders in the query.
        foreach ($conditions as $key => $value) {
            $parameters["where_{$key}"] = $value;
        }

        // Registers a query with the Unit of Work, specifying it as an UPDATE operation.
        // The `QueryBuilderEnum::QUERY_TYPE_UPDATE` indicates the type of a query being performed.
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_UPDATE, // Specifies the type of query as an 'UPDATE' operation.
            statement : $statement, // Passes the prepared PDO statement to be executed.
            pdo       : $pdo,  // Passes PDO connection
            parameters: $parameters // Provides the parameters for the query, likely used for a prepared statement binding.
        );

        // Return the current instance, allowing method chaining if needed.
        return $this;
    }
}

=== Database/QueryBuilder/Traits/JoinClauseBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **JoinClauseBuilderTrait**
 *
 * Handles SQL JOIN clauses, supporting INNER, LEFT, RIGHT, FULL, CROSS, NATURAL, and SELF joins.
 *
 * **Security Enhancements:**
 * - 🛡️ **Prevents SQL Injection** by sanitizing table and column names.
 * - 🔍 **Ensures JOIN conditions are valid** before appending them.
 * - 🔒 **Forces table and alias validation** to avoid SQL tampering.
 */
trait JoinClauseBuilderTrait
{
    private array $joinClauses = [];

    /**
     * Builds the SQL JOIN clauses as a concatenated string.
     */
    public function buildJoins() : string
    {
        return empty($this->joinClauses) ? '' : ' ' . implode(' ', $this->joinClauses);
    }

    /**
     * Resets all JOIN clauses.
     */
    public function resetJoins() : static
    {
        $this->joinClauses = [];

        return $this;
    }

    /**
     * Adds a LEFT JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function leftJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'LEFT JOIN'
        );
    }

    /**
     * Adds a JOIN clause with an optional alias and multiple conditions.
     *
     * @throws QueryBuilderException
     */
    public function join(string $table, string|null $alias, array|string $conditions, string $type = 'JOIN') : static
    {
        $tableWithAlias = $alias ? sprintf(
            '%s AS %s',
            $this->quoteIdentifier(name: $table),
            $this->quoteIdentifier(name: $alias)
        ) : $this->quoteIdentifier(name: $table);

        // Ensure conditions are valid
        if (is_array($conditions)) {
            $conditionString = implode(' AND ', array_map(static fn($condition) => trim($condition), $conditions));
        } else {
            $conditionString = trim($conditions);
        }

        if (empty($table) || empty($conditionString)) {
            throw new QueryBuilderException(message: 'Invalid JOIN statement: table name and conditions are required.');
        }

        $this->joinClauses[] = sprintf('%s %s ON %s', strtoupper($type), $tableWithAlias, $conditionString);

        return $this;
    }

    /**
     * Adds a RIGHT JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function rightJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'RIGHT JOIN'
        );
    }

    /**
     * Adds a FULL OUTER JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function fullOuterJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'FULL OUTER JOIN'
        );
    }

    /**
     * Adds a CROSS JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function crossJoin(string $table) : static
    {
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Invalid CROSS JOIN: table name cannot be empty.');
        }

        $this->joinClauses[] = sprintf('CROSS JOIN %s', $this->quoteIdentifier(name: $table));

        return $this;
    }

    /**
     * Adds a NATURAL JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function naturalJoin(string $table) : static
    {
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Invalid NATURAL JOIN: table name cannot be empty.');
        }

        $this->joinClauses[] = sprintf('NATURAL JOIN %s', $this->quoteIdentifier(name: $table));

        return $this;
    }

    /**
     * Adds a SELF JOIN clause (join on the same table using an alias).
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function selfJoin(string $table, string $alias, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: [$this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(name: $second)]
        );
    }

    /**
     * Adds a JOIN clause with an alias for the table.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinWithAlias(
        string $table,
        string $alias,
        string $first,
        string $operator,
        string $second,
        string $type = 'JOIN'
    ) : static {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : $type
        );
    }

    /**
     * Adds a JOIN clause using raw SQL.
     *
     * ⚠️ **Warning:** Using raw SQL can expose your query to SQL injection risks.
     * Ensure that `$rawSql` is properly sanitized before passing it.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinRaw(string $rawSql) : static
    {
        if (empty($rawSql)) {
            throw new QueryBuilderException(message: 'Invalid JOIN RAW: SQL statement cannot be empty.');
        }

        $this->joinClauses[] = $rawSql;

        return $this;
    }

    /**
     * Adds a JOIN clause with multiple conditions.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinWithConditions(
        string      $table,
        string|null $alias,
        array       $conditions,
        string      $type = 'JOIN'
    ) : static {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: $conditions,
            type      : $type
        );
    }
}

=== Database/QueryBuilder/Traits/OrderByAndGroupByBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\BaseQueryBuilder;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use PDO;

/**
 * Trait OrderByAndGroupByBuilderTrait
 *
 * Handles SQL ORDER BY, GROUP BY, and HAVING clauses using a fluent interface.
 *
 * ✅ OWASP Security: Prevents SQL Injection via safe query-building practices.
 * ✅ Strict Input Validation: Ensures only valid column names and values are accepted.
 */
trait OrderByAndGroupByBuilderTrait
{
    /**
     * Prefix used for placeholders in query building or other similar operations.
     */
    private const string PLACEHOLDER_PREFIX = 'orderByField_';

    /**
     * Stores ORDER BY clauses.
     */
    private array $orderByClauses = [];

    /**
     * Stores GROUP BY clauses.
     */
    private array $groupByClauses = [];

    /**
     * Stores HAVING clauses.
     */
    private array $havingClauses = [];

    /**
     * Stores bound parameters for safe query execution.
     */
    private array $boundParameters = [];

    /**
     * Resets all ORDER BY, GROUP BY, and HAVING clauses.
     */
    public function resetClauses() : self
    {
        $this->orderByClauses  = [];
        $this->groupByClauses  = [];
        $this->havingClauses   = [];
        $this->boundParameters = [];

        return $this;
    }

    /**
     * Adds an ORDER BY clause.
     *
     */
    public function orderBy(string $column, string $direction = 'ASC') : self
    {
        // Validate the column name to ensure it only contains valid characters (alphanumeric and underscores)
        $this->validateColumnName(name: $column);

        // Convert the order direction (ASC/DESC) to uppercase for consistent comparison
        $direction = strtoupper($direction);

        // Check whether the provided direction is valid (ASC or DESC)
        // If the direction is invalid, throw an exception with an appropriate error message
        if (! in_array($direction, ['ASC', 'DESC'], true)) {
            throw new InvalidArgumentException(message: 'Invalid ORDER BY direction. Use "ASC" or "DESC".');
        }

        // Append the valid ORDER BY clause to the array of clauses
        // The column name is safely enclosed using quoteIdentifier for preventing SQL injection
        $this->orderByClauses[] = sprintf('%s %s', $this->quoteIdentifier(name: $column), $direction);

        // Return the current instance to allow method chaining
        return $this;
    }

    /**
     * Adds an ORDER BY FIELD() clause for custom sorting.
     *
     */
    public function orderByField(string $column, array $values) : self
    {
        // Validate the column name to ensure it contains only alphanumeric characters and underscores
        $this->validateColumnName(name: $column);

        // Check if the input array of values is empty, and throw an exception if it is
        if (empty($values)) {
            throw new InvalidArgumentException(message: 'OrderByField requires a non-empty array of values.');
        }

        // Generate a set of placeholders and their corresponding bindings for the passed values
        $placeholdersWithBindings = $this->generatePlaceholdersWithBindings(values: $values);

        // Add an `ORDER BY FIELD` clause to the list of order clauses
        // The `FIELD` SQL function matches the column value to the provided list of placeholders
        $this->orderByClauses[] = sprintf(
            'FIELD(%s, %s)',
            // Sanitize and properly quote the column name according to the database driver
            $this->quoteIdentifier(name: $column),
            // Create a comma-separated list of placeholders (keys from the bindings array)
            implode(', ', array_keys($placeholdersWithBindings)) // Extract only keys for SQL placeholders
        );

        // Merge the generated parameter bindings with any previously existing bound parameters
        $this->boundParameters = array_merge($this->boundParameters, $placeholdersWithBindings);

        // Return the current instance to allow method chaining
        return $this;
    }

    /**
     * Generates a set of placeholders with corresponding value bindings
     * for use in a prepared SQL statement.
     *
     * @param array $values The array of values to create placeholders for.
     *
     * @return array An associative array where keys are placeholder names
     *               and values are the corresponding data from the input array.
     */
    private function generatePlaceholdersWithBindings(array $values) : array
    {
        // Initialize an array to hold the placeholder-value bindings
        $bindings = [];

        // Loop through each value in the provided array, with its index
        foreach ($values as $index => $value) {
            // Create a unique placeholder name using a prefix and the current index
            $placeholderName = ':' . self::PLACEHOLDER_PREFIX . $index;

            // Map the placeholder name to its corresponding value from the input
            $bindings[$placeholderName] = $value;
        }

        // Return the associative array of placeholders and their corresponding values
        return $bindings;
    }

    /**
     * Adds an ORDER BY RAND() clause for random ordering.
     */
    public function orderByRand() : self
    {
        $this->orderByClauses[] = 'RAND()';

        return $this;
    }

    /**
     * Adds a GROUP BY clause.
     *
     */
    public function groupBy(string $column) : self
    {
        $this->validateColumnName(name: $column);
        $this->groupByClauses[] = $this->quoteIdentifier(name: $column);

        return $this;
    }

    /**
     * Adds a HAVING clause with **secure parameter binding**.
     *
     */
    public function having(string $column, string $operator, mixed $value) : self
    {
        // Validate the column name to ensure it contains only alphanumeric characters and underscores.
        $this->validateColumnName(name: $column);

        // Check if the operator provided is valid by comparing it against the list of allowed operators.
        // If the operator is not valid, throw an InvalidArgumentException.
        if (! in_array($operator, ['=', '!=', '<', '>', '<=', '>=', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'], true)) {
            throw new InvalidArgumentException(message: 'Invalid HAVING operator.');
        }

        // Create a parameter placeholder by replacing periods in the column name with underscores.
        // The placeholder is prefixed with ":having_".
        $placeholder = sprintf(':having_%s', str_replace('.', '_', $column));

        // Build the HAVING clause using the quoted column name, the operator, and the placeholder.
        // Add the resulting clause to the `havingClauses` array.
        $this->havingClauses[] = sprintf('%s %s %s', $this->quoteIdentifier(name: $column), $operator, $placeholder);

        // Store the actual value of the parameter in the `boundParameters` array, keyed by the placeholder.
        // This helps ensure the value is safely bound to the statement later during query execution.
        $this->boundParameters[$placeholder] = $value;

        // Return the current object to allow method chaining.
        return $this;
    }

    /**
     * Modifies the query to sort the results in random order, using the appropriate SQL function based on the database
     * driver.
     *
     * @return BaseQueryBuilder|QueryBuilder|OrderByAndGroupByBuilderTrait Returns applied.
     */
    public function inRandomOrder() : self
    {
        // Retrieve the name of the database driver (e.g., 'mysql', 'pgsql') from the current connection.
        // This is done by accessing the PDO::ATTR_DRIVER_NAME attribute of the PDO connection object.
        $driver = $this->getConnection()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);

        // Add a clause to the `orderByClauses` array based on the database driver.
        // For PostgreSQL ('pgsql'), use `RANDOM()`; for other database drivers, use `RAND()`.
        $this->orderByClauses[] = match ($driver) {
            'pgsql' => 'RANDOM()', // If the database driver is Postgres, use the `RANDOM()` function for random ordering.
            default => 'RAND()',   // For other database drivers (e.g., MySQL), use the `RAND()` function for random ordering.
        };

        // Return the current object instance to allow method chaining.
        return $this;
    }

    /**
     * Builds the ORDER BY clause.
     */
    public function buildOrderBy() : string
    {
        return empty($this->orderByClauses) ? '' : ' ORDER BY ' . implode(', ', $this->orderByClauses);
    }

    /**
     * Builds the GROUP BY and HAVING clauses.
     */
    public function buildGroupByAndHaving() : string
    {
        $sql = '';

        if (! empty($this->groupByClauses)) {
            $sql .= ' GROUP BY ' . implode(', ', $this->groupByClauses);
        }

        if (! empty($this->havingClauses)) {
            $sql .= ' HAVING ' . implode(' AND ', $this->havingClauses);
        }

        return $sql;
    }

    /**
     * **Retrieves bound parameters** for safe query execution.
     */
    public function getBoundParameters() : array
    {
        return $this->boundParameters;
    }
}

=== Database/QueryBuilder/Traits/ProvidesUnitOfWork.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\UnitOfWork;

/**
 * Trait ProvidesUnitOfWork
 *
 * Ensures that any class using this trait has access to a UnitOfWork instance.
 */
trait ProvidesUnitOfWork
{
    /**
     * Retrieves the UnitOfWork instance.
     *
     * @return UnitOfWork The Unit of Work instance.
     * @throws QueryBuilderException
     */
    protected function getUnitOfWork() : UnitOfWork
    {
        if (! isset($this->unitOfWork) || ! $this->unitOfWork instanceof UnitOfWork) {
            // Check if the `unitOfWork` property is either not set or is not an instance of the `UnitOfWork` class.
            // If this condition is true, throw a `QueryBuilderException` with a descriptive message.
            throw new QueryBuilderException(message: "UnitOfWork is not set in the class using this trait.");
        }
        if (! method_exists($this, 'getTableName')) {
            // Check if the class using this trait does not define the `getTableName` method.
            // If the `getTableName` method doesn't exist, throw a `QueryBuilderException` with an appropriate message.
            throw new QueryBuilderException(message: "getTableName() is not set in the class using this trait.");
        }

        // If both checks pass (i.e., `unitOfWork` is set and is an instance of `UnitOfWork`, and `getTableName()` exists),
        // return the `unitOfWork` property, which is expected to handle database query registration and execution.
        return $this->unitOfWork;
    }
}

=== Database/QueryBuilder/Traits/QueryOptimizationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

/**
 * Trait QueryOptimizationTrait
 *
 * Provides query optimization strategies, including **indexing recommendations** and **performance insights**.
 *
 * ✅ Implements **OWASP security best practices** to prevent SQL injection.
 * ✅ Uses **PSR-3 Logging** instead of direct output.
 * ✅ Ensures **strict input validation** for indexing recommendations.
 */
trait QueryOptimizationTrait
{
    /**
     * @var array<string> Stores WHERE clauses for analysis.
     */
    private array $whereClauses = [];

    /**
     * Displays recommendations for indexing based on WHERE clauses.
     *
     * ✅ Uses structured **PSR-3 logging** instead of `echo`.
     * ✅ Ensures **strict column name validation** to prevent SQL injection.
     */
    public function showIndexingRecommendations() : void
    {
        $recommendations = $this->recommendIndexes();

        if (empty($recommendations)) {
            $this->logger->info(message: "🔍 No indexing recommendations. Your query is already optimized. 🚀");
        } else {
            $message = "⚡ Recommended columns for indexing: " . implode(', ', $recommendations);
            $this->logger->info(message: $message);

            foreach ($recommendations as $column) {
                $this->logger->info(message: "📌 Consider: CREATE INDEX idx_{$column} ON your_table({$column});");
            }
        }
    }

    /**
     * Analyzes WHERE conditions and suggests which columns should be indexed.
     *
     * ✅ **Prevents SQL injection** via strict column validation.
     * ✅ **Ensures best performance** by avoiding unnecessary recommendations.
     *
     * @return array<int, string> List of recommended columns for indexing.
     */
    public function recommendIndexes() : array
    {
        if (empty($this->whereClauses)) {
            return [];
        }

        $indexes = [];

        foreach ($this->whereClauses as $clause) {
            // Extract column names from WHERE conditions.
            if (preg_match('/^([a-zA-Z0-9_]+)\s*(=|LIKE|IN|>|<|>=|<=)/', $clause, $matches)) {
                $column = $matches[1];

                // Validate column name before adding to recommendations.
                if ($this->isValidColumnName(column: $column) && ! in_array($column, $indexes, true)) {
                    $indexes[] = $column;
                }
            }
        }

        return $indexes;
    }

    /**
     * Validates a column name against SQL injection risks.
     *
     * ✅ Ensures column names are safe before they are used in SQL statements.
     */
    private function isValidColumnName(string $column) : bool
    {
        return preg_match('/^[a-zA-Z0-9_]+$/', $column) === 1;
    }
}

=== Database/QueryBuilder/Traits/SchemaQueryBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Exception;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **SchemaQueryBuilderTrait**
 *
 * Secure **Schema Management API** for QueryBuilder.
 *
 * ✅ **Features:**
 * - **Database Operations:** Create, Drop, Switch
 * - **Table Operations:** Rename, Drop, Exists Checks
 * - **OWASP Security:** Prevents **SQL Injection** & **Malicious Schema Manipulation**
 * - **Idempotency Checks:** Avoids unnecessary operations
 */
trait SchemaQueryBuilderTrait
{
    /**
     * **Switches to a different database** (if it exists).
     *
     * @param string $database The database name to switch to.
     *
     * @throws QueryBuilderException If the database does not exist.
     * @throws \Random\RandomException
     */
    public function useDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if (! $this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Cannot switch: Database '{$database}' does not exist.");
        }

        try {
            $this->raw(sql: "USE {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(
                message: "Failed to switch to database '{$database}'", code: 0, previous: $e
            );
        }
    }

    /**
     * **Validates a database name against OWASP recommendations.**
     *
     * @param string $database The database name to validate.
     *
     * @throws QueryBuilderException If the name is invalid.
     */
    private function validateDatabaseName(string $database) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $database)) {
            throw new QueryBuilderException(message: "Invalid database name: '{$database}'");
        }
    }

    /**
     * **Checks if a database exists.**
     *
     * @param string $database The database name.
     *
     * @return bool True if the database exists, otherwise false.
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Random\RandomException
     */
    public function databaseExists(string $database) : bool
    {
        $this->validateDatabaseName(database: $database);

        return $this
            ->table(tableName: 'information_schema.SCHEMATA')
            ->where(column: 'SCHEMA_NAME', value: $database)
            ->exists();
    }

    /**
     * **Creates a new database** (if it does not exist).
     *
     * @param string $database The database name.
     *
     * @throws QueryBuilderException If creation fails.
     * @throws \Random\RandomException
     */
    public function createDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if ($this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Database '{$database}' already exists.");
        }

        try {
            $this->raw(sql: "CREATE DATABASE {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to create database '{$database}'", code: 0, previous: $e);
        }
    }

    /**
     * **Drops an existing database** (if it exists).
     *
     * @param string $database The database name.
     *
     * @throws QueryBuilderException If deletion fails.
     * @throws \Random\RandomException
     */
    public function dropDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if (! $this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Cannot drop: Database '{$database}' does not exist.");
        }

        try {
            $this->raw(sql: "DROP DATABASE IF EXISTS {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to drop database '{$database}'", code: 0, previous: $e);
        }
    }

    /**
     * **Renames an existing table** (if it exists).
     *
     * @param string $oldName The current table name.
     * @param string $newName The new table name.
     *
     * @throws QueryBuilderException If renaming fails.
     * @throws \Random\RandomException
     * @throws \Random\RandomException
     */
    public function renameTable(string $oldName, string $newName) : void
    {
        $this->validateTableName(table: $oldName);
        $this->validateTableName(table: $newName);

        if (! $this->tableExists(table: $oldName)) {
            throw new QueryBuilderException(message: "Cannot rename: Table '{$oldName}' does not exist.");
        }

        if ($this->tableExists(table: $newName)) {
            throw new QueryBuilderException(message: "Cannot rename: Table '{$newName}' already exists.");
        }

        try {
            $this->raw(
                sql: "RENAME TABLE {$this->quoteIdentifier(name:$oldName)} TO {$this->quoteIdentifier(name:$newName)}"
            )->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to rename table '{$oldName}'", code: 0, previous: $e);
        }
    }

    /**
     * **Validates a table name against OWASP recommendations.**
     *
     * @param string $table The table name to validate.
     *
     * @throws QueryBuilderException If the name is invalid.
     */
    private function validateTableName(string $table) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $table)) {
            throw new QueryBuilderException(message: "Invalid table name: '{$table}'");
        }
    }

    /**
     * **Checks if a table exists in the current database.**
     *
     * @param string $table The table name.
     *
     * @return bool True if the table exists, otherwise false.
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Random\RandomException
     */
    public function tableExists(string $table) : bool
    {
        $this->validateTableName(table: $table);

        return $this
            ->table(tableName: 'information_schema.tables')
            ->where(column: 'table_schema', value: $this->raw(sql: 'DATABASE()'))
            ->where(column: 'table_name', value: $table)
            ->exists();
    }

    /**
     * **Drops a table** (if it exists).
     *
     * @param string $table The table name.
     *
     * @throws QueryBuilderException If deletion fails.
     * @throws \Random\RandomException
     */
    public function dropTable(string $table) : void
    {
        $this->validateTableName(table: $table);

        if (! $this->tableExists(table: $table)) {
            throw new QueryBuilderException(message: "Cannot drop: Table '{$table}' does not exist.");
        }

        try {
            $this->raw(sql: "DROP TABLE IF EXISTS {$this->quoteIdentifier(name:$table)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to drop table '{$table}'", code: 0, previous: $e);
        }
    }
}

=== Database/QueryBuilder/Traits/SelectQueryTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use JsonException;
use PDO;
use PDOException;
use PDOStatement;
use Psr\SimpleCache\CacheInterface;

/**
 * Trait SelectQueryTrait
 *
 * Provides functionality for handling SELECT queries, including:
 * - 🔥 Built-in caching (In-Memory + External Cache)
 * - 🚀 Query performance optimization
 * - 📌 Pagination & indexing
 * - 💾 Hybrid cache system with cache invalidation
 */
trait SelectQueryTrait
{
    /**
     * Controls whether the SELECT query should return distinct results.
     *
     * @readonly
     * @var bool Defaults to false for standard SELECT operations
     */
    protected bool $distinct = false;

    /**
     * Specifies the window function to be applied in the query.
     * Used for analytical operations like ROW_NUMBER(), RANK(), etc.
     *
     * @readonly
     * @var string|null Window function SQL expression or null if not used
     */
    protected string|null $windowFunction = null;

    /**
     * Defines the columns to be retrieved in the SELECT statement.
     * Supports both array of column names and complex expressions.*
     */
    protected array $columns = [];

    /**
     * Determines the locking strategy for the SELECT operation.
     * Supports pessimistic/optimistic locking mechanisms.
     *
     * @readonly
     * @var string|null Lock mode (e.g., 'FOR UPDATE', 'SHARED') or null for no explicit locking
     */
    protected string|null $lockMode = null;

    /**
     * Maximum number of rows to return in the result set.
     * Implements pagination control alongside offset.
     *
     * @readonly
     * @var positive-int|null Number of rows to limit or null for no limit
     */
    protected int|null $limit = null;

    /**
     * Number of rows to skip before starting to return rows.
     * Used in conjunction with the limit for pagination implementation.
     *
     * @readonly
     * @var non-negative-int|null Number of rows to offset or null for no offset
     */
    protected int|null $offset = null;

    /**
     * Determines if query results should be cached.
     * Enables performance optimization for frequently accessed data.
     *
     * @readonly
     * @var bool Defaults to false for real-time query execution
     */
    protected bool $cacheEnabled = false;

    /**
     * Duration in seconds for which cached results remain valid.
     * Affects cache invalidation strategy.
     *
     * @readonly
     * @var positive-int Cache time-to-live in seconds, defaults to 300 (5 minutes)
     */
    protected int $cacheTTL = 300;

    /**
     * Cache implementation for storing query results.
     * Supports PSR-16 compatible cache interfaces.
     *
     * @readonly
     * @var CacheInterface|null Cache implementation or null if caching is disabled
     */
    protected CacheInterface|null $cache = null;

    /**
     * Optional index hint for query optimization.
     * Allows explicit index selection for query execution.
     *
     * @readonly
     * @var string|null Index name to use or null for automatic index selection
     */
    protected string|null $indexHint = null;

    /**
     * Indicates whether to use a read-only database connection.
     * Supports read/write separation pattern in distributed systems.
     *
     * @readonly
     * @var bool|null True for read connection, false for write, null for default
     */
    protected bool|null $useReadConnection = false;

    /**
     * Specifies the NO LOCK hint for SQL Server compatibility.
     * Affects transaction isolation behavior.
     *
     * @readonly
     * @var string|null NO LOCK hint specification or null for default locking behavior
     */
    protected string|null $noLock = null;

    /**
     * Retrieves query results, supporting UnitOfWork if needed.
     *
     * @param bool $addToUnitOfWork If true, query will be deferred for execution.
     *
     * @return static|Arrhae The query results.
     * @throws QueryBuilderException
     * @throws JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function get(bool $addToUnitOfWork = false) : static|Arrhae
    {
        if ($this->cacheEnabled && ($cached = $this->fetchFromCache())) {
            return new Arrhae(items: $cached);
        }

        $query = $this->buildSelectQuery();
        $pdo   = $this->getDatabaseConnection();
        $stmt  = $pdo->prepare(query: $query);

        if ($addToUnitOfWork) {
            $this
                ->getUnitOfWork()
                ->registerQuery(
                    operation : QueryBuilderEnum::QUERY_TYPE_SELECT,
                    statement : $stmt,
                    pdo       : $pdo,
                    parameters: $this->getParameters(),
                );

            return $this;
        }

        return $this->executeQuery(stmt: $stmt);
    }

    /**
     * Attempts to retrieve a cached result.
     *
     * @throws QueryBuilderException|\JsonException|\Psr\SimpleCache\InvalidArgumentException
     */
    private function fetchFromCache() : array|null
    {
        if (! $this->cache || ! $this->cacheEnabled) {
            return null;
        }

        $key = $this->generateCacheKey();

        return $this->cache->has(key: $key) ? $this->cache->get(key: $key) : null;
    }

    /**
     * Generates a unique cache key for the query.
     *
     * This function generates a unique cache key for an SQL `SELECT` query to reduce redundancy in repeated database
     * queries. It combines the generated query (from the `buildSelectQuery` method) and its parameters (from
     * `getParameters`) into a JSON format, using specific encoding options to ensure readability and
     * accuracy. The resulting JSON string is then hashed using the `xxh128` algorithm, which is fast and efficient,
     * and the generated hash is used as a unique cache identifier with the prefix `'query:'`. This method plays a
     * crucial role in implementing query caching, optimizing application performance, and reducing the number of
     * database calls.
     *
     * @throws QueryBuilderException|JsonException
     */
    private function generateCacheKey() : string
    {
        return 'query:' . hash(
                'xxh128',
                json_encode(
                    [
                        'query'      => $this->buildSelectQuery(),
                        'parameters' => $this->getParameters(),
                    ],
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES
                )
            );
    }

    /**
     * Generates the SELECT query string.
     *
     * @throws QueryBuilderException
     */
    private function buildSelectQuery() : string
    {
        return implode(
            ' ',
            array_filter(
                [
                    // Build the SELECT clause of the SQL query (e.g., "SELECT column1, column2").
                    $this->buildSelectClause(),

                    // Build the FROM clause of the SQL query (e.g., "FROM table_name").
                    $this->buildFromClause(),

                    // Build the JOIN clauses for the query, if any (e.g., "LEFT JOIN tableB ON ...").
                    $this->buildJoins(),

                    // Build the WHERE clause for the query, defining specific conditions (e.g., "WHERE column = value").
                    $this->buildWhereClauses(),

                    // Build the GROUP BY clause and HAVING condition for the query (e.g., "GROUP BY column HAVING COUNT(*) > 1").
                    $this->buildGroupByAndHaving(),

                    // Build the ORDER BY clause to sort the query results (e.g., "ORDER BY column ASC/DESC").
                    $this->buildOrderBy(),

                    // Build the LIMIT and OFFSET clauses to restrict the number of rows returned and set an offset (e.g., "LIMIT 10 OFFSET 20").
                    $this->buildLimitOffsetClause(),

                    // Lock mode (optional) used for concurrency (e.g., "FOR UPDATE" or "LOCK IN SHARE MODE").
                    $this->lockMode,

                    // Boolean property indicating whether a "NOLOCK" option should be added (used in specific database systems).
                    $this->noLock,
                ]
            )
        );
    }

    /**
     * Builds the SELECT clause.
     */
    private function buildSelectClause() : string
    {
        // Initialize the $columns array with 'DISTINCT' if the $this->distinct property is true,
        // otherwise, start with an empty array.
        $columns = $this->distinct ? ['DISTINCT'] : [];

        // Merge the current $columns array with $this->columns. If $this->columns is empty
        // or null, use ['*'] as the default (to select all columns).
        $columns = array_merge($columns, $this->columns ?: ['*']);

        // If the $this->windowFunction property is set (not null or falsy), append its
        // value to the $columns array. This is typically used for specialized SQL
        // window functions like ROW_NUMBER() or RANK().
        if ($this->windowFunction) {
            $columns[] = $this->windowFunction;
        }

        // Join all the elements of the $columns array into a comma-separated string
        // and prepend it with 'SELECT'. This constructs the final SQL SELECT clause.
        return 'SELECT ' . implode(', ', $columns);
    }

    /**
     * Builds the FROM clause.
     *
     * @throws QueryBuilderException
     */
    private function buildFromClause() : string
    {
        // Fetch the table name using `getTableName` and sanitize/quote it with `quoteIdentifier`.
        $table = $this->quoteIdentifier(name: $this->getTableName());

        // Check if the sanitized/quoted table name is empty.
        // Throws a `QueryBuilderException` if the table name is not provided.
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Table name is required.');
        }

        // Return a string combining the SQL "FROM" clause and the quoted table name.
        return 'FROM ' . $table;
    }

    /**
     * Builds the LIMIT and OFFSET clauses.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function buildLimitOffsetClause() : string|null
    {
        if ($this->limit !== null && $this->limit < 0) {
            // If the $limit property is set (not null) and its value is less than 0,
            // this indicates an invalid value since a limit must be non-negative.
            // A QueryBuilderException is thrown to prevent invalid SQL queries.
            throw new QueryBuilderException(message: 'Limit must be a non-negative integer.');
        }

        if ($this->offset !== null && $this->offset < 0) {
            // If the $offset property is set (not null) and its value is less than 0,
            // this indicates an invalid value since an offset must be non-negative.
            // A QueryBuilderException is thrown similarly to the limit check above.
            throw new QueryBuilderException(message: 'Offset must be a non-negative integer.');
        }

        return implode(
            ' ', // The delimiter used to concatenate the resulting parts of the SQL clause.
            array_filter(
                [
                    // If $this->limit is set (not null), a "LIMIT" clause is constructed as a string
                    // containing the value of the $this->limit property. Otherwise, null is returned.
                    $this->limit !== null ? "LIMIT {$this->limit}" : null,

                    // Similarly, if $this->offset is set (not null), an "OFFSET" clause is constructed
                    // as a string containing the value of the $this->offset property.
                    // Otherwise, null is returned.
                    $this->offset !== null ? "OFFSET {$this->offset}" : null,
                ]
            )
        // The `array_filter()` function is used to remove null values from the array.
        // This prevents unnecessary spaces or invalid SQL fragments if no limit or offset is set.
        );
    }

    /**
     * Executes the SELECT query and caches the result if enabled.
     *
     * @throws QueryBuilderException|JsonException|\Psr\SimpleCache\InvalidArgumentException
     */
    private function executeQuery(PDOStatement $stmt) : Arrhae
    {
        try {
            // Attempts to execute the prepared SQL statement with the query parameters
            // `getParameters()` presumably returns an array of parameters for the query.
            $stmt->execute(params: $this->getParameters());
        } catch (PDOException $exception) {
            dumpx('executeQuery() dump: ', $exception, $stmt);
            // If an exception occurs during query execution, a custom `QueryBuilderException` is thrown.
            // It includes details about the error, such as the exception message and the executed SQL query.
            throw new QueryBuilderException(message: 'Query execution failed.', previous: $exception);
        }

        // Wraps the result of the executed query in an `Arrhae` object.
        // `fetchAll` retrieves the data from the query as an associative array.
        $result = new Arrhae(items: $stmt->fetchAll(mode: PDO::FETCH_ASSOC));

        if ($this->cacheEnabled) { // Checks if caching is enabled before proceeding.
            // Stores the query results in the cache.
            // `generateCacheKey()` generates a unique key for the query for identification in the cache.
            // `toArray()` converts the `Arrhae` object back to a standard array for caching purposes.
            $this->cache->set(
                key  : $this->generateCacheKey(), // Unique key identifying the cached data.
                value: $result->toArray(),        // The query result data is cached as a plain array.
                ttl  : $this->cacheTTL            // Time-to-live for the cache item (defaults to 300 seconds).
            );
        }

        // Returns the wrapped query result (`Arrhae` object) to the caller.
        return $result;
    }
}

=== Database/QueryBuilder/Traits/SoftDeleteAndDeleteTrait.php ===
<?php
/** @noinspection SqlWithoutWhere */

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use DateTime;
use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;

/**
 * Trait SoftDeleteAndDeleteTrait
 *
 * Provides functionality for managing soft and permanent deletes, including:
 * - Soft delete support with timestamp tracking.
 * - Restore functionality for soft-deleted records.
 * - Permanent delete operations.
 * - Cascading delete operations across related tables.
 * - DELETE JOIN operations for multi-table deletions.
 * - Table truncation support.
 *
 * Implements the **Unit of Work** pattern to defer execution of delete-related operations
 * until explicitly committed.
 */
trait SoftDeleteAndDeleteTrait
{
    /**
     * Indicates whether soft delete functionality is enabled.
     */
    private bool $softDeletes = false;

    /**
     * Indicates whether to include soft-deleted records in queries.
     */
    private bool $withTrashed = false;

    /**
     * Indicates whether to retrieve only soft-deleted records.
     */
    private bool $onlyTrashed = false;

    /**
     * The name of the column used for soft deletes.
     */
    private string $deletedColumn = 'deleted_at';

    /**
     * Enables soft deletes and optionally sets the column used for soft deletion timestamps.
     */
    public function enableSoftDeletes(bool $softDeletes, string|null $deletedColumn = null) : static
    {
        $this->softDeletes = $softDeletes;
        if ($deletedColumn !== null) {
            $this->deletedColumn = $deletedColumn;
        }

        return $this;
    }

    /**
     * Includes soft-deleted records in queries.
     */
    public function withTrashed() : static
    {
        $this->withTrashed = true;
        $this->onlyTrashed = false;

        return $this;
    }

    /**
     * Restricts queries to only soft-deleted records.
     */
    public function onlyTrashed() : static
    {
        $this->onlyTrashed = true;
        $this->withTrashed = false;

        return $this;
    }

    /**
     * Resets filters applied for soft delete queries.
     */
    public function resetSoftDeleteFilters() : static
    {
        $this->withTrashed = false;
        $this->onlyTrashed = false;

        return $this;
    }

    /**
     * Applies soft delete conditions to queries.
     */
    public function applySoftDeleteConditions() : string
    {
        if (! $this->softDeletes) {
            return '';
        }

        return match (true) {
            $this->onlyTrashed   => sprintf(' AND %s IS NOT NULL', $this->deletedColumn),
            ! $this->withTrashed => sprintf(' AND %s IS NULL', $this->deletedColumn),
            default              => '',
        };
    }

    /**
     * Marks records as soft deleted by setting the deleted timestamp.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function softDelete() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'UPDATE ' . $this->getTableName() .
                        ' SET ' . $this->deletedColumn . ' = :deleted_at ' . $this->buildWhereClauses(),
            parameters: [':deleted_at' => (new DateTime())->format('Y-m-d H:i:s')],
            operation : QueryBuilderEnum::QUERY_TYPE_SOFT_DELETE
        );
    }

    /**
     * Registers an operation for deferred execution using the Unit of Work pattern.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function registerForUnitOfWork(string $sql, array $parameters, QueryBuilderEnum $operation) : static
    {
        $pdo       = $this->getConnection();
        $statement = $pdo->prepare($sql);

        $this
            ->getUnitOfWork()
            ->registerQuery(
                operation : $operation,
                statement : $statement,
                parameters: $parameters
            );

        return $this;
    }


    /**
     * Restores soft-deleted records by setting the deleted timestamp to NULL.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function restore() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'UPDATE ' . $this->getTableName() .
                        ' SET ' . $this->deletedColumn . ' = NULL ' . $this->buildWhereClauses(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_RESTORE
        );
    }

    /**
     * Permanently deletes records without applying soft deletes.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function forceDelete() : static
    {
        return $this->delete();
    }

    /**
     * Registers a delete operation in the Unit of Work queue.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function delete() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'DELETE FROM ' . $this->getTableName() . ' ' . $this->buildWhereClauses(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_DELETE
        );
    }

    /**
     * Registers a cascading delete operation for related tables.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function cascadeDelete(array $relatedTables) : static
    {
        foreach ($relatedTables as $table) {
            $this->registerForUnitOfWork(
                sql       : 'DELETE FROM ' . $table . ' ' . $this->buildWhereClauses(),
                parameters: [],
                operation : QueryBuilderEnum::QUERY_TYPE_CASCADE_DELETE
            );
        }

        return $this->delete();
    }

    /**
     * Registers a DELETE JOIN operation in Unit of Work.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function deleteJoin(string $joinTable, string $joinCondition) : static
    {
        return $this->registerForUnitOfWork(
            sql       : sprintf(
                            'DELETE %s FROM %s INNER JOIN %s ON %s %s',
                            $this->getTableName(),
                            $this->getTableName(),
                            $joinTable,
                            $joinCondition,
                            $this->buildWhereClauses()
                        ),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_DELETE_JOIN
        );
    }

    /**
     * Registers a truncate operation in Unit of Work.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function truncate() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'TRUNCATE TABLE ' . $this->getTableName(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_TRUNCATE
        );
    }
}

=== Database/QueryBuilder/Traits/WhereTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use InvalidArgumentException;
use PDO;

/**
 * Trait WhereTrait
 *
 * Provides fluent and expressive methods for dynamically building SQL `WHERE` clauses.
 *
 * **Key Features:**
 * ✅ Supports both simple (`where()`) and advanced (`whereIs()`) conditions.
 * ✅ Prevents SQL Injection via strict column validation & parameterized queries.
 * ✅ Implements `WHERE IN`, `WHERE JSON_CONTAINS`, `FULLTEXT SEARCH`, and date-based filtering.
 * ✅ Optimized for MySQL and PostgreSQL compatibility.
 *
 */
trait WhereTrait
{
    /**
     * Stores bound parameters for prepared statements.
     *
     * @var array<string, mixed>
     */
    private array $parameters = [];

    /**
     * Stores `WHERE` clause conditions.
     *
     * @var array<string>
     */
    private array $whereClauses = [];

    /**
     * Adds a `WHERE` condition with a default `=` operator.
     *
     * @throws \Random\RandomException
     */
    public function where(string $column, mixed $value) : static
    {
        return $this->whereIs(column: $column, operator: '=', value: $value);
    }

    /**
     * Adds a safe and sanitized WHERE condition to the query with specified comparison operator.
     *
     * This method implements a secure way to add WHERE clauses by:
     * - Validating column names against SQL injection
     * - Supporting NULL value comparisons with proper IS NULL syntax
     * - Using a allowlist of allowed SQL operators
     * - Implementing parameterized queries for values
     *
     * @param string $column   The database column name to compare (unquoted)
     * @param string $operator The comparison operator (=,=, <>, >, <, >=, <=, LIKE, NOT LIKE, IN, NOT IN)
     * @param mixed  $value    The value to compare against, null supported
     *
     * @return static Returns $this for method chaining
     * @throws \Random\RandomException   When secure parameter key generation fails
     *
     * @throws InvalidArgumentException When an invalid operator or column name is provided
     */
    public function whereIs(string $column, string $operator, mixed $value) : static
    {
        // Ensure the column name contains only alphanumeric characters and underscores for SQL injection prevention
        $this->validateColumnName(name: $column);

        // Get database-specific quoted identifier for the column name to prevent SQL injection
        $quotedColumn = $this->quoteIdentifier(name: $column);

        // Special handling for NULL comparisons to use proper SQL syntax (IS NULL, IS NOT NULL)
        if ($value === null) {
            if ($operator === '=') {
                $this->whereClauses[] = sprintf('%s IS NULL', $quotedColumn);
            } elseif ($operator === '!=') {
                $this->whereClauses[] = sprintf('%s IS NOT NULL', $quotedColumn);
            } else {
                throw new InvalidArgumentException(
                    message: "Invalid operator for NULL comparison: {$operator}"
                );
            }

            return $this;
        }

        // Define allowed SQL operators to prevent SQL injection via operator
        $supportedOperators = [
            '=',
            '!=',
            '<>',
            '>',
            '<',
            '>=',
            '<=',
            'LIKE',
            'NOT LIKE',
            'IN',
            'NOT IN',
        ];

        // Validate that only whitelisted operators are used
        if (! in_array($operator, $supportedOperators, true)) {
            throw new InvalidArgumentException(
                message: "Unsupported operator: {$operator}"
            );
        }

        // Create a unique parameter key for safe value binding
        $paramKey = $this->generateParamKey(column: $column);

        // Build and store the WHERE clause with parameterized value
        $this->whereClauses[]        = sprintf('%s %s :%s', $quotedColumn, $operator, $paramKey);
        $this->parameters[$paramKey] = $value;

        return $this;
    }

    /**
     * Generates a unique parameter key to prevent conflicts.
     *
     * @throws \Random\RandomException
     */
    private function generateParamKey(string $column) : string
    {
        return $column . '_' . bin2hex(random_bytes(4)); // ✅ Secure random key
    }

    /**
     * Adds a `WHERE IN` condition.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function whereIn(string $column, array $values) : static
    {
        if (empty($values)) {
            throw new QueryBuilderException(message: 'The `IN` clause requires a non-empty array.');
        }

        return $this->prepareInClause(column: $column, values: $values, not: false);
    }

    /**
     * Prepares a safe `IN` clause using parameterized queries.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function prepareInClause(string $column, array $values, bool $not) : static
    {
        $this->validateColumnName(name: $column);
        $column = $this->quoteIdentifier(name: $column);

        if (empty($values)) {
            throw new QueryBuilderException(message: "IN clause requires a non-empty array.");
        }

        $placeholders = [];
        foreach ($values as $index => $value) {
            $paramKey                    = "{$column}_{$index}";
            $placeholders[]              = ":{$paramKey}";
            $this->parameters[$paramKey] = $value;
        }

        $operator             = $not ? 'NOT IN' : 'IN';
        $this->whereClauses[] = sprintf('%s %s (%s)', $column, $operator, implode(', ', $placeholders));

        return $this;
    }

    /**
     * Adds a `WHERE NOT IN` condition.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function whereNotIn(string $column, array $values) : static
    {
        return $this->prepareInClause(column: $column, values: $values, not: true);
    }

    /**
     * Adds a `WHERE IS NULL` condition.
     */
    public function whereNull(string $column) : static
    {
        $this->validateColumnName(name: $column);
        $column               = $this->quoteIdentifier(name: $column);
        $this->whereClauses[] = sprintf('%s IS NULL', $column);

        return $this;
    }

    /**
     * Adds a `WHERE IS NOT NULL` condition.
     */
    public function whereNotNull(string $column) : static
    {
        $this->validateColumnName(name: $column);
        $column               = $this->quoteIdentifier(name: $column);
        $this->whereClauses[] = sprintf('%s IS NOT NULL', $column);

        return $this;
    }

    /**
     * Adds an `OR WHERE` condition.
     *
     * @throws \Random\RandomException
     */
    public function orWhere(string $column, mixed $value) : static
    {
        return $this->orWhereIs(column: $column, operator: '=', value: $value);
    }

    /**
     * Adds an `OR WHERE` condition with a specified operator.
     *
     * @throws \Random\RandomException
     */
    public function orWhereIs(string $column, string $operator, mixed $value) : static
    {
        $this->validateColumnName(name: $column);

        $paramKey                    = $this->generateParamKey(column: $column);
        $this->whereClauses[]        = sprintf('OR %s %s :%s', $column, $operator, $paramKey);
        $this->parameters[$paramKey] = $value;

        return $this;
    }

    /**
     * Adds a `WHERE` condition that compares two columns.
     *
     */
    public function whereColumn(string $first, string $operator, string $second) : static
    {
        // Quote the identifier of the first column name to ensure it's safely encapsulated for SQL.
        // This prevents SQL injection by wrapping column names in suitable quotation marks.
        $first = $this->quoteIdentifier(name: $first);

        // Quote the identifier of the second column name, ensuring it's properly escaped for SQL.
        $second = $this->quoteIdentifier(name: $second);

        // Validate the provided operator to ensure that it's one of the acceptable SQL operators.
        // If invalid, an exception is thrown to prevent dangerous or malformed queries.
        if (! in_array($operator, ['=', '!=', '<', '>', '<=', '>='], true)) {
            throw new InvalidArgumentException(message: 'Invalid SQL operator.');
        }

        // Format and store the WHERE clause in the internal array of conditions (`whereClauses`).
        // The sprintf() is used for consistent and safe concatenation of identifiers and operators.
        $this->whereClauses[] = sprintf('%s %s %s', $first, $operator, $second);

        // Return the current object instance to facilitate method chaining (e.g., add multiple WHERE clauses).
        return $this;
    }

    /**
     * Adds an `OR WHERE` condition that compares two columns.
     */
    public function orWhereColumn(string $first, string $second, string $operator = '=') : static
    {
        $this->whereClauses[] = sprintf('OR %s %s %s', $first, $operator, $second);

        return $this;
    }

    /**
     * Adds a raw SQL expression as a WHERE clause to the query.
     *
     * @param string $sql      The raw SQL string representing the WHERE condition. It must only contain
     *                         valid characters (letters, numbers, underscores, parentheses, dots, commas,
     *                         asterisks, and spaces).
     * @param array  $bindings An associative array of parameter bindings where keys represent parameter
     *                         placeholders and values represent their corresponding values.
     *
     * @return static The current instance for method chaining.
     * @throws InvalidArgumentException If the provided SQL string contains invalid characters.
     */
    public function whereRaw(string $sql, array $bindings = []) : static
    {
        // Check if the provided SQL string contains a semicolon `;` or a double dash `--`.
        // These characters could indicate SQL injection risks or usage of raw SQL features like comments.
        if (str_contains($sql, ';') || str_contains($sql, '--')) {
            // If the string contains either of the above, throw an exception.
            // The exception message states that raw SQL must not include semicolons or comments.
            throw new InvalidArgumentException(message: 'Raw SQL must not contain semicolons or comments.');
        }

        // Adds the validated SQL string wrapped in parentheses to the `whereClauses` array.
        // The array collects raw SQL expressions for WHERE clauses.
        $this->whereClauses[] = "({$sql})";

        // Iterates over the provided bindings array (key-value pairs), where keys represent
        // parameter placeholders and values represent their corresponding values. These key-value pairs
        // are added to the `parameters` array, which stores all query parameter bindings.
        foreach ($bindings as $key => $value) {
            $this->parameters[$key] = $value;
        }

        // Returns the instance of the object to allow method chaining.
        return $this;
    }

    /**
     * Adds a `WHERE JSON_CONTAINS` condition for JSON column filtering.
     *
     * @throws \Random\RandomException
     * @throws \JsonException
     */
    public function whereJsonContains(string $column, mixed $value) : static
    {
        $this->validateColumnName(name: $column);
        $column = $this->quoteIdentifier(name: $column);

        if (! is_array($value) && ! is_object($value)) {
            throw new InvalidArgumentException(message: "Invalid JSON value. Must be array or object.");
        }

        $paramKey                    = $this->generateParamKey(column: $column);
        $this->whereClauses[]        = "JSON_CONTAINS({$column}, :{$paramKey})";
        $this->parameters[$paramKey] = json_encode($value, JSON_THROW_ON_ERROR);

        return $this;
    }

    /**
     * Adds a full-text search condition.
     */
    public function whereFullText(string $column, string $value) : static
    {
        $this->whereClauses[] = sprintf('MATCH(%s) AGAINST (?)', $column);
        $this->parameters[]   = $value;

        return $this;
    }

    /**
     * Adds a condition to filter records for today.
     */
    public function whereToday(string $column) : static
    {
        $this->whereClauses[] = sprintf('DATE(%s) = CURDATE()', $column);

        return $this;
    }

    /**
     * Adds a condition to filter past records.
     */
    public function wherePast(string $column) : static
    {
        $this->whereClauses[] = sprintf('%s < NOW()', $column);

        return $this;
    }

    /**
     * Adds a condition to filter future records.
     */
    public function whereFuture(string $column) : static
    {
        $this->whereClauses[] = sprintf('%s > NOW()', $column);

        return $this;
    }

    /**
     * Orders the query results in random order for items matching a specific condition.
     *
     * @return static Returns the current instance with a random ordering applied to the query.
     */
    public function whereInRandomOrder() : static
    {
        return $this->orderByRandom();
    }

    /**
     * Orders the results randomly.
     *
     * @return static The current query instance with a random ordering applied.
     */
    public function orderByRandom() : static
    {
        // Retrieve the PDO database connection.
        $pdo = $this->getConnection();

        // Determine the appropriate random ordering function based on the database driver.
        // Use 'RANDOM()' for PostgreSQL and 'RAND()' for other databases.
        $orderBy = ($pdo->getAttribute(attribute: PDO::ATTR_DRIVER_NAME) === 'pgsql') ? 'RANDOM()' : 'RAND()';

        // Append the random ordering clause to the list of "ORDER BY" clauses.
        $this->orderByClauses[] = $orderBy;

        // Return the current instance to enable method chaining.
        return $this;
    }

    /**
     * Builds the `WHERE` clause string.
     */
    public function buildWhereClauses() : string
    {
        return empty($this->whereClauses) ? '' : ' WHERE ' . implode(' AND ', $this->whereClauses);
    }

    /**
     * Retrieves all bound parameters.
     */
    public function getParameters() : array
    {
        return $this->parameters;
    }


    /**
     * Adds a "BETWEEN" condition to the SQL where clause for filtering results within a specified range.
     *
     * @param string $column The name of the column to apply the "BETWEEN" condition.
     * @param mixed  $start  The starting value of the range.
     * @param mixed  $end    The ending value of the range.
     * @param bool   $not    Indicates whether to negate the condition, resulting in "NOT BETWEEN".
     *
     * @return static Returns the current instance to allow method chaining.
     * @throws \Random\RandomException
     * @throws \Random\RandomException
     */
    public function whereBetween(string $column, mixed $start, mixed $end, bool $not = false) : static
    {
        // Validates that the column name contains only allowed characters (alphanumeric and underscores).
        $this->validateColumnName(name: $column);

        // Quotes the column name to safely use it in SQL queries, preventing SQL injection or reserved word conflicts.
        $column = $this->quoteIdentifier(name: $column);

        // Generates a unique parameter key for the start value of the "BETWEEN" condition.
        $paramStart = $this->generateParamKey(column: $column . '_start');

        // Generates a unique parameter key for the end value of the "BETWEEN" condition.
        $paramEnd = $this->generateParamKey(column: $column . '_end');

        // Assigns the start value to the `parameters` array using the generated key.
        $this->parameters[$paramStart] = $start;

        // Assigns the end value to the `parameters` array using the generated key.
        $this->parameters[$paramEnd] = $end;

        // Chooses the appropriate SQL operator based on the `$not` flag (either "BETWEEN" or "NOT BETWEEN").
        $operator = $not ? 'NOT BETWEEN' : 'BETWEEN';

        // Builds the SQL where clause for the "BETWEEN" condition and adds it to the list of where clauses.
        $this->whereClauses[] = sprintf('%s %s :%s AND :%s', $column, $operator, $paramStart, $paramEnd);

        // Returns the current instance to allow method chaining.
        return $this;
    }


    /**
     * Resets all `WHERE` conditions and parameters.
     */
    public function resetWhereConditions() : static
    {
        $this->whereClauses = [];
        $this->parameters   = [];

        return $this;
    }
}

=== Database/QueryBuilder/UnitOfWork.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Exception;
use Gemini\Database\DatabaseConnection;
use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use PDO;
use PDOException;
use PDOStatement;

/**
 * **UnitOfWork**
 *
 * Implements the **Unit of Work** pattern to manage database operations within a single transaction.
 *
 * This service allows multiple **INSERT, UPDATE, DELETE, and SELECT** queries to be queued
 * and executed in a single batch transaction, improving **data consistency** and **performance**.
 *
 * ## **Key Features**
 * - 🏗 **Batch Execution:** Defers multiple queries and executes them in a single transaction.
 * - 🔄 **Atomic Transactions:** Ensures all queries succeed or the transaction rolls back.
 * - 🚀 **Performance Optimization:** Reduces the number of database connections per request.
 * - ✅ **Consistency:** Guarantees that queries are executed in a controlled order.
 *
 * **🚀 Example Usage:**
 * ```
 * $unitOfWork->registerQuery(QueryBuilderEnum::QUERY_TYPE_INSERT, $stmt, $params);
 * $results = $unitOfWork->flush(); // Executes all registered queries in a transaction
 * ```
 *
 * @package Gemini\Database\QueryBuilder
 */
class UnitOfWork
{
    /**
     * Stores all queries scheduled for deferred execution.
     *
     * @var array<int, array{operation: QueryBuilderEnum, statement: PDOStatement, parameters: array}>
     */
    private array $unitOfWorkQueue = [];

    /**
     * UnitOfWork constructor.
     *
     * @param DatabaseConnection $databaseConnection The database connection manager.
     */
    public function __construct(private readonly DatabaseConnection $databaseConnection) {}

    /**
     * Registers a database query for deferred execution.
     *
     * Queries added here will be executed when `flush()` is called.
     *
     * @param QueryBuilderEnum $operation  The type of database operation (INSERT, UPDATE, DELETE, SELECT).
     * @param PDOStatement     $statement  The prepared PDO statement.
     * @param array            $parameters Optional parameters for the query.
     *
     * @throws QueryBuilderException If the query string is empty.
     */
    public function registerQuery(
        QueryBuilderEnum $operation,
        PDOStatement     $statement,
        PDO              $pdo,
        array            $parameters = [],
    ) : void {
        if (empty(trim($statement->queryString))) {
            throw new QueryBuilderException(message: "Cannot register an empty query in Unit of Work.");
        }

        $this->unitOfWorkQueue[] = compact('operation', 'statement', 'pdo', 'parameters');
    }

    /**
     * Executes all registered queries within a **single database transaction**.
     *
     * If an error occurs, all changes are rolled back to maintain **data consistency**.
     *
     * @return Arrhae Collection of query execution results.
     *
     * @throws QueryBuilderException If the transaction fails.
     */
    public function flush() : Arrhae
    {
        if (empty($this->unitOfWorkQueue)) {
            return new Arrhae(items: []);
        }

        $pdo = $this->databaseConnection->getConnection();
        $pdo->beginTransaction();
        $results = [];

        try {
            foreach ($this->unitOfWorkQueue as $query) {
                $results[] = $this->executeQuery(unitOfWork: $query);
            }
            $pdo->commit();
        } catch (PDOException|Exception $exception) {
            $pdo->rollBack();
            $this->unitOfWorkQueue = [];
            throw new QueryBuilderException(message: "Transaction failed in UnitOfWork: " . $exception->getMessage());
        }

        // Clear queue after successful execution.
        $this->unitOfWorkQueue = [];

        // Flatten the result structure if only a single query was executed.
        // This improves downstream readability and avoids unnecessary array nesting.
        if (count($results) === 1) {
            return new Arrhae(items: $results[0]);
        }

        // For multiple queries, wrap results under a 'batch' key to preserve structure.
        // Consumers can detect batch mode via Arrhae::isBatch().
        return new Arrhae(items: ['batch' => $results]);
    }

    /**
     * Executes a single query from the Unit of Work queue.
     *
     * If the query is an INSERT, returns both the affected rows and the last insert ID.
     *
     * @param array{operation: QueryBuilderEnum, statement: PDOStatement, pdo: PDO, parameters: array} $unitOfWork
     *     The queued query operation details.
     *
     * @return array Structured result containing affected_rows and optionally lastInsertId.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException When the execution of the query fails.
     */
    private function executeQuery(array $unitOfWork) : array
    {
        $statement  = $unitOfWork['statement'];
        $parameters = $unitOfWork['parameters'] ?? [];
        $operation  = $unitOfWork['operation'];
        $pdo        = $unitOfWork['pdo'];

        try {
            $statement->execute($parameters);

            $result = ['affected_rows' => $statement->rowCount()];

            if ($operation === QueryBuilderEnum::QUERY_TYPE_INSERT) {
                $result['lastInsertId'] = (int) $pdo->lastInsertId();
            }

            return $result;
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Error executing query: " . $exception->getMessage(), code: 0, previous: $exception
            );
        }
    }

}

=== DataHandling/ArrayHandling/Arrhae.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling;

use ArrayAccess;
use ArrayIterator;
use Closure;
use Countable;
use Gemini\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Gemini\DataHandling\ArrayHandling\Traits\AdvancedStringSearchTrait;
use Gemini\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\DebugTrait;
use Gemini\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\LockableTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Gemini\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\StringManipulationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\TransformationTrait;
use InvalidArgumentException;
use IteratorAggregate;
use Traversable;


/**
 * Class Arrhae
 *
 * The `Arrhae` class is a comprehensive utility for working with arrays. It offers a variety of methods
 * for transforming, querying, and manipulating complex arrays. It supports features like dot notation for nested
 * arrays, lazy evaluation, optimized array access, conditional operations, and more.
 *
 * This class implements the `ArrayAccess`, `IteratorAggregate`, and `Countable` interfaces, allowing it to work
 * seamlessly with array operations, iteration, and counting.
 *
 * Additionally, it leverages several traits to modularize functionality:
 * - `AbstractDependenciesTrait`: Manages dependencies required by the class.
 * - `AggregationTrait`: Provides methods for aggregating data (e.g., sum, average).
 * - `ArrayAccessTrait`: Implements array access methods.
 * - `ArrayConversionTrait`: Offers methods to convert arrays to different formats.
 * - `CollectionWalkthroughTrait`: Facilitates iteration and traversal of collections.
 * - `ConditionalsTrait`: Provides conditional operations on arrays.
 * - `DebugTrait`: Contains debugging utilities.
 * - `LazyEvaluationTrait`: Enables lazy evaluation of array operations.
 * - `MacrosTrait`: Allows adding custom macros to the class.
 * - `ManageItemsTrait`: Manages items within the array.
 * - `MetaInfoTrait`: Provides metadata information about the array.
 * - `OrderManipulationTrait`: Handles ordering and sorting of array items.
 * - `PartitioningTrait`: Facilitates partitioning of the array into subsets.
 * - `SetOperationsTrait`: Implements set operations like union and intersection.
 * - `SortOperationsTrait`: Offers advanced sorting capabilities.
 * - `StructureConversionTrait`: Converts the array structure as needed.
 * - `TransformationTrait`: Provides methods to transform array data.
 *
 * @method float|int sum(string|callable $key) Sums all numeric values in the array.
 * @method float|null average() Calculates the average of all numeric values in the array.
 * @method Arrhae fromJson(string $json) Creates an Arrhae instance from a JSON string.
 * @method string toJson() Converts the array to a JSON string.
 *
 * @package Gemini\DataHandling\ArrayHandling
 */
class Arrhae implements ArrayAccess, IteratorAggregate, Countable
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;
    use AdvancedStringSearchTrait;
    use StringManipulationTrait;
    use LockableTrait;

    /**
     * @var array The underlying items of the collection.
     */
    protected array $items = [];

    /**
     * Arrhae constructor.
     *
     * Initializes the `Arrhae` instance with an optional array of items. This constructor is called when a new
     * instance of `Arrhae` is created, and it optionally accepts an array of items that will be stored internally.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Converts an iterable to an array.
     *
     * This helper method ensures that the provided items are converted to an array,
     * regardless of whether they are initially an array or a Traversable object.
     *
     * @param iterable $items The items to convert.
     *
     * @return array The converted array of items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    protected function convertToArray(iterable $items) : array
    {
        if (is_array($items)) {
            return $items;
        }

        return iterator_to_array($items, false);
    }

    /**
     * Creates a new locked collection instance from the given items.
     *
     * This named constructor enforces immutability by creating a locked collection,
     * preventing any modifications after instantiation - adhering to DDD value object principles.
     *
     * @template TKey of array-key
     * @template TValue
     * @param iterable<TKey, TValue> $items The source items to populate the collection
     *
     * @return static<TKey, TValue> A new locked collection instance
     * @throws \RuntimeException If the collection cannot be locked
     * @immutable
     */
    public static function lockedFrom(iterable $items) : self
    {
        // First create a new collection instance from the provided items
        // Then immediately lock it to ensure immutability
        return self::make($items)->lock();
    }

    /**
     * Static factory method to create a new Arrhae instance.
     *
     * This method provides a convenient way to instantiate the Arrhae collection
     * with an initial set of items. It accepts any iterable data type, including
     * arrays and objects implementing the Traversable interface.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @return self A new instance of Arrhae initialized with the provided items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     *
     * @example
     * use Gemini\DataHandling\Arrhae;
     *
     * // Creating a collection from an array
     * $collection = Arrhae::make(['apple', 'banana', 'cherry']);
     *
     * // Creating a collection from a Traversable object
     * $iterator = new ArrayIterator(['apple', 'banana', 'cherry']);
     * $collection = Arrhae::make($iterator);
     */
    public static function make(iterable $items = []) : self
    {
        return new self(items: $items);
    }

    /**
     * Creates an immutable copy of the current instance.
     *
     * This method ensures thread-safety and immutability by creating a deep clone
     * of the current instance and applying a lock mechanism to prevent further modifications.
     * Implement the Immutable Object Pattern for defensive programming.
     *
     * @return self Returns a new locked instance
     * @throws \RuntimeException If the locking mechanism fails
     * @since 8.3.0
     * @immutable
     * @final
     */
    public function toImmutable() : self
    {
        // Create a defensive copy and apply immutability lock
        return clone $this->lock();
    }

    /**
     * Retrieves all items in the `Arrhae` instance.
     *
     * This method returns all items currently stored in the instance as a plain array. It is helpful for getting
     * access to the full dataset.
     *
     * @return array All items in the instance as a standard array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * print_r($arrh->all()); // Output: [1, 2, 3]
     * ```
     */
    public function all() : array
    {
        return $this->items;
    }

    /**
     * Sets a value at the specified key using dot notation for nested arrays.
     *
     * This method allows setting a value at a specific key, even within nested arrays, by using dot notation.
     * If a nested array doesn't exist, it will be created automatically.
     *
     * @param string|int $key   The key to set, which may include dot notation for nested arrays.
     * @param mixed      $value The value to set at the specified key.
     *
     * @return $this Returns the current instance for method chaining.
     *
     * @throws InvalidArgumentException If the key is not a string or integer.
     *
     * ```
     * $arrh = new Arrhae();
     * $arrh->set('user.name', 'Alice');
     * print_r($arrh->all()); // Output: ['user' => ['name' => 'Alice']]
     * ```
     */
    public function set(string|int $key, mixed $value) : self
    {
        if (! is_string($key) && ! is_int($key)) {
            throw new InvalidArgumentException(message: "Key must be a string or an integer.");
        }

        $this->assertNotLocked();

        if (is_string($key) && str_contains($key, '.')) {
            $array = &$this->items;
            foreach (explode('.', $key) as $segment) {
                if (! isset($array[$segment]) || ! is_array($array[$segment])) {
                    $array[$segment] = [];
                }

                $array = &$array[$segment];
            }

            $array = $value;
        } else {
            $this->items[$key] = $value;
        }

        return $this;
    }

    /**
     * Checks if a specific key exists using dot notation for nested keys.
     *
     * This method checks if a key exists in the array. If the key contains dot notation, it checks recursively
     * through the nested arrays.
     *
     * @param string|int $key The key to check for existence.
     *
     * @return bool True if the key exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->has('user.name'); // Output: true
     * ```
     */
    public function has(string|int $key) : bool
    {
        return $this->get(key: $key) !== null;
    }

    /**
     * Gets a value by key using dot notation for nested arrays.
     *
     * This method retrieves a value for a specific key, supporting dot notation for nested keys.
     * If the key doesn't exist, it returns the provided default value.
     *
     * @param string|int $key     The key to retrieve, supports dot notation for nested arrays.
     * @param mixed      $default The default value to return if the key does not exist. Default is `null`.
     *
     * @return mixed The value associated with the key or the default if the key does not exist.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->get('user.name'); // Output: 'Alice'
     * ```
     */
    public function get(string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists($key, $this->items)) {
            return $this->items[$key];
        }

        if (is_string($key) && str_contains($key, '.')) {
            $array = $this->items;
            foreach (explode('.', $key) as $segment) {
                if (is_array($array) && array_key_exists($segment, $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Removes an item by key, supporting dot notation for nested keys.
     *
     * This method removes a specific key and its associated value from the array. If the key is nested, dot notation
     * will be used to traverse through the levels and remove the item.
     *
     * @param string|int $key The key to remove.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * $arrh->forget('user.name');
     * print_r($arrh->all()); // Output: ['user' => []]
     * ```
     */
    public function forget(string|int $key) : self
    {
        $this->assertNotLocked();

        if (array_key_exists($key, $this->items)) {
            unset($this->items[$key]);
        } elseif (is_string($key) && str_contains($key, '.')) {
            $array = &$this->items;
            $keys  = explode('.', $key);
            while (count($keys) > 1) {
                $segment = array_shift($keys);
                if (! isset($array[$segment]) || ! is_array($array[$segment])) {
                    return $this;
                }

                $array = &$array[$segment];
            }

            unset($array[array_shift($keys)]);
        }

        return $this;
    }

    /**
     * Appends a value to the end of the array.
     *
     * This method adds a new value to the end of the current array, allowing dynamic expansion of the items.
     *
     * @param mixed $value The value to append to the array.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $arrh->add(4);
     * print_r($arrh->all()); // Output: [1, 2, 3, 4]
     * ```
     */
    public function add(mixed $value) : self
    {
        $this->assertNotLocked();

        $this->items[] = $value;

        return $this;
    }

    /**
     * Returns an iterator for the array.
     *
     * This method returns an iterator that can be used to loop through the items in the array using a `foreach`
     * loop or other iteration methods.
     *
     * @return Traversable An iterator for the items in the collection.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * foreach ($arrh as $item) {
     *     echo $item; // Outputs: 1 2 3
     * }
     * ```
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->items);
    }

    /**
     * Counts the number of items in the array.
     *
     * This method returns the total number of items in the array, equivalent to the result of the `count()` function.
     *
     * @return int The number of items in the array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->count(); // Output: 3
     * ```
     */
    public function count() : int
    {
        return count($this->items);
    }

    /**
     * Extracts a list of values from the array using the specified key or applies a Closure.
     *
     * This method maps through the items and extracts the values associated with the specified key from each item.
     * If a Closure is provided instead of a key, it applies the Closure to each item and returns the results.
     * If a value doesn't exist or isn't an array when using a key, `null` is returned for that item.
     *
     * @param string|\Closure $key The key to pluck from each item or a Closure to apply to each item.
     *
     * @return array An array containing the plucked values or the results of the Closure for each item.
     *
     * ```
     * // Using a key
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'John'],
     *     ['id' => 2, 'name' => 'Jane'],
     *     ['id' => 3, 'name' => 'Bob']
     * ]);
     * $names = $arrh->pluck('name');
     * print_r($names); // Output: ['John', 'Jane', 'Bob']
     *
     * // Using a Closure
     * $ages = $arrh->pluck(function($item) {
     *     return $item['id'] * 10;
     * });
     * print_r($ages); // Output: [10, 20, 30]
     * ```
     */
    public function pluck(string|Closure $key) : array
    {
        return match (true) {
            $key instanceof Closure => array_map($key, $this->items),
            default                 => array_map(
                fn($item) => is_array($item) && array_key_exists($key, $item) ? $item[$key] : null,
                $this->items
            ),
        };
    }

    /**
     * Retrieves a value from the items array using the specified key.
     *
     * This method retrieves the value associated with a specific key if it exists in the array, or returns
     * the provided default value if the key is absent.
     *
     * @param string $key     The key to retrieve from the items array.
     * @param mixed  $default The default value to return if the key doesn't exist. Default is `null`.
     *
     * @return mixed The value associated with the key, or the default value if the key doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['id' => 1, 'name' => 'Alice']);
     * echo $arrh->arrGet('name'); // Output: 'Alice'
     * echo $arrh->arrGet('age', 30); // Output: 30
     * ```
     */
    public function arrGet(string $key, mixed $default = null) : mixed
    {
        if (is_array($this->items) && array_key_exists($key, $this->items)) {
            return $this->items[$key];
        }

        return $default;
    }

    /**
     * Retrieves a nested value from an array using a dot-notated key.
     *
     * This method allows retrieving values from a nested array using a dot notation key. If the value is
     * not found at any level, it returns the provided default value.
     *
     * @param string $key     The dot-notated key to retrieve the value.
     * @param mixed  $default The default value to return if the key is not found.
     *
     * @return mixed The nested value associated with the key or the default value if not found.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->getValue('user.name'); // Output: 'Alice'
     * ```
     */
    public function getValue(string $key, mixed $default = null) : mixed
    {
        $firstItem = $this->first();
        if (! $firstItem || ! is_array($firstItem)) {
            return $default;
        }

        foreach (explode('.', $key) as $segment) {
            if (is_array($firstItem) && array_key_exists($segment, $firstItem)) {
                $firstItem = $firstItem[$segment];
            } else {
                return $default;
            }
        }

        return $firstItem;
    }

    /**
     * Retrieves the first item in the array, optionally extracting a specific key using dot notation or applying a
     * Closure.
     *
     * This method returns the first item in the array. If a `$key` is provided, it retrieves the value associated
     * with that key using dot notation, similar to the `get()` method. If `$key` is a Closure, it applies the Closure
     * to the first item and returns the result. If the array is empty or the key does not exist, it returns `null` or
     * the provided default value.
     *
     * @param string|int|Closure|null $key      Optional key to retrieve from the first item, supports dot notation or
     *                                          a Closure.
     * @param mixed                   $default  The default value to return if the key is not found. Default is `null`.
     *
     * @return mixed The first item, the value of the specified key in the first item, the result of the Closure, or
     *               the default value.
     *
     * ```
     * // Without key
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->first(); // Output: 1
     *
     * // With key
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->first('user.name'); // Output: 'Alice'
     *
     * // With Closure
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice', 'age' => 25]],
     *     ['user' => ['name' => 'Bob', 'age' => 30]],
     * ]);
     * $firstUserAge = $arrh->first(function($item) {
     *     return $item['user']['age'];
     * });
     * echo $firstUserAge; // Output: 25
     *
     * // With key that does not exist
     * echo $arrh->first('user.gender', 'unknown'); // Output: 'unknown'
     * ```
     * @noinspection PhpParameterNameChangedDuringInheritanceInspection
     */
    public function first(string|int|Closure|null $key = null, mixed $default = null) : mixed
    {
        if ($this->items === []) {
            return $default;
        }

        $firstItem = reset($this->items);
        if ($key === null) {
            return $firstItem;
        }

        if ($key instanceof Closure) {
            return $key($firstItem);
        }

        return $this->getFromItem(item: $firstItem, key: $key, default: $default);
    }

    /**
     * Retrieves a value from a single array item using a key with dot notation or applies a Closure.
     *
     * This helper method is used internally to extract a value from a single array item using a dot-notated key
     * or apply a Closure to it.
     *
     * @param mixed               $item    The array item to extract the value from.
     * @param string|int|\Closure $key     The key to retrieve, supports dot notation or a Closure.
     * @param mixed               $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key, the result of the Closure, or the default value if the key does
     *               not exist.
     */
    protected function getFromItem(mixed $item, string|int|Closure $key, mixed $default = null) : mixed
    {
        if ($key instanceof Closure) {
            return $key($item);
        }

        if (is_array($item)) {
            return $this->getValueFromArray(array: $item, key: $key, default: $default);
        }

        return $default;
    }

    /**
     * Retrieves a value from an array using a key with dot notation.
     *
     * This helper method is used internally to extract a value from an array using a dot-notated key.
     *
     * @param array      $array   The array to extract the value from.
     * @param string|int $key     The key to retrieve, supports dot notation.
     * @param mixed      $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key or the default value if the key does not exist.
     */
    protected function getValueFromArray(array $array, string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists($key, $array)) {
            return $array[$key];
        }

        if (is_string($key) && str_contains($key, '.')) {
            $segments = explode('.', $key);
            foreach ($segments as $segment) {
                if (is_array($array) && array_key_exists($segment, $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Determines whether some items in the array match a given condition.
     *
     * This method iterates over the items and applies the callback function to each item. It returns `true`
     * if the callback returns `true` for any item, and `false` otherwise.
     *
     * @param callable $callback The callback to apply to each item.
     *
     * @return bool `true` if at least one item satisfies the condition, `false` otherwise.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->some(fn($item) => $item > 2); // Output: true
     * ```
     */
    public function some(callable $callback) : bool
    {
        foreach ($this->items as $item) {
            if ($callback($item)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Determines if the collection is operating in batch mode.
     *
     * Batch mode indicates that the collection is handling multiple items
     * as a single unit of work, which can be useful for bulk operations
     * and performance optimization in data processing scenarios.
     *
     * @return bool True if the collection is in batch mode, false otherwise
     *
     * @since 1.0.0
     * @api
     *
     * @see   \Gemini\DataHandling\ArrayHandling\Arrhae::setItems() For setting batch mode
     */
    public function isBatch() : bool
    {
        // Verify the existence of 'batch' flag in the internal items collection
        return isset($this->items['batch']);
    }

    /**
     * Retrieves the items stored in the `Arrhae` instance.
     *
     * This is a protected method that returns the array of items, which is useful in internal operations.
     *
     * @return array The items in the collection.
     */
    protected function getItems() : array
    {
        return $this->items;
    }

    /**
     * Sets the array of items for the current instance.
     *
     * This method allows setting a new array of items for the `Arrhae` instance. It is useful when you want
     * to replace the current set of items with a different array.
     *
     * @param array|iterable $items The new items array to set.
     *
     * @return $this The current instance for method chaining.
     */
    protected function setItems(iterable $items) : static
    {
        $this->assertNotLocked();

        $this->items = $items;

        return $this;
    }
}

=== DataHandling/ArrayHandling/Traits/AbstractDependenciesTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

/**
 * This trait provides common query operations for collections.
 * It includes methods for filtering and checking the existence of items based on different conditions.
 */
trait AbstractDependenciesTrait
{
    /**
     * Retrieve the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @return array The items in the collection.
     */
    abstract protected function getItems() : array;

    /**
     * Sets the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @param array $items The items to set in the collection.
     */
    abstract protected function setItems(array $items) : static;
}

=== DataHandling/ArrayHandling/Traits/AdvancedStringSearchTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use FuzzyWuzzy\Fuzz;
use FuzzyWuzzy\Process;
use InvalidArgumentException;

/**
 * Trait AdvancedStringSearchTrait
 *
 * Provides advanced string search functionalities for collections, including fuzzy search and similarity-based search.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait AdvancedStringSearchTrait
{
    /**
     * Performs a fuzzy match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the query and each item using FuzzyWuzzy,
     * returning items that meet or exceed the specified similarity threshold.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->fuzzyMatch('aple', 80);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->fuzzyMatch('Alic', 70, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * //     ['name' => 'Alina'],
     * // ]
     */
    public function fuzzyMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower($query), s2: strtolower($target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Helper method to validate the threshold.
     *
     * @param float $threshold The threshold to validate.
     *
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     */
    protected function isProperThreshold(float $threshold) : void
    {
        if ($threshold < 0 || $threshold > 100) {
            throw new InvalidArgumentException(message: 'Threshold must be between 0 and 100.');
        }
    }

    /**
     * Searches for items with a similarity percentage above a specified threshold.
     *
     * This method uses the similarity percentage between the query and each item to determine matches.
     *
     * @param string      $query     The search query string.
     * @param float       $threshold The minimum similarity percentage (0 to 100).
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->similaritySearch('apple', 80);
     * // Returns ['apple', 'aple', 'apply']
     *
     * $arrhAssoc = new Arrhae([
     *     ['title' => 'Introduction to PHP'],
     *     ['title' => 'Advanced PHP Techniques'],
     *     ['title' => 'PHP for Beginners'],
     *     ['title' => 'JavaScript Essentials'],
     * ]);
     * $resultsAssoc = $arrhAssoc->similaritySearch('PHP Intro', 70, 'title');
     * // Returns [
     * //     ['title' => 'Introduction to PHP'],
     * //     ['title' => 'PHP for Beginners'],
     * // ]
     */
    public function similaritySearch(string $query, float $threshold = 70.0, string|null $key = null) : static
    {
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower($query), s2: strtolower($target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a Levenshtein-based search and sorts the results by similarity.
     *
     * This method finds items within a certain distance from the query and sorts them by their similarity to the query.
     *
     * @param string      $query       The search query string.
     * @param int         $maxDistance The maximum Levenshtein distance allowed.
     * @param string|null $key         The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items sorted by similarity.
     *
     * @throws InvalidArgumentException If the max distance is negative.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'apricot', 'banana', 'grape', 'pineapple']);
     * $results = $arrh->levenshteinSearch('appel', 2);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->levenshteinSearch('Alic', 2, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function levenshteinSearch(string $query, int|null $maxDistance = null, string|null $key = null) : static
    {
        $maxDistance ??= 2;
        if ($maxDistance < 0) {
            throw new InvalidArgumentException(message: 'Maximum distance cannot be negative.');
        }

        $matchedItems = [];

        foreach ($this->getItems() as $item) {
            $target = $key !== null ? ($item[$key] ?? '') : $item;

            if (! is_string($target)) {
                continue;
            }

            $distance = levenshtein(strtolower($query), strtolower($target));

            if ($distance <= $maxDistance) {
                $matchedItems[$distance][] = $item;
            }
        }

        ksort($matchedItems);

        // Flatten the array while preserving order
        $sortedMatchedItems = [];
        foreach ($matchedItems as $matchedItem) {
            foreach ($matchedItem as $item) {
                $sortedMatchedItems[] = $item;
            }
        }

        return new static(items: $sortedMatchedItems);
    }

    /**
     * Performs a partial match on the collection items based on a given query.
     *
     * This method checks if the query string is a substring of the target string.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->partialMatch('app');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->partialMatch('Ali', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function partialMatch(string $query, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $query) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Check if query is a substring of target
                return stripos($target, $query) !== false;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a token sort match on the collection items based on a given query.
     *
     * This method sorts the tokens in both the query and target strings and then calculates the similarity ratio.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSortMatch('banana apple', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSortMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Sort tokens in the query
        $sortedQuery = $this->sortTokens($query);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $sortedQuery, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Sort tokens in the target
                $sortedTarget = $this->sortTokens($target);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Helper method to sort tokens in a string.
     *
     * @param string $string The string to sort tokens for.
     *
     * @return string The string with sorted tokens.
     */
    protected function sortTokens(string $string) : string
    {
        $tokens = explode(' ', strtolower($string));
        sort($tokens); // Sort tokens in ascending order

        return implode(' ', $tokens);
    }

    /**
     * Performs a token set match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the unique tokens of the query and target strings.
     *
     * @param string      $query     The search query string.
     * @param float       $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSetMatch('apple banana', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSetMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        // Initializing FuzzyWuzzy components
        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Get unique tokens in the query
        $uniqueQueryTokens = array_unique(explode(' ', strtolower($query)));
        sort($uniqueQueryTokens);
        $sortedQuery = implode(' ', $uniqueQueryTokens);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $sortedQuery, $threshold, $process) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Get unique tokens in the target
                $uniqueTargetTokens = array_unique(explode(' ', strtolower($target)));
                sort($uniqueTargetTokens);
                $sortedTarget = implode(' ', $uniqueTargetTokens);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a phonetic match on the collection items based on a given query.
     *
     * This method uses the Metaphone algorithm to find phonetically similar strings.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['Smith', 'Smyth', 'Smithe', 'Johnson']);
     * $results = $arrh->phoneticMatch('Smyth');
     * // Returns ['Smith', 'Smyth', 'Smithe']
     */
    public function phoneticMatch(string $query, string|null $key = null) : static
    {
        $queryPhonetic = metaphone(strtolower($query));

        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $queryPhonetic) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Calculate phonetic code
                $targetPhonetic = metaphone(strtolower($target));

                return $queryPhonetic === $targetPhonetic;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a regular expression search on the collection items based on a given pattern.
     *
     * This method returns items that match the provided regular expression pattern.
     *
     * @param string      $pattern The regular expression pattern.
     * @param string|null $key     The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the provided pattern is invalid.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->regexSearch('/^ap/');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->regexSearch('/^Ali/', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function regexSearch(string $pattern, string|null $key = null) : static
    {
        if (@preg_match($pattern, '') === false) {
            throw new InvalidArgumentException(message: 'Invalid regular expression pattern.');
        }

        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $pattern) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                return preg_match($pattern, $target) === 1;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a custom match on the collection items using a user-defined callback.
     *
     * This method allows for highly flexible and customizable search criteria.
     *
     * @param callable    $callback The callback function to determine a match. Should return a boolean.
     * @param string|null $key      The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->customMatch(function($item) {
     *     return strpos($item, 'ap') === 0;
     * });
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30],
     *     ['name' => 'Alicia', 'age' => 25],
     *     ['name' => 'Alina', 'age' => 28],
     *     ['name' => 'Bob', 'age' => 35],
     * ]);
     * $resultsAssoc = $arrhAssoc->customMatch(function($value, $item) {
     *     return $item['age'] > 27;
     * }, 'age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 30],
     * //     ['name' => 'Alina', 'age' => 28],
     * // ]
     */
    public function customMatch(callable $callback, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $callback) {
                $target = $key !== null ? ($item[$key] ?? null) : $item;

                return $callback($target, $item);
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Sorts the matched items by similarity in descending order.
     *
     * This method is typically used after a search to rank the results based on how closely they match the query.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return array An array of matched items sorted by similarity.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->fuzzyMatch('apple', 60, 'name')->sortBySimilarity('apple', 'name');
     * // Returns items sorted by similarity to 'apple'
     */
    public function sortBySimilarity(string $query, string|null $key = null) : array
    {
        $queryLower = strtolower($query);

        $sortedItems = $this->getItems();
        usort($sortedItems, function ($a, $b) use ($key, $queryLower) : int {
            $fuzz   = new Fuzz();
            $aValue = $key !== null ? ($a[$key] ?? '') : $a;
            $bValue = $key !== null ? ($b[$key] ?? '') : $b;

            if (! is_string($aValue) || ! is_string($bValue)) {
                return 0;
            }

            $similarityA = $fuzz->ratio(s1: $queryLower, s2: strtolower($aValue));
            $similarityB = $fuzz->ratio(s1: $queryLower, s2: strtolower($bValue));

            return $similarityB <=> $similarityA;
        });

        return $sortedItems;
    }
}

=== DataHandling/ArrayHandling/Traits/AggregationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use LogicException;

/**
 * Trait AggregationTrait
 *
 * Provides robust aggregation methods for handling data collections.
 * Supports summation, averaging, min/max determination, and counting by keys or callbacks.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It offers flexible methods
 * that can operate on specific keys or use callbacks for dynamic value extraction.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait AggregationTrait
{
    /**
     * Calculate the average of values for a specified key or callback.
     *
     * This method computes the average (arithmetic mean) of all numeric values obtained
     * from the specified key or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float The resulting average or 0.0 if the collection is empty.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $averageScore = $arrh->average('score'); // Returns 80.0
     *
     * // Using a callback to calculate average age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $averageAge = $arrh->average(fn($item) => $item['age']); // Returns 30.0
     * ```
     */
    public function average(string|callable $key) : float
    {
        $count = count($this->getItems());

        return $count !== 0 ? $this->sum(key: $key) / $count : 0.0;
    }

    /**
     * Sum the values of a specified key or computed by a callback.
     *
     * This method calculates the total sum of all numeric values obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float|int The resulting sum of the values.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'amount' => 100.50],
     *     ['id' => 2, 'amount' => 200.75],
     *     ['id' => 3, 'amount' => 150.25],
     * ]);
     * $totalAmount = $arrh->sum('amount'); // Returns 451.5
     *
     * // Using a callback to sum ages
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $totalAge = $arrh->sum(fn($item) => $item['age']); // Returns 90
     * ```
     */
    public function sum(string|callable $key) : float|int
    {
        $this->validateData();

        return array_reduce(
            $this->getItems(),
            static function ($carry, $item) use ($key) : int|float {
                $value = is_callable($key) ? $key($item) : ($item[$key] ?? 0);

                if (! is_numeric($value)) {
                    throw new InvalidArgumentException('Non-numeric value encountered in sum calculation.');
                }

                return $carry + $value;
            },
            0
        );
    }

    /**
     * Validate the data structure before applying aggregation.
     *
     * Ensures that the collection is a valid array. This prevents unexpected errors
     * during aggregation operations.
     *
     * @throws LogicException If `getItems` does not return a valid array.
     */
    private function validateData() : void
    {
        $items = $this->getItems();

        if (! is_array($items)) {
            throw new LogicException('Expected data to be an array.');
        }
    }

    /**
     * Find the minimum value for a specified key or callback.
     *
     * This method identifies the smallest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The minimum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $minScore = $arrh->min('score'); // Returns 70
     *
     * // Using a callback to find minimum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $minAge = $arrh->min(fn($item) => $item['age']); // Returns 25
     * ```
     */
    public function min(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException('Cannot determine minimum value of an empty collection.');
        }

        return min($values);
    }

    /**
     * Map items to values based on a key or callback.
     *
     * Extracts values from each item in the collection based on the specified key or by applying a callback.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array The extracted values.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Mapping scores
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $scores = $arrh->mapValues('score'); // Returns [80, 90, 70]
     *
     * // Using a callback to extract names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $names = $arrh->mapValues(fn($item) => $item['name']); // Returns ['Alice', 'Bob', 'Charlie']
     * ```
     */
    private function mapValues(string|callable $key) : array
    {
        $this->validateData();

        return array_map(
            static fn($item) => is_callable($key) ? $key($item) : ($item[$key] ?? null),
            $this->getItems()
        );
    }

    /**
     * Find the maximum value for a specified key or callback.
     *
     * This method identifies the largest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The maximum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $maxScore = $arrh->max('score'); // Returns 90
     *
     * // Using a callback to find maximum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $maxAge = $arrh->max(fn($item) => $item['age']); // Returns 35
     * ```
     */
    public function max(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException('Cannot determine maximum value of an empty collection.');
        }

        return max($values);
    }

    /**
     * Count occurrences of unique values by a specified key or callback.
     *
     * This method tallies the number of times each unique value appears in the collection,
     * based on the specified key or by applying a callback to each item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array Associative array with counts for each unique value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $categoryCounts = $arrh->countBy('category');
     * // Returns ['A' => 2, 'B' => 2, 'C' => 1]
     *
     * // Using a callback to count based on a derived value
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 30],
     * ]);
     * $ageCounts = $arrh->countBy(fn($item) => $item['age']);
     * // Returns [25 => 1, 30 => 2, 35 => 1]
     * ```
     */
    public function countBy(string|callable $key) : array
    {
        $this->validateData();

        $result = [];
        foreach ($this->getItems() as $item) {
            $value          = is_callable($key) ? $key($item) : ($item[$key] ?? null);
            $result[$value] = ($result[$value] ?? 0) + 1;
        }

        return $result;
    }

    /**
     * Reduce the collection to a single value using a callback.
     *
     * This method applies a callback function cumulatively to the items of the collection,
     * from left to right, to reduce the collection to a single value.
     *
     * @param callable   $callback  Callback to apply to each item. It should accept two parameters:
     *                              the carry (accumulator) and the current item.
     * @param mixed|null $initial   Initial value to start the reduction. If not provided, the first item of the
     *                              collection is used.
     *
     * @return mixed The reduced value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $product = $arrh->reduce(fn($carry, $item) => $carry * $item, 1); // Returns 24
     *
     * // Using reduce to concatenate names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Bob'],
     *     ['name' => 'Charlie'],
     * ]);
     * $names = $arrh->reduce(fn($carry, $item) => $carry . ', ' . $item['name'], '');
     * // Returns ', Alice, Bob, Charlie'
     * ```
     */
    public function reduce(callable $callback, mixed $initial = null) : mixed
    {
        $this->validateData();

        return array_reduce($this->getItems(), $callback, $initial);
    }

    /**
     * Group items by a specified key or callback.
     *
     * This method organizes the collection into groups based on the specified key or by applying a callback to each
     * item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the grouping
     *                             value.
     *
     * @return array The grouped items.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Grouping by category
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $grouped = $arrh->aggregateGroupBy('category');
     *
     * Returns:
     * [
     *     'A' => [
     *         ['id' => 1, 'category' => 'A'],
     *         ['id' => 3, 'category' => 'A'],
     *     ],
     *     'B' => [
     *         ['id' => 2, 'category' => 'B'],
     *         ['id' => 5, 'category' => 'B'],
     *     ],
     *     'C' => [
     *         ['id' => 4, 'category' => 'C'],
     *     ],
     * ]
     *
     *
     * // Grouping by age range using a callback
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 40],
     * ]);
     * $groupedByAgeRange = $arrh->aggregateGroupBy(function($item) {
     *     if ($item['age'] < 30) {
     *         return 'Under 30';
     *     } elseif ($item['age'] < 40) {
     *         return '30-39';
     *     } else {
     *         return '40 and above';
     *     }
     * });
     *
     * Returns:
     * [
     *     'Under 30' => [
     *         ['name' => 'Alice', 'age' => 25],
     *     ],
     *     '30-39' => [
     *         ['name' => 'Bob', 'age' => 30],
     *         ['name' => 'Charlie', 'age' => 35],
     *     ],
     *     '40 and above' => [
     *         ['name' => 'David', 'age' => 40],
     *     ],
     * ]
     *
     */
    public function aggregateGroupBy(string|callable $key) : array
    {
        $this->validateData();

        $grouped = [];
        foreach ($this->getItems() as $item) {
            $groupKey             = is_callable($key) ? $key($item) : ($item[$key] ?? null);
            $grouped[$groupKey][] = $item;
        }

        return $grouped;
    }
}

=== DataHandling/ArrayHandling/Traits/ArrayAccessTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ArrayAccessTrait
 *
 * Provides array-like access to a collection of items, enabling operations such as
 * checking existence, retrieving, setting, unsetting, and manipulating multiple items.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ArrayAccessTrait
{
    use AbstractDependenciesTrait;

    /**
     * Check if an offset exists in the collection items.
     *
     * Determines whether a specific key or index exists within the collection.
     *
     * @param mixed $offset The offset to check.
     *
     * @return bool True if the offset exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $exists = $arrh->offsetExists(1); // Returns true
     * $exists = $arrh->offsetExists(5); // Returns false
     * ```
     */
    public function offsetExists(mixed $offset) : bool
    {
        return isset($this->getItems()[$offset]);
    }

    /**
     * Get the value at a specific offset in the collection.
     *
     * Retrieves the value associated with a given key or index. Returns null if the offset does not exist.
     *
     * @param mixed $offset The offset to retrieve.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->offsetGet(1); // Returns 'banana'
     * $fruit = $arrh->offsetGet(5); // Returns null
     * ```
     */
    public function offsetGet(mixed $offset) : mixed
    {
        return $this->getItems()[$offset] ?? null;
    }

    /**
     * Set a value at a specific offset in the collection.
     *
     * Assigns a value to a specified key or index. If the offset is null, the value is appended to the collection.
     *
     * @param mixed $offset The offset to assign the value to.
     * @param mixed $value  The value to set.
     *
     *
     * @throws InvalidArgumentException If the key is invalid or cannot be set.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->offsetSet(1, 'blueberry'); // Collection becomes ['apple', 'blueberry']
     * $arrh->offsetSet(null, 'cherry'); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        $items = $this->getItems();
        if (is_null($offset)) {
            $items[] = $value;
        } else {
            $items[$offset] = $value;
        }

        $this->setItems($items);
    }

    /**
     * Unset the value at a specific offset in the collection.
     *
     * Removes the value associated with a given key or index from the collection.
     *
     * @param mixed $offset The offset to unset.
     *
     *
     * @throws InvalidArgumentException If the offset cannot be unset.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->offsetUnset(1); // Collection becomes ['apple', 'cherry']
     * ```
     */
    public function offsetUnset(mixed $offset) : void
    {
        $items = $this->getItems();
        unset($items[$offset]);
        $this->setItems($items);
    }

    /**
     * Retrieve multiple values by an array of offsets.
     *
     * Fetches values corresponding to the provided array of keys or indexes.
     *
     * @param array $keys The offsets to retrieve.
     *
     * @return array An array of values corresponding to the given offsets.
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * $fruits = $arrh->getMultiple([0, 2]); // Returns ['apple', 'cherry']
     * ```
     */
    public function getMultiple(array $keys) : array
    {
        $items = $this->getItems();

        return array_intersect_key($items, array_flip($keys));
    }

    /**
     * Set multiple values at once.
     *
     * Assigns multiple values to the collection based on an associative array of offsets and values.
     *
     * @param array $values An associative array of offsets and their corresponding values.
     *
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->setMultiple([1 => 'blueberry', 2 => 'cherry']); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function setMultiple(array $values) : void
    {
        $items = $this->getItems();

        foreach ($values as $key => $value) {
            $items[$key] = $value;
        }

        $this->setItems($items);
    }

    /**
     * Retrieve and remove an item by its offset.
     *
     * Fetches the value at the specified offset and removes it from the collection.
     *
     * @param mixed $offset The offset to retrieve and remove.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * @throws InvalidArgumentException If the offset is invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->pull(1); // Returns 'banana' and collection becomes ['apple', 'cherry']
     * $fruit = $arrh->pull(5); // Returns null
     * ```
     */
    public function pull(mixed $offset) : mixed
    {
        $items = $this->getItems();
        $value = $items[$offset] ?? null;

        if (array_key_exists($offset, $items)) {
            unset($items[$offset]);
            $this->setItems($items);
        }

        return $value;
    }

    /**
     * Swap two items in the collection.
     *
     * Exchanges the values at the specified offsets within the collection.
     *
     * @param mixed $offset1 The first offset.
     * @param mixed $offset2 The second offset.
     *
     *
     * @throws OutOfBoundsException If either offset does not exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->swap(0, 2); // Collection becomes ['cherry', 'banana', 'apple']
     *
     * $arrh->swap(1, 3); // Throws OutOfBoundsException
     * ```
     */
    public function swap(mixed $offset1, mixed $offset2) : void
    {
        $items = $this->getItems();

        if (! isset($items[$offset1]) || ! isset($items[$offset2])) {
            throw new OutOfBoundsException(message: "One or both offsets do not exist.");
        }

        [$items[$offset1], $items[$offset2]] = [$items[$offset2], $items[$offset1]];

        $this->setItems($items);
    }

    /**
     * Retrieve all keys of the collection.
     *
     * Provides an array of all keys or indexes present in the collection.
     *
     * @return array An array of keys.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $keys = $arrh->keys(); // Returns [0, 1, 2]
     * ```
     */
    public function keys() : array
    {
        return array_keys($this->getItems());
    }

    /**
     * Retrieve all values of the collection.
     *
     * Provides an array of all values present in the collection.
     *
     * @return array An array of values.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $values = $arrh->values(); // Returns ['apple', 'banana', 'cherry']
     * ```
     */
    public function values() : array
    {
        return array_values($this->getItems());
    }
}

=== DataHandling/ArrayHandling/Traits/ArrayConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Exception;
use InvalidArgumentException;
use LogicException;
use SimpleXMLElement;

/**
 * Trait ArrayConversionTrait
 *
 * Provides methods to convert the collection to various formats such as JSON, XML, and arrays.
 * Also includes methods to filter the collection by including or excluding specific keys.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ArrayConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Convert the collection to a JSON string.
     *
     * This method serializes the collection into a JSON-formatted string. It accepts optional
     * JSON encoding options to customize the output.
     *
     * @param int $options Optional JSON encoding options. Default is 0.
     *
     * @return string JSON-encoded string representation of the collection.
     *
     * @throws InvalidArgumentException If the collection contains data that cannot be encoded to JSON.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $json = $arrh->toJson(); // Returns '["apple","banana","cherry"]'
     *
     * // With JSON_PRETTY_PRINT option
     * $jsonPretty = $arrh->toJson(JSON_PRETTY_PRINT);
     * /*
     * Returns:
     * [
     *     "apple",
     *     "banana",
     *     "cherry"
     * ]
     *
     */
    public function toJson(int $options = 0) : string
    {
        $json = json_encode($this->toArray(), $options);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new InvalidArgumentException(
                message: 'Failed to encode collection to JSON: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
     * Convert the collection and nested collections to an array.
     *
     * This method recursively converts each item in the collection to an array if it implements
     * the `toArray` method. Otherwise, it retains the item's original value.
     *
     * @return array Array representation of the collection.
     *
     * @throws LogicException If the collection contains non-escapable items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $array = $arrh->toArray();
     * // Returns [
     * //     ['id' => 1, 'score' => 80],
     * //     ['id' => 2, 'score' => 90],
     * //     ['id' => 3, 'score' => 70],
     * // ]
     * ```
     */
    public function toArray() : array
    {
        return array_map(function ($item) {
            if (is_object($item) && method_exists($item, 'toArray')) {
                return $item->toArray();
            }

            return $item;
        }, $this->getItems());
    }

    /**
     * Convert the collection to an XML string with a customizable root element.
     *
     * This method serializes the collection into an XML-formatted string. It allows specifying
     * a custom root element name. All values are escaped to ensure valid XML.
     *
     * @param string $rootElement The root element name for the XML. Default is 'root'.
     *
     * @return string XML representation of the collection.
     *
     * @throws Exception If the XML conversion fails.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $xml = $arrh->toXml('fruits');
     * /*
     * Returns:
     * <?xml version="1.0"?>
     * <fruits>
     *     <item>apple</item>
     *     <item>banana</item>
     *     <item>cherry</item>
     * </fruits>
     *
     */
    public function toXml(string $rootElement = 'root') : string
    {
        try {
            $xml = new SimpleXMLElement(data: sprintf('<%s/>', $rootElement));
            $this->arrayToXml(data: $this->toArray(), xml: $xml);

            return $xml->asXML();
        } catch (Exception $exception) {
            throw new Exception(
                message : 'Failed to convert collection to XML: ' . $exception->getMessage(),
                code    : $exception->getCode(),
                previous: $exception
            );
        }
    }

    /**
     * Helper method to recursively convert an array to XML.
     *
     * @param array            $data The data to convert.
     * @param SimpleXMLElement $xml  The XML element to append data to.
     */
    private function arrayToXml(array $data, SimpleXMLElement &$xml) : void
    {
        foreach ($data as $key => $value) {
            // Handle numeric keys by using 'item' as the tag name
            if (is_numeric($key)) {
                $key = 'item';
            }

            if (is_array($value)) {
                $child = $xml->addChild(qualifiedName: $key);
                $this->arrayToXml(data: $value, xml: $child);
            } else {
                $xml->addChild(qualifiedName: $key, value: htmlspecialchars((string) $value));
            }
        }
    }

    /**
     * Include only specified keys in the collection.
     *
     * This method filters the collection to retain only the specified keys. It returns a new
     * instance of the collection with the filtered items.
     *
     * @param array $keys Keys to retain in the collection.
     *
     * @return static Collection instance with specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->only(['name', 'city']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function only(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            $this->getItems(),
            static fn($item, $key) : bool => in_array($key, $keys, true),
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Exclude specified keys from the collection.
     *
     * This method filters the collection to remove the specified keys. It returns a new
     * instance of the collection without the excluded items.
     *
     * @param array $keys Keys to exclude from the collection.
     *
     * @return static Collection instance without specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->except(['age']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function except(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            $this->getItems(),
            static fn($item, $key) : bool => ! in_array($key, $keys, true),
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }
}

=== DataHandling/ArrayHandling/Traits/CollectionWalkthroughTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait CollectionWalkthroughTrait
 *
 * A comprehensive trait for traversing, querying, filtering, and searching collections.
 * This trait combines essential methods to enable structured and efficient collection handling.
 *
 * It is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait CollectionWalkthroughTrait
{
    use AbstractDependenciesTrait;

    /** ***Traversal and Filtering Methods*** */

    /**
     * Applies a callback to each item in the collection, transforming the items
     * and returning a new collection with the modified values.
     *
     * This method allows for the transformation of each item in the collection by
     * applying the provided callback function. The resulting collection contains
     * the transformed items.
     *
     * @param Closure $callback The callback to apply to each item. It should accept the item as a parameter and return
     *                          the transformed value.
     *
     * @return static A new instance with the mapped items.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $squared = $arrh->map(fn($item) => $item * $item); // Returns [1, 4, 9]
     * ```
     */
    public function map(Closure $callback) : static
    {
        $mappedItems = array_map($callback, $this->getItems());

        return new static(items: $mappedItems);
    }

    /**
     * Applies a callback to each item in the collection without modifying it.
     *
     * This method iterates over each item in the collection and applies the provided callback.
     * It is useful for performing operations that do not require modifying the collection,
     * such as logging or side effects.
     *
     * @param Closure $callback The callback to apply. It should accept the item and its key as parameters.
     *
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->each(fn($item) => echo $item . "\n");
     * // Outputs:
     * // apple
     * // banana
     * // cherry
     * ```
     */
    public function each(Closure $callback) : void
    {
        foreach ($this->getItems() as $key => $item) {
            $callback($item, $key);
        }
    }

    /**
     * Gets the first item passing a given truth test.
     *
     * This method retrieves the first item in the collection that satisfies the provided callback.
     * If no callback is provided, it returns the first item in the collection.
     *
     * @param Closure|null $callback The callback for the truth test. It should accept the item as a parameter and
     *                               return a boolean.
     *
     * @return mixed The first item passing the test, or null if none found.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $firstEven = $arrh->first(fn($item) => $item % 2 === 0); // Returns 2
     *
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $first = $arrh->first(); // Returns 'apple'
     * ```
     */
    public function first(Closure|null $callback = null) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (! $callback instanceof Closure || $callback($item)) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Zips items in the collection with additional arrays.
     *
     * This method combines the collection with one or more additional arrays. The resulting collection
     * contains arrays where each array contains elements from the corresponding positions of the input arrays.
     * If the input arrays have different lengths, the missing values are filled with `null`.
     *
     * @param array ...$items Arrays to zip with the collection.
     *
     * @return static A new collection with zipped items.
     *
     * @throws InvalidArgumentException If no additional arrays are provided.
     *
     * ```
     * $arrh1 = new Arrhae([1, 2, 3]);
     * $arrh2 = new Arrhae(['a', 'b', 'c']);
     * $zipped = $arrh1->zip($arrh2->getItems()); // Returns [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * $arrh3 = new Arrhae(['x', 'y']);
     * $zipped = $arrh1->zip($arrh2->getItems(), $arrh3->getItems());
     * // Returns [[1, 'a', 'x'], [2, 'b', 'y'], [3, 'c', null]]
     * ```
     */
    public function zip(array ...$items) : static
    {
        if ($items === []) {
            throw new InvalidArgumentException(message: 'At least one array must be provided to zip with.');
        }

        $zipped = array_map(null, $this->getItems(), ...$items);

        return new static(items: $zipped);
    }

    /**
     * Checks if the collection contains a specific value.
     *
     * This method determines whether a given value exists within the collection.
     * It uses strict comparison to ensure accurate matching.
     *
     * @param mixed $value The value to search for.
     *
     * @return bool True if found, false otherwise.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $hasBanana = $arrh->contains('banana'); // Returns true
     * $hasDate = $arrh->contains('date'); // Returns false
     * ```
     */
    public function contains(mixed $value) : bool
    {
        return in_array($value, $this->getItems(), true);
    }

    /** ***Query and Search Methods*** */

    /**
     * Alias for the search method.
     *
     * This method provides an alternative name for the `search` method for better readability.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $index = $arrh->indexOf('cherry'); // Returns 2
     * $index = $arrh->indexOf('date'); // Returns false
     * ```
     */
    public function indexOf(mixed $value) : int|false
    {
        return $this->search(value: $value);
    }

    /**
     * Finds the index of the first occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its first occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value  The value to search for.
     * @param bool  $strict Use strict comparison.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $index = $arrh->search('banana'); // Returns 1
     * $index = $arrh->search('date'); // Returns false
     * ```
     */
    public function search(mixed $value, bool $strict = false) : int|false
    {
        return array_search($value, $this->getItems(), $strict);
    }

    /**
     * Finds the last occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its last occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index of the last occurrence, or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $lastIndex = $arrh->lastIndexOf('banana'); // Returns 3
     * $lastIndex = $arrh->lastIndexOf('date'); // Returns false
     * ```
     */
    public function lastIndexOf(mixed $value) : int|false
    {
        $reversedItems = array_reverse($this->getItems(), true);

        return array_search($value, $reversedItems, true);
    }

    /**
     * Filters items where a specific key matches a given value.
     *
     * This method filters the collection to include only items where the specified key's value
     * is equal to the provided value.
     *
     * @param string $key   The key to filter by.
     * @param mixed  $value The value to match.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 25],
     * ]);
     * $filtered = $arrh->where('age', 25);
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 25],
     * //     ['name' => 'Charlie', 'age' => 25],
     * // ]
     * ```
     */
    public function where(string $key, mixed $value) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) === $value
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is between the provided minimum and maximum values, inclusive.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Alice', 'score' => 85],
     * //     ['name' => 'Bob', 'score' => 90],
     * // ]
     * ```
     */
    public function whereBetween(string $key, array $range) : static
    {
        if (count($range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) >= $min &&
                                       ($item[$key] ?? null) <= $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values are in an array.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of values.
     *
     * @param string $key    The key to filter by.
     * @param array  $values Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the values array is empty.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     * $filtered = $arrh->whereIn('role', ['admin', 'editor']);
     * // Returns [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Bob', 'role' => 'editor'],
     * // ]
     * ```
     */
    public function whereIn(string $key, array $values) : static
    {
        if ($values === []) {
            throw new InvalidArgumentException(message: 'Values array cannot be empty.');
        }

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => in_array($item[$key] ?? null, $values, true)
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is not within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is outside the provided minimum and maximum values.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereNotBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Charlie', 'score' => 75],
     * // ]
     * ```
     */
    public function whereNotBetween(string $key, array $range) : static
    {
        if (count($range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) < $min ||
                                       ($item[$key] ?? null) > $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNull('age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => null],
     * //     ['name' => 'Charlie', 'age' => null],
     * // ]
     * ```
     */
    public function whereNull(string $key) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) === null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is not null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is not `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNotNull('age');
     * // Returns [
     * //     ['name' => 'Bob', 'age' => 30],
     * // ]
     * ```
     */
    public function whereNotNull(string $key) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) !== null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values belong to a group of acceptable values.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of groups. It allows for grouping-based filtering of collections.
     *
     * @param string $key    The key to filter by.
     * @param array  $groups Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $filtered = $arrh->whereInGroup('role', ['admin', 'subscriber']);
     *
     * // $filtered contains:
     * // [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Charlie', 'role' => 'subscriber'],
     * // ]
     * ```
     */
    public function whereInGroup(string $key, array $groups) : static
    {
        return $this->filter(callback: static fn($item) : bool => in_array($item[$key] ?? null, $groups, true));
    }

    /**
     * Filters items in the collection based on a callback.
     *
     * This method filters the collection by applying the provided callback to each item.
     * Only items for which the callback returns `true` are included in the resulting collection.
     *
     * @param Closure $callback The callback to filter items. It should accept the item and its key as parameters and
     *                          return a boolean.
     *
     * @return static A new instance containing only the filtered items.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $evens = $arrh->filter(fn($item) => $item % 2 === 0); // Returns [2, 4]
     * ```
     */
    public function filter(Closure $callback) : static
    {
        $filteredItems = array_filter(
            $this->getItems(),
            $callback,
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Updates items in the collection based on a condition.
     *
     * This method applies the provided update callback to items that satisfy the specified condition.
     * It returns a new instance with the updated items, ensuring immutability.
     *
     * @param Closure $condition The condition to check for each item. It should accept an item as a parameter and
     *                           return a boolean indicating whether the item should be updated.
     * @param Closure $updater   The callback to apply to items that satisfy the condition. It should accept an item
     *                           as a parameter and return the updated item.
     *
     * @return static A new instance with the updated items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     *     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     *     ['id' => 3, 'name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $updated = $arrh->updateWhere(
     *     fn($item) => $item['role'] === 'subscriber',
     *     fn($item) => array_merge($item, ['role' => 'member'])
     * );
     *
     * // $updated contains:
     * // [
     * //     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     * //     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     * //     ['id' => 3, 'name' => 'Charlie', 'role' => 'member'],
     * // ]
     * ```
     */
    public function updateWhere(Closure $condition, Closure $updater) : static
    {
        $updated = array_map(
            static fn($item) => $condition($item) ? $updater($item) : $item,
            $this->getItems()
        );

        return new static(items: $updated);
    }

    /**
     * Adds a whereIs clause to filter the array based on a condition.
     *
     * This method filters the items in the array based on the specified condition applied to a given column.
     * It supports a wide range of operators such as '=', '==', '===', '!=', '<>', '!==', '>', '<', '>=', '<=',
     * '<=>', 'contains', 'not contains', 'in', and 'not in'. The column can be specified using dot notation to access
     * nested values.
     *
     * @param string $column   The column name for the where clause.
     * @param string $operator The operator to be used in the where clause (e.g., '=', '==', '!=', '>', '<',
     *                         'contains', 'in', '<=>').
     * @param mixed  $value    The value to be compared with the column.
     */
    public function whereIs(string $column, string $operator, mixed $value) : self
    {
        // add more here if needed
        $supportedOperators = [
            '=',
            '==',
            '===',
            '!=',
            '<>',
            '!==',
            '>',
            '<',
            '>=',
            '<=',
            '<=>',
            'contains',
            'not contains',
            'in',
            'not in',
        ];

        if (! in_array($operator, $supportedOperators, true)) {
            throw new InvalidArgumentException(message: 'Unsupported operator: ' . $operator);
        }

        $filteredItems = array_filter(
            $this->items,
            function ($item) use ($column, $operator, $value) : bool {
                $itemValue = $this->getFromItem(item: $item, key: $column);

                return match ($operator) {
                    '=', '=='      => $itemValue == $value,
                    '==='          => $itemValue === $value,
                    '!=', '<>'     => $itemValue != $value,
                    '!=='          => $itemValue !== $value,
                    '>'            => $itemValue > $value,
                    '<'            => $itemValue < $value,
                    '>='           => $itemValue >= $value,
                    '<='           => $itemValue <= $value,
                    '<=>'          => $itemValue <=> $value,
                    'contains'     => match (true) {
                        is_string($itemValue) && is_string($value) => str_contains($itemValue, $value),
                        is_array($itemValue)                       => in_array($value, $itemValue, true),
                        default                                    => false,
                    },
                    'not contains' => match (true) {
                        is_string($itemValue) && is_string($value) => ! str_contains($itemValue, $value),
                        is_array($itemValue)                       => ! in_array($value, $itemValue, true),
                        default                                    => true,
                    },
                    'in'           => in_array($itemValue, (array) $value, true),
                    'not in'       => ! in_array($itemValue, (array) $value, true),
                    default        => false,
                };
            }
        );

        $this->items = array_values($filteredItems);

        return new static(items: $this->items);
    }

}

=== DataHandling/ArrayHandling/Traits/ConditionalsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait ConditionalsTrait
 *
 * Adds conditional behaviors to collections, enabling the application of callbacks
 * based on specific conditions. This promotes more expressive and readable code
 * when dealing with collections.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ConditionalsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Apply a callback if the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on a boolean condition. If the condition is true,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is true. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->when(true, fn($collection) => $collection->filter(fn($item) => $item > 2));
     * // $result contains [3, 4]
     * ```
     */
    public function when(bool $condition, Closure $callback) : static
    {
        if ($condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on the inverse of a boolean condition. If the condition is false,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is false. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->unless(false, fn($collection) => $collection->map(fn($item) => $item * 2));
     * // $result contains [2, 4, 6, 8]
     * ```
     */
    public function unless(bool $condition, Closure $callback) : static
    {
        if (! $condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the collection is empty.
     *
     * This method provides an inverse conditional application. It checks if the collection
     * is not empty, and if so, executes the provided callback with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->unlessEmpty(fn($collection) => $collection->remove(2));
     * // $result contains [1, 3]
     * ```
     */
    public function unlessEmpty(Closure $callback) : static
    {
        return $this->whenNotEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is not empty.
     *
     * This method checks if the collection has items. If it is not empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->whenNotEmpty(fn($collection) => $collection->map(fn($item) => $item + 1));
     * // $result contains [2, 3, 4]
     * ```
     */
    public function whenNotEmpty(Closure $callback) : static
    {
        if (! $this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Check if the collection is empty.
     *
     * This method determines whether the collection contains any items.
     *
     * @return bool True if the collection has no items, false otherwise.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $isEmpty = $arrh->isEmpty(); // Returns true
     *
     * $arrh = new Arrhae([1, 2, 3]);
     * $isEmpty = $arrh->isEmpty(); // Returns false
     * ```
     */
    public function isEmpty() : bool
    {
        return empty($this->getItems());
    }

    /**
     * Apply a callback unless the collection is not empty.
     *
     * This method checks if the collection is empty, and if so, executes the provided callback
     * with the current instance as its parameter. It serves as a semantic alternative to `whenEmpty`.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->unlessNotEmpty(fn($collection) => $collection->add('default'));
     * // $result contains ['default']
     * ```
     */
    public function unlessNotEmpty(Closure $callback) : static
    {
        return $this->whenEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is empty.
     *
     * This method checks if the collection has no items. If it is empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->whenEmpty(fn($collection) => $collection->setItems(['default']));
     * // $result contains ['default']
     * ```
     */
    public function whenEmpty(Closure $callback) : static
    {
        if ($this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }
}

=== DataHandling/ArrayHandling/Traits/DebugTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait DebugTrait
 *
 * Provides debugging capabilities for classes that implement the required methods.
 * This trait enforces the presence of `toArray` and `count` methods in the using class.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait DebugTrait
{
    /**
     * Dumps the array representation of the class and returns the instance.
     *
     * This method outputs the array representation using `var_dump` and returns
     * the current instance to allow method chaining.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dump();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * ```
     */
    public function dump() : static
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array($arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump($arrayRepresentation);

        return $this;
    }

    /**
     * Enforce the implementation of toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The array representation of the collection.
     */
    abstract public function toArray() : array;

    /**
     * Dumps the array representation of the class and terminates execution.
     *
     * This method outputs the array representation using `var_dump` and then
     * terminates the script execution.
     *
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dd();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * // Script execution terminated.
     * ```
     */
    public function dd() : void
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array($arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump($arrayRepresentation);
        die();
    }

    /**
     * Overrides the __debugInfo magic method to provide custom debugging information.
     *
     * This method is automatically called by `var_dump` and similar functions to retrieve
     * debugging information about the object.
     *
     * @return array The debugging information.
     */
    public function __debugInfo() : array
    {
        return $this->debugInfo();
    }

    /**
     * Provides debugging information including count and items.
     *
     * This method returns an associative array containing the count of items
     * and their array representation. It can be used to log or inspect the collection's state.
     *
     * @return array The debugging information for the current instance.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $debugInfo = $arrh->debugInfo();
     * // Returns:
     * // [
     * //     'count' => 3,
     * //     'items' => ['apple', 'banana', 'cherry']
     * // ]
     * ```
     */
    public function debugInfo() : array
    {
        $items = $this->toArray();

        if (! is_array($items)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        return [
            'count' => $this->count(),
            'items' => $items,
        ];
    }

    /**
     * Enforce the implementation of count method.
     *
     * Classes using this trait must implement this method.
     *
     * @return int The number of items in the collection.
     */
    abstract public function count() : int;
}

=== DataHandling/ArrayHandling/Traits/LazyEvaluationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait LazyEvaluationTrait
 *
 * Provides methods to enable lazy evaluation on collections.
 * It offers a set of functions to manipulate collections in a memory-efficient manner
 * using generator functions, enabling operations like taking or skipping elements
 * based on conditions, selecting every nth element, and sliding windows of elements.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait LazyEvaluationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Take items from the collection while the callback returns true.
     *
     * Creates a new collection taking elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to continue taking items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeWhile(fn($item) => $item < 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool($result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if (! $result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /** ***Traversal and Filtering Methods*** */


    /**
     * Skip items in the collection while the callback returns true.
     *
     * Creates a new collection that skips initial elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to skip items. It should accept the item and its key as parameters
     *                          and return a boolean.
     *
     * @return static A new lazy collection skipping items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipWhile(fn($item) => $item < 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool($result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if (! $result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Get every nth item in the collection.
     *
     * Useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved. Must be a positive integer.
     *
     * @return static A new lazy collection containing every nth item.
     *
     * @throws InvalidArgumentException If $step is not a positive integer.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5, 6]);
     * $result = $arrh->nth(2);
     * // $result yields 1, 3, 5
     * ```
     */
    public function nth(int $step) : static
    {
        if ($step <= 0) {
            throw new InvalidArgumentException(message: 'Step must be a positive integer.');
        }

        return new static(function () use ($step) {
            $index = 0;
            foreach ($this->getItems() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection until the callback returns true.
     *
     * Creates a new collection taking elements until the specified condition is met.
     *
     * @param Closure $callback The condition that stops the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeUntil(fn($item) => $item === 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool($result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if ($result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /**
     * Skip items in the collection until the callback returns true.
     *
     * Creates a new collection that starts taking elements once the specified
     * condition is met.
     *
     * @param Closure $callback The condition that starts the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection skipping items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipUntil(fn($item) => $item === 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool($result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if ($result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Creates a sliding window of items in the collection.
     *
     * Produces sub-arrays (chunks) of size specified, sliding by step count.
     * Useful for windowed computations or batch processing.
     *
     * @param int $size The size of each sliding window. Must be a positive integer.
     * @param int $step The step by which the window slides. Must be a positive integer. Defaults to 1.
     *
     * @return static A new lazy collection containing sliding windows of items.
     *
     * @throws InvalidArgumentException If $size or $step are not positive integers.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->sliding(3, 1);
     * // $result yields [1, 2, 3], [2, 3, 4], [3, 4, 5]
     * ```
     */
    public function sliding(int $size = 2, int $step = 1) : static
    {
        if ($size <= 0 || $step <= 0) {
            throw new InvalidArgumentException(message: 'Size and step must be positive integers.');
        }

        return new static(function () use ($size, $step) {
            $buffer = [];
            foreach ($this->getItems() as $item) {
                $buffer[] = $item;
                if (count($buffer) === $size) {
                    yield $buffer;
                    array_splice($buffer, 0, $step);
                }
            }

            // Yield remaining items if needed (optional)
            // if (count($buffer) > 0) {
            //     yield $buffer;
            // }
        });
    }

    /**
     * Returns a new instance with the first $limit items of the current collection.
     *
     * This method uses generator functions to yield only the specified number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $limit The number of items to take from the beginning of the collection. Must be a non-negative
     *                   integer.
     *
     * @return static A new lazy collection with the first $limit items.
     *
     * @throws InvalidArgumentException If $limit is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->take(3);
     * // $result yields 1, 2, 3
     * ```
     */
    public function take(int $limit) : static
    {
        if ($limit < 0) {
            throw new InvalidArgumentException(message: 'Limit must be a non-negative integer.');
        }

        return new static(
            iterator_to_array(
                (function () use ($limit) {
                    if ($limit === 0) {
                        return;
                    }

                    $count = 0;
                    foreach ($this->getItems() as $item) {
                        yield $item;
                        if (++$count >= $limit) {
                            break;
                        }
                    }
                })(),
                false
            )
        );
    }

    /**
     * Returns a new instance with the items starting from the $offset position of the current collection.
     *
     * This method utilizes generator functions to skip a certain number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $offset The number of items to skip from the beginning of the collection. Must be a non-negative
     *                    integer.
     *
     * @return static A new lazy collection with items starting from the $offset position.
     *
     * @throws InvalidArgumentException If $offset is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skip(2);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skip(int $offset) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset must be a non-negative integer.');
        }

        return new static(function () use ($offset) {
            if ($offset === 0) {
                foreach ($this->getItems() as $item) {
                    yield $item;
                }

                return;
            }

            $count = 0;
            foreach ($this->getItems() as $item) {
                if ($count++ < $offset) {
                    continue;
                }

                yield $item;
            }
        });
    }

    /**
     * Converts a lazy collection to an eagerly-loaded collection.
     *
     * This method resolves all deferred (lazy) items into an array, allowing for immediate
     * in-memory operations. It's useful for scenarios where further operations require
     * the collection to be fully loaded in memory.
     *
     * @return static A new instance containing the eagerly-loaded collection.
     *
     * ```
     * // Example: Processing a large dataset lazily, then converting to eager for final transformation.
     * $lazyCollection = new Arrhae((function () {
     *     // Simulate fetching a large dataset lazily.
     *     for ($i = 1; $i <= 10000; $i++) {
     *         yield [
     *             'id' => $i,
     *             'value' => $i * 2,
     *             'category' => $i % 2 === 0 ? 'even' : 'odd',
     *         ];
     *     }
     * })());
     *
     * // Step 1: Lazy filtering and mapping.
     * $filteredLazyCollection = $lazyCollection
     *     ->filter(fn($item) => $item['id'] > 5000)  // Keep items with IDs > 5000.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'value' => $item['value'] + 10,
     *         'is_even' => $item['category'] === 'even',
     *     ]);
     *
     * // Step 2: Convert to eager-loaded collection.
     * $eagerCollection = $filteredLazyCollection->toEager();
     *
     * // Step 3: Further eager operations.
     * $finalResult = $eagerCollection
     *     ->filter(fn($item) => $item['is_even'])     // Only keep even items.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'summary' => "Item ID: {$item['id']}, Value: {$item['value']}",
     *     ])
     *     ->toArray();
     *
     * // Output: $finalResult contains an eagerly-loaded array with transformed data.
     * [
     *     ['id' => 5002, 'summary' => 'Item ID: 5002, Value: 10014'],
     *     ['id' => 5004, 'summary' => 'Item ID: 5004, Value: 10018'],
     *     ...
     * ]
     * ```
     */
    public function toEager() : static
    {
        return new static(iterator_to_array($this->getItems()));
    }


}

=== DataHandling/ArrayHandling/Traits/LockableTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use LogicException;

/**
 * Trait LockableTrait
 *
 * Provides a locking mechanism to enforce immutability on collection-like objects.
 * Intended for use in data container classes (e.g., value object arrays) where mutation
 * should be explicitly prohibited after initialization or transformation.
 *
 * When locked, any attempt to mutate the object via methods like `set`, `forget`, `add`,
 * or internal `setItems` should result in a runtime exception.
 *
 * This trait enforces strict runtime safety in contexts such as:
 * - Domain-driven value object snapshots
 * - Immutable API response structures
 * - Secure, read-only configuration holders
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait LockableTrait
{
    /**
     * Indicates whether the current instance is locked and protected from mutation.
     */
    protected bool $locked = false;

    /**
     * Locks the current instance, making all mutating operations forbidden.
     *
     * This method should be called once the object reaches a stable state, typically
     * after construction, transformation, or hydration from a DTO.
     *
     * @return static Returns the same instance for fluent chaining.
     */
    public function lock() : static
    {
        // Enables the immutability flag
        $this->locked = true;

        // Return self to support fluent calls
        return $this;
    }

    /**
     * Indicates whether this instance has been locked.
     *
     * Useful for consumers to check immutability status.
     *
     * @return bool True if locked, false otherwise.
     */
    public function isLocked() : bool
    {
        return $this->locked;
    }

    /**
     * Checks whether mutation is allowed. Throws an exception if the instance is locked.
     *
     * Should be called at the top of any mutating method (e.g., set, forget, etc.)
     * to enforce write protection contract.
     *
     * @throws LogicException If mutation is attempted on a locked instance.
     */
    protected function assertNotLocked() : void
    {
        // Enforces immutability post-lock
        if ($this->locked === true) {
            throw new LogicException(message: 'Mutation is forbidden: this instance is locked and read-only.');
        }
    }
}

=== DataHandling/ArrayHandling/Traits/MacrosTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use BadMethodCallException;
use Closure;
use InvalidArgumentException;

/**
 * Trait MacrosTrait
 *
 * Provides the ability to register and handle macros (dynamic methods) within a class.
 * This trait allows for the registration of global macros and namespaced macros,
 * enabling flexible and organized method extensions.
 *
 * The trait enforces the implementation of the `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait MacrosTrait
{
    // Store macros and namespaced macros
    protected static array $macros          = [];

    protected static array $macroNamespaces = [];

    /**
     * Register a new global macro.
     *
     * This method allows you to define a macro (dynamic method) that can be called
     * on instances of the class using this trait.
     *
     * @param string  $name  The name of the macro.
     * @param Closure $macro The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macro('toUpperCase', function() {
     *     return array_map(fn($item) => strtoupper($item), $this->getItems());
     * });
     *
     * $instance->toUpperCase(); // Transforms all items to uppercase.
     * ```
     */
    public static function macro(string $name, Closure $macro) : void
    {
        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macros[$name])) {
            throw new InvalidArgumentException(message: sprintf("Macro '%s' is already registered.", $name));
        }

        self::$macros[$name] = $macro;
    }

    /**
     * Register a new namespaced macro.
     *
     * This method allows you to define a macro within a specific namespace, enabling
     * better organization and avoiding naming collisions.
     *
     * @param string  $namespace The namespace for organizing macros.
     * @param string  $name      The name of the macro within the namespace.
     * @param Closure $macro     The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the namespace or macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macroNamespace('string', 'toCamelCase', function() {
     *     return array_map(fn($item) => lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $item)))),
     *     $this->getItems());
     * });
     *
     * $instance->string::toCamelCase(); // Converts snake_case strings to camelCase.
     * ```
     */
    public static function macroNamespace(string $namespace, string $name, Closure $macro) : void
    {
        if ($namespace === '' || $namespace === '0') {
            throw new InvalidArgumentException(message: 'Namespace cannot be empty.');
        }

        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macroNamespaces[$namespace][$name])) {
            throw new InvalidArgumentException(
                message: sprintf("Macro '%s' is already registered in namespace '%s'.", $name, $namespace)
            );
        }

        self::$macroNamespaces[$namespace][$name] = $macro;
    }

    /**
     * Dynamically handle static method calls to macros.
     *
     * This magic method intercepts static calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     *
     * @param string $name      The name of the static method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Static global macro
     * MacrosTrait::macro('staticMethod', function() {
     *     return 'Static method called';
     * });
     *
     * Arrhae::staticMethod(); // Returns 'Static method called'
     * ```
     */
    public static function __callStatic(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains($name, '::')) {
            [$namespace, $macro] = explode('::', $name, 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo(null, static::class);

                return call_user_func_array($boundMacro, $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo(null, static::class);

            return call_user_func_array($boundMacro, $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Static method '%s' does not exist.", $name));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return iterable The collection of items.
     */
    abstract public function getItems() : iterable;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param iterable $items The collection of items to set.
     */
    abstract public function setItems(iterable $items) : static;

    /**
     * Handle dynamic method calls to macros.
     *
     * This magic method intercepts calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     * It supports both global macros and namespaced macros (using the '::' separator).
     *
     * @param string $name      The name of the method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Global macro
     * MacrosTrait::macro('sum', function() {
     *     return array_sum($this->getItems());
     * });
     *
     * $instance->sum(); // Returns the sum of all items.
     *
     * // Namespaced macro
     * MacrosTrait::macroNamespace('math', 'average', function() {
     *     return array_sum($this->getItems()) / count($this->getItems());
     * });
     *
     * $instance->math::average(); // Returns the average of all items.
     * ```
     */
    public function __call(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains($name, '::')) {
            [$namespace, $macro] = explode('::', $name, 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo($this, static::class);

                return call_user_func_array($boundMacro, $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo($this, static::class);

            return call_user_func_array($boundMacro, $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Method '%s' does not exist.", $name));
    }
}

=== DataHandling/ArrayHandling/Traits/ManageItemsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ManageItemsTrait
 *
 * Provides methods to manage items within a collection.
 * This trait offers functionalities to append, prepend, concatenate, remove,
 * replace, and slice items in a collection in an immutable and memory-efficient manner.
 *
 * The trait enforces the implementation of `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ManageItemsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Append a value to the end of the collection.
     *
     * This method adds a new item to the end of the collection and returns a new instance
     * with the appended item, ensuring immutability.
     *
     * @param mixed $value The value to append.
     *
     * @return static A new instance with the appended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $newArrh = $arrh->append('cherry');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function append(mixed $value) : static
    {
        $items   = $this->getItems();
        $items[] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /** ***Item Management Methods*** */

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Prepend a value to the beginning of the collection.
     *
     * This method adds a new item to the beginning of the collection and returns a new instance
     * with the prepended item, ensuring immutability.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static A new instance with the prepended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['banana', 'cherry']);
     * $newArrh = $arrh->prepend('apple');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function prepend(mixed $value) : static
    {
        $items = $this->getItems();
        array_unshift($items, $value);

        return $this->setItems(items: $items);
    }

    /**
     * Concatenate the given iterable items to the current collection.
     *
     * This method merges the current collection with another iterable (array or instance of the using class)
     * and returns a new instance with the concatenated items, ensuring immutability.
     *
     * @param iterable $items The items to concatenate.
     *
     * @return static A new instance with concatenated items.
     *
     * @throws InvalidArgumentException If the provided items are not iterable.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $concatenated = $arrh1->concat($arrh2);
     * // $concatenated contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function concat(iterable $items) : static
    {
        $currentItems = $this->getItems();

        if ($items instanceof self) {
            $items = $items->getItems();
        } elseif (! is_array($items)) {
            throw new InvalidArgumentException(
                message: 'Concat method expects an array or an instance of the using class.'
            );
        }

        $newItems = array_merge($currentItems, $items);

        return $this->setItems(items: $newItems);
    }

    /**
     * Remove and return the first item of the collection.
     *
     * This method removes the first item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the first item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->shift();
     * // $newArrh contains ['banana', 'cherry']
     * ```
     */
    public function shift() : static|null
    {
        $items = $this->getItems();
        $value = array_shift($items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove and return the last item of the collection.
     *
     * This method removes the last item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the last item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->pop();
     * // $newArrh contains ['apple', 'banana']
     * ```
     */
    public function pop() : static|null
    {
        $items = $this->getItems();
        $value = array_pop($items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove an item at a specific index.
     *
     * This method removes the item at the specified index and returns a new instance
     * without that item. It throws an exception if the index is invalid.
     *
     * @param int $index The index of the item to remove.
     *
     * @return static A new instance without the specified item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->removeAt(1);
     * // $newArrh contains ['apple', 'cherry']
     * ```
     */
    public function removeAt(int $index) : static
    {
        $items = $this->getItems();

        if (! array_key_exists($index, $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        unset($items[$index]);

        // Reindex the array to maintain sequential keys
        $items = array_values($items);

        return $this->setItems(items: $items);
    }

    /**
     * Replace an item at a specific index.
     *
     * This method replaces the item at the specified index with a new value and returns a new instance
     * with the updated item. It throws an exception if the index is invalid.
     *
     * @param int   $index The index to replace.
     * @param mixed $value The new value.
     *
     * @return static A new instance with the replaced item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->replaceAt(1, 'blueberry');
     * // $newArrh contains ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function replaceAt(int $index, mixed $value) : static
    {
        $items = $this->getItems();

        if (! array_key_exists($index, $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        $items[$index] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Returns a sliced portion of the collection.
     *
     * This method returns a new instance containing a subset of the collection based on the provided offset and
     * length.
     *
     * @param int      $offset The starting index of the slice.
     * @param int|null $length The number of items to include in the slice. If null, slices to the end of the
     *                         collection.
     *
     * @return static A new instance containing the sliced portion.
     *
     * @throws InvalidArgumentException If the offset or length is negative.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $sliced = $arrh->slice(1, 3);
     * // $sliced contains ['banana', 'cherry', 'date']
     * ```
     */
    public function slice(int $offset, ?int $length = null) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset cannot be negative.');
        }

        if ($length !== null && $length < 0) {
            throw new InvalidArgumentException(message: 'Length cannot be negative.');
        }

        $slicedItems = array_slice($this->getItems(), $offset, $length, true);

        // If slicing preserves keys and you want sequential keys, reindex
        // $slicedItems = array_values($slicedItems);

        return new static(items: $slicedItems);
    }

    /**
     * Get all items in the collection.
     *
     * This method provides a complete array of all items in the collection.
     *
     * @return array The array of all items.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $allItems = $arrh->all();
     * // $allItems contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function all() : array
    {
        return $this->getItems();
    }
}

=== DataHandling/ArrayHandling/Traits/MetaInfoTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Carbon\Carbon;
use Closure;
use Exception;
use InvalidArgumentException;
use Ramsey\Uuid\Exception\UnsatisfiedDependencyException;
use Ramsey\Uuid\Uuid;

/**
 * Trait MetaInfoTrait
 *
 * Provides methods to enrich items within a collection with metadata such as GUIDs, timestamps, and version
 * information. It also offers functionality to clone the collection.
 *
 * This trait enforces the implementation of `getItems()`, `setItems()`, `map()`, and `toArray()` methods
 * in the using class to manage and transform the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait MetaInfoTrait
{
    use AbstractDependenciesTrait;
    use TransformationTrait;

    /**
     * Add a unique GUID to each item in the collection.
     *
     * This method enriches each item with a universally unique identifier (UUID) under the 'id' key.
     *
     * @return static A new instance with GUIDs added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->guid();
     * // $newArrh contains:
     * // [
     * //     ['id' => 'uuid1', 'data' => 'apple'],
     * //     ['id' => 'uuid2', 'data' => 'banana'],
     * //     ['id' => 'uuid3', 'data' => 'cherry']
     * // ]
     * ```
     */
    public function guid() : static
    {
        return $this->map(static function ($item) : array {
            try {
                return [
                    'id'   => Uuid::uuid4()->toString(),
                    'data' => $item,
                ];
            } catch (Exception $e) {
                throw new InvalidArgumentException('Failed to generate UUID: ' . $e->getMessage(), $e->getCode(), $e);
            }
        });
    }

    /**
     * Enforce the implementation of the map method.
     *
     * Classes using this trait must implement this method.
     *
     * @param Closure $callback The callback to apply to each item.
     *
     * @return static A new instance with the transformed items.
     */
    abstract public function map(Closure $callback) : static;

    /**
     * Set or retrieve timestamps for items in the collection.
     *
     * When setting, this method adds a 'timestamp' key with the current time formatted as specified.
     * When retrieving, it extracts the 'timestamp' from each item.
     *
     * @param bool   $set    True to set the current timestamp, false to retrieve.
     * @param string $format Optional date format for timestamp. Defaults to Unix timestamp ('U').
     *
     * @return static A new instance with timestamps set or retrieved.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $timestamped = $arrh->timestamp();
     * // $timestamped contains:
     * // [
     * //     ['timestamp' => 'current_timestamp', 'data' => 'apple'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'banana'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'cherry']
     * // ]
     *
     * $timestamps = $arrh->timestamp(false);
     * // $timestamps contains: ['current_timestamp', 'current_timestamp', 'current_timestamp']
     * ```
     */
    public function timestamp(bool|null $set = null, string $format = 'U') : static
    {
        $set ??= true;
        try {
            $timestamp = Carbon::now()->format($format);
        } catch (Exception $exception) {
            throw new InvalidArgumentException(
                'Invalid date format: ' . $exception->getMessage(),
                $exception->getCode(),
                $exception
            );
        }

        return $this->map(
            static function ($item) use ($set, $timestamp) {
                if ($set) {
                    return [
                        'timestamp' => $timestamp,
                        'data'      => $item,
                    ];
                }

                return $item['timestamp'] ?? null;
            }
        );
    }

    /**
     * Add version information to each item in the collection.
     *
     * This method enriches each item with a 'version' key indicating the version number.
     *
     * @param int $version Version number to assign. Defaults to 1.
     *
     * @return static A new instance with version numbers added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $versioned = $arrh->version(2);
     * // $versioned contains:
     * // [
     * //     ['version' => 2, 'data' => 'apple'],
     * //     ['version' => 2, 'data' => 'banana'],
     * //     ['version' => 2, 'data' => 'cherry']
     * // ]
     * ```
     */
    public function version(int $version = 1) : static
    {
        return $this->map(static fn($item) : array => [
            'version' => $version,
            'data'    => $item,
        ]);
    }

    /**
     * Create a deep clone of the collection.
     *
     * This method creates a new instance of the collection with a deep copy of the current items.
     *
     * @return static Cloned collection.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $cloned = $arrh->clone();
     * // $cloned is a separate instance with the same items
     * ```
     */
    public function clone() : static
    {
        return new static($this->toArray());
    }

    /**
     * Enforce the implementation of the toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The collection represented as an array.
     */
    abstract public function toArray() : array;
}

=== DataHandling/ArrayHandling/Traits/OrderManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait OrderManipulationTrait
 *
 * Provides methods to manipulate the order of arrays.
 * This trait allows sorting arrays in ascending order
 * and shuffling array elements.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait OrderManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Sort items in ascending order based on a given key.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param string|callable $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new instance with sorted items.
     *
     * @throws InvalidArgumentException If the key is a string and does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortAsc('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAscending(string|callable $key) : static
    {
        $items = $this->getItems();

        // If sorting by a string key, ensure all items are arrays and contain the key
        if (is_string($key)) {
            foreach ($items as $item) {
                if (! is_array($item) || ! array_key_exists($key, $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            usort($items, static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable($key)) {
            usort($items, $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Shuffle the items.
     *
     * This method randomizes the order of items in the collection and returns a new instance
     * with the shuffled items, ensuring immutability.
     *
     * @return static A new instance with shuffled items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $shuffled = $arrh->shuffle();
     * // $shuffled might contain ['cherry', 'apple', 'banana']
     * ```
     */
    public function shuffle() : static
    {
        $items = $this->getItems();

        // Shuffle items to randomize their order
        shuffle($items);

        // Return a new instance to preserve immutability
        return new static(items: $items);
    }
}

=== DataHandling/ArrayHandling/Traits/PartitioningTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait PartitioningTrait
 *
 * Provides methods to partition and group items within a collection.
 * This trait allows splitting collections based on conditions, grouping by keys or callbacks,
 * and dividing collections into specified numbers of groups or chunks.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait PartitioningTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Splits the collection into two groups based on a callback.
     *
     * This method partitions the collection into two separate collections:
     * one where items satisfy the provided callback condition,
     * and another where items do not.
     *
     * @param Closure $callback The callback to determine the split condition.
     *
     * @return array Two collections: one matching the condition, one not.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * [$fruitsWithA, $fruitsWithoutA] = $arrh->partition(fn($item) => strpos($item, 'a') !== false);
     * // $fruitsWithA contains ['apple', 'banana', 'date']
     * // $fruitsWithoutA contains ['cherry']
     * ```
     */
    public function partition(Closure $callback) : array
    {
        $matches    = [];
        $nonMatches = [];

        foreach ($this->getItems() as $item) {
            if ($callback($item)) {
                $matches[] = $item;
            } else {
                $nonMatches[] = $item;
            }
        }

        return [new static(items: $matches), new static(items: $nonMatches)];
    }

    /** ***Partitioning Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Groups the collection items by a specific key or callback.
     *
     * This method organizes the collection into groups based on a specified key or a callback function.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param Closure|string $key The key to group by, or a callback function to determine the group key.
     *
     * @return static A collection containing grouped items.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * // Grouping by a string key
     * $arrh = new Arrhae([
     *     ['type' => 'fruit', 'name' => 'apple'],
     *     ['type' => 'fruit', 'name' => 'banana'],
     *     ['type' => 'vegetable', 'name' => 'carrot'],
     * ]);
     * $grouped = $arrh->groupBy('type');
     * // $grouped contains:
     * // [
     * //     'fruit' => new Arrhae([
     * //         ['type' => 'fruit', 'name' => 'apple'],
     * //         ['type' => 'fruit', 'name' => 'banana'],
     * //     ]),
     * //     'vegetable' => new Arrhae([
     * //         ['type' => 'vegetable', 'name' => 'carrot'],
     * //     ]),
     * // ]
     *
     * // Grouping by a callback
     * $groupedByLength = $arrh->groupBy(fn($item) => strlen($item['name']));
     * // $groupedByLength contains:
     * // [
     * //     5 => new Arrhae([['type' => 'fruit', 'name' => 'apple']]),
     * //     6 => new Arrhae([['type' => 'fruit', 'name' => 'banana'], ['type' => 'vegetable', 'name' => 'carrot']]),
     * // ]
     * ```
     */
    public function groupBy(Closure|string $key) : static
    {
        $grouped = [];

        foreach ($this->getItems() as $item) {
            if (is_callable($key)) {
                $groupKey = $key($item);
            } elseif (is_string($key)) {
                if (! is_array($item) || ! array_key_exists($key, $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }

                $groupKey = $item[$key];
            } else {
                throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
            }

            $grouped[$groupKey][] = $item;
        }

        return new static(items: array_map(fn($group) : static => new static(items: $group), $grouped));
    }

    /**
     * Splits the collection into a specified number of groups.
     *
     * This method divides the collection into the desired number of groups as evenly as possible.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param int $numberOfGroups The number of groups to split into.
     *
     * @return static A collection containing the specified number of groups.
     *
     * @throws InvalidArgumentException If the number of groups is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $groups = $arrh->split(2);
     * // $groups contains:
     * // [
     * //     new Arrhae(['apple', 'banana', 'cherry']),
     * //     new Arrhae(['date', 'elderberry']),
     * // ]
     * ```
     */
    public function split(int $numberOfGroups) : static
    {
        if ($numberOfGroups < 1) {
            throw new InvalidArgumentException(message: 'Number of groups must be at least 1.');
        }

        $totalItems = count($this->getItems());
        $groupSize  = (int) ceil($totalItems / $numberOfGroups);
        $groups     = array_chunk($this->getItems(), $groupSize);

        return new static(items: array_map(static fn($group) : static => new static(items: $group), $groups));
    }

    /**
     * Splits the collection into chunks of a given size.
     *
     * This method divides the collection into chunks, each containing a specified number of items.
     * Each chunk is represented as a sub-collection within the main collection.
     *
     * @param int $size The size of each chunk.
     *
     * @return static A collection containing the chunks.
     *
     * @throws InvalidArgumentException If the chunk size is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $chunks = $arrh->chunk(2);
     * // $chunks contains:
     * // [
     * //     new Arrhae(['apple', 'banana']),
     * //     new Arrhae(['cherry', 'date']),
     * //     new Arrhae(['elderberry']),
     * // ]
     * ```
     */
    public function chunk(int $size) : static
    {
        if ($size < 1) {
            throw new InvalidArgumentException(message: 'Chunk size must be at least 1.');
        }

        $chunks = array_chunk($this->getItems(), $size);

        return new static(items: array_map(static fn($chunk) : static => new static(items: $chunk), $chunks));
    }
}

=== DataHandling/ArrayHandling/Traits/SetOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait SetOperationsTrait
 *
 * Provides set operations methods to manipulate collections, including intersection, union, difference, and merging.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait SetOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Return the intersection of two collections.
     *
     * This method returns a new collection containing items that are present in both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to intersect with.
     *
     * @return static A new collection with intersected items.
     *
     * @throws InvalidArgumentException If the provided collection is empty.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'cherry', 'date']);
     * $intersection = $arrh1->intersect($arrh2);
     * // $intersection contains ['banana', 'cherry']
     * ```
     */
    public function intersect(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        if (empty($otherItems)) {
            throw new InvalidArgumentException('The provided collection for intersection is empty.');
        }

        $intersected = array_intersect($currentItems, $otherItems);

        return new static($intersected);
    }

    /** ***Set Operations Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Return the union of two collections.
     *
     * This method returns a new collection containing all unique items from both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to union with.
     *
     * @return static A new collection with unique combined items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['banana', 'cherry']);
     * $union = $arrh1->union($arrh2);
     * // $union contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function union(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);
        $unique = array_unique($merged, SORT_REGULAR); // SORT_REGULAR ensures proper uniqueness for arrays

        return new static($unique);
    }

    /**
     * Return the difference of two collections.
     *
     * This method returns a new collection containing items that are present in the current collection but not in the
     * provided collection.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with items in the original but not in the compared collection.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date']);
     * $difference = $arrh1->diff($arrh2);
     * // $difference contains ['apple', 'cherry']
     * ```
     */
    public function diff(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $diff = array_diff($currentItems, $otherItems);

        return new static($diff);
    }

    /**
     * Merge two collections together.
     *
     * This method merges the current collection with the provided collection and returns a new collection containing
     * all items.
     *
     * @param self $collection The collection to merge with.
     *
     * @return static A new collection with merged items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $merged = $arrh1->merge($arrh2);
     * // $merged contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function merge(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);

        return new static($merged);
    }

    /**
     * Returns the symmetric difference of two sets.
     *
     * This method returns a new collection containing elements that are present in either the current collection or
     * the
     * provided collection, but not in both. The symmetric difference is the combination of the differences in both
     * directions between the two sets.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with the symmetric difference of elements.
     *
     * @throws InvalidArgumentException If the provided collection is invalid or contains incompatible element types.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date', 'fig']);
     * $symDifference = $arrh1->symmetricDifference($arrh2);
     * print_r($symDifference->toArray());
     * // Outputs:
     * // ['apple', 'cherry', 'date', 'fig']
     * ```
     */
    public function symmetricDifference(self $collection) : static
    {
        $diff1         = array_diff($this->getItems(), $collection->toArray());
        $diff2         = array_diff($collection->toArray(), $this->getItems());
        $symDifference = array_merge($diff1, $diff2);

        return new static($symDifference);
    }
}

=== DataHandling/ArrayHandling/Traits/SortOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait SortOperationsTrait
 *
 * Provides methods to sort and manipulate the order of items within a collection.
 * This trait allows sorting in ascending or descending order based on a key or callback,
 * reversing the order of items, and sorting by keys.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait SortOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Sort the collection in descending order based on a given key or callback.
     *
     * This method sorts the collection in descending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $sortedDesc = $arrh->sortDesc('name');
     * // $sortedDesc contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function sortDesc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key)->reverse();
    }

    /** ***Sorting Methods*** */

    /**
     * Reverse the order of the items in the collection.
     *
     * This method returns a new instance with the items in reverse order, ensuring immutability.
     *
     * @return static A new instance with the items in reverse order.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $reversed = $arrh->reverse();
     * // $reversed contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function reverse() : static
    {
        return new static(items: array_reverse($this->getItems(), true));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Sort the collection based on a given key or callback.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortBy('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortBy(Closure|string $key) : static
    {
        $sortedItems = $this->getItems();

        if (is_string($key)) {
            foreach ($sortedItems as $sortedItem) {
                if (! is_array($sortedItem) || ! array_key_exists($key, $sortedItem)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            uasort($sortedItems, static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable($key)) {
            uasort($sortedItems, $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $sortedItems);
    }

    /**
     * Sort the collection by its keys in ascending order.
     *
     * This method sorts the collection by its keys in ascending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeys = $arrh->sortKeys();
     * // $sortedKeys contains ['a' => 'apple', 'b' => 'banana', 'c' => 'cherry']
     * ```
     */
    public function sortKeys() : static
    {
        $sorted = $this->getItems();
        ksort($sorted);

        return new static(items: $sorted);
    }

    /**
     * Sort the collection by its keys in descending order.
     *
     * This method sorts the collection by its keys in descending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeysDesc = $arrh->sortKeysDesc();
     * // $sortedKeysDesc contains ['c' => 'cherry', 'b' => 'banana', 'a' => 'apple']
     * ```
     */
    public function sortKeysDesc() : static
    {
        $sorted = $this->getItems();
        krsort($sorted);

        return new static(items: $sorted);
    }

    /**
     * Sorts the collection in ascending order based on a given key or callback.
     *
     * This method sorts the collection in ascending order using the specified key or a callback function for comparing
     * elements. If the key is a string, it is expected that the collection's elements are associative arrays
     * containing the specified key. If a callback function is provided, it is used to dynamically compare elements.
     *
     * @param Closure|string $key The key to sort by or a callable function for comparison.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more elements,
     *                                  or if the provided parameter is neither a Closure nor a string.
     *
     * ```
     * // Sorting by the 'price' key in ascending order
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sortedAsc = $arrh->sortAsc('price');
     * print_r($sortedAsc->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     *
     * // Sorting using a callback function
     * $sortedAscCallback = $arrh->sortAsc(function($a, $b) {
     *     return strlen($a['name']) <=> strlen($b['name']);
     * });
     * print_r($sortedAscCallback->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAsc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key);
    }

    /**
     * Sorts the collection by multiple criteria.
     *
     * This method allows sorting by multiple keys with specified orders (ascending or descending).
     * It accepts an associative array where keys represent the attributes to sort by,
     * and values specify the sorting order (`'asc'` for ascending, `'desc'` for descending).
     *
     * @param array $criteria Associative array of sorting criteria.
     *                        Keys are the item attributes, and values are sorting orders.
     *                        Example: `['name' => 'asc', 'age' => 'desc']`.
     *
     * @return static A new collection instance sorted by the given criteria.
     *
     * ```
     * $collection = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     *     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     *     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     *     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * ]);
     *
     * // Sort by name (ascending), then by age (ascending), and then by score (descending).
     * $sortedCollection = $collection->sortByMultiple([
     *     'name' => 'asc',
     *     'age' => 'asc',
     *     'score' => 'desc',
     * ]);
     *
     * // Result:
     * // [
     * //     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     * //     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     * //     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     * //     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * // ]
     * ```
     */
    public function sortByMultiple(array $criteria) : static
    {
        $items = $this->getItems();
        usort($items, static function (array $a, array $b) use ($criteria) : int {
            foreach ($criteria as $key => $order) {
                $result = $a[$key] <=> $b[$key];
                if ($result !== 0) {
                    return $order === 'desc' ? -$result : $result;
                }
            }

            return 0;
        });

        return new static(items: $items);
    }
}

=== DataHandling/ArrayHandling/Traits/StringManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StringManipulationTrait
 *
 * Provides advanced string manipulation capabilities to the Arrhae class, including
 * concatenation, case transformation, trimming, replacing, and more.
 */
trait StringManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Defines the default characters to be trimmed.
     */
    private const string DEFAULT_TRIM_CHARACTERS = " \t\n\r\0\x0B";

    /**
     * Concatenates the items of the collection into a string using a glue string.
     *
     * @param string $glue The string to use between items. Defaults to an empty string.
     *
     * @return string The concatenated string.
     *
     * @throws InvalidArgumentException If the collection contains non-string items.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana', 'cherry']);
     * echo $arrh->implode(', '); // Output: 'apple, banana, cherry'
     */
    public function implode(string $glue = '') : string
    {
        // Ensure all items are strings
        foreach ($this->getItems() as $item) {
            if (! is_string($item)) {
                throw new InvalidArgumentException(message: 'All items must be strings to perform implode.');
            }
        }

        return implode($glue, $this->getItems());
    }

    /**
     * Converts all string items in the collection to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to uppercase.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana']);
     * $uppercased = $arrh->uppercase();
     * // ['APPLE', 'BANANA']
     */
    public function uppercase(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => strtoupper($value), key: $key);
    }

    /**
     * A helper method to process items within the collection and apply string transformations.
     *
     * @param callable    $callback The transformation to apply to string items.
     * @param string|null $key      The key to target within associative arrays if applicable.
     *
     * @return static A new Arrhae instance with processed items.
     */
    private function processItems(callable $callback, ?string $key = null) : static
    {
        return $this->map(callback: function ($item) use ($callback, $key) {
            if ($key !== null && is_array($item) && isset($item[$key]) && is_string($item[$key])) {
                $item[$key] = $callback($item[$key]);

                return $item;
            }

            if (is_string($item)) {
                return $callback($item);
            }

            return $item;
        });
    }

    /**
     * Converts all string items in the collection to lowercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to lowercase.
     *
     * @example
     * $arrh = Arrhae::make(['APPLE', 'BANANA']);
     * $lowercased = $arrh->lowercase();
     * // ['apple', 'banana']
     */
    public function lowercase(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => strtolower($value), key: $key);
    }

    /**
     * Converts the first character of each word in the string items to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to the title case.
     *
     * @example
     * $arrh = Arrhae::make(['hello world', 'php is great']);
     * $titlecased = $arrh->title();
     * // ['Hello World', 'Php Is Great']
     */
    public function title(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => ucwords(strtolower($value)), key: $key);
    }

    /**
     * Removes whitespace or other predefined characters from the beginning and end of string items.
     *
     * @param string      $characters The characters to trim. Defaults to trimming common whitespace characters.
     * @param string|null $key        The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items trimmed.
     *
     * @example
     * $arrh = Arrhae::make([' apple  ', "\tbanana\n", ' cherry ']);
     * $trimmed = $arrh->trim();
     * // ['apple', 'banana', 'cherry']
     */
    public function trim(string $characters = self::DEFAULT_TRIM_CHARACTERS, ?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => trim($value, $characters), key: $key);
    }

    /**
     * Converts string items in the collection to camelCase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to camelCase.
     *
     * @example
     * $arrh = Arrhae::make(['hello_world', 'php-is-great', 'convert this']);
     * $camelCased = $arrh->camelCase();
     * // ['helloWorld', 'phpIsGreat', 'convertThis']
     */
    public function camelCase(?string $key = null) : static
    {
        return $this->processItems(
            callback: fn(string $value) : string => lcfirst(
                str_replace(' ', '', ucwords(str_replace(['-', '_'], ' ', $value)))
            ),
            key     : $key
        );
    }
}
=== DataHandling/ArrayHandling/Traits/StructureConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StructureConversionTrait
 *
 * Provides methods to convert the structure of collections,
 * including flattening multidimensional arrays into dot-notated arrays
 * and converting collections to indexed lists.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait StructureConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multidimensional collection into a dot-notated array.
     *
     * Dot notation represents nested elements in a flat structure with keys such as "key.subkey".
     * This method returns a new instance with flattened keys and corresponding values.
     *
     * @return static A new instance with dot-notated keys and values.
     *
     * @throws InvalidArgumentException If the collection contains non-array nested items.
     *
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'address' => [
     *             'street' => '123 Main St',
     *             'city' => 'Anytown'
     *         ]
     *     ],
     *     'status' => 'active'
     * ]);
     * $flattened = $arrh->dot();
     * // $flattened contains:
     * // [
     * //     'user.name' => 'John Doe',
     * //     'user.address.street' => '123 Main St',
     * //     'user.address.city' => 'Anytown',
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function dot() : static
    {
        $results = [];
        $flatten = static function (array $items, string $prefix = '') use (&$flatten, &$results) : void {
            foreach ($items as $key => $value) {
                if (! is_scalar($key) && ! is_null($key)) {
                    throw new InvalidArgumentException(message: 'Keys must be scalar or null.');
                }

                $dotKey = $prefix . $key;
                if (is_array($value)) {
                    $flatten($value, $dotKey . '.');
                } else {
                    $results[$dotKey] = $value;
                }
            }
        };

        $items = $this->getItems();
        if (! is_array($items)) {
            throw new InvalidArgumentException(
                message: 'The collection must be an array to perform dot notation flattening.'
            );
        }

        $flatten(items: $items);

        return new static(items: $results);
    }

    /** ***Design Conversion Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Converts the collection to a list (indexed array).
     *
     * This method returns only the values, disregarding the keys.
     * It returns a new instance containing an indexed list of the original values.
     *
     * @return static A new instance with an indexed list of array values.
     *
     * ```
     * $arrh = new Arrhae(['first' => 'apple', 'second' => 'banana', 'third' => 'cherry']);
     * $list = $arrh->toList();
     * // $list contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function toList() : static
    {
        $list = array_values($this->getItems());

        return new static(items: $list);
    }

    /**
     * Reconstruct a dot-notated array back into a multidimensional array.
     *
     * This method reverses the flattening process, restoring the original multidimensional structure.
     *
     * @return static A new instance with the original multidimensional array structure.
     *
     * ```
     * $flattened = new Arrhae([
     *     'user.name' => 'John Doe',
     *     'user.address.street' => '123 Main St',
     *     'user.address.city' => 'Anytown',
     *     'status' => 'active'
     * ]);
     * $original = $flattened->unDot();
     * // $original contains:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'address' => [
     * //             'street' => '123 Main St',
     * //             'city' => 'Anytown'
     * //         ]
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function unDot() : static
    {
        $results = [];
        foreach ($this->getItems() as $dotKey => $item) {
            $keys = explode('.', (string) $dotKey);
            $temp = &$results;
            foreach ($keys as $key) {
                if (! isset($temp[$key]) || ! is_array($temp[$key])) {
                    $temp[$key] = [];
                }

                $temp = &$temp[$key];
            }

            $temp = $item;
            unset($temp);
        }

        return new static($results);
    }
}

=== DataHandling/ArrayHandling/Traits/TransformationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;
use RecursiveArrayIterator;
use RecursiveIteratorIterator;

/**
 * Trait TransformationTrait
 *
 * Provides methods to transform the structure of collections,
 * including flattening multidimensional arrays, applying callbacks,
 * and mapping with custom keys.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait TransformationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multi-dimensional array into a single-dimensional array.
     *
     * This method recursively flattens a multi-dimensional array into a single-dimensional
     * array, disregarding the original keys.
     *
     * @return static A new instance with the flattened array.
     *
     * @throws InvalidArgumentException If the collection is not an array.
     *
     * ```
     * $arrh = new Arrhae([
     *     'fruits' => ['apple', 'banana'],
     *     'vegetables' => ['carrot', 'lettuce'],
     *     'dairy' => 'milk'
     * ]);
     * $flattened = $arrh->flatten();
     * // $flattened contains:
     * // ['apple', 'banana', 'carrot', 'lettuce', 'milk']
     * ```
     */
    public function flatten() : static
    {
        $items = $this->getItems();
        if (! is_array($items)) {
            throw new InvalidArgumentException(message: 'The collection must be an array to perform flattening.');
        }

        $iterator  = new RecursiveIteratorIterator(iterator: new RecursiveArrayIterator(array: $items));
        $flattened = [];

        foreach ($iterator as $value) {
            $flattened[] = $value;
        }

        return new static(items: $flattened);
    }


    /** ***Transformation Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Apply a callback to each item and flatten the results into a single array.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an array, and the results are merged into a single, flattened array.
     *
     * @param Closure $callback The callback to apply. It should return an array for each item.
     *
     * @return static A new instance with the mapped and flattened array.
     *
     * @throws InvalidArgumentException If the callback does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $flatMapped = $arrh->flatMap(function($item) {
     *     return [$item, strtoupper($item)];
     * });
     * // $flatMapped contains ['apple', 'APPLE', 'banana', 'BANANA', 'cherry', 'CHERRY']
     * ```
     */
    public function flatMap(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $item) {
            $result = $callback($item);
            if (! is_array($result)) {
                throw new InvalidArgumentException(message: 'The callback for flatMap must return an array.');
            }

            $mapped = array_merge($mapped, $result);
        }

        return new static(items: $mapped);
    }

    /**
     * Apply a callback to each item, using returned keys as the new array keys.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an associative array with a single key-value pair, where the key becomes
     * the new key in the resulting collection.
     *
     * @param Closure $callback The callback to apply. It should return an associative array with one key-value pair.
     *
     * @return static A new instance with mapped keys and values.
     *
     * @throws InvalidArgumentException If the callback does not return an associative array with one key-value pair.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $mappedWithKeys = $arrh->mapWithKeys(function($item, $key) {
     *     return [$item => strlen($item)];
     * });
     * // $mappedWithKeys contains ['apple' => 5, 'banana' => 6, 'cherry' => 6]
     * ```
     */
    public function mapWithKeys(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $key => $item) {
            $result = $callback($item, $key);
            if (! is_array($result) || count($result) !== 1) {
                throw new InvalidArgumentException(
                    message: 'The callback for mapWithKeys must return an associative array with exactly one key-value pair.'
                );
            }

            $newKey   = key($result);
            $newValue = reset($result);
            if (array_key_exists($newKey, $mapped)) {
                throw new InvalidArgumentException(
                    message: sprintf("Duplicate key '%s' returned by mapWithKeys callback.", $newKey)
                );
            }

            $mapped[$newKey] = $newValue;
        }

        return new static(items: $mapped);
    }

    /**
     * Transform the current items using a callback.
     *
     * This method applies the provided callback to each item in the collection and returns
     * a new instance with the transformed items, ensuring immutability.
     *
     * @param Closure $callback The callback to apply.
     *
     * @return static A new instance with transformed items.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $transformed = $arrh->transform(function($item) {
     *     return $item * 2;
     * });
     * // $transformed contains [2, 4, 6]
     * ```
     */
    public function transform(Closure $callback) : static
    {
        $transformedItems = array_map($callback, $this->getItems());

        return new static(items: $transformedItems);
    }

    /**
     * Apply a complex transformation using SPL iterators.
     *
     * This method allows applying a callback to each element during iteration,
     * enabling complex transformations beyond simple mapping.
     *
     * @param Closure $callback The callback to apply to each element.
     *
     * @return static A new instance with the transformed collection.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * @example
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'age' => 30
     *     ],
     *     'status' => 'active'
     * ]);
     * $advancedTransformed = $arrh->advancedTransform(function($value, $key) {
     *     if ($key === 'age') {
     *         return $value + 1; // Increment age by 1
     *     }
     *     return $value;
     * });
     * print_r($advancedTransformed->toArray());
     * // Outputs:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'age' => 31
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function advancedTransform(Closure $callback) : static
    {
        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveArrayIterator(array: $this->getItems()),
            mode    : RecursiveIteratorIterator::CHILD_FIRST
        );

        $transformed = $this->getItems();

        foreach ($iterator as $key => $value) {
            if (! is_array($value)) {
                $transformed[$key] = $callback($value, $key);
            }
        }

        return new static(items: $transformed);
    }
}

=== DataHandling/Cache/ReflectionCache.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Cache;

use ReflectionClass;

class ReflectionCache
{
    private static array $reflectionCache = [];

    /**
     * @throws \ReflectionException
     */
    public static function getReflectionClass(string $dtoClass) : ReflectionClass
    {
        return self::$reflectionCache[$dtoClass] ??= new ReflectionClass(objectOrClass: $dtoClass);
    }
}

=== DataHandling/ObjectHandling/Collections/BaseCollection.php ===
<?php

/** @noinspection PhpMemberCanBePulledUpInspection */

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Closure;
use Traversable;

/**
 * BaseCollection provides an abstract foundation for collections,
 * handling core functionalities and item storage while leaving specific collection behaviors to subclasses.
 *
 * This class is designed to be extended, providing common methods
 * that can be used by all types of collections.
 */
abstract class BaseCollection implements CollectionInterface
{
    /**
     * @var array Holds the items of the collection.
     * Using a protected array allows subclasses to access and manipulate the stored items directly.
     */
    protected array $items = [];

    /**
     * BaseCollection constructor.
     * Initializes the collection with the provided items.
     *
     * By accepting any iterable type, this constructor ensures flexibility in initializing the collection.
     *
     * @param iterable $items Initial items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Convert various types of inputs to an array.
     *
     * Ensures compatibility regardless of the input type,
     * whether it's an instance of self, Traversable, or an array.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array
    {
        if ($items instanceof self) {
            return $items->all();
        }

        if ($items instanceof Traversable) {
            return iterator_to_array($items);
        }

        return (array) $items;
    }

    /**
     * Retrieve all items in the collection.
     *
     * Provides a consistent way to access all the items stored in the collection.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return $this->getItems();
    }

    /**
     * Abstract method to retrieve the internal items.
     * To be implemented by subclasses.
     *
     * Forces each subclass to define how items should be retrieved,
     * allowing for flexibility in different types of collections.
     *
     * @return array The items in the collection.
     */
    abstract public function getItems() : array;

    /**
     * Abstract method to set the internal items.
     * To be implemented by subclasses.
     *
     * Ensures that subclasses handle the specific logic for setting the items,
     * which can vary based on the type of collection.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Get an iterator for the collection.
     *
     * Supports iteration over the collection using foreach.
     *
     * @return Traversable An iterator over the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->getItems());
    }

    /**
     * Get the count of items in the collection.
     *
     * Provides a quick way to determine how many items are currently in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int
    {
        return count($this->getItems());
    }

    /**
     * Convert the collection to an array for JSON serialization.
     *
     * Ensures that when the collection is JSON-encoded, it gets correctly represented as an array.
     *
     * @return array Data ready for JSON serialization.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Recursively converts nested collections to arrays.
     *
     * Handles nested collections to ensure they are also converted to arrays,
     * preserving the structure when serialized or manipulated.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array
    {
        return array_map(fn($item) => $item instanceof self ? $item->toArray() : $item, $this->getItems());
    }

    // Abstract methods to be implemented by subclasses for specific functionalities

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|CollectionInterface $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function merge(array|CollectionInterface $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function tap(Closure $callback) : static;
}

=== DataHandling/ObjectHandling/Collections/CollectionInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\Collections;

use ArrayAccess;
use Closure;
use Countable;
use IteratorAggregate;
use JsonSerializable;

/**
 * CollectionInterface serves as a contract for collection operations that
 * supports various interfaces such as Countable, ArrayAccess, IteratorAggregate,
 * and JsonSerializable. This ensures a standardized way to manipulate
 * collections across the application.
 */
interface CollectionInterface extends Countable, ArrayAccess, IteratorAggregate, JsonSerializable
{
    /**
     * Retrieve all items in the collection.
     *
     * @return array All items in the collection.
     */
    public function all() : array;

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|self $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function merge(array|self $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function tap(Closure $callback) : static;

    /**
     * Convert the collection to an array.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array;

    /**
     * Get the count of items in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int;

    /**
     * Convert various types of inputs to an array.
     * This accommodates different forms of collection items.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array;

    /**
     * Find the first item in the collection where a given key has a specific value.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value of the key.
     *
     * @return mixed The first item matching the criteria.
     */
    public function firstWhere(string $key, mixed $value) : mixed;

    /**
     * Find the maximum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The maximum value.
     */
    public function max(string|null $key = null) : mixed;

    /**
     * Find the minimum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The minimum value.
     */
    public function min(string|null $key = null) : mixed;

    /**
     * Calculate the mode (most frequent value) for a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for determining mode of the whole item.
     *
     * @return string|int|null The mode value, or null if no mode is found.
     */
    public function mode(string|null $key = null) : string|int|null;

    /**
     * Count items in the collection based on the given closure.
     *
     * @param Closure $callback The closure to determine the count criteria.
     *
     * @return static The collection instance, enabling method chaining.
     */
    public function countBy(Closure $callback) : static;
}

=== DataHandling/ObjectHandling/Collections/Collection.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Closure;
use Gemini\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Gemini\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\DebugTrait;
use Gemini\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Gemini\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\TransformationTrait;
use Traversable;

/**
 * Collection class providing utilities for array manipulations.
 * Combines traits to enable sorting, filtering, partitioning, and more.
 */
class Collection extends BaseCollection implements CollectionInterface
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;

    /**
     * Internal storage for collection items specific to Collection.
     */
    protected array $elements = [];

    /**
     * Collection constructor.
     *
     * Initializes the collection with an optional set of items.
     *
     * @param iterable $items Initial set of items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        parent::__construct(items: $items);
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Set the internal elements array.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    public function setItems(iterable $items) : static
    {
        $this->elements = $items;

        return $this;
    }

    /**
     * Invokes a callback on the collection and returns the collection itself.
     *
     * Useful for debugging and inspection without altering chainability.
     *
     * @param Closure $callback The callback to execute.
     *
     * @return static The current collection instance for method chaining.
     */
    public function tap(Closure $callback) : static
    {
        $callback($this);

        return $this;
    }

    /**
     * Retrieves the first item that matches a given key-value pair.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value to compare against.
     *
     * @return mixed|null The first matching item or null if not found.
     */
    public function firstWhere(string $key, mixed $value) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (($item[$key] ?? null) === $value) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Get the internal elements array.
     *
     * @return array The elements in the collection.
     */
    public function getItems() : array
    {
        return $this->elements;
    }

    /**
     * Determine the maximum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The maximum value or null if the collection is empty.
     */
    public function max(string|null $key = null) : mixed
    {
        return max(
            array_map(
                static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                $this->getItems(),
            ),
        );
    }

    /**
     * Determine the minimum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The minimum value or null if the collection is empty.
     */
    public function min(string|null $key = null) : mixed
    {
        return min(
            array_map(
                static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                $this->getItems(),
            ),
        );
    }

    /**
     * Determine the mode (most frequent value) in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return string|int|null The mode or null if the collection is empty.
     */
    public function mode(string|null $key = null) : string|int|null
    {
        $counts = array_count_values(
            array_map(
                static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                $this->getItems(),
            ),
        );
        arsort($counts);

        return array_key_first($counts);
    }

    /**
     * Count items in the collection based on a given callback.
     *
     * @param Closure $callback The callback to determine the key for counting.
     *
     * @return static A new collection containing count values.
     */
    public function countBy(Closure $callback) : static
    {
        $counts = [];
        foreach ($this->getItems() as $item) {
            $key          = $callback($item);
            $counts[$key] = ($counts[$key] ?? 0) + 1;
        }

        return new static($counts);
    }

    /**
     * Appends a value to the end of the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static The current collection instance for method chaining.
     */
    public function append(mixed $value) : static
    {
        $this->elements[] = $value;

        return $this;
    }

    /**
     * Prepends a value to the beginning of the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static The current collection instance for method chaining.
     */
    public function prepend(mixed $value) : static
    {
        array_unshift($this->elements, $value);

        return $this;
    }

    /**
     * Merges the collection with another collection or array.
     *
     * Supports merging arrays or other collections seamlessly.
     *
     * @param CollectionInterface|array $items The items to merge.
     *
     * @return static The current collection instance for method chaining.
     */
    public function merge(CollectionInterface|array $items) : static
    {
        $mergedItems = array_merge($this->getItems(), is_array($items) ? $items : $items->all());
        $this->setItems(items: $mergedItems);

        return $this;
    }

    /**
     * Returns the count of items in the collection.
     *
     * @return int The number of items in the collection.
     */
    public function count() : int
    {
        return count($this->getItems());
    }

    /**
     * Returns an iterator for the collection.
     *
     * @return Traversable An iterator for the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator($this->getItems());
    }
}

=== DataHandling/ObjectHandling/Collections/Exceptions/ItemNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\Collections\Exceptions;

use Exception;

/**
 * Exception thrown when a specified item is not found in the collection.
 *
 * This exception is used to signal cases where an operation expected a specific
 * item to be available in the collection, but it wasn't found. It simplifies
 * error handling across the application by providing a specific exception type
 * for missing items, allowing for cleaner and more specific catch blocks.
 */
class ItemNotFoundException extends Exception
{
    /**
     * The default exception message indicating the item was not found.
     *
     * This message is pre-set to provide a consistent error message throughout
     * the application whenever an item is missing from a collection, avoiding
     * the need to define a message each time this exception is thrown.
     *
     * @var string
     */
    protected $message = 'The specified item was not found in the collection.';
}

=== DataHandling/ObjectHandling/Collections/LazyCollection.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\Collections;

use Gemini\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Closure;
use Traversable;

/**
 * Class LazyCollection
 *
 * This class represents a collection with lazy evaluation, where items are generated on the fly.
 * The primary benefit is memory efficiency, especially for large datasets.
 */
class LazyCollection extends Collection
{
    use LazyEvaluationTrait;

    /**
     * LazyCollection constructor.
     *
     * @param Closure $generator A generator function to build the collection lazily.
     */
    public function __construct(protected Closure $generator)
    {
        parent::__construct();
    }

    /**
     * Retrieve all items in the collection as an array.
     *
     * Converts the lazy-loaded items into a straightforward array.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return iterator_to_array($this->getIterator());
    }

    /**
     * Get an iterator for the collection.
     *
     * This method facilitates the lazy evaluation by returning the generator.
     *
     * @return Traversable The generator yielding items of the collection.
     */
    public function getIterator() : Traversable
    {
        return ($this->generator)();
    }

    /**
     * Get every nth item in the collection.
     *
     * This method is useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved.
     *
     * @return static A new lazy collection containing every nth item.
     */
    public function nth(int $step) : static
    {
        return new static(generator: function () use ($step) {
            $index = 0;
            foreach ($this->getIterator() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection while the callback returns true.
     *
     * This allows conditional data processing where items are taken as long as a condition holds.
     *
     * @param Closure $callback The condition used to continue taking items.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(generator: function () use ($callback) {
            foreach ($this->getIterator() as $item) {
                if (! $callback($item)) {
                    break;
                }

                yield $item;
            }
        });
    }
}

=== DataHandling/ObjectHandling/DTO/AbstractDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\Traits\CastsTypes;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\HandlesAttributes;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\HandlesHydration;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\InspectsProperties;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\Serialization;

/**
 * Base abstract class for Data Transfer Objects (DTOs).
 *
 * This class provides the foundational structure for Data Transfer Objects within the application.
 * It is responsible for implementing shared behavior and logic such as:
 *
 * - Hydration from associative arrays.
 * - Property casting based on defined types.
 * - Attribute handling and lifecycle interactions.
 * - Inspection of available properties.
 * - Efficient serialization for DTO representations.
 *
 * The use of traits ensures a modular and reusable design, promoting separation of concerns.
 */
abstract class AbstractDTO
{
    /**
     * Include the `HandlesHydration` trait.
     *
     * Provides functionality for mapping external data (like arrays) into object properties.
     */
    use HandlesHydration;

    /**
     * Include the `CastsTypes` trait.
     *
     * Enables strict casting of properties into specified types, ensuring type safety when working
     * with data.
     */
    use CastsTypes;

    /**
     * Include the `HandlesAttributes` trait.
     *
     * Adds methods to manipulate and interact with internal object attributes dynamically.
     */
    use HandlesAttributes;

    /**
     * Include the `InspectsProperties` trait.
     *
     * Adds utilities to inspect the state of object properties during runtime, allowing access to
     * their metadata or dynamic availability checks.
     */
    use InspectsProperties;

    /**
     * Include the `Serialization` trait.
     *
     * Defines methods for serializing and deserializing object data to formats like arrays or JSON,
     * ensuring compatibility with external systems.
     */
    use Serialization;

    /**
     * Constructor with array hydration capability.
     *
     * Constructs a new instance of the Data Transfer Object (DTO) from an array of data.
     * This constructor leverages the `HandlesHydration` trait to populate DTO properties
     * with data provided in the array.
     *
     * @param array $data The associative array containing the initial properties of the DTO.
     *
     * @throws \ReflectionException If reflection fails to evaluate class or property metadata during hydration.
     */
    public function __construct(array $data)
    {
        // Hydrate the object with the given data array.
        $this->hydrateFrom($data);
    }
}
=== DataHandling/ObjectHandling/DTO/DTOValidationException.php ===
<?php

declare(strict_types=1); // Strict type declarations to enforce type safety and ensure predictable behavior of code.

namespace Gemini\DataHandling\ObjectHandling\DTO;

use InvalidArgumentException;

/**
 * DTOValidationException
 *
 * This final exception class is specifically designed to encapsulate multiple
 * validation errors when dealing with Data Transfer Objects (DTOs).
 *
 * As part of Domain-Driven Design (DDD), this exception helps to clearly define
 * validation-related errors, thereby enhancing the domain layer's adherence to constraints
 * and encapsulating the behavior required to handle such errors.
 *
 * Extends:
 *  - InvalidArgumentException: This base exception aligns with the concept of invalid
 *    arguments being passed to a DTO during validation, enhancing semantic meaning.
 */
final class DTOValidationException extends InvalidArgumentException
{
    /**
     * A collection of validation errors.
     *
     * This property holds an associative array containing validation error messages,
     * where the key represents the invalid field name, and the value represents
     * the reason or detailed validation error message.
     *
     * The `readonly` contract ensures immutability of this object property after construction,
     * adhering to clean code principles for simple and predictable objects.
     *
     * @var array<string, string> An associative array where the keys are field names,
     *                            and the values are validation error messages.
     */
    public readonly array $errors;

    /**
     * Constructs a new DTOValidationException.
     *
     * Leverages constructor promotion for leaner and more expressive class construction
     * while ensuring appropriate validation messages and errors are encapsulated.
     *
     * @param string                $message A detailed exception message providing context about the DTO validation
     *                                       failure.
     * @param array<string, string> $errors  Associative array of validation errors, with keys as field names
     *                                       and values as corresponding messages explaining the validation failure.
     */
    public function __construct(
        string $message,
        array  $errors,
    ) {
        $formattedErrors = [];

        foreach ($errors as $field => $errorMsg) {
            $formattedErrors[] = sprintf('%s: %s', $field, $errorMsg);
        }

        $message .= "\n" . implode("\n", $formattedErrors);

        parent::__construct(message: $message);
        $this->errors = $errors;
    }


    public function jsonSerialize() : array
    {
        return [
            'error'  => $this->getMessage(),
            'fields' => $this->getErrors(),
        ];
    }

    /**
     * Retrieves the collection of validation errors.
     *
     * This method provides read-only access to the `errors` property containing detailed
     * validation error information for the failed DTO attributes or fields.
     *
     * Keeping this method focused and simple aligns with the principles of clean code
     * by facilitating immutability and enforcing predictable behavior.
     *
     * @return array<string, string> Returns an associative array of validation errors, where the
     *                               keys represent the invalid fields or attributes, and the values
     *                               detail the validation issues.
     */
    public function getErrors() : array
    {
        // Return the immutably defined validation error details to the caller.
        return $this->errors;
    }

}
=== DataHandling/ObjectHandling/DTO/Support/PropertyMetadata.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Support;

use ReflectionAttribute;
use ReflectionProperty;

final class PropertyMetadata
{
    public function __construct(
        public readonly string             $name,
        public readonly ReflectionProperty $property,
        /** @var array<ReflectionAttribute> */
        public readonly array              $attributes,
    ) {}

    /**
     * Checks whether the property has an explicit type.
     */
    public function isTyped() : bool
    {
        return $this->property->hasType();
    }

    /**
     * Checks whether the property is nullable.
     */
    public function isNullable() : bool
    {
        $type = $this->property->getType();

        return $type?->allowsNull() ?? true;
    }

    /**
     * Returns true if at least one attribute matches the given FQCN (case-sensitive).
     */
    public function hasAttribute(string $fqcn) : bool
    {
        return $this->property->getAttributes($fqcn) !== [];
    }

    /**
     * Instantiates all attributes.
     *
     * @return object[] List of attribute instances.
     */
    public function instantiateAttributes() : array
    {
        return array_map(
            static fn(ReflectionAttribute $attr) => $attr->newInstance(),
            $this->attributes
        );
    }
}

=== DataHandling/ObjectHandling/DTO/Support/Reflector.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Support;

use Gemini\DataHandling\ObjectHandling\DTO\DTOValidationException;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\CastsTypes;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\HandlesAttributes;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\InspectsProperties;
use Gemini\DataHandling\ObjectHandling\DTO\Traits\Serialization;
use InvalidArgumentException;
use ReflectionClass;
use ReflectionException;
use ReflectionProperty;
use Throwable;

/**
 * A utility class for handling deep reflection-based operations on DTOs.
 *
 * This class provides functionality for manipulating, inspecting, and hydrating
 * Data Transfer Objects (DTOs) through reflection, while maintaining domain and type safety.
 *
 * ### Key Responsibilities:
 * - Hydration of DTO properties with strict validation and error reporting.
 * - Reflection and inspection of public properties and their metadata.
 * - Handling complex business rules through attributes and type casting.
 *
 * @final This class is immutable in its implementation and should not be extended.
 */
final class Reflector
{
    /**
     * Use traits that modularize reflection-based behaviors.
     * - `InspectsProperties`: Adds the ability to inspect DTO object's properties.
     * - `CastsTypes`: Handles casting raw values to expected types as part of hydration.
     * - `HandlesAttributes`: Processes and applies custom attribute-based rules on properties.
     * - `Serialization`: Offers serialization support for the DTO.
     */
    use InspectsProperties;
    use CastsTypes;
    use HandlesAttributes;
    use Serialization;

    /**
     * The target object being reflected and operated on.
     *
     * This object is the primary reference for all reflection-based operations
     * such as property inspection, hydration, and serialization.
     *
     * @var object The DTO or object being managed by this reflector.
     */
    private object $target;

    /**
     * Constructs a Reflector instance and initializes it with a target object.
     *
     * Follows constructor promotion for lean and expressive initialization.
     *
     * @param object $target The target object for reflection and operations.
     */
    public function __construct(object $target)
    {
        $this->target = $target;
    }

    /**
     * Creates a Reflector instance for a specific object instance.
     *
     * This factory method enables a fluent and semantic API for initializing
     * a Reflector from an existing object.
     *
     * @param object $instance The object instance being wrapped by the reflector.
     *
     * @return self Returns a new Reflector instance.
     */
    public static function fromInstance(object $instance) : self
    {
        return new self(target: $instance);
    }

    /**
     * Creates a Reflector instance for a given class name.
     *
     * Uses `ReflectionClass` to instantiate the object without calling its constructor,
     * allowing flexibility for reflection-based object construction and hydration.
     *
     * @param string $className The fully qualified class name of the target object.
     *
     * @return self Returns a new Reflector instance wrapping the created object.
     * @throws ReflectionException If the provided class does not exist or cannot be instantiated.
     *
     */
    public static function fromClass(string $className) : self
    {
        return new self(target: (new ReflectionClass(objectOrClass: $className))->newInstanceWithoutConstructor());
    }

    /**
     * Hydrates the target object with the provided raw data.
     *
     * Iterates over the public properties of the target object and applies the
     * given raw data to each property. Attributes and type safety rules are
     * respected during the process, ensuring that all DTO constraints are enforced.
     *
     * @param array<string, mixed> $data An associative array mapping property names
     *                                   to their corresponding values.
     *
     * @throws DTOValidationException If hydration fails due to validation or type casting errors.
     * @throws ReflectionException    If reflection operations encounter an issue.
     */
    public function hydrate(array $data) : void
    {
        // Initialize an empty array to collect errors during the hydration process.
        $errors = [];

        // Iterate through all public fields of the target object.
        foreach ($this->reflectPublicFields() as $meta) {
            try {
                // Attempt to hydrate the given field using the metadata and data provided.
                $this->hydrateField(
                    name      : $meta->name,
                    property  : $meta->property,
                    attributes: $meta->attributes,
                    data      : $data
                );
            } catch (Throwable $exception) {
                // Capture and format any errors that occur during hydration.
                $errors[$meta->name] = $this->formatHydrationError(
                    fieldName: $meta->name,
                    exception: $exception
                );
            }
        }

        // If any errors occurred during hydration, throw a validation exception.
        if (! empty($errors)) {
            throw new DTOValidationException(
                message: 'DTO hydration failed.',
                errors : $errors
            );
        }
    }

    /**
     * Populates a specific field of the target object with a value from the data array.
     *
     * The method validates the presence of the field in the raw data, handles type casting,
     * and applies any field-specific attributes before assigning the final value.
     *
     * @param string             $name       The name of the property being hydrated.
     * @param ReflectionProperty $property   The reflection of the target property.
     * @param array              $attributes An array of attributes applied to the property.
     * @param array              $data       The raw input data used for hydration.
     */
    private function hydrateField(
        string             $name,
        ReflectionProperty $property,
        array              $attributes,
        array              $data
    ) : void {
        // If the field is not present in the data array, handle it as missing.
        if (! array_key_exists($name, $data)) {
            $this->handleMissingField(name: $name, property: $property);

            return;
        }

        // Extract the raw value corresponding to the field.
        $rawValue = $data[$name];

        // Cast the raw value to the expected type of the property.
        $resolvedValue = $this->castToExpectedType(property: $property, value: $rawValue);

        // Apply attribute-specific rules or transformations to the field value.
        $resolvedValue = $this->applyFieldAttributes(
            fieldName : $name,
            value     : $resolvedValue,
            attributes: $attributes
        );

        // Assign the resolved value to the corresponding property of the target object.
        $this->target->{$name} = $resolvedValue;
    }

    /**
     * Handles cases where required data for a field is missing.
     *
     * This method sets default values or null based on the property's attributes
     * or throws an exception if the property is mandatory and cannot be resolved.
     *
     * @param string             $name     The name of the missing property.
     * @param ReflectionProperty $property The reflection of the target property.
     *
     * @throws InvalidArgumentException If no suitable value is found for the missing property.
     */
    private function handleMissingField(string $name, ReflectionProperty $property) : void
    {
        // If the property is nullable, assign a null value to the field.
        if ($this->isPropertyNullable(property: $property)) {
            $this->target->{$name} = null;

            return;
        }

        // If the property has a default value, assign it to the field.
        if ($property->hasDefaultValue()) {
            $this->target->{$name} = $property->getDefaultValue();

            return;
        }

        // Throw an exception when no suitable value is available for the property.
        throw new InvalidArgumentException(message: "Missing required field: {$name}");
    }

    /**
     * Formats detailed error messages for failed hydration of a single field.
     *
     * @param string    $fieldName The name of the field where hydration failed.
     * @param Throwable $exception The exception that occurred during hydration.
     *
     * @return string Returns a string describing the error with the field's name and exception message.
     */
    private function formatHydrationError(string $fieldName, Throwable $exception) : string
    {
        return sprintf(
            '%s → Field "%s": %s',
            $this->target::class,
            $fieldName,
            $exception->getMessage()
        );
    }

    /**
     * Retrieves the target object being operated on by the Reflector.
     *
     * @return object The target object.
     */
    public function getTarget() : object
    {
        return $this->target;
    }

    /**
     * Converts the public properties of a target object into a schema-friendly array format.
     *
     * This method inspects the metadata of all public fields in the object,
     * including property type, nullability, and attributes,
     * and formats this data into an array representation.
     *
     * @return array An array representing the schema of the object's public fields.
     * @throws \ReflectionException If reflection operations encounter an error.
     */
    public function toSchema() : array
    {
        // Apply a transformation to each metadata entry from reflectPublicFields().
        // The resulting array will contain a schema representation for each public property.
        return array_map(
            fn($meta) => [
                // Add the property name to the schema array.
                'name'       => $meta->name,

                // Add the property type to the schema array. If no type is defined, default to 'mixed'.
                'type'       => $meta->property->getType()?->getName() ?? 'mixed',

                // Add the nullability information of the property to the schema array.
                'nullable'   => $meta->isNullable(),

                // Map the attributes of the property to their names and add them to the schema array.
                'attributes' => array_map(fn($a) => $a->getName(), $meta->attributes),
            ],

            // Retrieve metadata for all public fields of the target object.
            // Metadata includes details about the properties of the object being reflected.
            $this->reflectPublicFields()
        );
    }
}
=== DataHandling/ObjectHandling/DTO/Traits/CastsTypes.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Traits;

use BackedEnum;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use InvalidArgumentException;
use ReflectionIntersectionType;
use ReflectionNamedType;
use ReflectionProperty;
use ReflectionUnionType;

/**
 * Trait CastsTypes
 *
 * This trait provides sophisticated value-casting mechanisms
 * to enable flexible and reliable data transfer object (DTO) hydration.
 *
 * Supports:
 * - Nested DTO instances
 * - Arrays of DTOs (DTO[])
 * - Backed Enums
 * - Primitive type fallback pass through
 *
 * Uses strict type checking and powerful casting techniques
 * to resolve property type constraints dynamically.
 */
trait CastsTypes
{
    /**
     * Provides a public entry point to the internal casting mechanism.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return mixed The casted value matching the expected type of the property.
     */
    public function castTo(ReflectionProperty $property, mixed $value) : mixed
    {
        // Delegates to the internal casting method.
        return $this->castToExpectedType($property, $value);
    }

    /**
     * Dynamically dispatches value casting logic based on the property's type metadata.
     *
     * Uses `match` to select the appropriate casting method:
     * - DTO detection
     * - Array of DTOs detection
     * - Backed Enums detection
     *
     * Falls back to the raw value if no special handling is needed.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return mixed The casted value (or the original value if no special casting is applied).
     */
    protected function castToExpectedType(ReflectionProperty $property, mixed $value) : mixed
    {
        return match (true) {
            $this->isDTOType($property)    => $this->castToDTO($property, $value),
            $this->isDTOArray($property)   => $this->castToDTOArray($property, $value),
            $this->isBackedEnum($property) => $this->castToEnum($property, $value),
            default                        => $value,
        };
    }

    /**
     * Checks if the given property is a subclass of the current DTO base class.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property maps to a DTO class, `false` otherwise.
     */
    protected function isDTOType(ReflectionProperty $property) : bool
    {
        $type = $this->resolvePropertyType($property);

        return $type !== null && is_subclass_of($type, AbstractDTO::class);
    }

    /**
     * Resolves the fully qualified class name or built-in type of a property.
     *
     * Prioritizes class names over scalars when multiple union types are present.
     *
     * @param ReflectionProperty $property The property for which to determine the type.
     *
     * @return string|null The resolved class or scalar type name, or null if unavailable.
     */
    protected function resolvePropertyType(ReflectionProperty $property) : string|null
    {
        $type = $property->getType();

        // If no type is declared, return null
        if ($type === null) {
            return null;
        }

        // Handle single-named types directly
        if ($type instanceof ReflectionNamedType) {
            return $type->getName();
        }

        // Handle union types (e.g., string|int|EnumType)
        if ($type instanceof ReflectionUnionType) {
            // Extract only named types excluding null/mixed/etc.
            $types = array_filter(
                $type->getTypes(),
                fn($t) => $t instanceof ReflectionNamedType && $t->getName() !== 'null'
            );

            // Prioritize classes (DTO/Enum) over scalar primitives
            usort(
                $types,
                fn(ReflectionNamedType $a, ReflectionNamedType $b) : int => class_exists(
                                                                                $b->getName()
                                                                            ) <=> class_exists($a->getName())
            );

            return $types[0]?->getName();
        }

        // Handle intersection types (PHP 8.2+)
        if ($type instanceof ReflectionIntersectionType) {
            foreach ($type->getTypes() as $named) {
                if ($named instanceof ReflectionNamedType) {
                    return $named->getName();
                }
            }
        }

        return null;
    }

    /**
     * Casts a given value to a DTO instance.
     *
     * Initializes a new DTO instance by passing a normalized array of values to its constructor.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return object A new DTO instance based on the resolved class type.
     *
     * @throws InvalidArgumentException If the resolved class is invalid or not a DTO.
     */
    protected function castToDTO(ReflectionProperty $property, mixed $value) : object
    {
        $class = $this->resolvePropertyType($property);
        $this->assertDTOClass($class, $property);

        // Instantiate the DTO using the normalized array of input data.
        return new $class($this->normalizeToArray($value));
    }

    /**
     * Validates whether the given class is a valid subclass of the DTO base class.
     *
     * @param string|null        $class    The class name to validate.
     * @param ReflectionProperty $property The property for which the class is being validated.
     *
     * @throws InvalidArgumentException If the class is not a valid DTO.
     */
    protected function assertDTOClass(string|null $class, ReflectionProperty $property) : void
    {
        if ($class === null || ! class_exists($class) || ! is_subclass_of($class, AbstractDTO::class)) {
            throw new InvalidArgumentException(
                sprintf(
                    "Invalid DTO class '%s' for property '%s'.",
                    $class ?? 'null',
                    $property->getName()
                )
            );
        }
    }

    /**
     * Normalizes a mixed input value into an array.
     *
     * Ensures that values can be safely passed as an array during DTO instantiation.
     *
     * @param mixed $value The raw input value.
     *
     * @return array The normalized array representation of the input.
     */
    protected function normalizeToArray(mixed $value) : array
    {
        return is_array($value) ? $value : (array) $value;
    }

    /**
     * Checks if the given property corresponds to an array of DTO instances.
     *
     * Determines this by analyzing the type information and optional metadata
     * from PHPDoc annotations or attributes.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property is an array of DTOs, `false` otherwise.
     */
    protected function isDTOArray(ReflectionProperty $property) : bool
    {
        return $this->resolvePropertyType($property) === 'array'
               && $this->resolveDTOClassFromAnnotationsOrAttributes($property) !== null;
    }

    /**
     * Resolves the class name of the DTO from either PHP attributes or @param ReflectionProperty $property The
     * property for which to resolve the class.
     *
     * @return string|null The fully qualified class name of the DTO, or `null` if not found.
     * "@var annotations"
     *
     */
    protected function resolveDTOClassFromAnnotationsOrAttributes(ReflectionProperty $property) : string|null
    {
        // Check for attributes first.
        foreach ($property->getAttributes() as $attribute) {
            $instance = $attribute->newInstance();
            if (method_exists($instance, 'of')) {
                return $instance->of();
            }
        }

        // Fallback to PHPDoc annotations.
        $doc = $property->getDocComment();
        if ($doc && preg_match('/@var\s+([\w\\\\]+)\[\]/', $doc, $matches)) {
            return ltrim($matches[1], '\\');
        }

        return null;
    }

    /**
     * Casts a given value to an array of DTO instances.
     *
     * Iterates over the input array and creates a new DTO instance for each element.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value (array) to be casted.
     *
     * @return array An array of DTO instances.
     *
     * @throws InvalidArgumentException If the DTO class is invalid.
     */
    protected function castToDTOArray(ReflectionProperty $property, mixed $value) : array
    {
        $class = $this->resolveDTOClassFromAnnotationsOrAttributes($property);
        $this->assertDTOClass($class, $property);

        // Map each array element to a new DTO instance.
        return array_map(
            fn($item) => new $class($this->normalizeToArray($item)),
            is_array($value) ? $value : []
        );
    }

    /**
     * Checks if the given property maps to a backed enum.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property type is a subclass of `BackedEnum`, `false` otherwise.
     */
    protected function isBackedEnum(ReflectionProperty $property) : bool
    {
        $type = $this->resolvePropertyType($property);

        return $type !== null
               && enum_exists($type)
               && is_subclass_of($type, BackedEnum::class);
    }

    /**
     * Casts a scalar value to its corresponding backed enum instance.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw scalar value to be converted.
     *
     * @return BackedEnum The enum instance corresponding to the given value.
     *
     * @throws InvalidArgumentException If the provided value does not match a valid enum case.
     */
    protected function castToEnum(ReflectionProperty $property, mixed $value) : BackedEnum|string|null
    {
        if ($value === null) {
            return null;
        }

        $type = $this->resolvePropertyType($property);
        $this->assertEnumClass($type, $property);

        /** @var class-string<BackedEnum> $type */
        if ($value instanceof $type) {
            return $value;
        }

        $enum = $type::tryFrom($value);

        if (! $enum) {
            throw new InvalidArgumentException(
                sprintf(
                    "Invalid enum value '%s' for '%s' on property '%s'. Valid: [%s]",
                    is_scalar($value) ? $value : gettype($value),
                    $type,
                    $property->getName(),
                    implode(', ', array_map(static fn($case) => $case->value, $type::cases()))
                )
            );
        }

        return $enum;
    }


    /**
     * Asserts that the given type is a valid backed enum class.
     *
     * @param string|null        $class    The class name to validate.
     * @param ReflectionProperty $property The property for which the enum is being validated.
     *
     * @throws InvalidArgumentException If the class is not a valid backed enum.
     */
    protected function assertEnumClass(string|null $class, ReflectionProperty $property) : void
    {
        if ($class === null || ! enum_exists($class) || ! is_subclass_of($class, BackedEnum::class)) {
            throw new InvalidArgumentException(
                sprintf(
                    "Invalid enum type '%s' for property '%s'. Must be a backed enum.",
                    $class ?? 'null',
                    $property->getName()
                )
            );
        }
    }
}
=== DataHandling/ObjectHandling/DTO/Traits/HandlesAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Traits;

use InvalidArgumentException;
use ReflectionAttribute;
use Throwable;

/**
 * Trait HandlesAttributes
 *
 * **Purpose**: This trait provides reusable functionality to apply transformations
 * and validations to object fields via custom attributes. It centralizes attribute
 * handling logic for better maintainability and reusability.
 *
 * **Context in DDD**: Designed for entities or value objects that require attribute-driven
 * field transformations and validations, fostering clean and declarative object definitions.
 *
 * **Key Features**:
 * - Instantiation of attributes.
 * - Transformation of field values using attribute logic.
 * - Validation of field values against attribute-defined rules.
 */
trait HandlesAttributes
{
    /**
     * Applies the given attributes to modify and/or validate the value of a field.
     * Each attribute may define transformation (`apply`) logic or validation (`validate`) logic.
     *
     * **Usage in DDD**: Enables well-encapsulated validation and behavior adjustments
     * directly linked to the domain model's field attributes.
     *
     * @param string                $fieldName  The name of the field currently being processed.
     * @param mixed                 $value      The current value of the field, passed by reference for in-place
     *                                          updates.
     * @param ReflectionAttribute[] $attributes A collection of `ReflectionAttribute` instances to apply.
     *
     * @return mixed
     *
     */
    protected function applyFieldAttributes(string $fieldName, mixed &$value, array $attributes) : mixed
    {
        // Iterate over all attributes associated with the field.
        foreach ($attributes as $attribute) {
            // Instantiate the attribute into a usable object.
            $instance = $this->instantiateAttribute($attribute);

            // Apply transformation logic if the attribute defines the `apply` method.
            if (method_exists($instance, 'apply')) {
                $value = $this->applyAttribute(instance: $instance, value: $value, fieldName: $fieldName);
            }

            // Perform validation if the attribute defines the `validate` method.
            if (method_exists($instance, 'validate')) {
                $this->validateAttribute(instance: $instance, value: $value, fieldName: $fieldName);
            }
        }

        return $value;
    }

    /**
     * Instantiates an attribute safely and ensures its validity for further processing.
     *
     * **Delegated Responsibility**: Verifies the integrity of an attribute's instantiation,
     * ensuring downstream logic (like `apply` or `validate`) receives a valid object.
     *
     * @param ReflectionAttribute $attribute The `ReflectionAttribute` instance to instantiate.
     *
     * @return object The instantiated attribute object, ready for application.
     *
     * @throws InvalidArgumentException If attribute instantiation fails due to invalid parameters
     *                                  or a runtime exception.
     */
    private function instantiateAttribute(ReflectionAttribute $attribute) : object
    {
        try {
            // Create an instance of the attribute dynamically.
            return $attribute->newInstance();
        } catch (Throwable $e) {
            // Throw a developer-friendly error with contextual information.
            throw new InvalidArgumentException(
                message : sprintf(
                              'Failed to instantiate attribute of type "%s": %s',
                              $attribute->getName(),
                              $e->getMessage()
                          ),
                code    : 422, // Exception code (standardized as 0 for consistent exception chaining).
                previous: $e // Preserve the original exception for backtrace details.
            );
        }
    }

    /**
     * Applies the transformation logic defined by the `apply` method of an attribute.
     *
     * **Domain Use Case**: Alters the field value as determined by attribute-specific
     * transformation rules, enriching the domain model with declarative behavior logic.
     *
     * @param object $instance  The instantiated attribute object with the `apply` method.
     * @param mixed  $value     The current field value to be transformed.
     * @param string $fieldName The name of the field to provide context in case of errors.
     *
     * @return mixed The transformed value after applying the attribute's logic.
     *
     * @throws InvalidArgumentException If the `apply` method fails or is improperly implemented.
     */
    private function applyAttribute(object $instance, mixed $value, string $fieldName) : mixed
    {
        try {
            // Invoke the attribute's `apply` method and return the modified value.
            return $instance->apply($value);
        } catch (Throwable $e) {
            // Throw an exception with clear diagnostic information.
            throw new InvalidArgumentException(
                message : sprintf(
                              'The "apply" method of attribute "%s" failed for field "%s": %s',
                              $instance::class,
                              $fieldName,
                              $e->getMessage()
                          ),
                code    : 422, // Exception code to maintain consistent exception hierarchy.
                previous: $e // Preserve chained exception details for diagnosis.
            );
        }
    }

    /**
     * Validates a value against the rules defined by an attribute's `validate` method.
     *
     * **Domain Implication**: Ensures that field values adhere to domain-driven constraints encapsulated
     * by attributes, supporting robust domain model invariants.
     *
     * @param object $instance  The instantiated attribute object with validation capability.
     * @param mixed  $value     The current field value to be validated.
     * @param string $fieldName The name of the field being validated for error reporting.
     *
     * @return void
     *
     * @throws InvalidArgumentException If validation rules are violated or improperly implemented.
     */
    private function validateAttribute(object $instance, mixed $value, string $fieldName) : void
    {
        try {
            // Invoke the attribute's `validate` method to perform validation checks.
            $instance->validate($value, $fieldName);
        } catch (Throwable $e) {
            // Throw informative validation exceptions to aid debugging.
            throw new InvalidArgumentException(
                message : sprintf(
                              'Validation failed for field "%s" with attribute "%s": %s',
                              $fieldName,
                              $instance::class,
                              $e->getMessage()
                          ),
                code    : 422, // Maintain consistent exception codes.
                previous: $e // Include original exception for additional debug trace.
            );
        }
    }
}
=== DataHandling/ObjectHandling/DTO/Traits/HandlesHydration.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Traits;

use Gemini\DataHandling\ObjectHandling\DTO\DTOValidationException;
use InvalidArgumentException;
use ReflectionProperty;
use Throwable;

/**
 * The `HandlesHydration` trait provides advanced hydration logic for DTO objects.
 *
 * It operates by using reflection to dynamically populate object properties with
 * provided raw data while performing type casting, validation, and handling attributes.
 * This ensures that the hydrated object adheres to the defined structure and constraints.
 */
trait HandlesHydration
{
    /**
     * Method responsible for dynamic hydration of the object with raw input data.
     *
     * The method processes each public field of the DTO using reflection, applying
     * type validation, attribute-based transformations, and error handling for invalid data.
     *
     * @param array<string, mixed> $data An associative array of input data for hydration,
     *                                   where keys correspond to public property names
     *                                   and values represent their respective input values.
     *
     * @throws DTOValidationException Thrown if one or more fields fail validation during hydration.
     * @throws \ReflectionException   Raised when an error occurs in accessing reflective metadata for the class.
     */
    public function hydrateFrom(array $data) : void
    {
        $errors        = [];
        $simpleMessage = null;

        foreach ($this->reflectPublicFields() as $meta) {
            try {
                $this->hydrateField(
                    name      : $meta->name,
                    property  : $meta->property,
                    attributes: $meta->attributes,
                    data      : $data
                );
            } catch (Throwable $e) {
                $errors[$meta->name] = $this->formatHydrationError(
                    fieldName: $meta->name,
                    e        : $e
                );

                $simpleMessage = $e->getMessage();
            }
        }

        if (! empty($errors)) {
            logger()->warning(
                message: 'DTO hydration failed - ' . $simpleMessage,
                context: ['errors' => $errors]
            );

            throw new DTOValidationException(
                message: 'DTO hydration failed - ' . $simpleMessage,
                errors : $errors
            );
        }
    }

    /**
     * Hydrates a single field of the DTO by casting, validating, and assigning the value.
     *
     * @param string             $name
     * @param ReflectionProperty $property
     * @param array              $attributes
     * @param array              $data
     */
    protected function hydrateField(
        string             $name,
        ReflectionProperty $property,
        array              $attributes,
        array              $data
    ) : void {
        if (! array_key_exists($name, $data)) {
            $this->handleMissingField(name: $name, property: $property);

            return;
        }

        $rawValue = $data[$name];

        // 🔁 STEP 1: Type casting FIRST
        $resolvedValue = $this->castToExpectedType(
            property: $property,
            value   : $rawValue
        );

        // ✅ STEP 2: Validate AFTER casting
        $this->validateField(
            fieldName : $name,
            value     : $resolvedValue,
            attributes: $attributes
        );

        // ✅ STEP 3: Set property after validation
        $this->$name = $resolvedValue;
    }

    /**
     * Handles scenarios where a field is missing during hydration by
     * either assigning a default value, setting it to `null` if nullable,
     * or throwing an exception for required fields.
     *
     * @param string             $name      The name of the missing property in the DTO.
     * @param ReflectionProperty $property  Reflective metadata for the missing property,
     *                                      used to inspect its type and default value.
     *
     * @throws InvalidArgumentException If the field is required but no value or default is provided.
     */
    protected function handleMissingField(string $name, ReflectionProperty $property) : void
    {
        // Check if the property explicitly allows null values using type reflection.
        if ($this->isPropertyNullable(property: $property)) {
            // Assign null to the property if it is nullable.
            $this->$name = null;

            return;
        }

        // Check if the property has a default value defined in the class.
        if ($property->hasDefaultValue()) {
            // Retrieve and assign the default value to the property if available.
            $this->$name = $property->getDefaultValue();

            return;
        }

        // Log a warning indicating that a required field is missing during hydration.
        logger()->warning(
            message: 'Missing required field: ' . $name, // Descriptive message for the log entry.
            context: ['class' => static::class] // Include the class name for debugging context.
        );

        // Throw an exception if the field is required and no value or default is provided.
        throw new InvalidArgumentException(
            message: "Missing required field: {$name}" // Provide a clear error message.
        );
    }

    /**
     * Validates the resolved value with all assigned attributes.
     *
     * @param string $fieldName
     * @param mixed  $value
     * @param array  $attributes
     */
    private function validateField(string $fieldName, mixed $value, array $attributes) : void
    {
        foreach ($attributes as $attribute) {
            if (method_exists($attribute, 'validate')) {
                $attribute->validate(
                    value   : $value,
                    property: $fieldName
                );
            }
        }
    }

    /**
     * Formats a hydration error for detailed exception reporting.
     *
     * @param string    $fieldName
     * @param Throwable $e
     *
     * @return string
     */
    private function formatHydrationError(string $fieldName, Throwable $e) : string
    {
        return sprintf(
            '%s → Field "%s": %s',
            static::class,
            $fieldName,
            $e->getMessage()
        );
    }
}

=== DataHandling/ObjectHandling/DTO/Traits/InspectsProperties.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Traits;

use Gemini\DataHandling\ObjectHandling\DTO\Support\PropertyMetadata;
use ReflectionClass;
use ReflectionException;
use ReflectionProperty;

/**
 * Trait InspectsProperties
 *
 * Provides a set of metadata reflection utilities for Data Transfer Objects (DTOs),
 * enabling efficient and consistent introspection of public properties.
 *
 * Key features:
 * - Caches reflection metadata per class for optimized performance.
 * - Supplies structured metadata constructs (`PropertyMetadata`), making them reusable across the application.
 * - Supports property-level logic that promotes composition, testability, and maintainability.
 */
trait InspectsProperties
{
    /**
     * @var array<class-string, PropertyMetadata[]> Stores cached metadata for each class.
     *                                              This cache prevents redundant reflection calls, thereby improving
     *                                              performance.
     */
    private static array $metadataCache = [];

    /**
     * Queries and retrieves metadata for a specific property of the DTO by its name.
     *
     * @param string $name The name of the property for which metadata is being retrieved.
     *
     * @return PropertyMetadata|null The structured metadata for the given property, or `null`
     *                               if the property does not exist or is inaccessible.
     *
     * @throws ReflectionException If there are issues during reflection (e.g., invalid class or property access).
     */
    protected function reflectField(string $name) : PropertyMetadata|null
    {
        // Iterate through all public property metadata; match the target property by name
        foreach ($this->reflectPublicFields() as $metadata) {
            if ($metadata->name === $name) {
                // Return the matched metadata if found
                return $metadata;
            }
        }

        // Return null if the property is not found
        return null;
    }

    /**
     * Retrieves metadata for all publicly accessible properties of the current DTO class.
     *
     * @return PropertyMetadata[] An array of `PropertyMetadata` instances, representing all metadata
     *                            for the public properties of the DTO.
     *
     * @throws ReflectionException If reflection fails during metadata construction.
     */
    protected function reflectPublicFields() : array
    {
        // Use the static class name as a reference for caching
        $class = static::class;

        // Attempt to retrieve cached metadata or lazily generate it if unavailable
        return self::$metadataCache[$class] ??= $this->buildMetadataFor(class: $class);
    }

    /**
     * Dynamically builds and caches property metadata for a given class.
     *
     * This provides efficient inspection of all public properties and ensures a reusable
     * metadata structure for future operations like validation or serialization.
     *
     * @param class-string $class The fully qualified name of the class whose properties will be inspected.
     *
     * @return PropertyMetadata[] An array of `PropertyMetadata` objects, one for each public property of the class.
     *
     * @throws ReflectionException If the class cannot be reflected upon (e.g., invalid class name).
     */
    private function buildMetadataFor(string $class) : array
    {
        // Initialize a ReflectionClass instance to inspect the class structure
        $reflection = new ReflectionClass(objectOrClass: $class);

        // Use an array mapping function to convert ReflectionProperty instances to PropertyMetadata objects
        return array_map(
            static fn(ReflectionProperty $property) : PropertyMetadata => new PropertyMetadata(
                name      : $property->getName(),       // Assign the property name
                property  : $property,             // Embed the ReflectionProperty instance
                attributes: $property->getAttributes() // Extract any PHP attributes applied to the property
            ),
            $reflection->getProperties(filter: ReflectionProperty::IS_PUBLIC) // Focus only on public properties
        );
    }

    /**
     * Determines whether a given property allows null values.
     *
     * This function is useful for validation or type safety checks where
     * nullable types impact business logic.
     *
     * @param ReflectionProperty $property The property to evaluate.
     *
     * @return bool Returns `true` if the property allows null values; otherwise, `false`.
     */
    protected function isPropertyNullable(ReflectionProperty $property) : bool
    {
        // Retrieve the property type and check if it explicitly allows null values
        $type = $property->getType();

        // Return true if the type allows null, or if no type is defined
        return $type?->allowsNull() ?? true;
    }

    /**
     * Checks if a specific attribute has been applied to a property.
     *
     * This method supports reflection-based checks for attributes, enabling flexible configuration
     * and behavior customization driven by annotations or metadata.
     *
     * @param ReflectionProperty $property     The property to check for attributes.
     * @param class-string       $attributeFqn The fully qualified name of the attribute class to look for.
     *
     * @return bool `true` if the property has been annotated with the given attribute; `false` otherwise.
     */
    protected function hasAttribute(ReflectionProperty $property, string $attributeFqn) : bool
    {
        // Use the ReflectionProperty API to fetch attributes by their fully qualified name
        return ! empty($property->getAttributes(name: $attributeFqn));
    }

    /**
     * Retrieves the first resolved attribute instance of a given type on a property.
     *
     * @param ReflectionProperty $property     The property to inspect. Represents a class property.
     *                                         Provides metadata about its type, visibility, and attributes.
     * @param class-string       $attributeFqn Fully qualified class name (FQN) of the attribute.
     *                                         Used to look up the attribute on the property.
     *
     * @return object|null The resolved attribute instance, or null if the attribute is not present on the property.
     *                     This ensures type-safe use of specific attributes in further logic.
     */
    protected function getAttribute(ReflectionProperty $property, string $attributeFqn) : ?object
    {
        // Retrieve all attributes that match the given fully qualified name on the property.
        $attributes = $property->getAttributes(name: $attributeFqn);

        // If no attributes of the provided class type are present, immediately return null.
        if (empty($attributes)) {
            return null;
        }

        // Instantiate and return the first attribute instance found. Assumes resolving the attribute is lightweight.
        return $attributes[0]->newInstance();
    }

    /**
     * Checks if the property has at least one attribute from a given list.
     *
     * Designed to optimize lookups when validating if a property contains any of several related attributes.
     *
     * @param ReflectionProperty $property The property to inspect. Provides introspection features
     *                                     for examining attribute metadata and existence.
     * @param string[]           $fqns     A list of fully qualified attribute class names (FQNs) to check against.
     *                                     Each entry should be a valid class-string.
     *
     * @return bool True if at least one of the specified attributes is defined on the property,
     *              otherwise false.
     */
    protected function hasAnyAttribute(ReflectionProperty $property, array $fqns) : bool
    {
        // Iterate through the provided list of attribute FQNs.
        foreach ($fqns as $attributeFqn) {
            // Check if any attributes matching the current FQN exist on the property.
            if (! empty($property->getAttributes(name: $attributeFqn))) {
                // Return true immediately if at least one attribute is found.
                return true;
            }
        }

        // Return false if no matching attributes exist for any provided FQN.
        return false;
    }
}
=== DataHandling/ObjectHandling/DTO/Traits/Serialization.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ObjectHandling\DTO\Traits;

use BackedEnum;
use DateTimeInterface;
use Gemini\DataHandling\ObjectHandling\Collections\Collection;
use Gemini\DataHandling\Validation\Attributes\Hidden;
use JsonException;
use JsonSerializable;
use ReflectionException;
use ReflectionProperty;
use stdClass;
use Traversable;

/**
 * Trait Serialization
 *
 * Provides recursive, flexible serialization capabilities for Data Transfer Objects (DTO).
 * Includes support for:
 * - JSON serialization with optional formatting.
 * - Recursive normalization of nested data structures.
 * - Handling of custom types such as enums, dates, and objects.
 * - Filtering of fields using #[Hidden] attributes.
 *
 * Designed to integrate seamlessly with Domain-Driven Design (DDD) practices.
 */
trait Serialization
{
    /**
     * Converts the DTO to a JSON string representation.
     * Useful for logging or debugging purposes.
     *
     * @return string The JSON representation of the DTO.
     * @throws JsonException|ReflectionException If an error occurs during encoding.
     */
    public function __toString() : string
    {
        return $this->toJson(flags: JSON_PRETTY_PRINT); // Beautify JSON output for readability.
    }

    /**
     * Encodes the DTO to a JSON string with optional flags and encoding depth.
     *
     * @param int|null $flags Optional JSON encoding flags (e.g., JSON_PRETTY_PRINT).
     * @param int      $depth Maximum depth for JSON serialization to prevent infinite recursion.
     *
     * @return string The JSON-encoded string representation of the DTO.
     * @throws JsonException|ReflectionException If JSON encoding fails.
     */
    public function toJson(int|null $flags = null, int $depth = 512) : string
    {
        $flags ??= 0; // Default to no flags if none provided.

        return json_encode($this->toArray(), $flags | JSON_THROW_ON_ERROR, $depth); // Encode object as JSON.
    }

    /**
     * Converts the DTO into an associative array representation.
     * Recurses through nested properties and filters hidden fields if configured.
     *
     * @param int|null $depth         Maximum recursion depth, null for unlimited depth.
     * @param bool     $excludeHidden Whether to exclude fields marked with #[Hidden] attribute.
     *
     * @return array<string, mixed> The DTO as an associative array.
     * @throws ReflectionException
     */
    public function toArray(int|null $depth = null, bool $excludeHidden = true) : array
    {
        // Normalize and filter object properties depending on the excludeHidden flag.
        return $this->normalizeValue(
            value: $excludeHidden
                       ? $this->filterHiddenFields(get_object_vars($this)) // Filter hidden fields.
                       : get_object_vars($this),
            depth: $depth
        );
    }

    /**
     * Recursively normalizes a given value into a JSON-safe structure.
     * Supports enums, date objects, JSON-serializable objects, arrays, and iterables.
     *
     * @param mixed    $value Any value to normalize.
     * @param int|null $depth Maximum depth for recursion, null for unlimited depth.
     *
     * @return mixed The normalized, JSON-serializable value.
     * @throws ReflectionException
     */
    protected function normalizeValue(mixed $value, int|null $depth = null) : mixed
    {
        // Return early if recursion depth has reached zero.
        if ($depth === 0) {
            return null; // Prevent infinite recursion.
        }

        // Match on specific value types and normalize accordingly.
        return match (true) {
            $value instanceof self              => $value->toArray(
                depth: $depth !== null ? $depth - 1 : null
            ), // Normalize nested DTO objects recursively.
            $value instanceof BackedEnum        => $value->value, // Return enum value.
            $value instanceof DateTimeInterface => $value->format(
                format: DATE_ATOM
            ), // Format dates as ISO 8601 strings.
            $value instanceof JsonSerializable  => $value->jsonSerialize(), // Serialize JSON-serializable objects.
            $value instanceof Traversable       => array_map(
            // Convert iterable objects to arrays and normalize their items.
                fn($item) => $this->normalizeValue(value: $item, depth: $depth !== null ? $depth - 1 : null),
                iterator_to_array($value)
            ),
            is_array($value)                    => array_map(
            // Normalize and recurse through array elements.
                fn($item) => $this->normalizeValue(value: $item, depth: $depth !== null ? $depth - 1 : null),
                $value
            ),
            is_object($value) && method_exists(
                $value,
                '__toString'
            )                                   => (string) $value, // Convert objects with __toString to strings.
            is_object(
                $value
            )                                   => (array) $value, // Fallback: convert objects to arrays.
            default                             => $value, // Default case: return the value as-is.
        };
    }

    /**
     * Implements the JsonSerializable interface by converting the DTO to an array.
     *
     * @return array A JSON-serializable representation of the DTO.
     * @throws ReflectionException
     */
    public function jsonSerialize() : array
    {
        return $this->toArray(); // Re-use the toArray method for serialization.
    }

    /**
     * Filters out fields marked with the #[Hidden] attribute from an array of properties.
     *
     * @param array<string, mixed> $properties The properties to be filtered.
     *
     * @return array<string, mixed> A filtered associative array of properties.
     * @throws ReflectionException If reflection fails while accessing class properties.
     */
    protected function filterHiddenFields(array $properties) : array
    {
        foreach ($this->reflectPublicFields() as $meta) {
            if ($this->shouldHideField(property: $meta->property)) {
                unset($properties[$meta->name]); // Remove fields marked as hidden.
            }
        }

        return $properties;
    }

    /**
     * Determines whether a given property should be hidden based on the #[Hidden] attribute.
     * Can be extended to provide more sophisticated filtering logic.
     *
     * @param ReflectionProperty $property The property to evaluate.
     *
     * @return bool True if the property should be hidden, false otherwise.
     */
    protected function shouldHideField(ReflectionProperty $property) : bool
    {
        // Check whether the property has the #[Hidden] attribute.
        return $this->hasAttribute(property: $property, attributeFqn: Hidden::class);
    }

    /**
     * Converts the DTO into a flat array with all its properties.
     * Does not normalize or filter hidden fields.
     *
     * @return array<string, mixed> A flat array of the DTO properties.
     */
    public function toFlatArray() : array
    {
        return get_object_vars($this); // Return an associative array of all object properties.
    }

    /**
     * Converts the DTO into an instance of stdClass for compatibility with generic object types.
     *
     * @return stdClass The DTO represented as a standard class object.
     * @throws JsonException If the DTO cannot be encoded into JSON.
     * @throws \ReflectionException
     */
    public function toStdClass() : stdClass
    {
        return json_decode(
            json       : $this->toJson(), // Serialize DTO as JSON.
            associative: false, // Decode JSON as an object, not an array.
            depth      : 512, // Maximum decoding depth.
            flags      : JSON_THROW_ON_ERROR // Throw exceptions on JSON decoding errors.
        );
    }

    /**
     * Transforms the current object into a Collection instance.
     *
     * This method provides a convenient way to convert the object's array representation
     * into a Collection, enabling fluent collection operations on the object's data.
     * The resulting Collection inherits all the powerful collection manipulation methods
     * and can be further chained with other collection operations.
     *
     * @return Collection Immutable collection containing the object's data
     *
     * @throws \ReflectionException When reflection fails to analyze the object structure
     * @api
     * @since 1.0.0
     * @final
     */
    public function toCollection() : Collection
    {
        // Convert the object to an array and wrap it in a Collection instance
        return collect(items: $this->toArray());
    }

    /**
     * Transforms the Data Transfer Object into a JSON:API compliant format.
     *
     * This method implements the JSON:API specification (jsonapi.org) structure,
     * providing a standardized response format with type, id, and attributes.
     *
     * @param string $type The resource type identifier for the JSON:API document
     *
     * @return array<string, array<string, mixed>> The JSON:API formatted response
     * @throws \ReflectionException When reflection fails during property inspection
     *
     * @see https://jsonapi.org/format/ JSON:API Specification
     */
    public function toJsonApi(string $type) : array
    {
        // Create the outer JSON:API compliant structure
        return [
            // Root-level data container as per JSON:API spec
            'data' => [
                // Resource type identifier for the object
                'type'       => $type,
                // Unique identifier for the resource, null if not set
                'id'         => $this->id ?? null,
                // Object attributes normalized through toArray method
                'attributes' => $this->toArray(),
            ],
        ];
    }
}
=== DataHandling/Transformers/Mapper/AbstractApiMapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\DataTransformers\Mapper;

use Gemini\DataHandling\Cache\ReflectionCache;
use Gemini\DataHandling\DTO\DTOCollection;
use Gemini\DataHandling\DTO\DTOInterface;
use Gemini\DataHandling\DTO\Validation\Casting\ValueCaster;
use Gemini\DataHandling\DTO\Validation\DTOValidator;
use ReflectionNamedType;
use ReflectionProperty;

/**
 * AbstractApiMapper
 *
 * This abstract class is responsible for mapping API responses to DTO (Data Transfer Object) instances.
 * It utilizes reflection to auto-populate DTO instances, providing flexibility and reusability
 * for different DTO types, including nested DTO structures.
 *
 * ### Example usage:
 * ```
 * class UserApiMapper extends AbstractApiMapper {
 *     protected function defineDtoClass(): string {
 *         return UserDTO::class;
 *     }
 *
 *     protected function defineDtoCollectionClass(): string {
 *         return UserDTOCollection::class;
 *     }
 * }
 *
 * $mapper = new UserApiMapper();
 * $userDto = $mapper->map(data: $data);
 * ```
 *
 * @implements MapperInterface<DTOInterface, DTOCollection>
 */
abstract class AbstractApiMapper implements MapperInterface
{
    /**
     * Maps data to a DTO or a collection of DTOs based on the given data.
     *
     * This method decides whether to map to a single DTO or a collection of DTOs
     * based on the size of the response.
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOInterface|DTOCollection Either a single DTO object or a DTOCollection.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoOrCollection = $this->map(data: $apiResponse);
     * ```
     */
    public function map(array $data) : DTOInterface|DTOCollection
    {
        return count(value: $data) === 1
            ? $this->mapSingleDTO(data: $data[0])
            : $this->mapToDTOCollection(data: $data);
    }

    /**
     * Maps a single data array to a DTO object.
     * Internal helper method used by map().
     *
     * @param array $data The data set to be mapped.
     *
     * @return DTOInterface The DTO object created from the provided data.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $singleDto = $this->mapSingleDTO(data: $dataArray);
     * ```
     */
    private function mapSingleDTO(array $data) : DTOInterface
    {
        $dtoClass = $this->getDtoClassName();
        DTOValidator::validateClassExistence(dtoClass: $dtoClass);

        return $this->transformToDTO(data: $data, dtoClass: $dtoClass);
    }

    /**
     * Getter method for the DTO class name.
     *
     * @return string The fully qualified class name of the DTO.
     */
    protected function getDtoClassName() : string
    {
        return $this->defineDtoClass();
    }

    /**
     * Abstract method to set the DTO class name for mapping.
     *
     * Child classes must implement this method to provide the DTO class name.
     *
     * @return string The fully qualified class name of the DTO.
     */
    abstract protected function defineDtoClass() : string;

    /**
     * Transforms an array of data into a DTO object.
     *
     * @param array  $data     The data set to be transformed.
     * @param string $dtoClass The fully qualified class name of the DTO.
     *
     * @return DTOInterface The DTO object created from the provided data.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoObject = $this->transformToDTO(data: $data, dtoClass: UserDTO::class);
     * ```
     */
    protected function transformToDTO(array $data, string $dtoClass) : DTOInterface
    {
        $castedData = $this->castData(data: $data, dtoClass: $dtoClass);

        return new $dtoClass(...$castedData);
    }

    /**
     * Casts data according to the type defined in the DTO class.
     *
     * This method uses reflection to find the type of each property in the DTO class,
     * and then casts the data accordingly using the `ValueCaster` class.
     *
     * @param array  $data     The data to be cast.
     * @param string $dtoClass The fully qualified class name of the DTO which contains type definitions.
     *
     * @return array An array of casted data that can be used to instantiate the DTO object.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $castedData = $this->castData(data: $dataArray, dtoClass: UserDTO::class);
     * ```
     */
    protected function castData(array $data, string $dtoClass) : array
    {
        $reflectionClass = ReflectionCache::getReflectionClass(dtoClass: $dtoClass);
        $castedData      = [];

        foreach ($reflectionClass->getProperties(filter: ReflectionProperty::IS_PUBLIC) as $reflectionProperty) {
            $propertyName = $reflectionProperty->getName();
            $type         = $reflectionProperty->getType();

            if ($type instanceof ReflectionNamedType && array_key_exists(key: $propertyName, array: $data)) {
                $castedData[$propertyName] = ValueCaster::castValue(
                    value     : $data[$propertyName],
                    type      : $type->getName(),
                    allowsNull: $type->allowsNull(),
                );
            }
        }

        return $castedData;
    }

    /**
     * Maps an array of data sets into an array or collection of DTO objects.
     * Internal helper method used by map().
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOCollection A collection of mapped DTO objects.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoCollection = $this->mapToDTOCollection(data: $dataArray);
     * ```
     */
    private function mapToDTOCollection(array $data) : DTOCollection
    {
        $dtoCollection = new DTOCollection();

        foreach ($data as $item) {
            $dtoCollection->add(
                dto: $this->mapSingleDTO(data: $item),
            );
        }

        return $dtoCollection;
    }

    /**
     * Getter method for the DTO collection class name.
     *
     * @return string The fully qualified class name of the DTO collection.
     */
    protected function getDtoCollectionClassName() : string
    {
        return $this->defineDtoCollectionClass();
    }

    /**
     * Abstract method to set the DTO collection class name for mapping.
     *
     * Child classes must implement this method to provide the DTO collection class name.
     *
     * @return string The fully qualified class name of the DTO collection.
     */
    abstract protected function defineDtoCollectionClass() : string;
}

=== DataHandling/Transformers/Mapper/MapperInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\DataTransformers\Mapper;

use Gemini\DataHandling\DTO\DTOCollection;
use Gemini\DataHandling\DTO\DTOInterface;

/**
 * MapperInterface
 *
 * This interface defines methods for mapping data to DTO (Data Transfer Object) instances.
 *
 * ### Example Implementation:
 * ```
 * class UserApiMapper extends AbstractApiMapper implements MapperInterface {
 *     protected function defineDtoClass(): string {
 *         return UserDTO::class;
 *     }
 *
 *     protected function defineDtoCollectionClass(): string {
 *         return UserDTOCollection::class;
 *     }
 * }
 * ```
 */
interface MapperInterface
{
    /**
     * Maps data to a DTO or a collection of DTOs based on the given data.
     *
     * This method decides whether to map to a single DTO or a collection of DTOs
     * based on the size of the response.
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOInterface|DTOCollection Either a single DTO object or a DTOCollection.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example implementation:
     * ```
     * class UserApiMapper implements MapperInterface {
     *     public function map(array $data): DTOInterface|DTOCollection {
     *         // Implement the mapping logic
     *     }
     * }
     * ```
     */
    public function map(array $data) : DTOInterface|DTOCollection;
}

=== DataHandling/Validation/Attributes/AbstractRule.php ===
<?php

namespace Gemini\DataHandling\Validation\Attributes;

use Gemini\DataHandling\Validation\Attributes\Contracts\RuleValidator;

abstract class AbstractRule implements RuleValidator
{
    use RuleHelpers;

    /**
     * Common error thrower.
     */
    protected function fail(string $message, string $property) : never
    {
        throw new ValidationException("Validation failed on '{$property}': {$message}");
    }
}

=== DataHandling/Validation/Attributes/Contracts/RuleValidator.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Contracts;

use Gemini\Exceptions\ValidationException;

/**
 * Interface RuleValidator
 *
 * A contract for implementing custom validation rules for a Data Transfer Object (DTO).
 * This interface enforces a consistent structure and ensures flexibility
 * when implementing reusable and testable validation logic.
 */
interface RuleValidator
{
    /**
     * Validates the input value for a specific property of a Data Transfer Object (DTO).
     *
     * @param mixed  $value    The value to be validated.
     *                         It can be of any data type and represents the value assigned to the DTO property.
     * @param array  $data     The complete data array representing the DTO.
     *                         This allows access to other properties of the DTO during validation, enabling
     *                         advanced validation logic that involves relationships between properties.
     * @param string $property The name of the DTO property being validated.
     *                         This parameter identifies which specific property the $value represents.
     *
     * @throws ValidationException If the validation fails.
     *                             The exception provides details of the validation failure, enabling the caller
     *                             to handle validation errors appropriately, such as returning user-friendly error
     *                             messages or logging the failure for debugging purposes.
     */
    public function validate(mixed $value, array $data, string $property) : void;
}
=== DataHandling/Validation/Attributes/Hidden.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes;

use Attribute;

/**
 * Attribute Hidden
 *
 * Marks a DTO property as hidden from serialization (toArray, toJson).
 *
 * Pure marker – contains no logic. Interpreted by Serialization trait.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
final class Hidden
{
    //
}

=== DataHandling/Validation/Attributes/Rules/AcceptedIf.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate if a property value is "accepted" conditionally based on another field's value.
 *
 * The 'AcceptedIf' attribute ensures the given property is validated as accepted (with specific valid values)
 * if a condition on a another field's value is met. This allows for conditional validation logic to be applied
 * on data transfer objects.
 *
 * The class is marked readonly to indicate that instances should have immutable properties. This ensures
 * consistency and reliability of the validation logic once an instance is created with a specific condition.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that a property is "accepted" if a certain condition in the data is met.
 *
 * The "acceptance" means that the value should be one of 'yes', 'on', 1, or true. If the condition specified
 * by conditionField and conditionValue is met and the value is not one of these acceptable values,
 * a ValidationException is thrown.
 *
 * @throws \Gemini\Exceptions\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AcceptedIf
{
    public function __construct(private string $conditionField, private mixed $conditionValue) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if (($data[$this->conditionField] ?? null) === $this->conditionValue
            && ! in_array(
                $value,
                ['yes', 'on', 1, true],
                true,
            )) {
            throw new ValidationException(message: $property . " must be accepted.");
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Accepted.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class representing an "Accepted" validation rule.
 *
 * This class can be used as an attribute to ensure that a property
 * has an acceptable value such as 'yes', 'on', 1, or true.
 *
 * - Flags Attribute::TARGET_PROPERTY restricts usage to class properties.
 * - Throws ValidationException if the value does not meet acceptable criteria.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * This attribute class enforces that a property must be explicitly accepted.
 * It's used for properties where a confirmation or acknowledgment is required.
 * The acceptable values are 'yes', 'on', 1, or true.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Accepted
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array($value, ['yes', 'on', 1, true], true)) {
            throw new ValidationException(message: $property . ' must be accepted.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/ActiveURL.php ===
<?php

declare(strict_types=1);

/**
 * ActiveURL Attribute class to enforce the validation of URLs.
 * This attribute can be applied to properties to ensure they are active URLs.
 * The requirement for the URL to be active involves both validation of URL format and DNS resolution.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates if the provided value is an active URL.
 *
 * This method checks if the given value is a valid URL format and also verifies
 * whether the host of the URL has a DNS A record. This dual-check ensures that
 * the URL is both syntactically correct and points to an existing domain.
 *
 * @param mixed  $value    The value to be validated as an active URL.
 * @param string $property The name of the property being validated, used in the exception message.
 *
 * @throws \Gemini\Exceptions\ValidationException if the value is not a valid or active URL.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ActiveURL
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_URL) || ! checkdnsrr(parse_url((string) $value, PHP_URL_HOST), 'A')) {
            throw new ValidationException(message: $property . ' must be an active URL.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/AfterOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a property to be a date after or equal to a specified date.
 *
 * This attribute is applied at the property level within a Data Transfer Object (DTO).
 * It ensures that the validated date is not earlier than the provided comparison date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class designed to enforce the rule that a given date must be
 * either after or equal to a specified date. This validation is used
 * in scenarios where certain business rules require dates to respect
 * a minimum threshold.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AfterOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate < $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be a date after or equal to %s.',
                             $property,
                             $this->date,
                         ),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/After.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a date property must be after a specified date.
 *
 * The After attribute can be applied to properties to ensure the date value
 * assigned to the property is after a predefined date. This is particularly
 * useful in scenarios where certain events must occur after a specific date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that the provided date is after the date specified during instantiation.
 *
 * @throws \Gemini\Exceptions\ValidationException if the input date is not after the comparison date.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class After
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate <= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date after %s.', $property, $this->date));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/AlphaDash.php ===
<?php

declare(strict_types=1);

/**
 * This class represents a validation rule to ensure that a given property
 * contains only letters, numbers, dashes, and underscores.
 *
 * The class is marked as an attribute and is intended to be used on class properties.
 * The Attribute::TARGET_PROPERTY flag restricts its use to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that the given value adheres to the AlphaDash rule.
 *
 * Ensures the value only contains letters, numbers, dashes, and underscores.
 *
 * @throws \Gemini\Exceptions\ValidationException if the value does not match the allowed pattern.
 *
 * Rationale: This validation is necessary for sanitizing inputs where only alphanumeric characters,
 * dashes, and underscores are allowed. It helps prevent potential security risks
 * and ensures consistency in the values stored or processed.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaDash
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^[\pL\pM\pN_-]+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(
                message: $property . ' may only contain letters, numbers, dashes, and underscores.',
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/AlphaNumOrEmail.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute to validate that a value is either alphanumeric or in a valid email format.
 *
 * This rule can be applied to properties of a class to ensure their value adheres to
 * the specified format. It supports usernames (alphanumeric) or valid email addresses.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AlphaNumOrEmail
{
    /**
     * Default error message template for validating either an alphanumeric username or a valid email.
     */
    private const string DEFAULT_ERROR_MESSAGE = 'The "%s" must be either an alphanumeric username or a valid email.';

    /**
     * Constructor for the AlphaNumOrEmail attribute.
     *
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private string|null $message = null) {}

    /**
     * Validates that the provided value is either alphanumeric or a valid email.
     *
     * @param mixed  $value The value to validate.
     * @param string $name  The property name being validated.
     *
     * @throws ValidationException If the value is not a valid alphanumeric string or email.
     */
    public function validate(mixed $value, string $name) : void
    {
        if (! $this->isValidValue($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $name),
                metadata: [
                              'property' => $name,
                              'value'    => $value,
                              'expected' => 'alphanumeric or valid email',
                          ]
            );
        }
    }

    /**
     * Checks if the value is a valid alphanumeric string or email.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is valid; false otherwise.
     */
    private function isValidValue(mixed $value) : bool
    {
        return is_string($value) && ($this->isAlphanumeric($value) || $this->isEmail($value));
    }

    /**
     * Determines if the string is alphanumeric.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is alphanumeric; false otherwise.
     */
    private function isAlphanumeric(string $value) : bool
    {
        return (bool) preg_match('/^[a-zA-Z0-9]+$/', $value);
    }

    /**
     * Determines if the string is a valid email.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is a valid email; false otherwise.
     */
    private function isEmail(string $value) : bool
    {
        return filter_var($value, FILTER_VALIDATE_EMAIL) !== false;
    }
}

=== DataHandling/Validation/Attributes/Rules/AlphaNum.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce alphanumeric validation on properties.
 *
 * This class can be used to annotate class properties to indicate that
 * they must only contain letters and numbers. This is particularly useful
 * for ensuring data integrity in DTOs (Data Transfer Objects) by validating
 * their properties against the alphanumeric constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * An attribute class to enforce that a property value consists solely of letters and numbers.
 *
 * This attribute can be applied to class properties to ensure data validation for alphanumeric characters.
 *
 * Note: This class relies on Unicode property escapes (\pL, \pM, \pN) to cover all letters, marks, and numbers,
 * allowing for internationalization support.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaNum
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^[\pL\pM\pN]+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' may only contain letters and numbers.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Alpha.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to ensure a property contains only alphabetic characters.
 *
 * This class uses the #[Attribute] annotation to indicate that it can be used as an attribute,
 * specifically targeting properties. The validation logic enforces that the value assigned to the
 * annotated property consists solely of letters (alpha characters).
 *
 * Using this class helps in maintaining data integrity by validating properties directly at the attribute definition
 * level.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class used to validate that a property contains only letters.
 * Targets properties, indicating this rule applies at the property level.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Alpha
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^\pL+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' must only contain letters.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/ArrayType.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property value must be an array.
 *
 * Annotated properties treated with this attribute will have
 * their values validated to ensure they are arrays. If not,
 * an exception is thrown to signal a validation failure.
 *
 * To be used specifically on property level.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class intended to enforce array type validation for properties.
 *
 * This class is designed to ensure that certain properties, when decorated with
 * this attribute, must hold array values. It integrates with the validation
 * mechanism throwing exceptions when validation fails.
 *
 * Decorate properties in DTOs with this class to enforce type constraints and
 * keep data integrity.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ArrayType
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_array($value)) {
            throw new ValidationException(message: $property . ' must be an array.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/BeforeOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class that ensures a property is a date before or equal to a specified date.
 *
 * This attribute can be applied to properties and ensures that their value is a date
 * formatted as 'Y-m-d' that is before or equal to the date specified during instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * This attribute class enforces that a given date must be before or equal to a specified date.
 *
 * The readonly modifier ensures immutability, providing a safeguard against accidental changes to the date property.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class BeforeOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate > $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be a date before or equal to %s.',
                             $property,
                             $this->date,
                         ),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Before.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce date validation rules.
 *
 * This Attribute can only be applied to properties.
 * It checks if a given date value is before a specified date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute to validate if a given date is before a specified date.
 *
 * The "Before" class is a read-only attribute designed to enforce a date validation rule.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Before
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate >= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date before %s.', $property, $this->date));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Between.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to impose a "between" validation rule on a property.
 *
 * This attribute is intended to be used on properties that need to ensure
 * their values lie between a specified minimum and maximum range.
 *
 * The class is marked as read-only to prevent changes to the min and max
 * values after instantiation, ensuring the integrity of the validation rule.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class for enforcing that a property's value is within a specified range.
 *
 * Modifiers:
 * - This class is read-only to ensure immutability once it is constructed.
 * - It is intended to be used as a property attribute.
 *
 * Use this class to validate that a given property falls within a specific minimum and maximum range.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Between
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value < $this->min || $value > $this->max) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be between %d and %d.',
                             $property,
                             $this->min,
                             $this->max,
                         ),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Boolean.php ===
<?php

declare(strict_types=1);

/**
 * A custom attribute to validate boolean values.
 *
 * This attribute is applied to properties within Data Transfer Objects (DTOs). The validation ensures that the
 * property
 * value adheres to a boolean format. The attribute itself helps enforce data consistency and integrity, typically in
 * data handling and transfer scenarios.
 *
 * Note: The #[Attribute(flags: Attribute::TARGET_PROPERTY)] syntax ensures this attribute can only be applied to
 * properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that the provided value is a boolean.
 * Throws a ValidationException if the value is not a boolean.
 *
 * The use of filter_var with FILTER_VALIDATE_BOOLEAN and FILTER_NULL_ON_FAILURE
 * ensures that we are only accepting true or false values. This is important
 * as some values (e.g., "yes", "no") might incorrectly pass simple boolean checks.
 *
 * The rationale here is to provide strict validation for a boolean context,
 * ensuring data consistency and avoiding potential bugs arising from loosely
 * validated values.
 *
 * @throws \Gemini\Exceptions\ValidationException if the value is not a boolean.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Boolean
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_bool(filter_var($value, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE))) {
            throw new ValidationException(message: $property . ' field must be true or false.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Custom.php ===
<?php

declare(strict_types=1);

/**
 * The Custom attribute class allows for custom validation logic to be applied
 * to object properties. This is particularly useful for defining property-specific
 * validation rules that don't fit standard validation patterns.
 *
 * - `Attribute::TARGET_PROPERTY` ensures this attribute is applied to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Closure;
use Gemini\Exceptions\ValidationException;

/**
 * Indicates that this attribute is targeting a property and is immutable.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Custom
{
    public function __construct(private Closure $callback) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $isValid = ($this->callback)($value);
        if (! $isValid) {
            throw new ValidationException(message: $property . ' is invalid according to custom rule.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/DateEquals.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a date equality rule on a DTO property.
 *
 * This attribute ensures that a property's date value matches a specified date.
 * Useful for scenarios where a particular date needs to be strictly validated,
 * such as ensuring a creation date matches a record date.
 *
 * - Declared readonly to emphasize immutability once initialized.
 * - Can only be applied to class properties (TARGET_PROPERTY).
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that the given value matches the specified date.
 *
 * The validation checks for strict equality between the input date
 * and the configured date. The date format used is 'Y-m-d'.
 *
 * @throws \Gemini\Exceptions\ValidationException if the dates do not match or if either date is invalid.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateEquals
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate != $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date equal to %s.', $property, $this->date));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/DateFormat.php ===
<?php

declare(strict_types=1);

/**
 * This class is an attribute that enforces a specific date format on a property.
 *
 * The 'readonly' keyword ensures immutability, making sure that once the attribute
 * is instantiated, its properties cannot be modified.
 *
 * Applied for property-level validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * The DateFormat class is a read-only attribute used to enforce a specific date format on a property.
 *
 * It leverages PHP's native DateTime class to attempt parsing the string into a date
 * according to the specified format. If the parsing fails, or if the parsed date does not match
 * the original string, a ValidationException is thrown. This is crucial for ensuring date fields
 * consistently conform to expected formats, which can help prevent errors related to date handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateFormat
{
    public function __construct(private string $format) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $date = DateTime::createFromFormat(format: $this->format, datetime: $value);
        if (! $date || $date->format(format: $this->format) !== $value) {
            throw new ValidationException(
                message: sprintf('%s does not match the format %s.', $property, $this->format),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Date.php ===
<?php

declare(strict_types=1);


/**
 * Includes a date validation attribute which targets properties.
 * Ensures that property values conform to date formats 'Y-m-d' or 'Y-m-d H:i:s'.
 *
 * This attribute can be instantiated and used to provide a clear validation rule
 * for date properties, simplifying validation logic in the broader application.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exceptions\ValidationException;

/**
 * This class is an attribute used to validate date properties.
 *
 * It ensures that the value assigned to a property is a valid date
 * in the standard formats 'Y-m-d' or 'Y-m-d H:i:s'. If the value
 * does not conform to these formats, a ValidationException is thrown.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Date
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! DateTime::createFromFormat(format: 'Y-m-d', datetime: $value) && ! DateTime::createFromFormat(
                format  : 'Y-m-d H:i:s',
                datetime: $value,
            )) {
            throw new ValidationException(message: $property . " is not a valid date.");
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Different.php ===
<?php

declare(strict_types=1);

/**
 * The Different validation attribute is used to enforce that a property must have a different value
 * from another specified property within the same data context.
 *
 * This is a read-only attribute applied to a class property, ensuring immutability after instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * The Different class is an immutable validator to ensure that a given property in a dataset
 * differs from another specified property. It is intended to be used as an attribute for data validation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Different
{
    public function __construct(private string $field) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if ($value === ($data[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be different from %s.', $property, $this->field));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/DigitsBetween.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a digit-based range constraint on a property.
 *
 * This Attribute is declared as read-only and targets properties.
 * It ensures that the value of the property contains only digits and
 * that the number of digits falls within the specified minimum and maximum range.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Class DigitsBetween
 *
 * This class contains validation logic to ensure that a given value is a string
 * composed only of digits and that its length falls within a specified minimum
 * and maximum range.
 *
 * Marked as readonly to indicate immutability: once instantiated, the properties
 * $min and $max should not be altered.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DigitsBetween
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^\d+$/', (string) $value), [0, false], true) || strlen(
                                                                                      (string) $value,
                                                                                  ) < $this->min || strlen(
                                                                                                        (string) $value,
                                                                                                    ) > $this->max) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be between %d and %d digits.',
                             $property,
                             $this->min,
                             $this->max,
                         ),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Digits.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a property to contain exactly a specified number of digits.
 *
 * - This class can only be used as a property attribute (TARGET_PROPERTY).
 * - The 'readonly' keyword denotes that the property values cannot be changed after instantiation.
 * - Instantiated with a single parameter 'digits' to determine the number of digits required.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Readonly class to validate that a property consists of a specific number of digits.
 *
 * @Attribute aims to use this class as a property attribute in another class.
 * This is useful for validating property values against a specific constraint.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Digits
{
    public function __construct(private int $digits) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match(sprintf('/^\d{%d}$/', $this->digits), (string) $value), [0, false], true)) {
            throw new ValidationException(message: sprintf('%s must be %d digits.', $property, $this->digits));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Distinct.php ===
<?php

declare(strict_types=1);

/**
 * The Distinct attribute is used to ensure that all elements in a property array are unique.
 * It is applied to a property using the PHP attribute syntax.
 *
 * @Attribute(flags: Attribute::TARGET_PROPERTY)
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class to enforce uniqueness constraint on property values.
 * This class uses the Attribute flag TARGET_PROPERTY to specify that it
 * should be used on class properties. Ensures that an array property
 * contains unique elements only.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Distinct
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (count($value) !== count(array_unique($value))) {
            throw new ValidationException(message: $property . ' field has a duplicate value.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/DTOArrayOf.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Attribute to automatically transform an array into an array of DTOs.
 *
 * Used for fields like: array<int, FieldDTO>
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class DTOArrayOf
{
    /**
     * @param class-string<AbstractDTO> $class Fully-qualified DTO class name
     */
    public function __construct(public string $class) {}

    /**
     * Transforms the input array into DTO instances
     *
     * @param array|null $value
     *
     * @return array<int, AbstractDTO>
     */
    public function apply(array|null $value) : array
    {
        return array_map(
            fn(array $item) => new ($this->class)($item),
            $value ?? []
        );
    }
}

=== DataHandling/Validation/Attributes/Rules/DTOObjectOf.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class DTOObjectOf
{
    public function __construct(public string $class) {}

    public function apply(array|object|null $value) : AbstractDTO|null
    {
        if (is_null($value)) {
            return null;
        }

        return new ($this->class)((array) $value);
    }
}

=== DataHandling/Validation/Attributes/Rules/Email.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to mark a property as needing email validation.
 *
 * This custom attribute can be used on property declarations to enforce
 * email validation rules, encapsulating the validation logic in a reusable manner.
 *
 * Example:
 *
 * #[Email]
 * private string $email;
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates whether the provided value is a valid email address.
 *
 * @throws \Gemini\Exceptions\ValidationException if the value is not a valid email address.
 *
 * The rationale for this approach is to ensure that only valid email addresses are accepted and
 * stored within the system. By enforcing this validation at the point where the attribute is used,
 * it provides a centralized validation mechanism that ensures consistency across different parts
 * of the application where the Email attribute is applied.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Email
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_EMAIL)) {
            throw new ValidationException(message: $property . ' must be a valid email address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/EndsWith.php ===
<?php

declare(strict_types=1);

/**
 * Represents a validation rule that asserts a property must end with one of the specified suffixes.
 *
 * This attribute is exclusively designed to be used on class properties, ensuring that the designated
 * property ends with one of the provided suffixes during validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * The EndsWith class is used to validate that a given value ends with one of the specified suffixes.
 *
 * This is particularly useful for ensuring values like file extensions, URLs, or other string properties
 * meet specific criteria. Instead of marking individual properties with multiple attributes, this class
 * allows for a centralized validation logic.
 *
 * ## Why Readonly:
 * The readonly class modifier is used here to ensure immutability of class instances. Once instantiated,
 * the suffixes cannot be altered, providing consistent behaviour throughout the lifetime of the object.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EndsWith
{
    public function __construct(private array $suffixes) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->suffixes as $suffix) {
            if (str_ends_with((string) $value, (string) $suffix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must end with one of the following: ' . implode(', ', $this->suffixes),
        );
    }
}

=== DataHandling/Validation/Attributes/Rules/EnumAreValuesAllowed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * EnumAreValuesAllowed Attribute
 *
 * This validation attribute ensures that a property is an array containing only
 * valid values of a specified Enum class. It applies validation rules during runtime and
 * supports declarative validation of Data Transfer Objects (DTOs) in a clean and DDD-friendly way.
 *
 * Example usage:
 * ```
 * #[EnumAreValuesAllowed(MyEnum::class)]
 * private array $myProperty;
 * ```
 *
 * - The `readonly` modifier ensures immutability after instantiation.
 * - The attribute works only on class properties (`TARGET_PROPERTY`).
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EnumAreValuesAllowed
{
    /**
     * Fully qualified class name of the Enum to validate against.
     *
     * @var string $enumClass The expected Enum class, which must implement `BackedEnum` to support `tryFrom`.
     */
    public function __construct(
        private string $enumClass,
        private bool   $strict = false // disallow null if strict = true
    ) {}

    /**
     * Validates whether the given value is an array of valid Enum instances or Enum-backed values.
     *
     * @param mixed  $value    The property value to validate.
     * @param string $property The name of the property (used for exception messages).
     *
     * @throws ValidationException If the validation fails due to:
     *                              - The value not being an array.
     *                              - The array containing invalid Enum values.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; // ⬅️ Null is valid — ignore further validation
        }

        // Ensure the value is an array
        if (! is_array($value)) {
            throw new ValidationException(
                message: "{$property} must be an array of {$this->enumClass}"
            );
        }

        // Iterate through the array to validate each element
        foreach ($value as $v) {
            if ($v === null) {
                throw new ValidationException(message: "{$property} must not contain null values");
            }

            $resolved = is_object($v) ? $v : ($this->enumClass)::tryFrom($v);

            if (! $resolved instanceof $this->enumClass) {
                throw new ValidationException(
                    message: "{$property} contains invalid enum value: " . var_export($v, true)
                );
            }
        }
    }

    /**
     * Applies the Enum resolution to each element of the value if valid.
     *
     * This method accepts an array of Enum-backed values or Enum instances and ensures
     * that all elements are converted into instances of the specified Enum class.
     *
     * @param mixed $value The property value to process.
     *
     * @return array|null Returns an array of Enum instances if the input is valid, null otherwise.
     */
    public function apply(mixed $value) : array|null
    {
        // Resolve each array element to its respective Enum instance, or return null if not an array
        return is_array($value)
            ? array_map(
                fn($v) => is_object($v) ? $v : ($this->enumClass)::tryFrom($v),
                $value
            )
            : null;
    }
}
=== DataHandling/Validation/Attributes/Rules/EnumIsValueAllowed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use BackedEnum;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute: EnumIsValueAllowed
 *
 * A declarative validation rule that ensures a property adheres to a specified enum constraint.
 * This attribute enforces that the annotated property either:
 * - Is already an instance of the specified Enum class.
 * - Resolves from a scalar value (if the Enum class is backed).
 *
 * If the value cannot be resolved to a valid Enum instance or scalar value, a ValidationException
 * is thrown with an appropriate error describing the issue.
 *
 * **Key Usage:**
 * - This Attribute ensures cleaner and more maintainable DTO properties within DDD contexts.
 * - Limited to `#[Attribute::TARGET_PROPERTY]` for enforcement at the property level.
 *
 * This validator relies on the PHP 8.1+ `BackedEnum` interface for backed enums.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class EnumIsValueAllowed
{
    /**
     * Constructor for the EnumIsValueAllowed Attribute.
     *
     * Leverages Constructor Promotion for concise and expressive class definition.
     *
     * @param class-string<BackedEnum> $enumClass Fully qualified Enum class name.
     *                                            This must be a valid class implementing PHP's `BackedEnum` interface.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates the value against the specified Enum class.
     *
     * This method ensures the following:
     * - If the value is already an instance of the predefined Enum class, no further action is required.
     * - For scalar values (e.g., strings, integers), the method attempts to resolve the value into a backed Enum case.
     * - Throws a `ValidationException` if:
     *   1. The resolution fails (e.g., the provided scalar does not map to any Enum case).
     *   2. The provided value is not an Enum instance or a valid scalar convertible to a case.
     *
     * @param mixed  $value    The value to validate. This can refer to any mixed-type data.
     *                         Passed as a reference (`&`) to apply inline transformations (e.g., scalar -> Enum
     *                         conversion).
     * @param string $property The name of the property being validated.
     *                         Used to provide meaningful error messages for exceptions.
     *
     * @throws ValidationException If the value cannot be validated or resolved to the specified Enum.
     */
    public function validate(mixed &$value, string $property) : void
    {
        // Retrieve the Enum class provided in the attribute.
        $enumClass = $this->enumClass;

        // Step 1: If the value is already an instance of the given Enum class, validation succeeds.
        if ($value instanceof $enumClass) {
            return;
        }

        // Step 2: If the value is a scalar (e.g., string, int), check for compatibility with backed Enums.
        if (is_scalar($value) && is_subclass_of($enumClass, BackedEnum::class)) {
            // Attempt to resolve the scalar value into a backed Enum case using 'tryFrom'.
            $resolved = $enumClass::tryFrom($value);

            // If the value was successfully resolved, update the reference and exit.
            if ($resolved !== null) {
                $value = $resolved;

                return;
            }

            // Step 3: If resolution failed, enumerate all possible backed values for error clarity.
            $allowed = implode(
                ', ',
                array_map(
                    static fn(BackedEnum $e) => $e->value, // Extract each Enum's value.
                    $enumClass::cases() // Retrieve all cases for the Enum.
                )
            );

            // Throw an exception with the allowed values for better debugging and usage feedback.
            throw new ValidationException(
                message: "{$property} must be one of enum {$enumClass}: {$allowed}"
            );
        }

        // Step 4: If the value is neither a valid Enum instance nor a valid scalar convertible to an Enum, throw an exception.
        throw new ValidationException(
            message: "{$property} must be an instance or value of {$enumClass}"
        );
    }
}
=== DataHandling/Validation/Attributes/Rules/Enum.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use BackedEnum;
use Gemini\Exceptions\ValidationException;
use UnitEnum;

/**
 * Enum Validator Attribute
 *
 * Ensures that the provided value matches the specified enum type.
 * Supports both:
 * - Standard enum instances.
 * - Scalar values mapping to `BackedEnum` values.
 * Throws a validation exception when the value violates the constraint.
 *
 * Use attribute declaration to enable declarative validations for Data Objects.
 * Complies with strict type safety and clean code principles.
 *
 * @template T of UnitEnum
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class Enum
{
    /**
     * Initializes the Enum Validator Attribute.
     *
     * @param class-string<T> $enumClass The fully qualified class name of the target enum.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates whether the provided value is a valid enum instance or a scalar value
     * that can be mapped to a `BackedEnum`.
     *
     * @param mixed  $value    The value being validated; expected to be an enum instance or backed value.
     * @param string $property The name of the property being validated (for meaningful exception messages).
     *
     * @throws ValidationException When the value does not match the expected enum or backed enum type.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the provided class exists and is a valid enum.
        if (! enum_exists($this->enumClass)) {
            // Throws an exception when the class does not exist or is not declared as an enum.
            throw new ValidationException(
                message: "Enum class '{$this->enumClass}' does not exist."
            );
        }

        // If the value is already an instance of the specified enum, accept it as valid.
        if ($value instanceof $this->enumClass) {
            return; // Validation passes with no further checks needed.
        }

        // If the value is scalar, validate its compatibility with BackedEnum.
        if (is_scalar($value) && is_subclass_of($this->enumClass, BackedEnum::class)) {
            // Extract all scalar values (backed values) from the enum cases.
            $values = array_column($this->enumClass::cases(), 'value');

            // If the scalar value matches one of the allowed enum backed values, validation passes.
            if (in_array($value, $values, true)) {
                return; // Validation passes; exit early.
            }

            // Throw an exception if the scalar value does not match any of the allowed backed values.
            throw new ValidationException(
                message: "{$property} must be one of: " . implode(', ', $values)
            );
        }

        // Fallback: Reject any other types (e.g., arrays, objects without compatibility).
        throw new ValidationException(message: "{$property} must be a valid enum of type {$this->enumClass}");
    }
}
=== DataHandling/Validation/Attributes/Rules/FileException.php ===
<?php

declare(strict_types=1);

/**
 * FileException ensures that a given property's value is a valid file.
 *
 * This attribute is applied to properties of a Data Transfer Object (DTO)
 * to enforce file validation rules. The class uses PHP's Attribute feature,
 * which allows adding metadata to classes, methods, properties, and more.
 *
 * The class operates under the assumption that file validation is critical
 * for the correctness and security of the business logic in the application
 * where it's used.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Custom exception for file validation errors.
 *
 * This class is used as an attribute to indicate that the associated property
 * should be validated to ensure it is a file. The rationale behind this custom
 * exception is to provide a more specific and meaningful error when validation fails.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FileException
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_file($value)) {
            throw new ValidationException(message: $property . ' must be a file.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Filled.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce that a property must have a value.
 * Applied as a property validator using attributes.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property must have a value.
 *
 * This Attribute is intended to be used on properties to ensure they are not empty.
 * The rationale behind this class is to provide a simple way to perform validation
 * through an attribute-based validation mechanism which enhances readability and maintains
 * validation logic closer to the data definition.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Filled
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (empty($value)) {
            throw new ValidationException(message: $property . ' must have a value.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/FloatRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property value must be a float.
 *
 * This attribute validates that the value of a property is a float. It is
 * primarily used in DTOs to ensure data integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FloatRule
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a valid float.';

    /**
     * Constructor for the FloatRule attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a float or numeric.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a float or numeric.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_float($value) && ! is_numeric($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'expected' => 'float',
                              'actual'   => gettype($value),
                          ]
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/ImageDimension.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate image dimensions for a property in a DTO.
 *
 * This class checks various constraints like specific width, height,
 * minimum and maximum dimensions, and aspect ratio. It is designed to
 * be used as an attribute on properties within data transfer objects (DTOs).
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Exception;
use Gemini\Exceptions\ValidationException;

/**
 * This readonly class is used to encapsulate the dimensions of an image and ensure they adhere to specified validation
 * rules. The readonly modifier ensures immutability, which is crucial for maintaining consistency in image validation
 * parameters.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class ImageDimension
{
    public function __construct(
        private int|null   $width = null,
        private int|null   $height = null,
        private int|null   $min_width = null,
        private int|null   $min_height = null,
        private int|null   $max_width = null,
        private int|null   $max_height = null,
        private float|null $ratio = null,
    ) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        try {
            $dimensions = getimagesize($value);

            $width  = $dimensions[0];
            $height = $dimensions[1];

            if ($this->width !== null && $width !== $this->width) {
                throw new ValidationException(message: sprintf('%s must be %d pixels wide.', $property, $this->width));
            }

            if ($this->height !== null && $height !== $this->height) {
                throw new ValidationException(message: sprintf('%s must be %d pixels tall.', $property, $this->height));
            }

            if ($this->min_width !== null && $width < $this->min_width) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s must be at least %d pixels wide.',
                                 $property,
                                 $this->min_width,
                             ),
                );
            }

            if ($this->min_height !== null && $height < $this->min_height) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s must be at least %d pixels tall.',
                                 $property,
                                 $this->min_height,
                             ),
                );
            }

            if ($this->max_width !== null && $width > $this->max_width) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels wide.', $property, $this->max_width),
                );
            }

            if ($this->max_height !== null && $height > $this->max_height) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels tall.', $property, $this->max_height),
                );
            }

            if ($this->ratio !== null && abs($width / $height - $this->ratio) > 0.0001) {
                throw new ValidationException(message: sprintf('%s aspect ratio must be %s.', $property, $this->ratio));
            }
        } catch (Exception) {
            throw new ValidationException(message: $property . ' has invalid image dimensions.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Image.php ===
<?php

declare(strict_types=1);

/**
 * Defines an attribute to validate that a property is an image.
 *
 * This attribute should be used to annotate properties that are expected to
 * hold image file names or paths. The validation logic checks the file
 * extension against a pre-defined list of allowed image formats.
 *
 * Usage:
 * #[Image]
 * private $imageProperty;
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validate that the provided file's extension is among the allowed image types.
 *
 * INTENT: Ensure that the input value is a valid image format to prevent
 * invalid data from entering the system, which could cause errors downstream.
 * This method throws an exception if validation fails to enforce strict conformity.
 *
 * @throws \Gemini\Exceptions\ValidationException If the file extension is not permitted.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Image
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $allowedMimes = ['jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'];
        $extension    = strtolower(pathinfo((string) $value, PATHINFO_EXTENSION));
        if (! in_array($extension, $allowedMimes, true)) {
            throw new ValidationException(message: $property . ' must be an image.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/In.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute that validates a property's value is one of a predefined set.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class In
{
    /**
     * @param array<int|string> $values List of accepted values for the field.
     */
    public function __construct(private array $values) {}

    /**
     * Validates whether a given value is in the allowed set.
     *
     * @param mixed  $value    Value to validate.
     * @param string $property Property name (for exception context).
     *
     * @throws ValidationException If the value is not in the list of allowed values.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Unwrap enum to scalar value if needed
        if (is_object($value) && method_exists($value, 'value')) {
            $value = $value->value;
        }

        // Perform strict comparison against an allowed set
        if (! in_array($value, $this->values, true)) {
            $allowed = implode(', ', array_map('strval', $this->values));

            throw new ValidationException(
                message: "{$property} must be one of: {$allowed}"
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Integer.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Class Integer
 *
 * This class is an attribute used for validating that the targeted property is an integer.
 * It is designed to enforce validation rules declaratively using PHP's Attribute syntax
 * and ensures that incorrect data types are rejected with clear exception handling.
 *
 * Domain-Driven Design (DDD) implications:
 * - Acts as a declarative rule for property validation within domain entities or value objects.
 * - Short-circuits invalid input before further operations, preserving domain integrity.
 *
 * @package Gemini\DataHandling\Validation\Attributes\Rules
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)] // Restricts this attribute to properties.
class Integer
{
    /**
     * The default error message used when the validation fails.
     *
     * This constant defines a generic error message indicating that the value must be an integer.
     * It uses a placeholder to include the property name dynamically.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be an integer.';

    /**
     * Custom error message for validation failures.
     *
     * @var string|null $message A custom message provided at instantiation to override the default.
     *                           If null, the default error message will be used.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the given value is an integer.
     *
     * A property is validated against this rule. If the value does not satisfy the constraint,
     * a `ValidationException` is thrown, containing detailed metadata about the failure.
     *
     * @param mixed  $value    The value to be validated. Can be any type, as mixed is used.
     * @param string $property The name of the property being validated, for error context.
     *
     * @return void
     *
     * @throws ValidationException If the value is not an integer.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the value is not an integer.
        if (! is_int($value)) {
            // Throw a detailed validation exception if the value is invalid.
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                // Use a custom or default error message.
                metadata: [
                              'property' => $property, // The name of the property being validated.
                              'value'    => $value,    // The actual value that failed validation.
                              'expected' => 'int',     // The expected type of the value (integer).
                              'actual'   => gettype($value), // The actual type of the provided value.
                          ]
            );
        }
    }
}
=== DataHandling/Validation/Attributes/Rules/IPAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to indicate that a property must be a valid IP address.
 *
 * This class is designed to be used as an attribute on properties within
 * Data Transfer Objects (DTOs). It validates that the given property value is a
 * valid IP address, ensuring data integrity and consistency.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * This class is designed to validate IP addresses for properties marked with the TARGET_PROPERTY attribute.
 *
 * The primary behavior of this class is to ensure that values assigned to certain properties are valid IP addresses,
 * throwing a ValidationException otherwise. This ensures data integrity and consistency across the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPAddress
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/IP.php ===
<?php

declare(strict_types=1);

/**
 * IP Attribute class used to validate that a property holds a valid IP address.
 *
 * This class is designed to be instantiated as an attribute to enforce that a property
 * within a Data Transfer Object (DTO) is a valid IP address. Utilizing PHP's Attribute
 * syntax makes the validation declarative and more maintainable.
 *
 * - The `TARGET_PROPERTY` flag ensures that this attribute can only be applied to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validate if the given value is a valid IP address.
 * Throws an exception if validation fails.
 *
 * @throws \Gemini\Exceptions\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IP
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/IPv4.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce IPv4 validation on properties.
 *
 * This class will be used to annotate properties and ensure they contain valid IPv4 addresses.
 * The main decision here is to leverage PHP's filter_var function with the FILTER_VALIDATE_IP flag.
 * This is a better approach than regular expressions due to its efficiency and robustness.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * An attribute class to validate if a given value is a valid IPv4 address.
 *
 * The validation is essential for ensuring that the property this attribute
 * is applied to adheres to the IPv4 format, which can be critical for
 * network configurations and communication protocols.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv4
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            throw new ValidationException(message: $property . ' must be a valid IPv4 address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/IPv6.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to designate a property that must be a valid IPv6 address.
 * The use of this attribute triggers validation against the IPv6 format.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates that the given value is a proper IPv6 address. If not, it throws a ValidationException.
 *
 * @param mixed  $value    The value to be validated as an IPv6 address.
 * @param string $property The name of the property being validated.
 *
 * @throws \Gemini\Exceptions\ValidationException If the value is not a valid IPv6 address.
 *
 * The use of filter_var function with FILTER_VALIDATE_IP and FILTER_FLAG_IPV6 ensures that only valid IPv6 formats are
 * accepted, reinforcing data integrity especially where IP addresses are critical.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv6
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            throw new ValidationException(message: $property . ' must be a valid IPv6 address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/JSON.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for marking properties that should be validated as JSON.
 * Using #[Attribute(flags: Attribute::TARGET_PROPERTY)] to limit usage to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates if the provided value is a valid JSON string.
 *
 * @throws \Gemini\Exceptions\ValidationException If the value is not a valid JSON string.
 *
 * The rationale for this function is to ensure that properties using this attribute
 * always contain valid JSON data. This helps maintain data integrity within the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class JSON
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        json_decode((string) $value);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new ValidationException(message: $property . ' must be a valid JSON string.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/MACAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for defining a MAC address validation rule to be used on DTO properties.
 *
 * This class leverages PHP's Attribute feature introduced in PHP 8. It is intended to be
 * used as an attribute on properties in Data Transfer Objects (DTOs) to enforce that the
 * value of the property is a valid MAC address.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validate the given MAC address.
 *
 * This method uses PHP's built-in `filter_var` function to check if the input value
 * is a valid MAC address. If it's not, a `ValidationException` is thrown.
 *
 * @throws \Gemini\Exceptions\ValidationException If the given value is not a valid MAC address.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class MACAddress
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_MAC)) {
            throw new ValidationException(message: $property . ' must be a valid MAC address.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Max.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Countable;
use Gemini\Exceptions\ValidationException;
use InvalidArgumentException;

/**
 * Attribute to enforce a maximum value or length constraint on a property.
 *
 * Supports validation for strings, numerics, arrays, and countable objects.
 **/
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Max
{
    /** Error messages for different validation types. */
    private const string ERROR_NUMERIC   = 'The value of "%s" must not exceed %d.';

    private const string ERROR_STRING    = 'The length of "%s" must not exceed %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must not exceed %d.';

    private const string ERROR_INVALID   = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';

    /**
     * Constructor for the Max attribute.
     *
     * @param int         $max     The maximum value or size.
     * @param string|null $message Optional custom error message.
     *
     * @throws InvalidArgumentException If the max value provided is negative.
     */
    public function __construct(private readonly int $max, private readonly string|null $message = null)
    {
        // Ensure the maximum value is a non-negative integer.
        if ($max < 0) {
            throw new InvalidArgumentException(message: 'The maximum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the maximum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     **/
    public function validate(mixed $value, string $property) : void
    {
        // Allow null values (no validation required for null).
        if ($value === null) {
            return;
        }

        // Match the type of value to the appropriate validation method.
        match (true) {
            is_numeric($value)                              => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string($value)                               => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable($value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                                         => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    /**
     * Validates numeric values against the maximum constraint.
     *
     * @param float  $value    The numeric value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value exceeds the maximum.
     */
    private function validateNumeric(float $value, string $property) : void
    {
        if ($value > $this->max) {
            // The Numeric value exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    /**
     * Throws a ValidationException with relevant error details.
     *
     * @param string $errorKey The error key identifying the type of validation error.
     * @param string $property The name of the property being validated.
     * @param mixed  $value    The value that caused the validation failure.
     *
     * @throws ValidationException Always triggered when called.
     */
    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        // Constructs and throws a detailed ValidationException.
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at most %d.', ucfirst($property), $this->max),
            metadata: [
                          'property' => $property,
                          'value'    => $value,
                          'max'      => $this->max,
                          'errorKey' => $errorKey,
                      ]
        );
    }

    /**
     * Validates string values against the maximum length constraint.
     *
     * @param string $value    The string value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the string length exceeds the maximum.
     */
    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen($value) > $this->max) {
            // String length exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    /**
     * Validates array or countable values against the maximum count constraint.
     *
     * @param array|Countable $value    The array or countable value to validate.
     * @param string          $property The name of the property being validated.
     *
     * @throws ValidationException If the count exceeds the maximum.
     */
    private function validateCountable(array|Countable $value, string $property) : void
    {
        // Determine the count of elements.
        $count = is_array($value) ? count($value) : iterator_count($value);

        if ($count > $this->max) {
            // Element count exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}
=== DataHandling/Validation/Attributes/Rules/MigrationArrayRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates and casts to array from native array or JSON stringified array.
 *
 * Accepts:
 * - native PHP array
 * - JSON-encoded array string
 * - null
 *
 * Rejects:
 * - all other types (objects, ints, resources, strings that are not valid JSON arrays)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationArrayRule
{
    /**
     * Validates that the value is either a PHP array or a valid JSON string representing an array.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_array($value)) {
            return;
        }

        if (is_string($value) && json_validate(json: $value)) {
            $decoded = json_decode($value, true);

            if (is_array($decoded)) {
                return;
            }
        }

        throw new ValidationException(
            message: "{$property} must be a valid array or JSON array string. Got: " . get_debug_type($value)
        );
    }

    /**
     * Converts value to PHP array if valid. Returns null if value is null.
     *
     * @param mixed $value
     *
     * @return array|null
     */
    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== DataHandling/Validation/Attributes/Rules/MigrationFieldAttributesRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\FieldModifierEnum;
use Gemini\Exceptions\ValidationException;

/**
 * Validates and casts an array of migration field modifiers.
 *
 * Accepts:
 * - FieldModifierEnum[]
 * - string[] matching FieldModifierEnum values
 *
 * Rejects:
 * - any non-array input
 * - values not resolvable via FieldModifierEnum::tryFrom()
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldAttributesRule
{
    /**
     * Validates an array of enum-compatible modifiers.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! is_array($value)) {
            throw new ValidationException(
                message: "{$property} must be an array of FieldModifierEnum values or string equivalents."
            );
        }

        foreach ($value as $item) {
            if ($item === null) {
                continue;
            }

            if ($item instanceof FieldModifierEnum) {
                continue;
            }

            if (! is_string($item)) {
                throw new ValidationException(
                    message: "{$property} contains non-string value: " . var_export($item, true)
                );
            }

            if (! FieldModifierEnum::tryFrom($item)) {
                throw new ValidationException(
                    message: "{$property} contains invalid field modifier: " . var_export($item, true)
                );
            }
        }
    }

    public function apply(mixed $value) : array|null
    {
        return is_array($value) ? $value : null;
    }

}

=== DataHandling/Validation/Attributes/Rules/MigrationFieldTypeRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Gemini\Exceptions\ValidationException;

/**
 * Validation rule for the 'type' field in FieldDTO.
 *
 * Ensures the field is either:
 * - an instance of FieldTypeEnum (hydrated previously), or
 * - null (optional field)
 *
 * No casting is done here – hydration must have resolved the correct type.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldTypeRule
{
    /**
     * Validates the 'type' field value without casting.
     *
     * @param mixed  $value    The raw or hydrated value of the property
     * @param string $property The property name being validated
     *
     * @throws ValidationException If the value is not null or a FieldTypeEnum instance
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! $value instanceof FieldTypeEnum) {
            throw new ValidationException(
                message: "{$property} must be an instance of FieldTypeEnum or null. Got: " . get_debug_type($value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}
=== DataHandling/Validation/Attributes/Rules/MigrationForeignActionRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Gemini\Exceptions\ValidationException;

/**
 * Validates the 'onDelete' and 'onUpdate' fields as valid ForeignActionEnum values.
 *
 * Accepts:
 * - null (no validation error)
 * - ForeignActionEnum instance (direct assignment)
 * - string (cast to enum via tryFrom)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationForeignActionRule
{
    /**
     * Validates that the input is either null or a valid ForeignActionEnum (or castable string).
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException If an invalid type or unknown enum case is given.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || $value instanceof ForeignActionEnum) {
            return;
        }

        if (! is_string($value)) {
            throw new ValidationException(message: "{$property} must be a string or ForeignActionEnum instance.");
        }

        if (ForeignActionEnum::tryFrom(value: $value) === null) {
            throw new ValidationException(
                message: "{$property} is not a valid ForeignActionEnum. Got: " . var_export($value, true)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== DataHandling/Validation/Attributes/Rules/MigrationIntegerRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates and casts integer-compatible inputs.
 *
 * Accepts:
 * - Native integer (e.g. 42)
 * - Numeric strings representing non-negative integers (e.g. "42")
 *
 * Rejects:
 * - Floats (e.g. 3.14)
 * - Negative numeric strings with non-digit chars (e.g. "-42", "42a")
 * - Booleans, arrays, objects, null (except null is accepted)
 *
 * Example:
 *   "42" => 42
 *   42 => 42
 *   null => null
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class MigrationIntegerRule
{
    /**
     * Validates the value against integer or digit-only string formats.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || is_int($value)) {
            return;
        }

        if (is_string($value) && preg_match('/^\d+$/', $value)) {
            return;
        }

        throw new ValidationException(
            message: "{$property} must be an integer or numeric string. Got: " . get_debug_type($value)
        );
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== DataHandling/Validation/Attributes/Rules/MigrationStringRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Validates and casts a value to string if allowed.
 *
 * Accepts:
 * - native string
 * - int, float, bool (castable scalars)
 * - objects implementing __toString()
 * Rejects:
 * - arrays, resources, objects without __toString
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationStringRule
{
    /**
     * Validates the string-compatibility of a value.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_bool($value)) {
            throw new ValidationException(message: "{$property} cannot be a boolean when casting to string.");
        }

        if (! is_scalar($value) && ! (is_object($value) && method_exists($value, '__toString'))) {
            throw new ValidationException(
                message: "{$property} must be a string or string-castable object. Got: " . get_debug_type($value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== DataHandling/Validation/Attributes/Rules/Mimes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class Mimes to enforce file type restrictions on a given property.
 *
 * This class is marked as `readonly` to indicate that once instantiated, the `$mimes` array should not be modified,
 * maintaining the integrity of the type rules it enforces.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * ########################################################################
 * Represents a validation rule for file mime types.
 *
 * `readonly` keyword ensures the $mimes array cannot be modified after
 * the object is constructed, which guarantees immutability and consistency.
 * This is crucial for validation logic as allowed mime types must remain constant.
 * ########################################################################
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimes
{
    public function __construct(private array $mimes) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $extension = strtolower(pathinfo((string) $value, PATHINFO_EXTENSION));
        if (! in_array($extension, $this->mimes)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(', ', $this->mimes),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Mimetypes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define permissible MIME types for a file property.
 *
 * The class is marked as readonly to ensure immutability after initialization.
 * It is targeted specifically for class properties using the `Attribute::TARGET_PROPERTY` flag.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use finfo;
use Gemini\Exceptions\ValidationException;

/**
 * This class is designed to enforce validation of file MIME types.
 * Declared as `readonly` to ensure immutability of `mimetypes` after instantiation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimetypes
{
    public function __construct(private array $mimetypes) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $finfo    = new finfo(flags: FILEINFO_MIME_TYPE);
        $mimeType = $finfo->file(filename: $value);

        if (! in_array($mimeType, $this->mimetypes, true)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(
                           ', ',
                           $this->mimetypes,
                       ),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Min.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Countable;
use Gemini\Exceptions\ValidationException;
use InvalidArgumentException;

/**
 * Attribute to enforce a minimum value or length constraint on a property.
 *
 * Supports numeric values, strings, and countable objects/arrays.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Min
{
    private const string ERROR_NUMERIC   = 'The value of "%s" must be at least %d.';

    private const string ERROR_STRING    = 'The length of "%s" must be at least %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must be at least %d.';

    private const string ERROR_INVALID   = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';


    /**
     * Constructor for the Min attribute.
     *
     * @param int         $min     The minimum value or size.
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private readonly int $min, private readonly string|null $message = null)
    {
        if ($min < 0) {
            throw new InvalidArgumentException(message: 'The minimum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the minimum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; // Allow nulls; other validators handle required constraints.
        }

        match (true) {
            is_numeric($value)                              => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string($value)                               => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable($value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                                         => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    private function validateNumeric(float $value, string $property) : void
    {
        if ($value < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at least %d.', ucfirst($property), $this->min),
            metadata: [
                          'property' => $property,
                          'value'    => $value,
                          'min'      => $this->min,
                          'errorKey' => $errorKey,
                      ]
        );
    }

    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen($value) < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    private function validateCountable(array|Countable $value, string $property) : void
    {
        $count = is_array($value) ? count($value) : iterator_count($value);

        if ($count < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/NotIn.php ===
<?php

declare(strict_types=1);

/**
 * An attribute class applied to a property to ensure the property value is not
 * within a specified set of values. This uses a 'NotIn' validation rule.
 *
 * This class is marked as 'readonly' to signify that it should not be modified
 * after instantiation, enhancing its immutability and ensuring integrity.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property value is not within a specified array of values.
 *
 * The readonly modifier ensures that instances of this class are immutable once constructed.
 * This design choice prevents accidental changes to the array of invalid values after instantiation,
 * which is critical for maintaining consistent validation rules.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotIn
{
    public function __construct(private array $values) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array($value, $this->values, true)) {
            throw new ValidationException(message: $property . ' must not be one of: ' . implode(', ', $this->values));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/NotRegex.php ===
<?php

declare(strict_types=1);

/**
 * The NotRegex class is an attribute used to validate that a property does not match a given regex pattern.
 *
 * This attribute is applied at the property level (TARGET_PROPERTY) and enforces validation rules at runtime.
 * The primary use case is to ensure that certain input properties do not conform to particular patterns,
 * which is critical for enforcing business rules and avoiding invalid data submissions.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * This attribute class ensures that a value does not match a specific regex pattern.
 *
 * Using the #[Attribute(flags: Attribute::TARGET_PROPERTY)] directive to target properties only,
 * it integrates with validation mechanisms seamlessly.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotRegex
{
    public function __construct(private string $pattern) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (preg_match($this->pattern, (string) $value)) {
            throw new ValidationException(message: $property . ' format is invalid.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Nullable.php ===
<?php

declare(strict_types=1);

/**
 * This class represents an attribute that can be used to mark a property as nullable.
 *
 * By using the #[Nullable] attribute, it indicates that a property on a data transfer object (DTO)
 * can accept a null value, which is relevant in many scenarios like optional fields or partial updates.
 *
 * The use of #[Attribute(flags: Attribute::TARGET_PROPERTY)] specifies that this attribute can only
 * be applied to properties, ensuring it isn't misapplied to methods or classes.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * This class is used as an attribute to indicate that a property can be null.
 * The lack of validation signifies that null values are permissible, simplifying the handling of such properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Nullable
{
    public function validate(mixed $value, string $property) : void
    {
        // No validation needed; the property being null is acceptable.
    }
}

=== DataHandling/Validation/Attributes/Rules/Numeric.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce numeric validation on a property.
 *
 * This attribute is applied to properties that must contain numeric values.
 * The `validate` method will be called to ensure the property value adheres to the numeric constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property must be numeric.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Numeric
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_numeric($value)) {
            throw new ValidationException(message: $property . ' must be a number.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Present.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class intended to mark properties that are required to be 'present'.
 * While commonly attributes enforce validation rules, this class only ensures
 * that the marked property is flagged as existing within the data set.
 *
 * This can be used in situations where simply the presence (even null or empty)
 * signifies a valid state. The property carrying this attribute thus should be checked
 * for its existence, but no further validation on its value is performed.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * Attribute class that enforces the presence of a property.
 * This is typically used in situations where merely setting the property is enough to confirm its presence.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Present
{
    public function validate(mixed $value, array $data, string $property) : void
    {
        // No validation needed; the property being set means it is present.
    }
}

=== DataHandling/Validation/Attributes/Rules/RegexException.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;
use InvalidArgumentException;

/**
 * Attribute for enforcing regular expression validation on class properties.
 *
 * Validates that a property value matches a specified regular expression.
 * Includes optional custom error messages for flexible validation error handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RegexException
{
    private const string DEFAULT_ERROR_MESSAGE = '%s format is invalid.';

    /**
     * Constructor for the RegexException attribute.
     *
     * @param string      $pattern The regular expression pattern to validate against.
     * @param string|null $message Optional custom error message for validation failures.
     *
     * @throws InvalidArgumentException If the provided regex pattern is invalid.
     */
    public function __construct(
        private string      $pattern,
        private string|null $message = null
    ) {
        $this->validatePattern($pattern);
    }

    /**
     * Ensures the regex pattern is valid.
     *
     * @param string $pattern The regex pattern to validate.
     *
     * @throws InvalidArgumentException If the regex pattern is invalid.
     */
    private function validatePattern(string $pattern) : void
    {
        if (preg_match($pattern, '') === false) {
            throw new InvalidArgumentException(sprintf('Invalid regex pattern: %s', $pattern));
        }
    }

    /**
     * Validates a value against the regex pattern.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value does not match the regex pattern.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($this->isInvalidValue($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'pattern'  => $this->pattern,
                          ]
            );
        }
    }

    /**
     * Checks if a value is invalid based on the regex pattern.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is invalid; false otherwise.
     */
    private function isInvalidValue(mixed $value) : bool
    {
        if (! is_string($value) && ! is_numeric($value)) {
            return true; // Only strings and numeric values are valid
        }

        return preg_match($this->pattern, (string) $value) !== 1;
    }
}

=== DataHandling/Validation/Attributes/Rules/Required.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property (or a nested path) must be provided and not null.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY | Attribute::IS_REPEATABLE)]
class Required
{
    /**
     * Path within the object to validate (e.g., 'schema.fields')
     *
     * @var string|null
     */
    private string|null $path;

    /**
     * Custom validation error message.
     *
     * @var string|null
     */
    private string|null $message;

    /**
     * Constructor
     *
     * @param string|null $path    Optional deep path to validate (e.g., 'schema.fields')
     * @param string|null $message Optional custom error message
     */
    public function __construct(string|null $path = null, string|null $message = null)
    {
        $this->path    = $path;
        $this->message = $message;
    }

    /**
     * Validates a required value, supporting deep paths like 'schema.fields'.
     *
     * @param mixed  $value    The full object or field to validate.
     * @param string $property The property name being validated.
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $target = $value;

        if ($this->path !== null) {
            // Traverse nested properties (e.g., schema.fields)
            foreach (explode('.', $this->path) as $segment) {
                if (is_array($target) && array_key_exists($segment, $target)) {
                    $target = $target[$segment];
                } elseif (is_object($target) && isset($target->$segment)) {
                    $target = $target->$segment;
                } else {
                    $target = null;
                    break;
                }
            }
        }

        if ($target === null) {
            throw new ValidationException(
                message : $this->message ?? sprintf(
                'The "%s" field is required and cannot be null.',
                $this->path ?? $property
            ),
                metadata: ['property' => $this->path ?? $property]
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/RequiredWithout.php ===
<?php

declare(strict_types=1);

/**
 * The RequiredWithout attribute marks a property as required only if certain other fields are not present.
 * This is useful for conditional validation scenarios where the presence of a property is dependent on the absence of
 * other properties.
 *
 * This attribute is intended to be applied to class properties (Target: PROPERTY).
 * It leverages PHP 8's attribute syntax to integrate seamlessly with the language's validation infrastructure.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Class RequiredWithout
 *
 * Attribute class to enforce the requirement of a property being non-empty unless certain other properties are present
 * in data.
 *
 * - The use of readonly ensures immutability, making fields immutable after instantiation.
 * - The __construct function takes an array of fields to check against, ensuring robustness and flexibility.
 * - The validate method includes complex business logic following a specific validation rule, demanding an explanation
 * for future maintainability.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWithout
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (! isset($data[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s is required when %s is not present.',
                                 $property,
                                 $field,
                             ),
                );
            }
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/RequiredWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class enforcing a "required with" validation rule.
 *
 * This attribute ensures that a given property must have a value if the specified fields are present in the provided
 * data array. The class and its methods help enforce specific business rules where data interdependencies require
 * conditional validations.
 *
 * Attribute is set to TARGET_PROPERTY for use with class properties.
 * The class is marked as readonly as it doesn't require modification after instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class for validating that a property is required if specified sibling properties are present.
 *
 * The readonly modifier ensures that the $fields property is immutable, providing safety by preventing accidental
 * changes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWith
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (isset($data[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf('%s is required when %s is present.', $property, $field),
                );
            }
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Same.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce that the value of the decorated property
 * must match the value of another specified property within the same data context.
 *
 * This attribute should be applied to properties within a DTO to ensure
 * that certain fields have equal values, which is helpful for tasks such as
 * confirming password or email fields.
 *
 * Using the readonly class guarantees immutability once instantiated, ensuring data consistency.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * This class defines a validation rule that ensures a given property value is the same as another specified property
 * value. It is an immutable class, signified by the 'readonly' keyword, meaning its state cannot be altered after
 * instantiation.
 *
 * The primary use case is validation scenarios where fields need to have matching values, such as password
 * confirmation fields.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Same
{
    public function __construct(private string $field) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if ($value !== ($data[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be the same as %s.', $property, $this->field));
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Size.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define a validation rule for the exact size of a property's value.
 *
 * This class is marked readonly to enforce immutability after instantiation, ensuring
 * the consistency of the size constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class for enforcing fixed-size length constraints on properties.
 * Applied at the property level to validate that a property's length matches the specified size.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Size
{
    public function __construct(private int $size) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (strlen((string) $value) !== $this->size) {
            throw new ValidationException(
                message: sprintf('%s must be exactly %d characters.', $property, $this->size),
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/StartsWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property's value starts with one of the specified prefixes.
 * Using this attribute helps ensure consistent data formatting and validation across the application.
 *
 * The Attribute is restricted to be used on properties by the TARGET_PROPERTY flag.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class for validating that a given value starts with one of the specified prefixes.
 *
 * The class uses PHP 8.0's Attributes feature to provide declarative validation rules on class properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class StartsWith
{
    public function __construct(private array $prefixes) {}

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->prefixes as $prefix) {
            if (str_starts_with((string) $value, (string) $prefix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must start with one of the following: ' . implode(', ', $this->prefixes),
        );
    }
}

=== DataHandling/Validation/Attributes/Rules/StringType.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property value must be a string.
 *
 * This attribute validates that the value of a property is a string. It is
 * primarily used in DTOs to ensure data integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class StringType
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a string.';

    /**
     * Constructor for the StringType attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a string.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a string.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_string($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'expected' => 'string',
                              'actual'   => gettype($value),
                          ]
            );
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Timezone.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to specify a property should hold a valid timezone.
 *
 * - Set the target to property to enforce the attribute can only be used on class properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTimeZone;
use Gemini\Exceptions\ValidationException;

/**
 * Validates whether the provided value is a valid timezone identifier.
 *
 * @throws \Gemini\Exceptions\ValidationException If the value is not a valid timezone identifier.
 *
 * The method leverages the DateTimeZone::listIdentifiers() method to ensure
 * the value conforms to one of the recognized timezone identifiers. This is
 * crucial for maintaining consistency and avoiding errors related to time
 * calculations throughout the application. Any deviation triggers a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Timezone
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array($value, DateTimeZone::listIdentifiers(), true)) {
            throw new ValidationException(message: $property . ' must be a valid timezone.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/Trimmed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

#[Attribute(Attribute::TARGET_PROPERTY)]
class Trimmed
{
    /**
     * Trims the given value if it is a string.
     *
     * @param mixed $value The value to trim.
     *
     * @return mixed The trimmed value.
     */
    public function apply(mixed $value) : mixed
    {
        return is_string($value) ? trim($value) : $value;
    }
}


=== DataHandling/Validation/Attributes/Rules/Url.php ===
<?php

declare(strict_types=1);

/**
 * Class URL
 *
 * Defines a custom attribute for validating if a property is a valid URL.
 * Meant to be used on class properties to enforce URL format validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute class to represent URL validation.
 *
 * Applied at TARGET_PROPERTY level to ensure properties are valid URLs.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class URL
{
    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_URL)) {
            throw new ValidationException(message: $property . ' must be a valid URL.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/UUID.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for enforcing UUID validation on properties.
 *
 * This class is defined as an attribute which can be used to annotate properties within data transfer objects (DTOs).
 * The validation logic ensures that any property marked with this attribute contains a valid UUID string.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * This class defines a UUID attribute to be used for property validation.
 *
 * The class ensures that UUIDs conform to the standard format, making it useful for
 * database or API validations where UUIDs are commonly used as unique identifiers.
 *
 * The UUID class is marked as an attribute with the TARGET_PROPERTY flag, meaning
 * it can be assigned to class properties for validation purposes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class UUID
{
    private const string UUID_REGEX =
        '/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i';

    /**
     * @throws \Gemini\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match(self::UUID_REGEX, (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' must be a valid UUID.');
        }
    }
}

=== DataHandling/Validation/Attributes/Rules/ValidDTOArray.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exceptions\ValidationException;

/**
 * Attribute for validating an array of data transfer objects (DTOs).
 *
 * This attribute ensures that a property adheres to an array structure where all items
 * are valid DTOs inheriting from the specified target class (via `$dtoClass`).
 *
 * The validation process assumes that the target DTO class's constructor validates
 * its input automatically. Invalid data within the array will trigger a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
final readonly class ValidDTOArray
{
    /**
     * The fully-qualified class name of the Data Transfer Object (DTO) we expect.
     *
     * @param string $dtoClass The DTO class name to validate instantiated items.
     */
    public function __construct(private string $dtoClass) {}

    /**
     * Validates the given value to ensure it is an array of valid DTOs.
     *
     * Checks the following conditions:
     * - The value must be an array.
     * - Each item in the array must be either an array or an object.
     * - An instance of the specified `$dtoClass` must be successfully created for each item.
     *
     * If any of the above conditions are violated, a ValidationException is thrown.
     *
     * @param mixed  $value    The value of the property to be validated.
     * @param string $property The name of the property being validated, used in exception messages.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Ensure the provided value is of type array.
        if (! is_array($value)) {
            throw new ValidationException(
                message: "Expected array of DTOs for {$property}"
            );
        }

        // Iterate through the array to validate each item.
        foreach ($value as $item) {
            // Ensure each item is either an array or an object.
            if (! is_array($item) && ! is_object($item)) {
                throw new ValidationException(
                    message: "Invalid item in {$property}, must be an array or object"
                );
            }

            // Attempt to instantiate the target DTO class with the item.
            // This assumes the DTO constructor validates its input.
            new $this->dtoClass($item);
        }
    }

    /**
     * Converts all elements of the array into instances of the specified DTO class.
     *
     * This method applies a transformation where each element of the input array
     * is passed to the constructor of the defined `$dtoClass`, returning a new array
     * of fully instantiated DTO objects.
     *
     * @param mixed $value The input array to transform.
     *
     * @return array<int, object> An array of DTO objects.
     *
     * @throws ValidationException If construction of any DTO fails.
     */
    public function apply(mixed $value) : array
    {
        return array_map(
            fn($v) => new $this->dtoClass($v), // Instantiate DTO for each item
            $value // Input array
        );
    }
}
=== DataHandling/Validation/messages.php ===
<?php

declare(strict_types=1);

return [
    'validation.max.invalid_type' => 'Invalid type for {property}. Expected {expected}, got {actual}.',
    'validation.max.string'       => '{property} may not be longer than {max} characters.',
    'validation.max.numeric'      => '{property} may not be greater than {max}.',
    'validation.max.countable'    => '{property} may not contain more than {max} items.',
];
=== DumpDebugger.php ===
<?php

declare(strict_types=1);

namespace Gemini;

use JetBrains\PhpStorm\NoReturn;
use RuntimeException;

final class DumpDebugger
{
    #[NoReturn]
    /**
     * Enhanced Dump and Die functionality with interactive HTML output.
     *
     * This method provides a sophisticated debugging tool that renders variables
     * in an interactive HTML interface with search and navigation capabilities.
     * Execution is terminated after output is rendered.
     *
     * @param mixed ...$args The variables to dump and inspect
     *
     * @return never Method terminates execution
     * @throws \RuntimeException If headers have already been sent
     *
     * @api
     * @since 8.3.0
     */
    public static function ddx(mixed ...$args) : never
    {
        // Retrieve caller information from debug backtrace, limiting to 2 frames for performance
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1] ?? [];

        // Extract file and line information with fallback values for safety
        $file = $trace['file'] ?? 'unknown';
        $line = $trace['line'] ?? 0;

        // Set the content type to ensure proper rendering in the browser
        header('Content-Type: text/html; charset=utf-8');

        // Render the HTML header with file and line information
        echo self::renderHtmlHeader(
            file: $file,
            line: $line
        );

        // Iterate through and render each provided argument in a separate container
        foreach ($args as $arg) {
            echo '<div class="ddx">' . self::renderValue(
                    key  : null,
                    value: $arg
                ) . '</div>';
        }

        // Close HTML structure and terminate execution with error status
        echo '</body></html>';
        exit(1);
    }

    /**
     * Renders the HTML header for the debug dump viewer.
     *
     * This method generates the complete HTML header including styles and JavaScript
     * for the interactive debug dump interface. It implements a sophisticated search
     * functionality with real-time highlighting and navigation capabilities.
     *
     * Features:
     * - Modern dark theme optimized for readability
     * - Interactive search with key-value pair support
     * - Collapsible tree structure for nested data
     * - Keyboard navigation support
     * - Syntax highlighting for different data types
     *
     * @param string $file The source file path where the dump was triggered
     * @param int    $line The line number where the dump was triggered
     *
     * @return string Complete HTML header markup with embedded styles and JavaScript
     *
     * @throws \InvalidArgumentException When a file path is empty or the line number is negative
     * @since 1.0.0
     */
    private static function renderHtmlHeader(string $file, int $line) : string
    {
        $fileEsc = htmlspecialchars($file);

        return <<<HTML
                                    <!DOCTYPE html>
                                    <html lang="en">
                                    <head>
                                        <meta charset="UTF-8">
                                        <title>GemDump</title>
                                        <style>
                                            body { background: #0f0f0f; color: #eee; font-family: 'JetBrains Mono', monospace; padding: 5rem 2rem 2rem; font-size: 14px; }
                                            .entry { white-space: pre; margin: 3px 0; }
                                            .toggle { color: #58a6ff; cursor: pointer; user-select: none; margin-right: 0.5rem; font-weight: bold; }
                                            .children { padding-left: 2rem; border-left: 1px dashed #444; margin-top: 2px; }
                                            .key { color: #ffc66d; }
                                            .operator { color: #aaa; }
                                            .type { color: #8be9fd; }
                                            .value.string { color: #a5ff90; }
                                            .value.int { color: #bd93f9; }
                                            .value.float { color: #79c0ff; }
                                            .value.bool { color: #ff9ac1; }
                                            .value.null { color: #808080; font-style: italic; }
                                            .value.unknown { color: #999; }
                                            .collapsed > .children { display: none; }
                                            .highlight-key { background: #343a40; color: #80ffea; padding: 1px 4px; border-radius: 3px; }
                                            .current-key { outline: 2px solid #ff5722; }
                                            .dumpx-stack { margin-top: 2rem; padding: 1rem 2rem; background: #121212; border-left: 4px solid #ffc107; }
                                            .search-container { position: fixed; top: 0; left: 0; right: 0; z-index: 9999; background: #1a1a1a; padding: 10px 20px; border-bottom: 1px solid #333; display: flex; align-items: center; gap: 8px; }
                                            .search-container input { padding: 6px 10px; font-size: 13px; background: #0f0f0f; color: #fff; border: 1px solid #555; border-radius: 5px; width: 300px; }
                                            .search-container button { background: #ffc107; color: #000; font-weight: bold; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
                                            .search-container span { font-size: 12px; color: #bbb; }
                                        </style>
                                        <script>
                                            let results = [], currentIndex = -1;
            
                                            function normalize(text) {
                                                return text.toLowerCase()
                                                    .replace(/\\s+/g, '')
                                                    .replace(/['"“”‘’]/g, '')
                                                    .replace(/&\\w+;/g, '')
                                                    .trim();
                                            }
            
                                            function searchDump(term) {
                                                clearHighlights();
                                                results = [], currentIndex = -1;
                                                if (!term.trim()) return updateStatus();
                    
                                                const rawTerm = term.trim().toLowerCase();
                                                const quotedTerm = '"' + rawTerm.replace(/^"+|"+$/g, '') + '"';
                                                const normalizedTerm = normalize(rawTerm);
                                                const normalizedQuoted = normalize(quotedTerm);
                    
                                                const entries = document.querySelectorAll('.entry');
                    
                                                entries.forEach(el => {
                                                    const keyEl = el.querySelector('.key');
                                                    const valEl = el.querySelector('.value');
                                                    if (!keyEl || !valEl) return;
                    
                                                    const keyRaw = keyEl.textContent.trim().toLowerCase();
                                                    const valRaw = valEl.textContent.trim().toLowerCase();
                    
                                                    const keyNorm = normalize(keyRaw);
                                                    const valNorm = normalize(valRaw);
                    
                                                    const combined = normalize(keyRaw + '=>' + valRaw);
                    
                                                    const matches = (
                                                        keyRaw.includes(rawTerm) || keyNorm.includes(normalizedTerm) ||
                                                        valRaw.includes(rawTerm) || valNorm.includes(normalizedTerm) ||
                                                        valRaw.includes(quotedTerm) || valNorm.includes(normalizedQuoted) ||
                                                        combined.includes(normalizedTerm)
                                                    );
                    
                                                    if (matches) {
                                                        keyEl.classList.add('highlight-key');
                                                        valEl.classList.add('highlight-key');
                                                        results.push(keyEl);
                                                    }
                                                });
                    
                                                if (results.length) {
                                                    currentIndex = 0;
                                                    scrollToResult(currentIndex);
                                                }
                    
                                                updateStatus();
                                            }
            
                                            function scrollToResult(index) {
                                                results.forEach(el => el.classList.remove('current-key'));
                                                if (results[index]) {
                                                    const rect = results[index].getBoundingClientRect();
                                                    const y = window.scrollY + rect.top - 100;
                                                    window.scrollTo({ top: y, behavior: 'smooth' });
                                                    results[index].classList.add('current-key');
                                                }
                                                updateStatus();
                                            }
            
                                            function searchNext() {
                                                if (!results.length) {
                                                    const term = document.getElementById('dump-search').value;
                                                    searchDump(term);
                                                } else {
                                                    currentIndex = (currentIndex + 1) % results.length;
                                                    scrollToResult(currentIndex);
                                                }
                                            }
            
                                            function searchPrev() {
                                                if (!results.length) return;
                                                currentIndex = (currentIndex - 1 + results.length) % results.length;
                                                scrollToResult(currentIndex);
                                            }
            
                                            function updateStatus() {
                                                const el = document.getElementById('search-status');
                                                if (!el) return;
                                                el.textContent = results.length ? (currentIndex + 1) + ' of ' + results.length : 'No results';
                                            }
            
                                          function clearHighlights() {
                                            document.querySelectorAll('.highlight-key').forEach(el =>
                                                el.classList.remove('highlight-key', 'current-key')
                                            );
            }
            
            
                                            function toggle(el) {
                                                const parent = el.closest('.entry');
                                                if (parent) {
                                                    parent.classList.toggle('collapsed');
                                                    el.textContent = parent.classList.contains('collapsed') ? '▶' : '▼';
                                                }
                                            }
            
                                            document.addEventListener('DOMContentLoaded', () => {
                                                const search = document.getElementById('dump-search');
                                                search.focus();
                                                search.addEventListener('keydown', (e) => {
                                                    if (e.key === 'Enter') searchNext();
                                                });
                                            });
                                        </script>
                                    </head>
                                    <body>
                                        <div class="search-container">
                                            <input id="dump-search" type="text" placeholder="🔍 Search key => value" oninput="searchDump(this.value)">
                                            <button onclick="searchNext()">Next</button>
                                            <button onclick="searchPrev()">Prev</button>
                                            <span id="search-status"></span>
                                        </div>
                                        <h3 style="color:#ffc107;margin-bottom:2rem;">
                                        🔍 Dump and Die — <span style="color:#f88">{$fileEsc}</span> : <span style="color:#6cf">{$line}</span>
                                        </h3>
            HTML;
    }

    /**
     * Renders a value into an HTML representation with interactive features for complex data structures.
     *
     * This method implements a recursive rendering strategy for various data types, producing
     * a hierarchical HTML structure with collapsible sections for arrays and objects.
     * It handles proper escaping and type-specific formatting while maintaining visual hierarchy.
     *
     * @param string|null $key   The key associated with the value, or null for root elements
     * @param mixed       $value The value to be rendered
     * @param int         $depth Current depth in the rendering hierarchy, defaults to 0
     *
     * @return string HTML representation of the value
     *
     * @throws RuntimeException When encountering unhandled value types
     */
    private static function renderValue(
        string|null $key,
        mixed       $value,
        int         $depth = 0
    ) : string {
        // Construct the prefix HTML with proper key formatting and operator
        $prefix = $key !== null
            ? '<span class="key">' . (is_int($key)
                ? $key
                : htmlspecialchars(
                           $key,
                    flags: ENT_QUOTES
                )) . '</span><span class="operator"> => </span>'
            : '';

        // Handle array rendering with a collapsible structure
        if (is_array($value)) {
            $count = count($value);
            // Return compact representation for empty arrays
            if ($count === 0) {
                return '<div class="entry">' . $prefix . '<span class="type">array:0</span> []</div>';
            }

            // Build expandable array representation with nested elements
            $html = '<div class="entry"><span class="toggle" onclick="toggle(this)">▼</span> ' .
                    $prefix . '<span class="type">array:' . $count . '</span> [';
            $html .= '<div class="children">';
            // Recursively render each array element
            foreach ($value as $k => $v) {
                $html .= self::renderValue(key: (string) $k, value: $v, depth: $depth + 1);
            }
            $html .= '</div>]</div>';

            return $html;
        }

        // Handle object rendering with a collapsible structure
        if (is_object($value)) {
            $class = get_class($value);
            $props = (array) $value;
            $count = count($props);
            // Return compact representation for empty objects
            if ($count === 0) {
                return '<div class="entry">' . $prefix .
                       '<span class="type">object:' . $class . '</span> {}</div>';
            }

            // Build expandable object representation with nested properties
            $html = '<div class="entry"><span class="toggle" onclick="toggle(this)">▼</span> ' .
                    $prefix . '<span class="type">object:' . $class . '</span> {';
            $html .= '<div class="children">';
            // Recursively render each object property
            foreach ($props as $k => $v) {
                $html .= self::renderValue(key: (string) $k, value: $v, depth: $depth + 1);
            }
            $html .= '</div>}</div>';

            return $html;
        }

        // Handle scalar values with appropriate type-specific formatting
        $val = match (true) {
            is_null($value)   => '<span class="value null">null</span>',
            is_bool($value)   => '<span class="value bool">' . ($value ? 'true' : 'false') . '</span>',
            is_string($value) => '<span class="value string">"' . htmlspecialchars($value) . '"</span>',
            is_int($value)    => '<span class="value int">' . $value . '</span>',
            is_float($value)  => '<span class="value float">' . $value . '</span>',
            default           => '<span class="value unknown">(unknown)</span>',
        };

        // Return the final HTML representation for scalar values
        return '<div class="entry">' . $prefix . $val . '</div>';
    }

    /**
     * Dumps variables with enhanced visualization and debugging capabilities.
     *
     * This method provides a sophisticated debugging tool that renders variable contents
     * in an interactive HTML interface. It supports type-aware visualization,
     * search functionality, and collapsible nested structures.
     *
     * @param mixed ...$args The variables to dump for inspection
     *
     * @throws \RuntimeException If output buffering has already started
     */
    public static function dumpx(mixed ...$args) : void
    {
        // Track the initialization state across multiple dump calls
        static $initialized = false;

        // Retrieve caller information from debug backtrace
        // Limit trace depth to 2 for performance and get only essential data
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1] ?? [];

        // Extract source file and line information with fallback values
        $file = $trace['file'] ?? 'unknown';
        $line = $trace['line'] ?? 0;

        // Initialize HTML structure if this is the first dump call
        // and headers haven't been sent yet
        if (! headers_sent() && ! $initialized) {
            echo self::renderHtmlHeader(file: $file, line: $line);
            $initialized = true;
        }

        // Begin a new dump stack container
        echo '<div class="dumpx-stack">';

        // Render dump location information with file and line details
        echo '<div class="entry"><span class="type">📦 Dump</span> ';
        echo '<span style="color:#f88">' . htmlspecialchars($file) . '</span> : ';
        echo '<span style="color:#6cf">' . $line . '</span></div>';

        // Process and render each provided argument
        foreach ($args as $arg) {
            echo self::renderValue(key: null, value: $arg);
        }

        // Close dump stack container
        echo '</div>';
    }
}

=== Entity/Entity.php ===
<?php

declare(strict_types=1);

namespace Gemini\Entity;

use ReflectionClass;

/**
 * Base Entity class to define a domain object.
 *
 * This serves as a base class for all domain entities, providing common functionality.
 * Currently, it is automating table name derivation from the class name.
 */
abstract class Entity
{
    /**
     * Get the table name for the entity.
     *
     * This method derives the table name from the class name of the entity. By default,
     * it converts the class name to lowercase and appends an 's' to follow convention
     * (e.g., the class 'User' becomes 'users'). Override this method in specific entities
     * if a different table name is required.
     *
     * @return string The table name associated with the entity.
     */
    public static function getTableName() : string
    {
        // Using reflection to acquire the short name of the class.
        // Allows automatic table name determination based on class naming conventions.
        $shortName = (new ReflectionClass(objectOrClass: static::class))->getShortName();

        // Converting to lowercase and appending 's' to standardize table naming.
        return strtolower($shortName) . 's';
    }
}
=== Exceptions/DatabaseErrorException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

class DatabaseErrorException {}

=== Exceptions/InvalidDTOClassException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use InvalidArgumentException;

/**
 * Class InvalidDTOClassException
 *
 * Thrown when a specified DTO class does not exist or is not valid.
 */
class InvalidDTOClassException extends InvalidArgumentException
{
    /**
     * InvalidDTOClassException constructor.
     *
     * @param string $className The name of the invalid DTO class.
     */
    public function __construct(string $className)
    {
        $message = sprintf("The class '%s' is not a valid DTO class.", $className);
        parent::__construct(message: $message);
    }
}

=== Exceptions/InvalidPropertyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use Exception;

/**
 * Class InvalidPropertyException
 *
 * Thrown when a DTO is missing a required property or has an invalid property.
 */
class InvalidPropertyException extends Exception
{
    /**
     * InvalidPropertyException constructor.
     *
     * @param string $propertyName The name of the missing or invalid property.
     */
    public function __construct(string $propertyName)
    {
        $message = sprintf("The property '%s' is missing or invalid in the DTO.", $propertyName);
        parent::__construct(message: $message);
    }
}

=== Exceptions/InvalidTypeException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use InvalidArgumentException;

/**
 * Class InvalidTypeException
 *
 * Thrown when a value does not match the expected type.
 */
class InvalidTypeException extends InvalidArgumentException
{
    /**
     * InvalidTypeException constructor.
     *
     * @param string $expectedType The expected type.
     * @param mixed  $actualValue  The actual value that caused the exception.
     */
    public function __construct(string $expectedType, mixed $actualValue)
    {
        $actualType = gettype($actualValue);
        $message    = sprintf("Expected type '%s', but got '%s'.", $expectedType, $actualType);
        parent::__construct(message: $message);
    }
}

=== Exceptions/MissingPropertyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use Exception;

/**
 * Class MissingPropertyException
 *
 * Thrown when a required property is missing from the data provided to a DTO.
 */
class MissingPropertyException extends Exception
{
    /**
     * MissingPropertyException constructor.
     *
     * @param string $propertyName The name of the missing property.
     */
    public function __construct(string $propertyName)
    {
        $message = sprintf("The property '%s' is required but missing in the data.", $propertyName);
        parent::__construct(message: $message);
    }
}

=== Exceptions/NotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use Exception;

/**
 * Class NotFoundException
 *
 * A custom exception class used to indicate that a requested resource could not be found.
 * It extends the built-in Exceptions class and provides a default message and HTTP 404 code.
 *
 * @package Gemini\Exceptions
 */
class NotFoundException extends Exception
{
    protected string $defaultMessage = 'Not found!';

    protected        $code           = 404;

    /**
     * Constructor for NotFoundException that appends file, line, and trace information.
     *
     * @param string|null $message Custom message for the exception (optional).
     */
    public function __construct(string|null $message = null)
    {
        // Use the custom message if provided, otherwise use the default message.
        $message ??= $this->defaultMessage;

        // Call the parent constructor to initialize the exception with the base message.
        parent::__construct(message: $message, code: $this->code);

        // Now that the exception is initialized, we can append file/line and trace details.
        $detailedMessage = $this->getDetailedMessage();

        // Update the exception's message to include the detailed message.
        $this->message = $detailedMessage;
    }

    /**
     * Get detailed error message with file, line, and stack trace information.
     *
     * @return string The detailed exception message.
     */
    private function getDetailedMessage() : string
    {
        return sprintf(
            "%s in file %s on line %d\nStack trace:\n%s",
            parent::getMessage(),
            $this->getFile(),
            $this->getLine(),
            $this->getTraceAsString(),
        );
    }
}

=== Exceptions/RouterException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use Exception;

class RouterException extends Exception {}

=== Exceptions/ValidationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Exceptions;

use RuntimeException;
use Throwable;

/**
 * Custom exception for validation errors.
 */
class ValidationException extends RuntimeException
{
    /**
     * Constructor for the ValidationException.
     */
    public function __construct(
        string                 $message,
        int                    $code = 422,
        Throwable|null         $previous = null,
        private readonly array $metadata = []
    ) {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Retrieves metadata related to the validation error.
     */
    public function getMetadata() : array
    {
        return $this->metadata;
    }

    /**
     * Converts the exception into a detailed array representation.
     */
    public function toArray() : array
    {
        return [
            'message' => $this->getMessage(),
            'code'    => $this->getCode(),
            'errors'  => $this->getErrors(),
        ];
    }

    /**
     * Retrieves the validation errors from metadata.
     */
    public function getErrors() : array
    {
        return $this->metadata['errors'] ?? $this->metadata;
    }
}

=== Facade/BaseFacade.php ===
<?php

declare(strict_types=1);

namespace Gemini\Facade;

use RuntimeException;

/**
 * Abstract base class for creating facades that provide static access to services.
 * Facades implemented using this base class allow methods to be called statically,
 * delegating the calls to the resolved instance of the service.
 */
abstract class BaseFacade
{
    /**
     * The key used to resolve the service instance from the container.
     * Concrete facades should override this property with the appropriate service key.
     */
    protected static string $accessor;

    /**
     * Handles static calls to the facade and delegates them to the resolved service instance.
     *
     * @param string $methodName The name of the method being called.
     * @param array  $arguments  Arguments passed to the method.
     *
     * @return mixed The result of the method call.
     *
     * @throws RuntimeException if the method does not exist on the service instance.
     */
    public static function __callStatic(string $methodName, array $arguments) : mixed
    {
        $instance = static::resolveFacadeInstance();

        if (! is_callable([$instance, $methodName])) {
            throw new RuntimeException(
                sprintf("Method '%s' does not exist or is not callable on the facade '%s'.", $methodName, static::class)
            );
        }

        return $instance->{$methodName}(...$arguments);
    }

    /**
     * Resolves the instance of the service being facade.
     *
     * @return mixed Resolved service instance.
     *
     * @throws RuntimeException if the service does not exist in the container.
     */
    protected static function resolveFacadeInstance() : mixed
    {
        if (! isset(static::$accessor) || (static::$accessor === '' || static::$accessor === '0')) {
            throw new RuntimeException(
                sprintf("The facade '%s' must define a non-empty static accessor property.", static::class)
            );
        }

        if (! app()->has(static::$accessor)) {
            throw new RuntimeException(
                sprintf("Service '%s' not found in the container.", static::$accessor)
            );
        }

        return app(static::$accessor);
    }
}
=== Facade/Facades/Auth.php ===
<?php

declare(strict_types=1);

namespace Gemini\Facade\Facades;

use Gemini\Auth\Contracts\AuthenticationServiceInterface;
use Gemini\Facade\BaseFacade;

/**
 * Facade for providing a simplified static interface to the AuthenticationService.
 *
 * This class leverages the static method calls provided by the base facade (`BaseFacade`) to
 * simplify interaction with the `AuthenticationService` implementation within the application.
 *
 * This facade is primarily aimed at providing syntactic convenience and ensuring strong
 * decoupling between application layers by interacting with the interface (DDD principle).
 *
 * Example usage:
 *
 * ```
 * Auth::login($credentials);  // Logs in a user with specific credentials.
 * Auth::check();              // Checks if a user is authenticated.
 * ```
 */
final class Auth extends BaseFacade
{
    /**
     * The unique key representing the authentication service in the application container.
     *
     * This key is used by the parent `BaseFacade` to dynamically resolve the concrete
     * implementation of the dependency injection container. The service contract (interface)
     * being represented is `AuthenticationServiceInterface`.
     *
     * @var string
     */
    protected static string $accessor = AuthenticationServiceInterface::class;
}
=== Facade/Facades/Request.php ===
<?php

declare(strict_types=1);

namespace Gemini\Facade\Facades;

use Gemini\Filesystem\Storage\FileStorageInterface;
use Gemini\Facade\BaseFacade;

/**
 * Facade for accessing the Filesystem service.
 *
 * @method static string read(string $path)
 * @method static bool write(string $path, string $content)
 * @method static bool delete(string $path)
 * @method static bool exists(string $path)
 * @method static bool createDirectory(string $directory)
 * @method static bool deleteDirectory(string $directory)
 * @method static bool setPermissions(string $path, int $permissions)
 * @method static FileStorageInterface disk(?string $name = null)
 * @method static bool isWritable(string $path)
 * @method static bool clear(string $directory)
 * @method static bool hasPermission(string $path, int $permissions)
 */
class Request extends BaseFacade
{
    /**
     * The service key used to resolve the Filesystem service from the container.
     */
    protected static string $accessor = 'Request';
}

=== Facade/Facades/Route.php ===
<?php

declare(strict_types=1);

namespace Gemini\Facade\Facades;

use Gemini\Facade\BaseFacade;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\RouterInterface;
use Gemini\HTTP\Router\Routing\RouteRegistrarProxy;
use Psr\Http\Message\ResponseInterface;

/**
 * Facade for interacting with the HTTP routing system.
 *
 * @method static RouteRegistrarProxy get(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy post(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy put(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy patch(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy delete(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy options(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy head(string $path, callable|array|string $action)
 * @method static RouteRegistrarProxy[] any(string $path, callable|array|string $action)
 * @method static void fallback(callable|array|string $handler)
 * @method static ResponseInterface resolve(Request $request)
 */
final class Route extends BaseFacade
{
    protected static string $accessor = RouterInterface::class;
}

=== Facade/Facades/Session.php ===
<?php

/** @noinspection OverrideMissingInspection */

declare(strict_types=1);

namespace Gemini\Facade\Facades;

use Gemini\Facade\BaseFacade;

class Session extends BaseFacade
{
    /**
     * Get the registered name of the component.
     *
     * The getFacadeAccessor() method returns a string, 'Router',
     * which represents the registered name of the component in the service container.
     * This method is used by the service container to bind the Router instance to the application,
     * allowing for the facade to work seamlessly with the underlying implementation.
     *
     * @return string the registered name of the component in the service container
     */
    protected static string $accessor = 'Session';

}

=== Facade/Facades/Storage.php ===
<?php

declare(strict_types=1);

namespace Gemini\Facade\Facades;

use Gemini\Facade\BaseFacade;
use Gemini\Filesystem\Storage\FileStorageInterface;

/**
 * Facade for accessing the Filesystem service.
 *
 * @method static string read(string $path)
 * @method static bool write(string $path, string $content, bool $append = false)
 * @method static bool delete(string $path)
 * @method static bool exists(string $path)
 * @method static bool createDirectory(string $directory)
 * @method static bool deleteDirectory(string $directory)
 * @method static bool setPermissions(string $path, int $permissions)
 * @method static FileStorageInterface disk(?string $name = null)
 * @method static bool isWritable(string $path)
 * @method static bool clear(string $directory)
 * @method static bool hasPermission(string $path, int $permissions)
 */
class Storage extends BaseFacade
{
    /**
     * The service key used to resolve the Filesystem service from the container.
     */
    protected static string $accessor = 'Storage';
}

=== Filesystem/DirectoryInitializer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem;

use Exception;

/**
 * Class to handle directory initialization, ensuring the directory exists,
 * has correct permissions, and is writable. This is critical for scenarios
 * where the application's smooth operation depends on specific directory setups.
 */
readonly class DirectoryInitializer
{
    // Number of attempts to make the directory writable before failing
    private const int RETRY_ATTEMPTS = 3;

    // Delay between retry attempts in microseconds
    private const int RETRY_DELAY = 100000;

    /**
     * DirectoryInitializer constructor.
     * Automatically initializes the directory by creating it if it doesn't exist,
     * setting permissions, and ensuring it is writable.
     *
     * @param string               $directoryPath The path to the directory to be initialized.
     * @param FileServiceInterface $fileService   The file service to handle directory operations.
     *
     * @throws \Exception
     * @throws \Exception
     */
    public function __construct(
        private string               $directoryPath,
        private FileServiceInterface $fileService
    ) {
        $this->initializeDirectory();
    }

    /**
     * Initializes the directory by creating it if necessary and setting permissions.
     * Ensures the directory is writable, which is crucial for subsequent operations.
     *
     * @throws Exception if the directory can't be created or made writable.
     */
    private function initializeDirectory() : void
    {
        // Only create the directory if it does not exist to avoid unnecessary operations
        if (! $this->fileService->isDirectory(path: $this->directoryPath) &&
            ! $this->fileService->createDirectory(path: $this->directoryPath, permissions: 0755)) {
            throw new Exception(message: 'Failed to create directory at ' . $this->directoryPath);
        }

        // Set permissions to 0755 and ensure the directory is writable
        $this->fileService->setPermissions(path: $this->directoryPath, permissions: 0755);
        $this->ensureWritable();
    }

    /**
     * Tries to ensure the directory is writable using multiple attempts.
     * This approach accounts for transient file system issues that may temporarily block write access.
     *
     * @throws Exception if the directory cannot be made writable after the given attempts.
     */
    private function ensureWritable() : void
    {
        for ($attempt = 1; $attempt <= self::RETRY_ATTEMPTS; ++$attempt) {
            // Attempt to write to the directory or retry after a delay
            if ($this->fileService->isWritable(path: $this->directoryPath) || $this->attemptFileCreation()) {
                return;
            }

            usleep(self::RETRY_DELAY);
        }

        throw new Exception(
            message: sprintf(
                         'Unable to make the directory writable at %s. Check file system permissions.',
                         $this->directoryPath
                     )
        );
    }

    /**
     * Attempts to create and write to a test file in the directory to check writability.
     * Removes the test file if successful, maintaining the directory's state.
     *
     * @return bool True if the directory is writable, false otherwise.
     */
    private function attemptFileCreation() : bool
    {
        $testFilePath = $this->directoryPath . '/.write_test';

        // Create the test file if it doesn't exist
        if (! $this->fileService->fileExists(path: $testFilePath)) {
            $this->fileService->createFile(path: $testFilePath);
        }

        // Set permissions for the test file to 0644
        $this->fileService->setPermissions(path: $testFilePath, permissions: 0644);

        // Check if the test file is writable
        $isWritable = $this->fileService->isWritable(path: $testFilePath);
        if ($isWritable) {
            unlink($testFilePath); // Clean up the test file if everything is functioning correctly
        }

        return $isWritable;
    }
}
=== Filesystem/Exceptions/DirectoryCreationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Exceptions;

use RuntimeException;

class DirectoryCreationException extends RuntimeException {}
=== Filesystem/Exceptions/DirectoryDeletionException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Exceptions;

use RuntimeException;

class DirectoryDeletionException extends RuntimeException {}
=== Filesystem/Exceptions/FileDeleteException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Exceptions;

use RuntimeException;

class FileDeleteException extends RuntimeException {}
=== Filesystem/Exceptions/FileNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Exceptions;

use RuntimeException;

class FileNotFoundException extends RuntimeException {}

=== Filesystem/Exceptions/FileWriteException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Exceptions;

use RuntimeException;

class FileWriteException extends RuntimeException {}
=== Filesystem/FileLogWriterTest.php ===
<?php

declare(strict_types=1);

namespace Tests\Unit;

use Gemini\Logging\FileLogWriter;
use Gemini\Logging\FileServiceInterface;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

final class FileLogWriterTest extends TestCase
{
    private readonly MockObject $mockObject;

    public function testInitializeLogFileSetsFallbackPathWhenDirectoryCreationFails() : void
    {
        $this->mockObject->method('isDirectory')->willReturn(false);
        $this->mockObject->method('createDirectory')->willReturn(false);

        $fileLogWriter = new FileLogWriter('/invalid/path/to/log.log', $this->mockObject);

        $this->assertFilePathEquals('/tmp/fallback-log.log', $fileLogWriter);
    }

    public function testEnsureWritableCreatesFileWhenNotWritable() : void
    {
        $this->mockObject->method('isWritable')->willReturn(false);
        $this->mockObject->method('fileExists')->willReturn(false);
        $this->mockObject->method('createFile')->willReturn(true);

        $this->mockObject->expects($this->once())->method('createFile');

        new FileLogWriter('/path/to/log.log', $this->mockObject);
    }

    public function testWriteAttemptsToAppendToProvidedFilePath() : void
    {
        $this->mockObject->method('appendToFile')->willReturn(true);

        $fileLogWriter = new FileLogWriter('/path/to/log.log', $this->mockObject);
        $fileLogWriter->write('Test log entry');

        $this->mockObject->expects($this->once())->method('appendToFile')->with('/path/to/log.log', 'Test log entry');
    }

    // Additional tests...
}

=== Filesystem/FileServiceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem;

/**
 * Interface for file services, outlining methods for directory and file operations.
 *
 * This interface defines the common operations for interacting with the filesystem.
 * Implementing classes should provide the actual logic for handling these filesystem tasks.
 */
interface FileServiceInterface
{
    /**
     * Checks if the given path is a directory.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the path is a directory, false otherwise.
     */
    public function isDirectory(string $path) : bool;

    /**
     * Creates a directory at the specified path with given permissions.
     *
     * @param string $path        The path where the directory should be created.
     * @param int    $permissions The permissions to set for the directory.
     *
     * @return bool True if the directory was successfully created, false otherwise.
     */
    public function createDirectory(string $path, int $permissions) : bool;

    /**
     * Sets permissions for the specified path.
     *
     * @param string $path        The path for which to set the permissions.
     * @param int    $permissions The permissions to set.
     *
     * @return bool True if the permissions were successfully set, false otherwise.
     */
    public function setPermissions(string $path, int $permissions) : bool;

    /**
     * Checks if the given path is writable.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the path is writable, false otherwise.
     */
    public function isWritable(string $path) : bool;

    /**
     * Checks if a file exists at the specified path.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the file exists, false otherwise.
     */
    public function fileExists(string $path) : bool;

    /**
     * Creates a new file at the specified path.
     *
     * @param string $path The path where the file should be created.
     *
     * @return bool True if the file was successfully created, false otherwise.
     */
    public function createFile(string $path) : bool;

    /**
     * Appends content to a file at the specified path.
     *
     * @param string $path    The path of the file to which content should be appended.
     * @param string $content The content to append to the file.
     *
     * @return bool True if the content was successfully appended, false otherwise.
     */
    public function appendToFile(string $path, string $content) : bool;
}
=== Filesystem/FilesystemService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem;

/**
 * Logging to handle file system operations.
 *
 * This service abstracts common file system operations such as writing files
 * and ensuring that directories are writable.
 */
class FilesystemService
{
    /**
     * Write content to a file.
     *
     * @param string $fileName The file path.
     * @param string $content  The content to write into the file.
     */
    public function writeFile(string $fileName, string $content) : void
    {
        file_put_contents(filename: $fileName, data: $content);
    }

    /**
     * Ensure the given directory is writable. If it's not writable, attempt to change the permissions.
     *
     * This method checks if the specified directory is writable and, if not, it attempts to set the necessary
     * permissions (e.g., 0777) to allow writing.
     *
     * @param string $directory The directory path to check.
     */
    public function ensureDirectoryIsWritable(string $directory) : void
    {
        if (! file_exists(filename: $directory)) {
            mkdir(
                directory  : $directory,
                permissions: 0755,
                recursive  : true,
            ); // Recursively create directories if they don't exist
        }

        if (! is_writable(filename: $directory)) {
            chmod(filename: $directory, permissions: 0755); // Ensure it is writable
        }
    }
}

=== Filesystem/LocalFileService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem;

/**
 * Implementation of FileServiceInterface for local filesystem operations.
 * This service handles directory and file management tasks described by the interface.
 */
class LocalFileService implements FileServiceInterface
{
    /**
     * Checks if the given path is a directory.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the path is a directory, false otherwise.
     */
    public function isDirectory(string $path) : bool
    {
        return is_dir($path);
    }

    /**
     * Creates a directory with the specified permissions.
     *
     * @param string $path        The directory path to create.
     * @param int    $permissions The permissions to set for the directory.
     *
     * @return bool True on success, false on failure.
     *
     * Note: The third argument for mkdir() is set to true to ensure recursive directory creation.
     */
    public function createDirectory(string $path, int $permissions) : bool
    {
        return ! (! is_dir($path) && ! @mkdir($path, $permissions, true));
    }


    /**
     * Sets the permissions for the given path.
     *
     * @param string $path        The path to set permissions for.
     * @param int    $permissions The new permissions.
     *
     * @return bool True on success, false on failure.
     */
    public function setPermissions(string $path, int $permissions) : bool
    {
        return chmod($path, $permissions);
    }

    /**
     * Checks if the given path is writable.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the path is writable, false otherwise.
     */
    public function isWritable(string $path) : bool
    {
        return is_writable($path);
    }

    /**
     * Checks if a file exists at the given path.
     *
     * @param string $path The path to check.
     *
     * @return bool True if the file exists, false otherwise.
     */
    public function fileExists(string $path) : bool
    {
        return file_exists($path);
    }

    /**
     * Creates an empty file at the specified path.
     *
     * @param string $path The file path to create.
     *
     * @return bool True on success, false on failure.
     *
     * Note: Uses touch() to create the file if it does not exist.
     */
    public function createFile(string $path) : bool
    {
        if (! $this->fileExists(path: $path)) {
            return touch($path);
        }

        return true;
    }

    /**
     * Appends content to a file at the specified path.
     *
     * @param string $path    The file path to append content to.
     * @param string $content The content to append.
     *
     * @return bool True on success, false on failure.
     *
     * Note: Uses FILE_APPEND to add content to the end of the file and LOCK_EX to prevent simultaneous write access.
     */
    public function appendToFile(string $path, string $content) : bool
    {
        // Ensure directory exists
        $directory = dirname($path);
        if (! $this->isDirectory(path: $directory) && ! $this->createDirectory(path: $directory, permissions: 0755)) {
            return false;
        }

        return file_put_contents($path, $content . PHP_EOL, FILE_APPEND | LOCK_EX) !== false;
    }
}

=== Filesystem/Storage/FileNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Storage;

use Exception;

class FileNotFoundException extends Exception
{
    public function __construct(string $string)
    {
        parent::__construct($string);
    }
}
=== Filesystem/Storage/FileStorageInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Storage;

/**
 * Interface for file storage operations.
 *
 * This interface outlines the methods required to interact with a file system,
 * including reading, writing, deleting files, and managing directories. It standardizes
 * file operations to ensure any implementing class provides these capabilities.
 */
interface FileStorageInterface
{
    /**
     * Reads the content of a file at the specified path.
     *
     * @param string $path The path to the file.
     *
     * @return string The file content.
     */
    public function read(string $path) : string;

    /**
     * Writes content to a file at the specified path.
     *
     * @param string $path    The path to the file.
     * @param string $content The content to write.
     *
     * @return bool True on success, false otherwise.
     */
    public function write(string $path, string $content, bool $append = false) : bool;

    /**
     * Deletes the file at the specified path.
     *
     * @param string $path The path to the file.
     *
     * @return bool True on success, false otherwise.
     */
    public function delete(string $path) : bool;

    /**
     * Checks if a file or directory exists at the specified path.
     *
     * @param string $path The path to the file or directory.
     *
     * @return bool True if exists, false otherwise.
     */
    public function exists(string $path) : bool;

    /**
     * Creates a directory at the specified path.
     *
     * @param string $directory The path to the directory.
     *
     * @return bool True on success, false otherwise.
     */
    public function createDirectory(string $directory) : bool;

    /**
     * Deletes a directory at the specified path.
     *
     * @param string $directory The path to the directory.
     *
     * @return bool True on success, false otherwise.
     */
    public function deleteDirectory(string $directory) : bool;

    /**
     * Sets permissions for a file or directory at the specified path.
     *
     * @param string $path        The path to the file or directory.
     * @param int    $permissions The permissions to set.
     *
     * @return bool True on success, false otherwise.
     */
    public function setPermissions(string $path, int $permissions) : bool;

    /**
     * Checks if the file or directory at the specified path is writable.
     *
     * @param string $path The path to check for write permissions.
     *
     * @return bool True if the path is writable, false otherwise.
     */
    public function isWritable(string $path) : bool;

    /**
     * Checks if the given path has the specified permissions.
     *
     * @param string $path        The file or directory path to check permissions for.
     * @param int    $permissions The permissions to check against.
     *
     * @return bool True if the path has the specified permissions, false otherwise.
     */
    public function hasPermission(string $path, int $permissions) : bool;

    /**
     * Clears the contents of the specified directory.
     *
     * @param string $directory The directory path to clear.
     *
     * @return bool True if the directory was successfully cleared, false otherwise.
     */
    public function clear(string $directory) : bool;
}
=== Filesystem/Storage/Filesystem.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Storage;

use Exception;

/**
 * Class Filesystem
 *
 * This class acts as an abstraction layer over various file storage mechanisms.
 * It allows switching between different types of storage (e.g., local, cloud)
 * based on the configuration provided.
 */
readonly class Filesystem
{
    /**
     * Filesystem constructor. Initializes the class with a specific file storage implementation.
     *
     * @param FileStorageInterface $fileStorage The file storage implementation to use.
     */
    public function __construct(private FileStorageInterface $fileStorage) {}

    /**
     * Retrieves the disk storage instance based on the given disk name.
     *
     * This method checks the configuration for the given disk name and returns the appropriate
     * file storage implementation. If the disk driver is not supported, an exception is thrown.
     *
     * @param string|null $name The name of the disk configuration to retrieve. If null, the default configuration will
     *                          be used.
     *
     * @return FileStorageInterface The instance of the file storage based on the disk configuration.
     * @throws \Gemini\Container\Exceptions\FrameworkContainerException
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \Exception
     */
    public function disk(string|null $name = null) : FileStorageInterface
    {
        $diskConfig = config(key: "filesystems.disks." . $name, default: config(key: "filesystems.default"));

        if ($diskConfig['driver'] === 'local') {
            return app(abstract: LocalFileStorage::class);
        }

        throw new Exception(message: 'Unsupported disk driver: ' . $diskConfig['driver']);
    }

    /**
     * Reads the content of the given file path.
     *
     * @param string $path The path of the file to read.
     *
     * @return string The content of the file.
     */
    public function read(string $path) : string
    {
        return $this->fileStorage->read(path: $path);
    }

    /**
     * Writes content to the given file path.
     *
     * @param string $path    The path where the content should be written.
     * @param string $content The content to write.
     *
     * @return bool True if the writing was successful, false otherwise.
     */
    public function write(string $path, string $content, bool $append = false) : bool
    {
        return $this->fileStorage->write(path: $path, content: $content, append: $append);
    }

    /**
     * Deletes the file at the specified path.
     *
     * @param string $path The path of the file to delete.
     *
     * @return bool True if the file was successfully deleted, false otherwise.
     */
    public function delete(string $path) : bool
    {
        return $this->fileStorage->delete(path: $path);
    }

    /**
     * Checks if a file exists at the specified path.
     *
     * @param string $path The path to check for existence.
     *
     * @return bool True if the file exists, false otherwise.
     */
    public function exists(string $path) : bool
    {
        return $this->fileStorage->exists(path: $path);
    }

    /**
     * Creates a directory at the specified path.
     *
     * @param string $directory The path of the directory to create.
     *
     * @return bool True if the directory was successfully created, false otherwise.
     */
    public function createDirectory(string $directory) : bool
    {
        return $this->fileStorage->createDirectory(directory: $directory);
    }

    /**
     * Deletes the directory at the specified path.
     *
     * @param string $directory The path of the directory to delete.
     *
     * @return bool True if the directory was successfully deleted, false otherwise.
     */
    public function deleteDirectory(string $directory) : bool
    {
        return $this->fileStorage->deleteDirectory(directory: $directory);
    }

    /**
     * Sets permissions for the file at the specified path.
     *
     * @param string $path        The path of the file.
     * @param int    $permissions The permissions to set.
     *
     * @return bool True if the permissions were successfully set, false otherwise.
     */
    public function setPermissions(string $path, int $permissions) : bool
    {
        return $this->fileStorage->setPermissions(path: $path, permissions: $permissions);
    }

    /**
     * Checks if the specified file or directory has the given permissions.
     *
     * This method allows checking for specific permissions (e.g., readability, writability).
     *
     * @param string $path        The path of the file or directory to check.
     * @param int    $permissions The permissions to check for (e.g., 0755).
     *
     * @return bool True if the path has the specified permissions, false otherwise.
     */
    public function hasPermission(string $path, int $permissions) : bool
    {
        return $this->fileStorage->hasPermission(path: $path, permissions: $permissions);
    }

    /**
     * Clears the contents of the specified directory.
     *
     * This method leverages the storage component to remove all files and subdirectories within the given directory.
     *
     * @param string $directory The path to the directory to be cleared.
     *
     * @return bool Returns true if the directory was successfully cleared, otherwise false.
     */
    public function clear(string $directory) : bool
    {
        return $this->fileStorage->clear(directory: $directory);
    }

    /**
     * Checks if the specified path is writable in the file storage.
     *
     * @param string $path The path to be checked for write permissions.
     *
     * @return bool Returns true if the path is writable, otherwise false.
     */
    public function isWritable(string $path) : bool
    {
        return $this->fileStorage->isWritable(path: $path);
    }


}

=== Filesystem/Storage/FileWriteException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Storage;

use Exception;

class FileWriteException extends Exception
{
    public function __construct(string $string)
    {
        parent::__construct($string);
    }
}
=== Filesystem/Storage/LocalFileStorage.php ===
<?php

declare(strict_types=1);

namespace Gemini\Filesystem\Storage;

use FilesystemIterator;
use Gemini\Filesystem\Exceptions\DirectoryCreationException;
use Gemini\Filesystem\Exceptions\DirectoryDeletionException;
use Gemini\Filesystem\Exceptions\FileDeleteException;
use RuntimeException;

/**
 * Class LocalFileStorage
 *
 * Provides local file storage operations, including reading, writing, and managing directories.
 */
class LocalFileStorage implements FileStorageInterface
{
    /**
     * Reads the content of a file.
     *
     * @param string $path Path to the file.
     *
     * @return string The file contents.
     * @throws FileNotFoundException If the file does not exist or cannot be read.
     */
    public function read(string $path) : string
    {
        if (! file_exists($path)) {
            throw new FileNotFoundException(string: sprintf('File not found: %s', $path));
        }

        if (! is_readable($path)) {
            throw new FileNotFoundException(string: sprintf('File is not readable: %s', $path));
        }

        $content = file_get_contents($path);
        if ($content === false) {
            throw new RuntimeException(message: sprintf('Failed to read file: %s', $path));
        }

        return $content;
    }

    /**
     * Writes content to a file, creating directories if necessary.
     *
     * @param string $path    Path to the file.
     * @param string $content Content to write.
     *
     * @return bool True on success.
     * @throws FileWriteException If writing fails.
     */
    public function write(string $path, string $content, bool $append = false) : bool
    {
        $directory = dirname($path);
        if (! is_dir($directory) && ! $this->createDirectory(directory: $directory)) {
            throw new FileWriteException(string: sprintf('Failed to create directory: %s', $directory));
        }

        $flags = $append ? FILE_APPEND | LOCK_EX : 0;
        if (file_put_contents($path, $content . PHP_EOL, $flags) === false) {
            throw new FileWriteException(string: "Failed to write to file: {$path}");
        }

        return true;
    }

    /**
     * Creates a directory with specified permissions.
     *
     * @param string $directory   Path to the directory.
     * @param int    $permissions Permissions to set (default: 0755).
     *
     * @return bool True on success.
     * @throws DirectoryCreationException If creation fails.
     */
    public function createDirectory(string $directory, int $permissions = 0755) : bool
    {
        if (is_dir($directory)) {
            return true; // Directory already exists.
        }

        if (! mkdir($directory, $permissions, true) && ! is_dir($directory)) {
            throw new DirectoryCreationException(message: sprintf('Failed to create directory: %s', $directory));
        }

        return true;
    }

    /**
     * Checks if a file or directory exists.
     *
     * @param string $path Path to check.
     *
     * @return bool True if it exists, false otherwise.
     */
    public function exists(string $path) : bool
    {
        return file_exists($path);
    }

    /**
     * Deletes a directory and its contents.
     *
     * @param string $directory Path to the directory.
     *
     * @return bool True on success.
     * @throws DirectoryDeletionException If deletion fails.
     */
    public function deleteDirectory(string $directory) : bool
    {
        if (! is_dir($directory)) {
            return true; // Non-existent directories are considered "deleted".
        }

        $this->clear(directory: $directory);

        if (! rmdir($directory)) {
            throw new DirectoryDeletionException(message: sprintf('Failed to delete directory: %s', $directory));
        }

        return true;
    }

    /**
     * Clears the contents of a directory.
     *
     * @param string $directory Path to the directory.
     *
     * @return bool True on success.
     * @throws RuntimeException If unable to clear the directory.
     */
    public function clear(string $directory) : bool
    {
        if (! is_dir($directory)) {
            throw new RuntimeException(message: sprintf('Not a directory: %s', $directory));
        }

        foreach (new FilesystemIterator(directory: $directory, flags: FilesystemIterator::SKIP_DOTS) as $item) {
            $itemPath = $item->getPathname();

            if ($item->isDir()) {
                $this->deleteDirectory(directory: $itemPath);
            } else {
                $this->delete(path: $itemPath);
            }
        }

        return true;
    }

    /**
     * Deletes a file.
     *
     * @param string $path Path to the file.
     *
     * @return bool True on success.
     * @throws FileDeleteException If deletion fails.
     */
    public function delete(string $path) : bool
    {
        if (! file_exists($path)) {
            return true; // Consider non-existent files as "deleted".
        }

        if (! unlink($path)) {
            throw new FileDeleteException(message: sprintf('Failed to delete file: %s', $path));
        }

        return true;
    }

    /**
     * Checks if a path is writable.
     *
     * @param string $path Path to check.
     *
     * @return bool True if writable, false otherwise.
     */
    public function isWritable(string $path) : bool
    {
        return is_writable($path);
    }

    /**
     * Sets permissions for a file or directory.
     *
     * @param string $path        Path to the file or directory.
     * @param int    $permissions Permissions to set.
     *
     * @return bool True on success.
     * @throws RuntimeException If chmod fails.
     */
    public function setPermissions(string $path, int $permissions) : bool
    {
        if (! file_exists($path)) {
            throw new RuntimeException(message: sprintf('Path does not exist: %s', $path));
        }

        if (! @chmod($path, $permissions)) { // Suppress warning to handle it manually
            error_log(sprintf('Failed to set permissions on: %s', $path));

            return false;
        }

        return true;
    }


    /**
     * Checks if the given path has the specified permissions.
     *
     * @param string $path        The file or directory path to check permissions for.
     * @param int    $permissions The permissions to check against.
     *
     * @return bool True if the path has the specified permissions, false otherwise.
     */
    public function hasPermission(string $path, int $permissions) : bool
    {
        if (! file_exists($path)) {
            return false; // Path does not exist, so it cannot have the specified permissions.
        }

        $actualPermissions = fileperms($path) & 0777; // Get permissions and mask to relevant bits.

        return $actualPermissions === $permissions;
    }
}

=== GemDump/assets/gemdump.css ===
body {
    background: #121212;
    color: #eee;
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
}

.gemdump {
    background: #1e1e1e;
    padding: 1rem;
    border-radius: 10px;
    border: 1px solid #333;
    overflow-x: auto;
    max-height: 600px;
    margin-bottom: 2rem;
}

.hl-search-match {
    background-color: #ffbf00;
    color: #000;
}

=== GemDump/assets/gemdump.js ===
function highlightSearch() {
    const dumps = document.querySelectorAll('.gemdump');
    const search = document.querySelector('input[x-model="search"]').value.trim();

    dumps.forEach((dump) => {
        dump.innerHTML = dump.textContent;

        if (!search) return;

        const regex = new RegExp(search, 'gi');
        dump.innerHTML = dump.innerHTML.replace(regex, (match) =>
            `<mark class="hl-search-match">${match}</mark>`
        );
    });
}

function nextMatch() {
    const matches = document.querySelectorAll('.hl-search-match');
    if (matches.length === 0) return;
    window.__hlIndex = (window.__hlIndex ?? -1) + 1;
    if (window.__hlIndex >= matches.length) window.__hlIndex = 0;
    matches.forEach(m => m.classList.remove('active'));
    matches[window.__hlIndex].scrollIntoView({behavior: 'smooth', block: 'center'});
    matches[window.__hlIndex].classList.add('active');
}

function prevMatch() {
    const matches = document.querySelectorAll('.hl-search-match');
    if (matches.length === 0) return;
    window.__hlIndex = (window.__hlIndex ?? matches.length) - 1;
    if (window.__hlIndex < 0) window.__hlIndex = matches.length - 1;
    matches.forEach(m => m.classList.remove('active'));
    matches[window.__hlIndex].scrollIntoView({behavior: 'smooth', block: 'center'});
    matches[window.__hlIndex].classList.add('active');
}

window.highlightSearch = highlightSearch;
window.nextMatch = nextMatch;
window.prevMatch = prevMatch;

=== GemDump/GemDumpDebugger.php ===
<?php

declare(strict_types=1);

namespace Gemini\GemDump;

use Gemini\View\BladeTemplateEngine;
use JetBrains\PhpStorm\NoReturn;

class GemDumpDebugger
{
    /**
     * Terminates the script and renders an interactive dump.
     *
     *
     */
    #[NoReturn]
    public static function ddx(mixed ...$args) : never
    {
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1] ?? [];
        $html  = self::renderDump(args: $args, file: $trace['file'] ?? 'unknown', line: $trace['line'] ?? 0);

        header('Content-Type: text/html; charset=utf-8');
        echo $html;
        exit(1);
    }

    /**
     * Renders the Blade HTML with variables.
     *
     *
     */
    private static function renderDump(array $args, string $file, int $line) : string
    {
        $blade = new BladeTemplateEngine(viewsPath: __DIR__ . '/views', cachePath: sys_get_temp_dir());

        return $blade->toHtml(view: 'dump', data: [
            'args' => $args,
            'file' => $file,
            'line' => $line,
        ]);
    }

    /**
     * Outputs a styled interactive dump, without terminating.
     *
     */
    public static function dumpx(mixed ...$args) : void
    {
        $trace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2)[1] ?? [];
        echo self::renderDump(args: $args, file: $trace['file'] ?? 'unknown', line: $trace['line'] ?? 0);
    }
}

=== GemDump/views/dump.blade.php ===
<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <title>📦 Dump Output</title>
    <link rel="stylesheet" href="@asset('assets/gemdump.css')">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
    <script>window.addEventListener('DOMContentLoaded', () => hljs.highlightAll())</script>
</head>
<body class="bg-dark text-light p-4 font-monospace" x-data="{ search: '', matchIndex: 0, results: [] }">

<div class="container-fluid">
    <h3 class="text-warning mb-3">
        🔍 Dump from <span class="text-danger">{{ $file }}</span> : <span class="text-info">{{ $line }}</span>
    </h3>

    <div class="input-group mb-4 w-50">
        <span class="input-group-text bg-secondary text-white">Search</span>
        <input x-model="search" @input="highlightSearch()" @keydown.enter="nextMatch()"
               class="form-control bg-dark text-white border-secondary">
        <button class="btn btn-outline-light" @click="prevMatch()">◀</button>
        <button class="btn btn-outline-light" @click="nextMatch()">▶</button>
    </div>

    @foreach ($args as $arg)
        <pre class="gemdump" x-ref="dump">
                {{ var_export($arg, true) }}
            </pre>
    @endforeach
</div>

<script src="@asset('assets/gemdump.js')"></script>
</body>
</html>

=== Gemini.php ===
<?php

declare(strict_types=1);

namespace Gemini;

use RuntimeException;

/**
 * Enum Gemini
 *
 * Manages application paths specifically within the "Framework" directory of the project.
 * Provides dynamic resolution and validation for key framework components.
 */
enum Gemini: string
{
    // Framework core directories
    case AUTH          = 'Framework/Auth/';

    case CACHE         = 'Framework/Cache/';

    case CONFIG        = 'Framework/Config/';

    case CONTAINER     = 'Framework/Container/';

    case DATA_HANDLING = 'Framework/DataHandling/';

    case DATABASE      = 'Framework/Database/';

    case EXCEPTIONS    = 'Framework/Exceptions/';

    case FACADE        = 'Framework/Facade/';

    case FILESYSTEM    = 'Framework/Filesystem/';

    case HTTP          = 'Framework/HTTP/';

    case LOGGING       = 'Framework/Logging/';

    case MIDDLEWARES   = 'Framework/Middlewares/';

    case VIEW          = 'Framework/View/';

    case MIGRATIONS    = 'Framework/Database/Migration/';


    /**
     * Retrieve the list of all paths managed by this enum.
     *
     * @return array An associative array of enum cases and their resolved paths.
     */
    public static function all() : array
    {
        return array_map(callback: fn(Gemini $gemini) : string => $gemini->resolve(), array: self::cases());
    }

    /**
     * Resolves the full path by appending the root directory to the relative path.
     *
     * @return string The resolved absolute path.
     */
    public function resolve() : string
    {
        $path = self::root() . $this->value;

        if (! file_exists(filename: $path)) {
            throw new RuntimeException(message: sprintf('The path "%s" does not exist.', $path));
        }

        return $path;
    }

    /**
     *
     */
    public static function root() : string
    {
        // Ensure APP_ROOT is set correctly in the environment.
        $root = env(key: 'FW_ROOT', default: dirname(__DIR__, 2));

        if (! is_dir($root)) {
            throw new RuntimeException(message: "The root path '" . $root . "' does not exist.");
        }

        return rtrim((string) $root, '/') . '/Infrastructure/';
    }

}

=== Helpers/helpers.php ===
<?php

declare(strict_types=1);

use Gemini\Auth\Contracts\AuthenticationServiceInterface;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Containers\DependencyInjector;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\Database\DatabaseConnection;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use Gemini\DataHandling\ObjectHandling\Collections\Collection;
use Gemini\DumpDebugger;
use Gemini\HTTP\Response\ResponseFactory;
use Gemini\HTTP\Router\Router;
use Gemini\HTTP\Security\CsrfTokenManager;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\View\BladeTemplateEngine;
use Infrastructure\Config\Service\Config;
use JetBrains\PhpStorm\NoReturn;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;

// -----------------------------------
// Dependency Injection and Services
// -----------------------------------

if (! function_exists(function: 'appInstance')) {
    function appInstance(ContainerInterface|null $instance = null) : DependencyInjector
    {
        static $container = null;

        if ($instance instanceof ContainerInterface) {
            if (! $instance instanceof DependencyInjector) {
                throw new RuntimeException(message: "Only DependencyInjector instances can be used for appInstance.");
            }

            $container = $instance;
        }

        if ($container === null) {
            throw new RuntimeException(
                message: "Container instance is not initialized. Please set the container first."
            );
        }

        return $container;
    }
}

if (! function_exists(function: 'app')) {
    function app(string|null $abstract = null) : mixed
    {
        $dependencyInjector = appInstance();

        if ($abstract === null) {
            return $dependencyInjector;
        }

//        if (! $dependencyInjector->has(id: $abstract)) {
//            throw new RuntimeException(message: "Action '" . $abstract . "' is not found in the container.");
//        }

        return $dependencyInjector->get(id: $abstract);
    }
}

// -----------------------------------
// Base Path Utility
// -----------------------------------

if (! function_exists(function: 'base_path')) {
    /**
     * Resolves the base path of the application.
     *
     * @param string $path The relative path to append to the base path.
     *
     * @return string The resolved base path.
     */
    function base_path(string $path = '') : string
    {
        return rtrim(string: AppPath::getRoot(), characters: '/') . '/' . ltrim(string: $path, characters: '/');
    }
}

if (! function_exists(function: 'response')) {
    function response(
        int|null $status = null,
        array    $headers = [],
        string   $body = ''
    ) : ResponseInterface|ResponseFactory {
        $responseFactory = app(abstract: ResponseFactory::class);

        if ($status === null) {
            return $responseFactory;
        }

        $response = $responseFactory->createResponse($status);

        foreach ($headers as $header => $value) {
            $response = $response->withHeader($header, $value);
        }

        $response->getBody()->write($body);

        return $response;
    }
}

// -----------------------------------
// CSRF Token Management
// -----------------------------------

if (! function_exists(function: 'csrf_token')) {
    /**
     * @throws \Exception
     */
    function csrf_token() : string
    {
        $csrfManager = app(abstract: CsrfTokenManager::class);

        if (! $csrfManager instanceof CsrfTokenManager) {
            throw new RuntimeException(message: "CsrfTokenManager is not registered in the container.");
        }

        return $csrfManager->getToken();
    }
}

// -----------------------------------
// Routing and Views
// -----------------------------------

if (! function_exists(function: 'route')) {
    function route(string $name, array $parameters = []) : string|null
    {
        try {
            // Retrieve the `Router` instance from the dependency injection container.
            // The `app` function resolves a service by its class (or abstract type).
            $router = app(abstract: Router::class);

            // Fetch the route definition by its name using the retrieved `Router` instance.
            // This name is typically associated with a specific route you defined earlier in the application.
            $route = $router->getRouteByName($name);

            // Extract the path of the route. The `path` property contains the URL pattern for the route.
            $path = $route->path;

            // Inject parameters into the path
            foreach ($parameters as $key => $value) {
                $path = preg_replace("/\{{$key}(?:[?*]?)}/", $value, $path);
            }

            // Clean up any optional params not provided
            $path = preg_replace('/\{[^}]+\}/', '', $path);

            return $path;
        } catch (Throwable $throwable) {
            logger(message: 'Failed to generate route.', context: ['route_name' => $name, 'exception' => $throwable]);

            return null;
        }
    }
}

if (! function_exists(function: 'view')) {
    /**
     * Renders a Blade view and returns an HTTP response.
     *
     * @param string $template The view template to render.
     * @param array  $data     The data to pass to the view.
     */
    function view(string $template, array $data = []) : ResponseInterface
    {
        try {
            $blade = app(BladeTemplateEngine::class);
            $body  = $blade->render($template, $data);

            return response(status: 200, headers: ['Content-Type' => 'text/html'], body: $body);
        } catch (Throwable $throwable) {
            dump('dump view ', $throwable);
            logger('View rendering failed.', ['template' => $template, 'exception' => $throwable]);

            return response(status: 500, body: 'An error occurred while rendering the view.');
        }
    }
}

// -----------------------------------
// Debugging Utilities
// -----------------------------------
// dd() like function
if (! function_exists('ddx')) {
    #[NoReturn]
    function ddx(mixed ...$args) : never
    {
        DumpDebugger::ddx(...$args);
    }
}

// dump() like function
if (! function_exists('dumpx')) {
    function dumpx(mixed ...$args) : void
    {
        DumpDebugger::dumpx(...$args);
    }
}

// -----------------------------------
// Session and Logging
// -----------------------------------

if (! function_exists(function: 'session')) {
    function session(string|null $key = null, mixed $value = null) : mixed
    {
        $session = app(abstract: SessionInterface::class);

        if ($key === null) {
            return $session;
        }

        if ($value === null) {
            return $session->get($key);
        }

        $session->set($key, $value);

        return null;
    }
}

if (! function_exists(function: 'logger')) {
    function logger(string|null $message = null, array $context = [], string $level = 'info')
    {
        $logger = app(abstract: LoggerInterface::class);

        if ($message === null) {
            return $logger;
        }

        $logger->log($level, $message, $context);

        return null;
    }
}

// -----------------------------------
// Utility Functions
// -----------------------------------

if (! function_exists(function: 'config')) {
    function config(string $key, mixed $default = null) : mixed
    {
        return app(abstract: Config::class)->get($key, $default);
    }
}

if (! function_exists(function: 'storage_path')) {
    function storage_path(string $path = '') : string
    {
        $base = base_path(path: 'storage');

        return rtrim(string: $base, characters: '/') . '/' . ltrim(string: $path, characters: '/');
    }
}

if (! function_exists(function: 'collect')) {
    function collect(iterable $items = []) : Collection
    {
        return new Collection(items: $items);
    }
}

if (! function_exists(function: 'auth')) {
    function auth() : AuthenticationServiceInterface
    {
        return app(abstract: AuthenticationServiceInterface::class);
    }
}

if (! function_exists('asset')) {
    function asset(string $path) : string
    {
        $baseUrl = (! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https://' : 'http://';
        $baseUrl .= $_SERVER['HTTP_HOST'] ?? 'localhost';

        return $baseUrl . '/' . ltrim($path, '/');
    }
}

/**
 * Redirects to a given relative path or route name.
 *
 * @param string $destination A relative path or route name.
 * @param array  $parameters  Parameters for dynamic route segments (if using route names).
 * @param int    $status      HTTP status code for the redirection (default: 302).
 *
 * @return \Psr\Http\Message\ResponseInterface
 */
if (! function_exists(function: 'redirect') && ! function_exists('redirect')) {
    /**
     * Redirects to a given URL.
     *
     * @param string $url    The URL to redirect to.
     * @param int    $status The HTTP status code for the redirection (default: 302).
     */
    function redirect(string $url, int $status = 302) : ResponseInterface
    {
        $responseFactory = app(ResponseFactoryInterface::class);

        return $responseFactory
            ->createResponse($status)
            ->withHeader('Location', $url);
    }
}

/**
 * Redirects to a given relative path or route name.
 *
 * @param string $destination A relative path or route name.
 * @param array  $parameters  Parameters for dynamic route segments (if using route names).
 * @param int    $status      HTTP status code for the redirection (default: 302).
 *
 * @return \Psr\Http\Message\ResponseInterface
 */
if (! function_exists(function: 'arrhae') && ! function_exists('arrhae')) {
    function arrhae(array $array) : Arrhae
    {
        return new Arrhae($array);
    }
}

if (! function_exists('connection')) {
    /**
     * Retrieves a PDO database connection.
     *
     * @param string|null $connectionName The name of the database connection to retrieve. Defaults to null for the default connection.
     *
     * @return PDO The PDO database connection instance.
     * @throws RuntimeException If the database connection service is not available in the dependency injection container.
     */
    function connection(string $connectionName = null) : PDO
    {
        /** @var DatabaseConnection $databaseManager */
        $databaseManager = app(abstract: DatabaseConnection::class);

        if (! $databaseManager instanceof DatabaseConnection) {
            throw new RuntimeException(message: 'Database connection service is not registered in DI container.');
        }

        return $databaseManager->getConnection(connectionName: $connectionName);
    }

    if (! function_exists('preview_text')) {
        /**
         * Shortens the given text for preview purposes.
         *
         * @param string $text
         * @param int    $limit Number of characters to show
         *
         * @return string Truncated text with ellipsis if necessary.
         */
        function preview_text(string $text, int $limit = 80) : string
        {
            $text = strip_tags($text);

            return mb_strlen($text) > $limit
                ? mb_substr($text, 0, $limit - 3) . '...'
                : $text;
        }
    }
}



=== HTTP/Dispatcher/ControllerDispatcher.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Dispatcher;

use Gemini\HTTP\Request\Request;
use InvalidArgumentException;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface;
use ReflectionMethod;
use ReflectionNamedType;
use RuntimeException;

/**
 * Dispatches a controller or callable based on the route action.
 * Supports:
 * - Invokable classes
 * - [ControllerClass::class, 'method']
 * - Callable (e.g., anonymous functions)
 */
final readonly class ControllerDispatcher
{
    /**
     * Constructs the class with a dependency injection container.
     *
     * @param ContainerInterface $container The container instance used for dependency injection.
     *
     * @return void
     */
    public function __construct(private ContainerInterface $container) {}

    /**
     * Dispatches a controller action or callable based on the route action definition.
     *
     * @param callable|array|string $action  The route's target action (controller, method, or callable).
     * @param Request               $request The PSR-7 compatible HTTP request instance.
     *
     * @return ResponseInterface
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    /**
     * Dispatches a controller action or callable based on the route action definition.
     *
     * @param callable|array|string $action  The route's target action (controller, method, or callable).
     * @param Request               $request The PSR-7 compatible HTTP request instance.
     *
     * @return ResponseInterface
     *
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    public function dispatch(callable|array|string $action, Request $request) : ResponseInterface
    {
        // Delegate to the appropriate handler based on action type
        // Evaluate the expression based on the provided $action input using the `match` expression.
        return match (true) {
            // If $action is callable (like a closure, anonymous function, or valid callable object),
            // invoke `dispatchCallable`, passing $action and the $request as arguments.
            is_callable($action) => $this->dispatchCallable(callable: $action, request: $request),

            // If $action is an array (typically [ControllerClass, "method"] format),
            // invoke `dispatchControllerAndMethod`, passing $action and the $request.
            is_array($action)    => $this->dispatchControllerAndMethod(action: $action, request: $request),

            // If $action is a string (usually indicating an invokable controller class name),
            // invoke `dispatchInvokableController`, passing the $action and $request.
            is_string($action)   => $this->dispatchInvokableController(controller: $action, request: $request),

            // If none of the above conditions match, throw an exception because the action provided
            // is invalid or unsupported.
            default              => throw new InvalidArgumentException(message: 'Invalid route action provided.')
        };
    }


    /**
     * Handles a directly callable action (e.g., anonymous function or Closure).
     *
     * @param callable $callable The callable to invoke.
     * @param Request  $request  The PSR-7 compatible HTTP request instance.
     *
     * @return ResponseInterface
     */
    private function dispatchCallable(callable $callable, Request $request) : ResponseInterface
    {
        // Passes the $request object to the provided callable function and
        // immediately returns the resulting ResponseInterface instance.
        return $callable($request);
    }

    /**
     * Handles an action that specifies a controller class and method.
     *
     * @param array   $action  [ControllerClass::class, 'method'].
     * @param Request $request The PSR-7 compatible HTTP request instance.
     *
     * @return ResponseInterface
     *
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    private function dispatchControllerAndMethod(array $action, Request $request) : ResponseInterface
    {
        // Check if the `$action` array has exactly 2 elements ([Class, "method"] format).
        if (count($action) !== 2) {
            // If not, throw an exception to indicate improper structure.
            throw new InvalidArgumentException(message: 'Controller action must be [Class, "method"]');
        }

        // Decompose the `$action` array into `$controller` (class) and `$method`.
        [$controller, $method] = $action;

        // Check if the `$controller` (class name) exists.
        if (! class_exists($controller)) {
            // Throw an exception if the provided class does not exist.
            throw new RuntimeException(message: "Controller class '{$controller}' not found.");
        }

        // Resolve the controller object instance (either from the container or by instantiating it directly).
        $instance = $this->resolveController(className: $controller);

        // Check if the `method` exists in the resolved controller instance.
        if (! method_exists($instance, $method)) {
            // Throw an exception if the method is not found in the class.
            throw new RuntimeException(message: "Method '{$method}' not found in '{$controller}'.");
        }

        // Create a new ReflectionMethod object to introspect the method's parameters and metadata.
        $reflection = new ReflectionMethod(objectOrMethod: $instance, method: $method);

        // Initialize an array to store resolved arguments for the method call.
        $arguments = [];

        // Loop through all parameters of the method.
        foreach ($reflection->getParameters() as $param) {
            // Get the name of the current parameter.
            $paramName = $param->getName();
            // Get the parameter's type (if declared).
            $paramType = $param->getType();

            // Check if the parameter type is a named type (not union or mixed).
            if ($paramType instanceof ReflectionNamedType) {
                // Get the name of the type (e.g., class or scalar type).
                $typeName = $paramType->getName();

                // If the type corresponds to a class that is a `Request` (or extends it).
                if (is_a($typeName, Request::class, true)) {
                    // Inject the `$request` instance as the value for this parameter.
                    $arguments[] = $request;
                    continue;
                }

                // Check if the type name is available in the dependency injection container.
                if ($this->container->has(id: $typeName)) {
                    // Fetch the dependency from the container and add it to the arguments array.
                    $arguments[] = $this->container->get(id: $typeName);
                    continue;
                }
            }

            // Attempt to resolve the parameter using a route attribute (from the `$request` object).
            // For example, if the parameter name matches a route placeholder.
            $attributeValue = $request->getAttribute(name: $paramName);
            if ($attributeValue !== null) {
                // Add the attribute value to the arguments array if found.
                $arguments[] = $attributeValue;
                continue;
            }

            // Check if the parameter has a default value provided in the method signature.
            if ($param->isDefaultValueAvailable()) {
                // Use the default value for the parameter and add it to the arguments array.
                $arguments[] = $param->getDefaultValue();
                continue;
            }

            // If the parameter cannot be resolved, throw an exception with detailed information.
            throw new RuntimeException(
                message: "Unable to resolve parameter '{$paramName}' for method '{$method}' in '{$controller}'"
            );
        }

        // Invoke the controller's method with the resolved arguments using reflection.
        return $reflection->invokeArgs(object: $instance, args: $arguments);
    }

    /**
     * Resolves a controller instance using the DI container.
     *
     * @param string $className The fully qualified name of the controller class.
     *
     * @return object
     *
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    private function resolveController(string $className) : object
    {
        if ($this->container->has(id: $className)) {
            return $this->container->get(id: $className);
        }

        if (class_exists($className)) {
            return new $className();
        }

        throw new RuntimeException(message: "Unable to resolve controller class '{$className}'.");
    }

    /**
     * Handles an action represented by an invokable controller.
     *
     * @param string  $controller The fully qualified name of the invokable controller class.
     * @param Request $request    The PSR-7 compatible HTTP request instance.
     *
     * @return ResponseInterface
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    private function dispatchInvokableController(string $controller, Request $request) : ResponseInterface
    {
        // Check if the specified controller class exists.
        // If the class is not found, throw a RuntimeException with a descriptive error message.
        if (! class_exists($controller)) {
            throw new RuntimeException(message: "Controller class '{$controller}' does not exist.");
        }

        // Instantiate the specified controller class by resolving it from the container or creating it directly.
        // This ensures the controller instance is properly resolved, respecting dependency injection rules.
        $instance = $this->resolveController(className: $controller);

        // Check if the resolved controller instance is callable (i.e., it must be an invokable class).
        // If the controller is not callable, throw a RuntimeException indicating the issue.
        if (! is_callable($instance)) {
            throw new RuntimeException(message: "Controller class '{$controller}' must be invokable.");
        }

        // If the controller is valid and invokable, call it and pass the incoming request as an argument.
        // The return value of the controller (usually a Response object) is returned as the method's result.
        return $instance($request);
    }
}
=== HTTP/Enums/HttpMethod.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Enums;

/**
 * Enum HttpMethod
 *
 * Represents all possible HTTP methods in a web application.
 * Utilizing an enum class ensures all HTTP methods are handled uniformly
 * and reduces the likelihood of typos or unsupported methods being used.
 */
enum HttpMethod: string
{
    /**
     * HTTP method GET.
     *
     * This constant represents the HTTP GET method used to request data from a specified resource.
     * It's part of HTTP/1.1, RFC 2616, and is widely utilized for retrieving information without
     * modifying the state of the resource.
     */
    case GET = 'GET';

    /**
     * Represents an HTTP POST request.
     *
     * This enum value signifies that the request method is POST, typically used
     * to submit data to be processed to a specified resource.
     */
    case POST = 'POST';

    /**
     * Indicates the HTTP PUT method, typically used for updating resources on a server.
     * Used to specify the idempotence and significance of the HTTP method in API operations.
     */
    case PUT = 'PUT';

    /**
     * HTTP DELETE method used to delete a specified resource.
     *
     * This constant represents the HTTP DELETE request. It's typically used in RESTful APIs
     * to signal that a resource identified by a URI should be deleted.
     *
     * Choosing DELETE over other HTTP methods is following RESTful principles, ensuring
     * that the method semantics are clear and standardized.
     */
    case DELETE = 'DELETE';

    /**
     * Represents an HTTP HEAD request method.
     *
     * The HEAD method is used to retrieve the headers that are returned if the specified resource would be requested
     * with an HTTP GET method. As such, it serves a similar purpose as GET but without the response body, making it
     * useful for checking what a GET request will return before actually making the request.
     */
    case HEAD = 'HEAD';

    /**
     * HTTP method constant representing the 'CONNECT' request method.
     *
     * The 'CONNECT' method starts two-way communications with the requested resource,
     * typically with the use-case of establishing a tunnel to the server identified by the target resource.
     * This is commonly used for SSL tunneling through an HTTP proxy.
     */
    case CONNECT = 'CONNECT';

    /**
     * Enumeration of HTTP request methods.
     * Options can be used in CORS pre-flight requests.
     */
    case OPTIONS = 'OPTIONS';

    /**
     * Enum value representing the HTTP TRACE method.
     * TRACE is typically used for diagnostic purposes. It echoes back the received request
     * so that a client can see what (if any) changes or additions have been made by intermediate servers.
     */
    case TRACE = 'TRACE';

    /**
     * HTTP PATCH method, used to apply partial modifications to a resource.
     *
     * @constant PATCH
     */
    case PATCH = 'PATCH';

    /**
     * Checks if the provided method is supported.
     *
     * @param string $method The HTTP method to check.
     *
     * @return bool True if the method is supported, otherwise false.
     *
     * Rationale: Using a match expression ensures that the method
     * comparison is concise and clear, making it easy to read and maintain.
     */
    public static function isSupported(string $method) : bool
    {
        return match ($method) {
            self::GET->value,
            self::POST->value,
            self::PUT->value,
            self::DELETE->value,
            self::HEAD->value,
            self::CONNECT->value,
            self::OPTIONS->value,
            self::TRACE->value,
            self::PATCH->value => true,
            default            => false,
        };
    }

    /**
     * Returns a list of all supported HTTP methods.
     *
     * @return array List of supported HTTP methods.
     *
     * Rationale: This method provides a comprehensive list of all supported methods,
     * making it easier to iterate over or validate against all possible HTTP methods
     * without hardcoding the values elsewhere.
     */
    public static function getSupportedMethods() : array
    {
        return array_map(static fn($case) => $case->value, self::cases());
    }
}

=== HTTP/Enums/HttpReasonPhrase.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Enums;

/**
 * Enum representing HTTP Reason Phrases associated with Status Codes.
 */
enum HttpReasonPhrase: string
{
    case OK                  = 'OK';

    case CREATED             = 'Created';

    case ACCEPTED            = 'Accepted';

    case NO_CONTENT          = 'No Content';

    case MOVED_PERMANENTLY   = 'Moved Permanently';

    case FOUND               = 'Found';

    case NOT_MODIFIED        = 'Not Modified';

    case BAD_REQUEST         = 'Bad Request';

    case UNAUTHORIZED        = 'Unauthorized';

    case FORBIDDEN           = 'Forbidden';

    case NOT_FOUND           = 'Not Found';

    case METHOD_NOT_ALLOWED  = 'Method Not Allowed';

    case INTERNAL_SERVER_ERROR = 'Internal Server Error';

    case NOT_IMPLEMENTED     = 'Not Implemented';

    case BAD_GATEWAY         = 'Bad Gateway';

    case SERVICE_UNAVAILABLE = 'Service Unavailable';

    case GATEWAY_TIMEOUT     = 'Gateway Timeout';
}

=== HTTP/Enums/HttpStatusCode.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Enums;

/**
 * Enum representing common HTTP Status Codes.
 */
enum HttpStatusCode: int
{
    case OK                  = 200;

    case CREATED             = 201;

    case ACCEPTED            = 202;

    case NO_CONTENT          = 204;

    case MOVED_PERMANENTLY   = 301;

    case FOUND               = 302;

    case NOT_MODIFIED        = 304;

    case BAD_REQUEST         = 400;

    case UNAUTHORIZED        = 401;

    case FORBIDDEN           = 403;

    case NOT_FOUND           = 404;

    case METHOD_NOT_ALLOWED  = 405;

    case INTERNAL_SERVER_ERROR = 500;

    case NOT_IMPLEMENTED     = 501;

    case BAD_GATEWAY         = 502;

    case SERVICE_UNAVAILABLE = 503;

    case GATEWAY_TIMEOUT     = 504;
}

=== HTTP/Enums/RequestOption.php ===
<?php

declare(strict_types=1);

/**
 * ENUM representing different request options for HTTP requests.
 *
 * This enum is used to clearly define and enforce the allowed request
 * options within the Gemini HTTP client implementation. The values within
 * this ENUM are used to standardize the keys for various request parameters.
 */

namespace Gemini\HTTP\Enums;

/**
 * Enum RequestOption
 *
 * Enum class representing different types of request options.
 * Each member of the enum stands for a specific way in which request data
 * can be formatted or processed, tailored for different use cases.
 */
enum RequestOption: string
{
    case HEADERS = 'headers';

    case JSON = 'json';
}

=== HTTP/HttpClient/Config/Clients/AbstractHttpClient.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Clients;

use Gemini\HTTP\HttpClient\Config\Contracts\Client\Async\AsyncOperationInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class AbstractHttpClient
 *
 * An abstract base class that defines the blueprint for HTTP clients.
 * Provides methods for sending synchronous and asynchronous requests, handling responses, and logging.
 * Concrete clients like GuzzleClient will implement the actual HTTP handling logic.
 */
abstract class AbstractHttpClient
{
    /**
     * Constructor to initialize the logger.
     *
     * @param LoggerInterface $logger Injected logger instance for error and info logging.
     */
    public function __construct(protected LoggerInterface $logger) {}

    /**
     * Sends a synchronous HTTP request.
     *
     * @param string $method   The HTTP method (GET, POST, etc.).
     * @param string $endpoint The URL endpoint.
     * @param array  $options  Additional options for the request.
     *
     * @return array A structured response with endpoint and result data.
     */
    abstract public function sendRequest(
        string $method,
        string $endpoint,
        array  $options = []
    ) : ResponseInterface;

    /**
     * Sends an asynchronous HTTP request.
     *
     * @param string $method   The HTTP method (GET, POST, etc.).
     * @param string $endpoint The URL endpoint.
     * @param array  $options  Additional options for the request.
     *
     * @return AsyncOperationInterface A promise-like interface that resolves with structured response data.
     */
    abstract public function sendAsyncRequest(
        string $method,
        string $endpoint,
        array  $options = [],
    ) : AsyncOperationInterface;

    /**
     * Formats the response data for synchronous or asynchronous requests.
     *
     * @param ResponseInterface $response The HTTP response.
     * @param string            $endpoint The URL endpoint from which the response was retrieved.
     *
     * @return array The formatted response data containing the endpoint and parsed result.
     */
    protected function formatResponse(ResponseInterface $response, string $endpoint) : array
    {
        $this->logger->info(
            message: sprintf('Request to %s succeeded', $endpoint),
            context: [
                         'status' => $response->getStatusCode(),
                     ],
        );

        return [
            'endpoint' => $endpoint,
            'status'   => $response->getStatusCode(),
            'data'     => $response->getBody()->getContents(),
        ];
    }

    /**
     * Logs successful async requests.
     *
     * @param string            $endpoint The endpoint URL.
     * @param ResponseInterface $response The response object.
     */
    protected function logSuccess(string $endpoint, ResponseInterface $response) : void
    {
        $this->logger->info(
            message: 'Asynchronous request to ' . $endpoint
                     . ' completed successfully with status ' . $response->getStatusCode(),
        );
    }

    /**
     * Asynchronous error handler for promises.
     *
     * @param string $endpoint The endpoint URL.
     * @param mixed  $reason   The reason for the failure (typically an exception or error message).
     *
     * @return array The formatted failure data.
     */
    protected function handleAsyncFailure(string $endpoint, mixed $reason) : array
    {
        $this->logger->error(
            message: 'Asynchronous request to ' . $endpoint . ' failed.',
            context: [
                         'reason' => $reason instanceof Throwable ? $reason->getMessage() : 'Unknown error',
                     ],
        );

        return $this->handleFailure(endpoint: $endpoint, reason: $reason);
    }

    /**
     * Logs an error and returns a formatted failure response.
     *
     * @param string $endpoint The endpoint URL.
     * @param mixed  $reason   The reason for the failure (could be an exception or another value).
     *
     * @return array The error data, structured with endpoint and reason.
     */
    public function handleFailure(string $endpoint, mixed $reason) : array
    {
        $errorMessage = $reason instanceof Throwable ? $reason->getMessage() : 'Unknown error';
        $this->logger->error(message: sprintf('Request to %s failed', $endpoint), context: ['error' => $errorMessage]);

        return [
            'endpoint' => $endpoint,
            'error'    => $errorMessage,
        ];
    }
}

=== HTTP/HttpClient/Config/Clients/Guzzle/GuzzleAsyncOperation.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Clients\Guzzle;

use Exception;
use Gemini\HTTP\HttpClient\Config\Contracts\Client\Async\AsyncOperationInterface;
use GuzzleHttp\Promise\PromiseInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class GuzzleAsyncOperation
 *
 * Provides standardized async operation handling using Guzzle promises.
 */
readonly class GuzzleAsyncOperation implements AsyncOperationInterface
{
    public function __construct(
        private PromiseInterface $promise,
        private LoggerInterface  $logger,
    ) {}

    /**
     * Resolves the promise and returns the result.
     *
     * @return mixed The result of the promise.
     * @throws \Throwable
     * @throws \Throwable
     */
    public function resolve() : mixed
    {
        try {
            return $this->promise->wait();
        } catch (Throwable $throwable) {
            $this->logger->error(
                message: "Async operation resolve failed",
                context: ["message" => $throwable->getMessage()],
            );
            throw $throwable;
        }
    }

    /**
     * Rejects the promise and logs the rejection.
     *
     * @return mixed The rejection reason.
     * @throws \Exception
     */
    public function reject() : mixed
    {
        try {
            return $this->promise->wait(unwrap: false);
        } catch (Throwable $throwable) {
            $this->logger->warning(
                message: "Async operation rejected",
                context: ["message" => $throwable->getMessage()],
            );
            throw new Exception(message: $throwable->getMessage(), code: $throwable->getCode(), previous: $throwable);
        }
    }

    /**
     * Attaches a success callback to the promise.
     *
     * @param callable $onFulfilled The callback for a successful response.
     *
     * @return self The current instance for chaining.
     */
    public function then(callable $onFulfilled) : self
    {
        $this->promise->then(onFulfilled: $onFulfilled);

        return $this;
    }

    /**
     * Attaches a failure callback to the promise.
     *
     * @param callable $onRejected The callback for a failed response.
     *
     * @return self The current instance for chaining.
     */
    public function catch(callable $onRejected) : self
    {
        $this->promise->otherwise(onRejected: $onRejected);

        return $this;
    }
}

=== HTTP/HttpClient/Config/Clients/Guzzle/GuzzleClient.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Clients\Guzzle;

use Gemini\HTTP\HttpClient\Config\Clients\AbstractHttpClient;
use Gemini\HTTP\HttpClient\Config\Contracts\Client\Async\AsyncOperationInterface;
use Gemini\HTTP\HttpClient\Traits\HandlesAggregationTrait;
use Gemini\HTTP\HttpClient\Traits\HandlesAsyncRequestsTrait;
use Gemini\HTTP\HttpClient\Traits\HandlesHttpErrorsTrait;
use Gemini\HTTP\HttpClient\Traits\HandlesHttpResponseTrait;
use Gemini\HTTP\HttpClient\Traits\SendsHttpRequestsTrait;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class GuzzleClient
 *
 * A concrete HTTP client that uses various traits for sending requests, handling responses, and managing errors.
 */
final class GuzzleClient extends AbstractHttpClient
{
    use HandlesHttpResponseTrait;
    use SendsHttpRequestsTrait;
    use HandlesAsyncRequestsTrait;
    use HandlesAggregationTrait;
    use HandlesHttpErrorsTrait;

    /**
     * Constructor for the class.
     *
     * @param HttpClient      $httpClient      Allows handling of HTTP requests.
     * @param LoggerInterface $dataLogger      Logger to capture and record data-related events.
     * @param ResponseFactory $responseFactory Factory to create response objects.
     */
    public function __construct(
        private readonly HttpClient      $httpClient,
        private readonly LoggerInterface $dataLogger,
        private readonly ResponseFactory $responseFactory,
    ) {
        parent::__construct(logger: $dataLogger);
    }

    /**
     * Sends an asynchronous HTTP request.
     *
     * @param string $method   The HTTP method (GET, POST, etc.).
     * @param string $endpoint The URL endpoint.
     * @param array  $options  Additional options for the request.
     *
     * @return AsyncOperationInterface A promise-like interface that resolves with structured response data.
     * @throws \Throwable
     * @throws \Throwable
     */
    public function sendAsyncRequest(string $method, string $endpoint, array $options = []) : AsyncOperationInterface
    {
        try {
            $promise = $this->httpClient->requestAsync(method: $method, uri: $endpoint, options: $options);

            return new GuzzleAsyncOperation(promise: $promise, logger: $this->dataLogger);
        } catch (Throwable $throwable) {
            // Log the error for debugging purposes
            $this->logRequestError(method: $method, endpoint: $endpoint, options: $options, throwable: $throwable);

            // Re-throw the exception to ensure it's handled upstream
            throw $throwable;
        }
    }

    /**
     * Logs request errors for debugging and monitoring purposes.
     *
     * @param string    $method    The HTTP method used.
     * @param string    $endpoint  The URL endpoint.
     * @param array     $options   Additional options for the request.
     * @param Throwable $throwable The exception that occurred.
     */
    private function logRequestError(string $method, string $endpoint, array $options, Throwable $throwable) : void
    {
        $this->dataLogger->error(
            message: 'HTTP Request failed',
            context: [
                         'method'    => $method,
                         'endpoint'  => $endpoint,
                         'options'   => $options,
                         'exception' => [
                             'message' => $throwable->getMessage(),
                             'code'    => $throwable->getCode(),
                             'trace'   => $throwable->getTraceAsString(),
                         ],
                     ]
        );
    }
}

=== HTTP/HttpClient/Config/Clients/Guzzle/HttpClient.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Clients\Guzzle;

use Exception;
use Gemini\HTTP\HttpClient\Config\Middleware\RetryMiddleware;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\Request;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\UriInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Final class HttpClient
 *
 * Acts as a Guzzle-based HTTP client with support for synchronous and asynchronous requests.
 * This client includes retry and error-handling middleware.
 */
final readonly class HttpClient implements ClientInterface
{
    private ClientInterface $guzzleClient;

    /**
     * @param RetryMiddleware     $retryMiddleware
     * @param LoggerInterface     $logger
     * @param string|UriInterface $baseUri
     */
    public function __construct(
        private RetryMiddleware     $retryMiddleware,
        private LoggerInterface     $logger,
        private string|UriInterface $baseUri,
    ) {
        // Initialize Guzzle client with base URI and middleware
        $this->guzzleClient = new Client(
            config: [
                        'base_uri'        => $this->baseUri,
                        'handler'         => $this->getHandlerStack(),
                        'timeout'         => 90,  // Maximum duration of request
                        'connect_timeout' => 10, // Timeout for connection
                        'http_errors'     => false,
                        'headers'         => [
                            'Accept'       => 'application/json',
                            'Content-Type' => 'application/json',
                        ],
                    ],
        );
    }

    /**
     * @return HandlerStack
     */
    private function getHandlerStack() : HandlerStack
    {
        $handlerStack = HandlerStack::create();
        $handlerStack->push(middleware: $this->retryMiddleware->createRetryMiddleware());

        return $handlerStack;
    }

    /**
     * @param RequestInterface $request
     * @param array            $options
     *
     * @return ResponseInterface
     * @throws Exception
     */
    public function send(RequestInterface $request, array $options = []) : ResponseInterface
    {
        try {
            return $this->performRequest(
                method : $request->getMethod(),
                uri    : $request->getUri(),
                options: $options,
            );
        } catch (Throwable $throwable) {
            $this->logger->error(
                message: "Request failed",
                context: [
                             'uri'   => (string) $request->getUri(),
                             'error' => $throwable->getMessage(),
                         ],
            );
            throw new Exception(message: "Failed to send request", code: $throwable->getCode(), previous: $throwable);
        }
    }

    /**
     * @param string              $method
     * @param string|UriInterface $uri
     * @param array|null          $options
     * @param bool                $async
     *
     * @return ResponseInterface|PromiseInterface
     * @throws GuzzleException
     */
    private function performRequest(
        string              $method,
        string|UriInterface $uri,
        array|null          $options = null,
        bool                $async = false
    ) : ResponseInterface|PromiseInterface {
        $options ??= [];
        try {
            $response = $async
                ? $this->guzzleClient->requestAsync(method: $method, uri: $uri, options: $options)
                : $this->guzzleClient->request(method: $method, uri: $uri, options: $options);

            if ($response->getStatusCode() === 504) {
                throw new RequestException(
                    message : "⏳ 504 Gateway Timeout - Server did not respond in time.",
                    request : new Request(method: $method, uri: $uri),
                    response: $response
                );
            }

            return $response;
        } catch (RequestException|ConnectException|Exception $e) {
            $this->logger->error(
                message: '⏳ HTTP error detected!',
                context: [
                             'method'    => $method,
                             'url'       => (string) $uri,
                             'exception' => $e->getMessage(),
                         ],
            );

            if (str_contains($e->getMessage(), 'timed out')) {
                $this->logger->warning(
                    message: '⏳ HTTP Request stopped because of timeout!',
                    context: [
                                 'method' => $method,
                                 'url'    => (string) $uri,
                                 'error'  => $e->getMessage(),
                             ],
                );
                throw new Exception(
                    message : "⏳ Request timeout (server did not respond in time)",
                    code    : 408,
                    previous: $e
                );
            }
            throw $e;
        }
    }

    /**
     * @param string $method
     * @param        $uri
     * @param array  $options
     *
     * @return PromiseInterface
     * @throws Exception
     */
    public function requestAsync(string $method, $uri, array $options = []) : PromiseInterface
    {
        return $this->performRequest(
            method : $method,
            uri    : $uri,
            options: $options,
            async  : true,
        );
    }

    /**
     * Implements Guzzle's request method.
     *
     * @param string              $method  HTTP method.
     * @param string|UriInterface $uri     Request URI.
     * @param array               $options Additional request options.
     *
     * @return ResponseInterface
     * @throws Exception
     */
    public function request(string $method, $uri, array $options = []) : ResponseInterface
    {
        return $this->performRequest(
            method : $method,
            uri    : $uri,
            options: $options,
            async  : false,
        );
    }

    /**
     * @param RequestInterface $request
     * @param array            $options
     *
     * @return PromiseInterface
     * @throws Exception
     */
    public function sendAsync(RequestInterface $request, array $options = []) : PromiseInterface
    {
        try {
            // Delegate the asynchronous request to the underlying Guzzle client
            return $this->guzzleClient->sendAsync($request, $options);
        } catch (Throwable $throwable) {
            $this->logger->error(
                message: "Asynchronous request failed",
                context: [
                             'uri'   => (string) $request->getUri(),
                             'error' => $throwable->getMessage(),
                         ],
            );
            throw new Exception(
                message : "Failed to send async request",
                code    : $throwable->getCode(),
                previous: $throwable
            );
        }
    }

    /**
     * Implements Guzzle's getConfig method.
     *
     * @param string|null $option Configuration option to retrieve.
     *
     * @return mixed
     */
    public function getConfig(?string $option = null)
    {
        return $this->guzzleClient->getConfig($option);
    }
}
=== HTTP/HttpClient/Config/Contracts/Client/Async/AsyncOperationInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Contracts\Client\Async;

/**
 * Interface AsyncOperationInterface
 *
 * Represents an asynchronous operation that can be fulfilled or rejected.
 * Provides a standardized approach to attach success and failure callbacks.
 */
interface AsyncOperationInterface
{
    /**
     * Resolves the asynchronous operation and returns the result.
     *
     * @return mixed The result of the asynchronous operation.
     */
    public function resolve() : mixed;

    /**
     * Rejects the asynchronous operation and returns the reason for the rejection.
     *
     * @return mixed The reason for rejection.
     */
    public function reject() : mixed;

    /**
     * Attaches a callback to be executed when the operation is fulfilled.
     *
     * @param callable $onFulfilled The callback to execute on success.
     *
     * @return self The instance for chaining.
     */
    public function then(callable $onFulfilled) : self;

    /**
     * Attaches a callback to be executed when the operation is rejected.
     *
     * @param callable $onRejected The callback to execute on failure.
     *
     * @return self The instance for chaining.
     */
    public function catch(callable $onRejected) : self;
}

=== HTTP/HttpClient/Config/Contracts/Client/GeminiClientInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Contracts\Client;

use Gemini\HTTP\Enums\HttpMethod;
use GuzzleHttp\Promise\PromiseInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * Interface GeminiClientInterface
 *
 * This interface defines the contract for interacting with HTTP clients.
 * The methods defined are for sending synchronous and asynchronous HTTP requests,
 * as well as aggregating data from multiple endpoints.
 */
interface GeminiClientInterface
{
    /**
     * Send a POST request with the specified body and optional headers.
     *
     * @param string $url     The endpoint URL.
     * @param array  $body    Data to send in the request body.
     * @param array  $headers Optional headers for the request.
     *
     * @return ResponseInterface The formatted response from the endpoint.
     */
    public function sendPostRequest(string $url, array $body, array $headers = []) : ResponseInterface;

    /**
     * Generic method for sending HTTP requests.
     *
     * @param string     $method  HTTP method (GET, POST, etc.).
     * @param string     $url     The URL endpoint.
     * @param array|null $headers Optional headers for the request.
     * @param array      $options Additional options for the request.
     *
     * @return ResponseInterface The raw response from the server.
     */
    public function sendRequest(
        string     $method,
        string     $url,
        array|null $headers = null,
        array      $options = [],
    ) : ResponseInterface;

    /**
     * Process the Guzzle response into a structured format using ResponseFactory.
     *
     * @param mixed  $response The raw Guzzle response.
     * @param string $endpoint The endpoint URL.
     *
     * @return ResponseInterface A standardized response.
     */
    public function getResponse(mixed $response, string $endpoint) : ResponseInterface;

    /**
     * Aggregates data asynchronously from multiple URLs.
     *
     * @param array $urls The list of URLs to request data from.
     *
     * @return PromiseInterface A promise that resolves with aggregated results.
     */
    public function aggregateDataAsynchronously(array $urls) : PromiseInterface;

    /**
     * Creates asynchronous requests for multiple endpoints.
     *
     * @param array      $urls   An array of URLs.
     * @param HttpMethod $method The HTTP method to use (GET, POST, etc.).
     *
     * @return array An array of promises for the requests.
     */
    public function createAsyncRequests(array $urls) : array;

    /**
     * Settles multiple promises and processes their results.
     *
     * @param array $promises The promises to settle.
     *
     * @return PromiseInterface A promise that resolves with the processed results.
     */
    public function settlePromises(array $promises) : PromiseInterface;

    /**
     * Processes the results of multiple promises.
     *
     * @param array $results The array of settled promises.
     *
     * @return array The processed results.
     */
    public function processPromisesResults(array $results) : array;

    /**
     * Processes a single promise result.
     *
     * @param string $endpoint The endpoint URL.
     * @param array  $result   The result of the request.
     *
     * @return ResponseInterface A structured response based on the result.
     */
    public function processSinglePromiseResult(string $endpoint, array $result) : ResponseInterface;

    /**
     * Handles failures in request promises.
     *
     * @param string $endpoint The URL of the failed request.
     * @param mixed  $reason   The reason for the failure.
     *
     * @return ResponseInterface A structured response containing the error information.
     */
    public function handleFailure(string $endpoint, mixed $reason) : ResponseInterface;
}

=== HTTP/HttpClient/Config/Middleware/Policies/Concrats/RetryPolicyInterface.php ===
<?php

declare(strict_types=1);

/**
 * This interface defines the contract for a retry policy that determines whether
 * an HTTP request should be retried based on the given response or exception.
 *
 * The interface is designed to be flexible enough to handle various retry conditions.
 *
 * @see ResponseInterface
 * @see Throwable
 */

namespace Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats;

use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * An interface that defines a retry policy for handling HTTP responses and exceptions.
 *
 * The purpose of this interface is to determine whether a failed request should be retried
 * based on the given ResponseInterface or Throwable.
 *
 * This approach allows for various implementations of retry logic based on the specific needs
 * of the application, such as retrying on certain status codes, or specific types of exceptions.
 */
interface RetryPolicyInterface
{
    /**
     * Determines whether a request should be retried based on the response or exception received.
     *
     * The primary intent behind this method is to encapsulate the logic for retrying a request,
     * taking into account specific business rules or conditions that warrant a retry.
     *
     * @param ResponseInterface|null $response  The response object received from a request. This can be null
     *                                          if the request failed without a response, such as network errors.
     * @param Throwable|null         $exception The exception thrown during the request, if any. This can be null if
     *                                          the request completed without throwing an exception.
     *
     * @return bool True if the request should be retried, false otherwise.
     *
     * Some scenarios where retrying might be essential:
     * - Handling transient network issues.
     * - Recovering from server-side errors that are expected to be temporary.
     * - Managing specific HTTP status codes that indicate a retry could succeed (e.g., 502, 503, 504).
     *
     * This method should encapsulate all such conditions to ensure consistent retry logic across the application.
     */
    public function shouldRetry(ResponseInterface|null $response, Throwable|null $exception) : bool;
}

=== HTTP/HttpClient/Config/Middleware/Policies/NetworkFailureRetryPolicy.php ===
<?php

declare(strict_types=1);

/**
 * Class NetworkFailureRetryPolicy
 *
 * This class implements the RetryPolicyInterface to provide a retry policy based on network failures.
 * It retries a request if a network failure (indicated by specific conditions) occurs.
 *
 * This policy is designed to handle transient network issues by attempting the request again,
 * under conditions where it is likely that the failure can be resolved by a simple retry.
 */

namespace Gemini\HTTP\HttpClient\Config\Middleware\Policies;

use Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats\RetryPolicyInterface;
use GuzzleHttp\Exception\RequestException;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * Class NetworkFailureRetryPolicy
 *
 * This class implements a retry policy specifically for network failures.
 * It determines whether a request should be retried based on the response or exception encountered.
 *
 * Implements RetryPolicyInterface to ensure standard retry behavior across different policies.
 */
class NetworkFailureRetryPolicy implements RetryPolicyInterface
{
    /**
     * Determines if a request should be retried based on the given response and exception.
     *
     * @param ResponseInterface|null $response  The HTTP response from the previous request attempt.
     * @param Throwable|null         $exception The exception thrown during the previous request attempt.
     *
     * @return bool Returns true if the request should be retried; otherwise, false.
     *
     * This method specifically checks if the exception is of type RequestException with a code of 0,
     * which may denote a network error that warrants a retry. This logic is based on the assumption that
     * such exceptions are transient and retrying the request could succeed.
     */
    public function shouldRetry(ResponseInterface|null $response, Throwable|null $exception) : bool
    {
        return $exception instanceof RequestException && $exception->getCode() === 0;
    }
}

=== HTTP/HttpClient/Config/Middleware/Policies/RetryPolicies.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Middleware\Policies;

use Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats\RetryPolicyInterface;

/**
 * Class that aggregates and provides different retry policies.
 */
class RetryPolicies
{
    public function getServerErrorPolicy() : RetryPolicyInterface
    {
        return new ServerErrorRetryPolicy();
    }

    public function getNetworkFailurePolicy() : RetryPolicyInterface
    {
        return new NetworkFailureRetryPolicy();
    }
}

=== HTTP/HttpClient/Config/Middleware/Policies/ServerErrorRetryPolicy.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Middleware\Policies;

use Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats\RetryPolicyInterface;
use GuzzleHttp\Exception\ConnectException;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * Retry policy to handle server errors (status codes 500-599).
 *
 * This class implements a retry policy that determines whether an HTTP request
 * should be retried based on the response received or an exception encountered.
 *
 * It is designed to automatically retry requests that result in server errors
 * (HTTP status codes 500-599).
 */
class ServerErrorRetryPolicy implements RetryPolicyInterface
{
    /**
     * @var array<int> HTTP status codes for which the request should be retried.
     */
    private array $retryStatusCodes = [500, 502, 503, 504, 429];

    /**
     * Determines whether a request should be retried based on the response or exception.
     *
     * **Technical Description**:
     * This method checks the HTTP response code against a predefined list of retryable codes.
     * If there is no response but an exception of type `ConnectException` is thrown, the method
     * instructs to retry the request, as this typically represents a network timeout or other
     * transient connection issue.
     *
     * **Business Description**:
     * This functionality ensures that temporary server or network issues do not interrupt a
     * user's experience with irreversible failures. It improves the resilience of requests by
     * allowing retries under specific circumstances, helping achieve reliable communication
     * with external services.
     *
     * @param ResponseInterface|null $response  The HTTP response (if available).
     * @param Throwable|null         $exception The thrown exception (if available).
     *
     * @return bool `true` if the request should be retried, `false` otherwise.
     */
    public function shouldRetry(ResponseInterface|null $response, Throwable|null $exception) : bool
    {
        // If there is an HTTP response, retry if the status code is in the list of allowed codes.
        if ($response instanceof ResponseInterface) {
            return in_array($response->getStatusCode(), $this->retryStatusCodes, true);
        }

        // If no response exists but it is a ConnectException (e.g., timeout), attempt retry.
        return $exception instanceof ConnectException;
    }
}
=== HTTP/HttpClient/Config/Middleware/RetryContext.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Middleware;

use GuzzleHttp\Exception\RequestException;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * A context for managing retry logic within API client services.
 *
 * This class encapsulates the state needed to determine whether an API call should be retried,
 * including the number of retries already attempted, the original request object,
 * and optionally the response or the exception received.
 *
 * The `readonly` modifier ensures immutability after instantiation, which is
 * essential in retry logic to avoid side effects across retries.
 */
final readonly class RetryContext
{
    /**
     * @param int                    $retries   The number of retry attempts made so far.
     * @param RequestInterface       $request   The request object being retried.
     * @param ResponseInterface|null $response  The response from the previous attempt, if any.
     * @param Throwable|null         $throwable The exception encountered, if any, during the last retry attempt.
     */
    public function __construct(
        public int                    $retries,
        public RequestInterface       $request,
        public ResponseInterface|null $response = null,
        public Throwable|null         $throwable = null,
    ) {}

    /**
     * Determines if a retry is necessary based on the response status code.
     *
     * @return bool True if a retry should be attempted, false otherwise.
     */
    public function shouldRetry() : bool
    {
        // Retry on server errors (5xx) or network-related exceptions (timeout, DNS failure, etc.)
        if ($this->response instanceof ResponseInterface && $this->isServerError(
                statusCode: $this->response->getStatusCode(),
            )) {
            return true;
        }

        return $this->throwable instanceof Throwable && $this->isNetworkException(throwable: $this->throwable);
    }

    /**
     * Checks if the response status code indicates a server error (5xx).
     *
     * @param int $statusCode The HTTP status code to check.
     *
     * @return bool True if the status code is a server error, false otherwise.
     */
    private function isServerError(int $statusCode) : bool
    {
        return $statusCode >= 500 && $statusCode < 600;
    }

    /**
     * Determines if the exception is network-related and should trigger a retry.
     *
     * @param Throwable $throwable The exception to check.
     *
     * @return bool True if the exception is network-related, false otherwise.
     */
    private function isNetworkException(Throwable $throwable) : bool
    {
        return $throwable instanceof RequestException && $throwable->getCode() === 0;
    }

    /**
     * Provides the next delay time in milliseconds using exponential backoff.
     *
     * @param int $initialWaitTime The initial delay in milliseconds.
     *
     * @return int The calculated delay for the next retry attempt.
     */
    public function getNextDelay(int $initialWaitTime) : int
    {
        return (int) 2 ** $this->retries * $initialWaitTime;
    }
}

=== HTTP/HttpClient/Config/Middleware/RetryMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Config\Middleware;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Middleware;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;

final class RetryMiddleware
{
    private array $retryStatusCodes = [504, 500, 502, 503, 429];

    public function __construct(
        private readonly LoggerInterface $logger,
        private int|null                 $maxRetries = null,
    ) {
        $this->maxRetries ??= 3;
    }

    public function createRetryMiddleware() : callable
    {
        return Middleware::retry(
            decider: function ($retries, $request, $response = null, $exception = null) {
                $statusCode = $response?->getStatusCode();

                if ($retries >= $this->maxRetries) {
                    $this->logger->warning(message: '🔄 Retry Middleware max reached out! 🚨');

                    return false;
                }

                if ($response instanceof ResponseInterface
                    && in_array($statusCode, $this->retryStatusCodes, true)) {
                    $this->logger->info(message: '🔄 Retrying due to response status: ' . $statusCode);


                    return true;
                }

                if ($exception instanceof RequestException || $exception instanceof ConnectException) {
                    $this->logger->warning(message: '🔄 Retrying due to exception: ' . $exception->getMessage());

                    return true;
                }

                return false;
            },
            delay  : static function ($retries) {
                return 1000 * (2 ** $retries); // ⏳ Exponential backoff
            }
        );
    }
}

=== HTTP/HttpClient/Traits/HandlesAggregationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Traits;

use GuzzleHttp\Promise\PromiseInterface;

trait HandlesAggregationTrait
{
    /**
     * Asynchronously aggregates data from multiple endpoints.
     *
     * @param array $urls The list of URLs to request data from.
     *
     * @return PromiseInterface A promise that resolves with the aggregated results.
     * @throws \Exception
     */
    public function aggregateDataAsynchronously(array $urls) : PromiseInterface
    {
        $this->dataLogger->info(message: 'Starting data aggregation for multiple endpoints.');

        $promises = $this->createAsyncRequests(urls: $urls);

        return $this->settlePromises(promises: $promises);
    }
}

=== HTTP/HttpClient/Traits/HandlesAsyncRequestsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Traits;

use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Promise\Utils;

trait HandlesAsyncRequestsTrait
{
    /**
     * Generates asynchronous requests for multiple endpoints.
     *
     * @param array $urls The list of URLs to fetch data from.
     *
     * @return array An array of promises for the asynchronous requests.
     * @throws \Exception
     * @throws \Exception
     */
    public function createAsyncRequests(array $urls) : array
    {
        $promises = [];
        foreach ($urls as $endpoint => $url) {
            $promises[$endpoint] = $this->httpClient->requestAsync(method: 'GET', uri: $url);
        }

        return $promises;
    }

    /**
     * Settles the promises for multiple requests and processes their results.
     *
     * @param array $promises The list of promises to settle.
     *
     * @return PromiseInterface A promise that resolves with processed results.
     */
    public function settlePromises(array $promises) : PromiseInterface
    {
        return Utils::settle(promises: $promises)->then(
            onFulfilled: fn(array $results) => $this->processPromisesResults(results: $results),
        );
    }

    /**
     * Processes the results of each settled promise.
     *
     * @param array $results The array of results from settled promises.
     *
     * @return array The array of processed responses.
     */
    private function processPromisesResults(array $results) : array
    {
        $aggregatedResponses = [];
        foreach ($results as $endpoint => $result) {
            $aggregatedResponses[$endpoint] = $this->processSinglePromiseResult($endpoint, $result);
        }

        return $aggregatedResponses;
    }
}

=== HTTP/HttpClient/Traits/HandlesHttpErrorsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Traits;

use Throwable;

trait HandlesHttpErrorsTrait
{
    /**
     * Logs an error and returns a formatted failure response.
     *
     * @param string $endpoint The endpoint that failed.
     * @param mixed  $reason   The reason for the failure.
     *
     * @return array A structured response with error information.
     */
    public function handleFailure(string $endpoint, mixed $reason) : array
    {
        $errorMessage = $reason instanceof Throwable ? $reason->getMessage() : 'Unknown error';
        $this->dataLogger->error(
            message: 'Error fetching data for ' . $endpoint,
            context: ['error' => $errorMessage],
        );

        return [
            'endpoint' => $endpoint,
            'reason'   => $errorMessage,
        ];
    }
}

=== HTTP/HttpClient/Traits/HandlesHttpResponseTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Traits;

use JsonException;
use Psr\Http\Message\ResponseInterface;

trait HandlesHttpResponseTrait
{
    /**
     * Decodes and formats the HTTP response.
     *
     * @param ResponseInterface $response The HTTP response.
     * @param string            $endpoint The endpoint URL.
     *
     * @return ResponseInterface A formatted response object.
     * @throws JsonException
     */
    public function getResponse(ResponseInterface $response, string $endpoint) : ResponseInterface
    {
        $body    = $response->getBody()->getContents();
        $decoded = json_decode($body, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            $this->dataLogger->warning(
                message: "HTTPClient Error! JSON decoding failed: " . json_last_error_msg(),
                context: ['body' => $body],
            );
            $decoded = $body;
        }

        $formattedResult = [
            'endpoint' => $endpoint,
            'result'   => $decoded ?? $body,
        ];

        return $this->responseFactory->json(data: $formattedResult);
    }
}

=== HTTP/HttpClient/Traits/SendsHttpRequestsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\HttpClient\Traits;

use Psr\Http\Message\ResponseInterface;
use RuntimeException;
use Throwable;

trait SendsHttpRequestsTrait
{
    /**
     * Core method for sending synchronous HTTP requests.
     *
     * @param string     $method  HTTP method (GET, POST, etc.).
     * @param string     $url     The URL endpoint.
     * @param array|null $headers Optional headers for the request.
     * @param array      $options Additional options for the request.
     *
     * @return ResponseInterface The raw HTTP response.
     * @throws \RuntimeException
     */
    public function sendRequest(
        string     $method,
        string     $url,
        array|null $headers = null,
        array      $options = [],
    ) : ResponseInterface {
        $headers            ??= [];
        $options['headers'] = $headers;

        try {
            return $this->httpClient->request(method: $method, uri: $url, options: $options);
        } catch (Throwable $throwable) {
            throw new RuntimeException(
                message : 'Failed to send request to ' . $url,
                code    : (int) $throwable->getCode(),
                previous: $throwable,
            );
        }
    }
}

=== HTTP/Middleware/CorsMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * Middleware to add CORS headers for cross-origin requests.
 */
class CorsMiddleware
{
    /**
     * Process the request and add CORS headers to the response.
     *
     * @param ServerRequestInterface $serverRequest The incoming request.
     * @param Closure $next The next middleware or handler.
     *
     * @return ResponseInterface The response with CORS headers.
     */
    public function handle(ServerRequestInterface $serverRequest, Closure $next): ResponseInterface
    {
        $response = $next($serverRequest);

        return $response
            ->withHeader('Access-Control-Allow-Origin', '*')
            ->withHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
            ->withHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')
            ->withHeader('Access-Control-Allow-Credentials', 'true');
    }
}
=== HTTP/Middleware/CSRF/CsrfMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware\CSRF;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\ResponseFactory;
use Gemini\HTTP\Security\CsrfTokenManager;

/**
 * `CsrfMiddleware` is a middleware that ensures CSRF token validation for specific HTTP methods.
 * The class is marked as `readonly` to ensure its properties are immutable after instantiation.
 */
readonly class CsrfMiddleware
{
    /**
     * Constructor initializes the CsrfMiddleware with a CSRF token manager and a response factory.
     *
     * @param CsrfTokenManager $csrfTokenManager The manager used for CSRF token validation.
     * @param ResponseFactory  $responseFactory  The factory used to create HTTP responses.
     */
    public function __construct(
        private CsrfTokenManager $csrfTokenManager,
        private ResponseFactory  $responseFactory,
    ) {}

    /**
     * Handles the incoming request and ensures that CSRF token validation is performed for certain HTTP methods.
     * If the token is invalid or absent, a 403 response is generated.
     *
     * @param Request  $request The incoming HTTP request object.
     * @param callable $next    The next middleware to be called.
     *
     * @return mixed Returns the next middleware response or a 403 response if CSRF validation fails.
     * @throws \Exception
     */
    public function handle(Request $request, callable $next) : mixed
    {
        // Only validate CSRF tokens for methods that can modify state
        if (in_array($request->getMethod(), ['POST', 'PUT', 'PATCH', 'DELETE'])) {
            // Retrieve the CSRF token from the request
            $token = $request->get(key: '_csrf_token');

            // If the token is invalid or missing, return a 403 Forbidden response
            if (! $this->csrfTokenManager->validateToken(token: $token)) {
                return $this->responseFactory->createResponse(code: 403, reasonPhrase: 'CSRF token validation failed');
            }
        }

        // Proceed to the next middleware if CSRF validation passes
        return $next($request);
    }
}
=== HTTP/Middleware/ExceptionHandlerMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Log\LoggerInterface;
use Spatie\Ignition\Ignition;
use Throwable;

/**
 * Middleware responsible for centralized exception handling using Spatie Ignition.
 *
 * Catches unhandled exceptions during request processing, logs them, and provides
 * appropriate user responses in either JSON format or via detailed Ignition pages,
 * based on the configured environment variable.
 */
readonly class ExceptionHandlerMiddleware
{
    /**
     * Supported exception response rendering formats.
     */
    private const string RENDER_FORMAT_IGNITION = 'ignition';

    private const string RENDER_FORMAT_JSON     = 'json';

    /**
     * @param LoggerInterface $logger          Logger instance for recording exceptions.
     * @param ResponseFactory $responseFactory Factory for generating HTTP responses.
     */
    public function __construct(
        private LoggerInterface $logger,
        private ResponseFactory $responseFactory,
    ) {}

    /**
     * Handles incoming HTTP requests and manages exception handling.
     *
     * Executes next middleware and catches unhandled exceptions, logs them, and renders
     * a response based on the configured rendering type (JSON or Ignition).
     *
     * @param ServerRequestInterface $serverRequest Incoming HTTP request instance.
     * @param Closure                $next          Next middleware handler closure.
     *
     * @return ResponseInterface HTTP response after handling exception.
     * @throws \JsonException
     * @throws \JsonException
     */
    public function handle(ServerRequestInterface $serverRequest, Closure $next) : ResponseInterface
    {
        try {
            // Invoke the next middleware or handler in the pipeline.
            return $next($serverRequest);
        } catch (Throwable $throwable) {
            // Log exception details for further analysis.
            $this->logger->error(
                message: 'Unhandled exception during request processing',
                context: ['exception' => $throwable]
            );

            // Determine a response rendering format based on environment configuration.
            return match ($this->renderFormat()) {
                self::RENDER_FORMAT_JSON => $this->renderJsonResponse($throwable),
                default                  => $this->renderIgnitionResponse($throwable),
            };
        }
    }

    /**
     * Retrieves configured exception rendering format from environment variables.
     *
     * Supported values:
     * - ignition: Renders exception using Ignition as detailed HTML.
     * - json: Returns JSON structured error response.
     *
     * @return string Configured rendering format.
     */
    private function renderFormat() : string
    {
        return env(key: 'EXCEPTION_RESPONSE_FORMAT', default: self::RENDER_FORMAT_IGNITION);
    }

    /**
     * Returns a structured JSON error response suitable for API clients.
     *
     * @param Throwable $throwable Exception instance to report.
     *
     * @return ResponseInterface Structured JSON error response.
     * @throws \JsonException
     * @throws \JsonException
     */
    private function renderJsonResponse(Throwable $throwable) : ResponseInterface
    {
        return $this->responseFactory->response(
            data  : json_encode([
                                    'error'   => 'Internal Server Error',
                                    'message' => 'Lele! An unexpected error occurred.',
                                ],
                                JSON_THROW_ON_ERROR),
            status: 500
        );
    }

    /**
     * Renders exception details using Spatie Ignition for debugging purposes.
     *
     * @param Throwable $throwable The exception instance to render.
     *
     * @return ResponseInterface Response containing Ignition detailed exception view.
     */
    private function renderIgnitionResponse(Throwable $throwable) : ResponseInterface
    {
        Ignition::make()
            ->shouldDisplayException(shouldDisplayException: true)
            ->setTheme(theme: 'dark')
            ->register();

        return $this->responseFactory->response(
            data  : Ignition::make()->renderException(throwable: $throwable),
            status: 500
        );
    }
}

=== HTTP/Middleware/IpRestrictionMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Http\Message\ResponseInterface;

/**
 * Abstract base class for middleware that restricts access based on IP addresses.
 *
 * Concrete subclasses can define specific business logic for allowable IPs,
 * such as office IPs or other access-controlled networks.
 */
abstract class IpRestrictionMiddleware
{
    public function __construct(protected ResponseFactory $responseFactory) {}

    /**
     * Main entry point for IP restriction middleware.
     *
     * @param Request $request The incoming HTTP request.
     * @param Closure $next    The next middleware or request handler.
     *
     * @return ResponseInterface A response if IP is disallowed, or proceeds to the next middleware.
     */
    public function handle(Request $request, Closure $next) : ResponseInterface
    {
        if (! $this->isAllowedIp($request->getClientIp())) {
            return $this->createAccessDeniedResponse();
        }

        return $next($request);
    }

    /**
     * Checks if the IP address is allowed.
     *
     * @param string $ipAddress The IP address to check.
     *
     * @return bool True if the IP is allowed, false otherwise.
     */
    abstract protected function isAllowedIp(string $ipAddress) : bool;

    /**
     * Generates a 403 Forbidden response for disallowed IPs.
     *
     * @return ResponseInterface The access denied response.
     */
    protected function createAccessDeniedResponse() : ResponseInterface
    {
        return $this->responseFactory->view(
            template: 'errors.403',
            data    : ['message' => 'Access from your IP address is not allowed.'],
            status  : 403
        );
    }
}

=== HTTP/Middleware/JsonResponseMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * Middleware to enforce JSON response format for API requests.
 */
readonly class JsonResponseMiddleware
{
    /**
     * Constructor method for initializing the ResponseFactory dependency.
     *
     * @param ResponseFactory $responseFactory The factory instance used to create responses.
     *
     * @return void
     */
    public function __construct(private ResponseFactory $responseFactory) {}

    /**
     * Process the request and ensure JSON response formatting.
     *
     * @param ServerRequestInterface $serverRequest The incoming request.
     * @param Closure                $next          The next middleware or handler.
     *
     * @return ResponseInterface The JSON-formatted response.
     */
    public function handle(ServerRequestInterface $serverRequest, Closure $next) : ResponseInterface
    {
        $response = $next($serverRequest);

        // Enforce JSON response if necessary
        return $this->responseFactory->response(
            data  : $response->getBody()->getContents(),
            status: $response->getStatusCode()
        );
    }
}
=== HTTP/Middleware/MiddlewareExecutionException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Exception;

/**
 * Class MiddlewareExecutionException
 *
 * Exception thrown when a middleware fails during execution.
 *
 * @package Gemini\HTTP\Middleware
 */
final class MiddlewareExecutionException extends Exception
{
    /**
     * MiddlewareExecutionException constructor.
     *
     * @param string         $message  The Exception message to throw.
     * @param int            $code     The Exception code.
     * @param Exception|null $previous The previous throwable used for exception chaining.
     */
    public function __construct(
        string         $message = "",
        int            $code = 0,
        Exception|null $previous = null,
    ) {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== HTTP/Middleware/MiddlewareGroupResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use RuntimeException;

/**
 * Resolves middleware group aliases into concrete middleware class lists.
 *
 * Responsible for handling middleware group definitions and providing
 * functionality to resolve those groups into their respective middleware chains.
 */
final readonly class MiddlewareGroupResolver
{
    /**
     * @param array{
     *     groups: array<string, array<class-string>>
     * } $config Middleware group configuration data.
     */
    public function __construct(private array $config)
    {
        $this->validateConfig(config: $config);
    }

    /**
     * Validates the initial configuration to detect early misconfigurations.
     *
     * @param array $config The middleware configuration data to validate.
     *
     * @throws RuntimeException If the configuration is invalid.
     */
    private function validateConfig(array $config) : void
    {
        if (! isset($config['groups']) || ! is_array($config['groups'])) {
            throw new RuntimeException(message: 'Middleware configuration must contain a "groups" array.');
        }

        foreach ($config['groups'] as $groupName => $middlewares) {
            if (! is_string($groupName)) {
                throw new RuntimeException(message: 'Middleware group names must be strings.');
            }

            if (! is_array($middlewares)) {
                throw new RuntimeException(message: "Middleware group [{$groupName}] must be an array.");
            }
        }
    }

    /**
     * Resolves a middleware group name to its list of middleware classes.
     *
     * @param string $entry Middleware group alias (e.g. 'web', 'api').
     *
     * @return array<class-string> List of fully qualified middleware class names.
     *
     * @throws RuntimeException If the middleware group does not exist or is invalid.
     */
    public function resolveGroup(string $entry) : array
    {
        if (! $this->hasGroup(group: $entry)) {
            throw new RuntimeException(message: "Middleware group [{$entry}] does not exist.");
        }

        $group = $this->config['groups'][$entry];

        if (! is_array($group)) {
            throw new RuntimeException(message: "Middleware group [{$entry}] must be an array.");
        }

        // Ensure all entries strictly adhere to the class-string type.
        foreach ($group as $middleware) {
            if (! is_string($middleware) || ! class_exists($middleware)) {
                throw new RuntimeException(
                    message: "Invalid middleware [{$middleware}] in group [{$entry}]. Must be a valid class name."
                );
            }
        }

        return $group;
    }

    /**
     * Checks if a middleware group alias is defined in the configuration.
     *
     * @param string $group Middleware group alias to check.
     *
     * @return bool True if the group exists, false otherwise.
     */
    public function hasGroup(string $group) : bool
    {
        return isset($this->config['groups'][$group]);
    }
}
=== HTTP/Middleware/MiddlewarePipelineLogger.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Psr\Http\Message\RequestInterface;
use Psr\Log\LoggerInterface;

/**
 * Logs middleware pipeline execution lifecycle.
 */
final class MiddlewarePipelineLogger
{
    public function __construct(
        private readonly LoggerInterface $logger
    ) {}

    /**
     * Logs the start of middleware execution.
     *
     * @param RequestInterface $request The incoming request.
     */
    public function logStart(RequestInterface $request) : void
    {
        $this->logger->info(
            message: '⚙️ Starting middleware pipeline',
            context: ['uri' => (string) $request->getUri()]
        );
    }

    /**
     * Logs a single middleware execution.
     *
     * @param string $middlewareClass Fully qualified class name.
     */
    public function logMiddleware(string $middlewareClass) : void
    {
        $this->logger->debug(
            message: sprintf('⛓ Executing middleware: %s', $middlewareClass)
        );
    }

    /**
     * Logs the end of middleware pipeline.
     */
    public function logEnd() : void
    {
        $this->logger->info(message: '✅ Finished middleware pipeline');
    }
}

=== HTTP/Middleware/MiddlewarePipeline.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Gemini\HTTP\Response\ResponseFactory;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * The MiddlewarePipeline class is responsible for managing and executing
 * a stack of middleware components. The middleware components are processed
 * based on their priority to generate a valid HTTP response.
 */
class MiddlewarePipeline
{
    /**
     * @var array The stack of middleware components, each with an associated priority.
     */
    private array $middlewareStack = [];

    /**
     * Adds middleware with a specified priority to the pipeline.
     *
     * The middleware stack is sorted based on priority after new middleware is added.
     *
     * @param callable $middleware The middleware to add.
     * @param int      $priority   The priority of the middleware. Lower values indicate higher priority.
     */
    public function add(callable $middleware, int $priority = 10) : void
    {
        $this->middlewareStack[] = ['middleware' => $middleware, 'priority' => $priority];
        usort($this->middlewareStack, static fn(array $a, array $b) : int => $a['priority'] <=> $b['priority']);
    }

    /**
     * Executes the middleware pipeline.
     *
     * Each middleware in the stack is executed until a valid ResponseInterface instance is produced.
     * Middleware components call the `$next` callable to proceed to the next middleware.
     *
     * @param RequestInterface $request The HTTP request to process.
     *
     * @return ResponseInterface The HTTP response produced by the middleware stack.
     *
     * @throws MiddlewareExecutionException If the pipeline does not produce a response.
     */
    public function execute(RequestInterface $request) : ResponseInterface
    {
        // Create the final handler
        $finalHandler = static fn($req) : ResponseFactory|ResponseInterface => response(
            status : 200,
            headers: ['Content-Type' => 'text/plain'],
            body   : 'Default OK'
        );


        // Build the middleware chain
        $next = $finalHandler;

        foreach (array_reverse($this->middlewareStack) as $entry) {
            $middleware = $entry['middleware'];

            $next = static fn($req) => $middleware($req, $next);
        }

        // Execute the pipeline
        try {
            $response = $next($request);

            // Ensure the response is valid
            if (! $response instanceof ResponseInterface) {
                throw new MiddlewareExecutionException(
                    message: 'Pipeline did not produce a valid ResponseInterface'
                );
            }

            return $response;
        } catch (Throwable $throwable) {
            throw new MiddlewareExecutionException(
                message : 'Middleware execution failed',
                code    : $throwable->getCode(),
                previous: $throwable
            );
        }
    }
}

=== HTTP/Middleware/MiddlewareResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Gemini\HTTP\Router\Exceptions\UnresolvableMiddlewareException;

/**
 * MiddlewareResolver
 *
 * Responsible for resolving middleware identifiers (either class names or group aliases)
 * into fully qualified class names. This class enables middleware pipelines to operate
 * with a resolved list of middleware class names, whether individual or grouped.
 */
final readonly class MiddlewareResolver
{
    /**
     * Constructor to initialize the resolver with its dependencies.
     *
     * @param MiddlewareGroupResolver $groupResolver The dependency capable of resolving middleware groups.
     */
    public function __construct(private MiddlewareGroupResolver $groupResolver) {}

    /**
     * Resolves a list of middleware definitions. Entries in the array can be either:
     * - Fully qualified class names (FQCNs) of middleware.
     * - Group aliases that represent a defined set of middleware.
     *
     * @param array<string|class-string> $middleware A list of middleware definitions (FQCNs or group aliases).
     *
     * @return array<class-string> Returns a list of resolved middleware FQCNs (fully-qualified class names).
     *
     * @throws UnresolvableMiddlewareException If any middleware entry is invalid or unresolvable.
     */
    public function resolve(array $middleware) : array
    {
        // Initialize an empty array to collect resolved middleware class names.
        $resolved = [];

        // Iterate through each middleware entry in the provided list.
        foreach ($middleware as $entry) {
            // Validate the middleware entry, ensuring it adheres to the expected data type.
            $this->validateEntry($entry);

            // If the entry matches a defined middleware group alias:
            if ($this->groupResolver->hasGroup(group: $entry)) {
                // Recursively resolve the middleware group and merge its entries into the result.
                $resolved = array_merge($resolved, $this->resolveGroup(entry: $entry));
            } elseif (class_exists($entry)) {
                // If the entry is a valid class name, add it to the result list.
                $resolved[] = $entry;
            } else {
                // If the entry cannot be resolved, throw an exception with details.
                throw new UnresolvableMiddlewareException(
                    message: "Middleware identifier [{$entry}] could not be resolved to a class or group."
                );
            }
        }

        // Return the fully resolved list of middleware class names.
        return $resolved;
    }

    /**
     * Validates the middleware entry to ensure it adheres to the expected type.
     *
     * Middleware entries must be strings to represent either:
     * - A middleware FQCN (class-string).
     * - A middleware group alias defined in the configuration.
     *
     * @param mixed $entry The middleware entry provided by the user.
     *
     * @throws UnresolvableMiddlewareException If the middleware entry is not a valid string.
     */
    private function validateEntry(mixed $entry) : void
    {
        // Ensure the entry is a string; otherwise, reject the entry.
        if (! is_string($entry)) {
            throw new UnresolvableMiddlewareException(
                message: "Middleware entry must be a string. Got: " . gettype($entry)
            );
        }
    }

    /**
     * Resolves a middleware group alias into its corresponding middleware class names.
     *
     * This process delegates the resolution task to the `MiddlewareGroupResolver` instance
     * and supports recursive resolution of nested middleware groups.
     *
     * @param string $entry The middleware group alias to resolve (e.g., 'web', 'api').
     *
     * @return array<class-string> Returns the fully resolved middleware classes for the group.
     *
     * @throws UnresolvableMiddlewareException If the group cannot be resolved.
     */
    private function resolveGroup(string $entry) : array
    {
        // Recursively resolve the group's middleware entries using the group resolver.
        return $this->resolve(middleware: $this->groupResolver->resolveGroup(entry: $entry));
    }
}
=== HTTP/Middleware/RateLimiterMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Gemini\Auth\Application\Service\RateLimiterService;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Http\Message\ResponseInterface;

/**
 * Middleware that enforces rate limiting per client identifier (e.g., IP address) to
 * prevent excessive requests within a defined time window.
 */
readonly class RateLimiterMiddleware
{
    private const string DEFAULT_IDENTIFIER_TYPE = 'ip';

    private const int    DEFAULT_MAX_REQUESTS    = 60;

    private const int    DEFAULT_TIME_WINDOW     = 60;

    public function __construct(
        private RateLimiterService $rateLimiterService,
        private ResponseFactory    $responseFactory,
        private string             $identifierType = self::DEFAULT_IDENTIFIER_TYPE,
        private int                $maxRequests = self::DEFAULT_MAX_REQUESTS,
        private int                $timeWindow = self::DEFAULT_TIME_WINDOW
    ) {}

    /**
     * Handles the incoming request, applying rate limiting logic based on a unique identifier.
     *
     * @param Request $request The incoming HTTP request.
     * @param Closure $next    The next middleware or handler.
     *
     * @return ResponseInterface The processed response or a rate-limit-exceeded response.
     *
     * @throws \Psr\Cache\InvalidArgumentException|\DateMalformedStringException If the cache is unavailable or invalid.
     */
    public function handle(Request $request, Closure $next) : ResponseInterface
    {
        $identifier = $this->extractIdentifier(request: $request);

        // Apply custom limits by overriding RateLimiterService's default values
        if ($this->isRateLimitExceeded(identifier: $identifier)) {
            return $this->createRateLimitExceededResponse();
        }

        $response = $next($request);

        // Record each attempt after handling to avoid affecting response time
        $this->rateLimiterService->recordFailedAttempt($identifier, $this->maxRequests, $this->timeWindow);

        return $response;
    }

    /**
     * Extracts a unique identifier for rate limiting (e.g., client IP or default).
     *
     * @param Request $request The current request.
     *
     * @return string The extracted identifier.
     */
    private function extractIdentifier(Request $request) : string
    {
        return $this->identifierType === 'ip' ? $request->getClientIp() : 'default';
    }

    /**
     * Checks if the rate limit has been exceeded based on the identifier.
     *
     * @param string $identifier The unique identifier for rate limiting.
     *
     * @return bool True if rate limit is exceeded, false otherwise.
     *
     * @throws \Psr\Cache\InvalidArgumentException
     */
    private function isRateLimitExceeded(string $identifier) : bool
    {
        return ! $this->rateLimiterService->canAttempt(
            identifier : $identifier,
            maxAttempts: $this->maxRequests,
            timeWindow : $this->timeWindow
        );
    }

    /**
     * Creates a response to indicate the rate limit has been exceeded.
     *
     * @return ResponseInterface The response indicating rate limit exceeded.
     */
    private function createRateLimitExceededResponse() : ResponseInterface
    {
        return $this->responseFactory->createResponse(
            code        : 429,
            reasonPhrase: 'Too Many Requests'
        )->withHeader('Retry-After', (string) $this->timeWindow);
    }
}

=== HTTP/Middleware/RequestLoggerMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Closure;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;

/**
 * Middleware to log details of incoming HTTP requests.
 *
 * This middleware logs the HTTP method, URI, and client IP of each incoming request
 * using the provided PSR-3 compliant logger.
 *
 * The "readonly" modifier is used to enforce immutability, ensuring that once
 * instantiated the properties cannot be altered.
 */
readonly class RequestLoggerMiddleware
{
    /**
     * @param LoggerInterface $logger Instance of the logger used to log request details.
     */
    public function __construct(private LoggerInterface $logger) {}

    /**
     * Handle an incoming request and log its details.
     *
     * This method logs information about the incoming request, including its HTTP method,
     * URI, and client IP address. After logging, it passes the request to the next middleware/component.
     *
     * @param Request $request Incoming HTTP request.
     * @param Closure $next    Next middleware or handler in the request lifecycle.
     *
     * @return ResponseInterface Response from the next middleware/component.
     */
    public function handle(Request $request, Closure $next) : ResponseInterface
    {
        // Log the request details: method, URI, and client IP.
        $this->logger->info(message: 'Incoming request', context: [
            'method' => $request->getMethod(),
            'uri'    => (string) $request->getUri(),
            'ip'     => $request->getClientIp(),
        ]);

        // Proceed to the next middleware or handler.
        return $next($request);
    }
}
=== HTTP/Middleware/SecurityHeadersMiddleware.php ===
<?php
declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;
use Closure;

/**
 * The SecurityHeadersMiddleware class adds essential security-related headers
 * to HTTP responses to mitigate common web vulnerabilities.
 */
class SecurityHeadersMiddleware
{
    /**
     * Handle an incoming request and add security headers to the response.
     *
     * @param Request $request The incoming HTTP request.
     * @param Closure $next A Closure that passes the request to the next middleware.
     *
     * @return ResponseInterface The HTTP response with security headers added.
     */
    public function handle(Request $request, Closure $next): ResponseInterface
    {
        // Pass the request to the next middleware and get the response.
        $response = $next($request);

        // Adding security headers to the response to prevent certain types of attacks:
        // - X-Content-Type-Options: Prevents the browser from MIME-sniffing the content type.
        // - X-Frame-Options: Prevents the page from being displayed in a frame or iframe.
        // - X-XSS-Protection: Enables Cross-Site Scripting (XSS) filter built into most browsers.
        return $response
            ->withHeader('X-Content-Type-Options', 'nosniff')
            ->withHeader('X-Frame-Options', 'DENY')
            ->withHeader('X-XSS-Protection', '1; mode=block');
    }
}
=== HTTP/Middleware/SessionLifecycleMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Middleware;

use Gemini\HTTP\Session\Contracts\SessionInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * Class SessionLifecycleMiddleware
 *
 * Middleware responsible for managing the session lifecycle during an HTTP request.
 * Handles:
 * - Session start
 * - FlashBag load/sweep
 * - PSR-15 response validation
 * - Optional native session write-close
 *
 * @final
 */
final readonly class SessionLifecycleMiddleware
{
    public function __construct(
        private SessionInterface $session
    ) {}

    public function handle(RequestInterface $request, callable $next) : ResponseInterface
    {
        $bags = $this->session->getRegistry();

        $this->session->start();
        $bags->get('flash')->load();

        $response = $next($request);

        if (! $response instanceof ResponseInterface) {
            error_log('Invalid response returned from middleware chain.');

            $response = response(
                status : 500,
                headers: [],
                body   : 'Middleware chain did not return a valid ResponseInterface.'
            );
        }

        $bags->get('flash')->sweep();

        if (session_status() === PHP_SESSION_ACTIVE) {
            session_write_close();
        }

        return $response;
    }
}

=== HTTP/Request/AbsoluteServerRequest.php ===
<?php
/** @noinspection ALL */

declare(strict_types=1);

namespace Gemini\HTTP\Request;

use Gemini\HTTP\Response\Classes\Stream;
use Gemini\HTTP\URI\UriBuilder;
use InvalidArgumentException;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\StreamInterface;
use Psr\Http\Message\UploadedFileInterface;
use Psr\Http\Message\UriInterface;
use RuntimeException;

/**
 * Class AbsoluteServerRequest
 *
 * Base class implementing PSR-7's ServerRequestInterface.
 * Integrates ParameterBag for easy handling of parameters and manages uploaded files.
 */
class AbsoluteServerRequest implements ServerRequestInterface
{
    /**
     * @var array $attributes
     *
     * Stores attributes for an entity. This array might be used to dynamically
     * add or remove attributes without cluttering the class properties.
     */
    protected array $attributes = [];

    /**
     * @var array $headers
     * An array to store HTTP headers for the request. This is initialized as an empty
     * array and will be populated later based on specific headers required for the request.
     */
    protected array $headers = [];

    /**
     * Represents the HTTP method of the request (e.g., GET, POST).
     *
     * This is initialized from the `REQUEST_METHOD` server parameter.
     */
    protected string $method;

    /**
     * @var UriInterface $uri Represents the Uniform Resource Identifier (URI) for the resource.
     *                        Used consistently across functions to refer the endpoint being accessed or manipulated.
     *                        This variable may be set and modified frequently within different contexts, so it is
     *                        essential to maintain clarity about its purpose and usage to avoid confusion or misuse.
     */
    protected UriInterface $uri;

    /**
     * Handles the processing and validation of the request body.
     *
     * @param array $body The associative array representing the request body.
     *
     * This function processes the incoming request body and ensures that all necessary fields are present and valid.
     * Important business logic constraints are enforced here to maintain data integrity.
     */
    protected StreamInterface $body;

    /**
     * The version of the protocol being used.
     * This value may dictate how the server and client handle certain HTTP features.
     */
    protected string $protocolVersion = '1.1';

    /**
     * @var array $serverParams
     *
     * Holds server-specific parameters. This array is initialized as empty and expected to be populated
     * with parameters relevant to the server environment. It is crucial for accessing server configurations
     * and details required for various operations.
     *
     * The rationale for using an array here is to keep a structured, key-value format for easy retrieval
     * and manipulation of server parameters as needed throughout the codebase.
     */
    protected array $serverParams = [];

    /**
     * Class representing a database query builder.
     *
     * This class encapsulates logic for constructing SQL queries dynamically.
     * The primary goal is to provide an interface for developers to build complex
     * SQL queries using a fluent API, making it easier to maintain and read.
     *
     * The class uses a combination of SQL fragments and placeholders to
     * securely build queries and prevent SQL injection.
     */
    protected ParameterBag $query;

    /**
     * Class handling HTTP requests.
     *
     * This class encapsulates all incoming HTTP request data and provides methods
     * to interact with that data, ensuring uniform handling of different types
     * of requests (GET, POST, etc.). It abstracts the complexities of dealing with raw
     * input data and provides a structured way to access them.
     */
    protected ParameterBag $request;

    /**
     * Class holds methods to handle HTTP cookies.
     *
     * @class CookiesHelper
     * Final class to prevent inheritance.
     * Provides methods for setting, getting, and deleting cookies.
     */
    protected ParameterBag $cookies;

    /**
     * Constructor to initialize server request object.
     *
     * @param array|null           $server        Server parameters or defaults to $_SERVER.
     * @param UriInterface|null    $uri           URI of the request.
     * @param StreamInterface|null $body          Body of the request.
     * @param array|null           $queryParams   Query parameters or defaults to $_GET.
     * @param array|null           $parsedBody    Parsed body or an empty array.
     * @param array|null           $cookies       Cookie parameters or defaults to $_COOKIE.
     * @param array                $uploadedFiles Uploaded files parsed from the request.
     */
    public function __construct(
        array|null           $server = null,
        UriInterface|null    $uri = null,
        StreamInterface|null $body = null,
        array|null           $queryParams = null,
        array|null           $parsedBody = null,
        array|null           $cookies = null,
        protected array      $uploadedFiles = [],
    ) {
        $this->serverParams = $server ?? $_SERVER;
        $this->uri          = $uri ?? $this->initializeUri(requestUri: $this->serverParams['REQUEST_URI'] ?? '/');
        $resource           = fopen('php://temp', 'r+');
        if ($resource === false) {
            throw new RuntimeException(message: 'Unable to create temporary stream for request body.');
        }

        $this->body            = $body ?? new Stream(stream: $resource);
        $this->method          = $this->serverParams['REQUEST_METHOD'] ?? 'GET';
        $this->protocolVersion = $this->serverParams['SERVER_PROTOCOL'] ?? '1.1';
        $this->query           = new ParameterBag(parameters: $queryParams ?? $_GET);
        $this->request         = new ParameterBag(parameters: is_array($parsedBody) ? $parsedBody : []);
        $this->cookies         = new ParameterBag(parameters: $cookies ?? $_COOKIE);
        $this->headers         = $this->extractHeaders(server: $this->serverParams);
    }

    private function initializeUri(string $requestUri) : UriInterface
    {
        return UriBuilder::createFromString(uri: $requestUri);
    }

    /**
     * Extract HTTP headers from server parameters.
     *
     * @param array $server Server parameters.
     *
     * @return array Extracted headers.
     */
    private function extractHeaders(array $server) : array
    {
        $headers = [];
        foreach ($server as $key => $value) {
            if (str_starts_with($key, 'HTTP_')) {
                $name           = str_replace(' ', '-', ucwords(str_replace('_', ' ', strtolower(substr($key, 5)))));
                $headers[$name] = $value;
            }
        }

        return $headers;
    }

    /** ***PSR-7 Protocol Version Methods*** */


    /**
     * Retrieve the network protocol version used.
     *
     * @return string The current protocol version.
     */
    public function getProtocolVersion() : string
    {
        return $this->protocolVersion;
    }

    /**
     * Clone the instance with a new protocol version.
     *
     * @param string $version New protocol version.
     *
     * @return static Cloned instance with updated protocol version.
     */
    public function withProtocolVersion(string $version) : static
    {
        $clone                  = clone $this;
        $clone->protocolVersion = $version;

        return $clone;
    }

    /** ***Server Params Methods*** */

    /**
     * Retrieve server parameters.
     *
     * This method is used to fetch server parameters which may include details
     * such as server name, IP address, and other configurations. Understanding
     * the server environment is crucial for various functionalities like
     * logging, request handling, and more.
     *
     * Ensure that the server parameters are properly initialized before calling
     * this method to avoid inconsistencies in server-related operations.
     *
     * @return array Array containing server parameters.
     */
    public function getServerParams() : array
    {
        return $this->serverParams;
    }

    /**
     * Clone the instance with a new attribute.
     *
     * @param string $name  Name of the attribute to add or update.
     * @param mixed  $value Value to associate with the attribute name.
     *
     * @return static Cloned instance with the updated attribute.
     *
     * Intent: This method allows for immutability by cloning the current
     * instance and then modifying the clone, preserving the original instance.
     */
    public function withAttribute(string $name, mixed $value) : static
    {
        $clone                    = clone $this;
        $clone->attributes[$name] = $value;

        return $clone;
    }

    /**
     * Clone the instance without a specified attribute.
     *
     * The rationale behind cloning the instance is to adhere to the immutability principle, ensuring
     * the original instance remains unchanged and any modifications are reflected in a new instance.
     * This can be particularly useful in scenarios where objects need to be shared across different
     * parts of an application without the risk of unintended side-effects.
     *
     * @param string $name Attribute name to be removed from the cloned instance.
     *
     * @return static Cloned instance without the specified attribute.
     */
    public function withoutAttribute(string $name) : static
    {
        $clone = clone $this;
        unset($clone->attributes[$name]);

        return $clone;
    }

    /**
     * Retrieve the attributes for the current instance.
     *
     * @return array The set of attributes stored in the instance.
     */
    public function getAttributes() : array
    {
        return $this->attributes;
    }

    /**
     * Retrieve all query parameters as an associative array.
     *
     * @return array Associative array of all query parameters.
     */
    public function getQueryParams() : array
    {
        return $this->query->all();
    }

    /** ***Query and Request Parameter Methods*** */

    /**
     * Clone the instance with new query parameters.
     *
     * @param array $query New query parameters.
     *
     * @return static Cloned instance with updated query parameters.
     */
    public function withQueryParams(array $query) : static
    {
        $clone        = clone $this;
        $clone->query = new ParameterBag(parameters: $query);

        return $clone;
    }

    /**
     * Retrieve and parse the body of the HTTP request.
     *
     * This method leverages the framework's ability to retrieve all input data from the request.
     * It returns the parsed body content as an associative array.
     *
     * @return array Parsed contents of the HTTP request body.
     */
    public function getParsedBody() : array
    {
        return $this->request->all();
    }

    /**
     * Clone the instance with a new parsed body.
     *
     * @param mixed $data Parsed body data (must be an array).
     *
     * @return static Cloned instance with updated parsed body.
     */
    public function withParsedBody(mixed $data) : static
    {
        $clone          = clone $this;
        $clone->request = new ParameterBag(parameters: is_array($data) ? $data : []);

        return $clone;
    }

    /**
     * Retrieve all cookie parameters from the cookies store.
     *
     * @return array An associative array of all cookie parameters.
     */
    public function getCookieParams() : array
    {
        return $this->cookies->all();
    }

    /** ***Cookie Parameter Methods*** */

    /**
     * Clone the instance with new cookie parameters.
     *
     * @param array $cookies New cookie parameters.
     *
     * @return static Cloned instance with updated cookie parameters.
     */
    public function withCookieParams(array $cookies) : static
    {
        $clone          = clone $this;
        $clone->cookies = new ParameterBag(parameters: $cookies);

        return $clone;
    }

    /**
     * Retrieve the list of uploaded files.
     *
     * @return array The array of uploaded files.
     */
    public function getUploadedFiles() : array
    {
        return $this->uploadedFiles;
    }

    /** ***Uploaded Files Methods*** */

    /**
     * Clone the instance with new uploaded files.
     *
     * @param array $uploadedFiles Array of UploadedFileInterface instances.
     *
     * @return static Cloned instance with updated uploaded files.
     * @throws InvalidArgumentException If any file does not implement UploadedFileInterface.
     */
    public function withUploadedFiles(array $uploadedFiles) : static
    {
        foreach ($uploadedFiles as $uploadedFile) {
            if (! $uploadedFile instanceof UploadedFileInterface) {
                throw new InvalidArgumentException(message: 'Uploaded files must implement UploadedFileInterface');
            }
        }

        $clone                = clone $this;
        $clone->uploadedFiles = $uploadedFiles;

        return $clone;
    }

    /**
     * Retrieve the request target.
     *
     * Returns the request target, which is the path of the URI.
     * If the query string is present, it appends it to the path.
     *
     * @return string The request target.
     */
    public function getRequestTarget() : string
    {
        $target = $this->uri->getPath();
        $query  = $this->uri->getQuery();

        return $query !== '' && $query !== '0' ? $target . "?" . $query : $target;
    }

    /** ***Request Target Methods*** */

    /**
     * Clone the instance with a new request target.
     *
     * @param string $requestTarget New request target.
     *
     * @return static Cloned instance with updated request target.
     */
    public function withRequestTarget(string $requestTarget) : static
    {
        $clone      = clone $this;
        $clone->uri = $clone->uri->withPath(path: $requestTarget);

        return $clone;
    }

    /**
     * Retrieve the header line for a given header name.
     *
     * Combines all the header values for the specified name into a single string
     * separated by commas.
     *
     * @param string $name The name of the header.
     *
     * @return string The header line as a string.
     */
    public function getHeaderLine(string $name) : string
    {
        return implode(', ', $this->getHeader(name: $name));
    }

    /** ***Header Methods*** */

    /**
     * Retrieve the values of a specified header.
     *
     * Returns an array of values for the specified header name. If the header does
     * not exist, an empty array is returned.
     *
     * @param string $name The name of the header.
     *
     * @return array An array of header values.
     */
    public function getHeader(string $name) : array
    {
        return $this->headers[$name] ?? [];
    }

    /**
     * Clone the instance with a new header.
     *
     * @param string $name  Header name.
     * @param mixed  $value Header value.
     *
     * @return static Cloned instance with updated header.
     */
    public function withHeader(string $name, mixed $value) : static
    {
        $clone                 = clone $this;
        $clone->headers[$name] = (array) $value;

        return $clone;
    }

    /**
     * Clone the instance with an added header.
     *
     * @param string $name  Header name.
     * @param mixed  $value Header value to add.
     *
     * @return static Cloned instance with added header.
     */
    public function withAddedHeader(string $name, mixed $value) : static
    {
        $clone                 = clone $this;
        $clone->headers[$name] = array_merge($this->getHeader(name: $name), (array) $value);

        return $clone;
    }

    /**
     * Clone the instance without a specified header.
     *
     * @param string $name Header name to remove.
     *
     * @return static Cloned instance without the header.
     */
    public function withoutHeader(string $name) : static
    {
        $clone = clone $this;
        unset($clone->headers[$name]);

        return $clone;
    }

    /**
     * Retrieve all headers.
     *
     * Returns an associative array of all headers, where the key is the header name
     * and the value is an array of header values.
     *
     * @return array An associative array of all headers.
     */
    public function getHeaders() : array
    {
        return $this->headers;
    }

    /**
     * Clone the instance with a new body.
     *
     * @param StreamInterface $stream New body body.
     *
     * @return static Cloned instance with updated body.
     */
    public function withBody(StreamInterface $stream) : static
    {
        $clone       = clone $this;
        $clone->body = $stream;

        return $clone;
    }

    /** ***Body Methods*** */

    /**
     * Retrieve the body of the request.
     *
     * Returns the body of the request as a StreamInterface instance.
     *
     * @return StreamInterface The body of the request.
     */
    public function getBody() : StreamInterface
    {
        return $this->body;
    }

    /**
     * Clone the instance with a new HTTP method.
     *
     * @param string $method HTTP method.
     *
     * @return static Cloned instance with updated method.
     */
    public function withMethod(string $method) : static
    {
        $clone         = clone $this;
        $clone->method = $method;

        return $clone;
    }

    /** ***Method Methods*** */

    /**
     * Retrieve the HTTP method of the request.
     *
     * Returns the HTTP method used for the request (e.g., GET, POST).
     *
     * @return string The HTTP method as a string.
     */
    public function getMethod() : string
    {
        return $this->method;
    }

    /**
     * Retrieve the URI of the request.
     *
     * Returns the URI of the request as a UriInterface instance.
     *
     * @return UriInterface The URI of the request.
     */
    public function getUri() : UriInterface
    {
        return $this->uri;
    }

    /** ***URI Methods*** */

    /**
     * Clone the instance with a new URI.
     *
     * @param UriInterface $uri          New URI.
     * @param bool         $preserveHost Whether to preserve the host header.
     *
     * @return static Cloned instance with updated URI.
     */
    public function withUri(UriInterface $uri, bool $preserveHost = false) : static
    {
        $clone      = clone $this;
        $clone->uri = $uri;
        if (! $preserveHost || ! $this->hasHeader(name: 'Host')) {
            $clone->headers['Host'] = [$uri->getHost()];
        }

        return $clone;
    }

    /**
     * Check if a given header exists.
     *
     * Determines whether a specified header is present in the request.
     *
     * @param string $name The name of the header.
     *
     * @return bool True if the header exists, false otherwise.
     */
    public function hasHeader(string $name) : bool
    {
        return isset($this->headers[$name]);
    }

    /** ***Header Presence Check*** */

    /**
     * Retrieve the client IP address.
     *
     * @return string|null The client IP address or null if not found.
     */
    public function getClientIp() : string|null
    {
        $keys = [
            'HTTP_CLIENT_IP',
            'HTTP_X_FORWARDED_FOR',
            'HTTP_X_FORWARDED',
            'HTTP_X_CLUSTER_CLIENT_IP',
            'HTTP_FORWARDED_FOR',
            'HTTP_FORWARDED',
            'REMOTE_ADDR',
        ];

        foreach ($keys as $key) {
            if (! empty($this->serverParams[$key])) {
                $ipList = explode(',', (string) $this->serverParams[$key]);

                // Log ambiguous cases for debugging
                if (count($ipList) > 1) {
                    error_log(sprintf('Multiple IPs found in %s: %s', $key, implode(', ', $ipList)));
                }

                return trim(current($ipList));
            }
        }

        return null;
    }

    /**
     * Retrieve an attribute value by key, with an optional default.
     *
     * @param string $key     The key to look up in the attributes.
     * @param mixed  $default The default value to return if the key does not exist.
     *
     * @return mixed The value of the attribute or the default value.
     */
    public function route(string $key, mixed $default = null) : mixed
    {
        return $this->getAttribute($key, $default);
    }

    /**
     * Retrieve an attribute value by its name, or return a default value if the attribute is not found.
     *
     * The rationale for returning a default value is to provide a safe fallback mechanism, avoiding potential
     * null pointer exceptions or undefined index errors which might occur if the attribute does not exist.
     *
     * @param string $name    The name of the attribute to retrieve.
     * @param mixed  $default The default value to return if the attribute is not set. Defaults to null.
     *
     * @return mixed The value of the attribute if found, otherwise the default value.
     */
    public function getAttribute(string $name, mixed $default = null) : mixed
    {
        return $this->attributes[$name] ?? $default;
    }


}

=== HTTP/Request/ParameterBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Request;

use InvalidArgumentException;

/**
 * Class ParameterBag
 *
 * This class is designed to handle a collection of parameters.
 * It allows for adding, removing, and retrieving parameters with type safety.
 */
class ParameterBag
{
    /**
     * ParameterBag constructor.
     *
     * Initializes the parameter bag with an optional array of parameters.
     *
     * @param array $parameters An initial set of parameters.
     */
    public function __construct(private array $parameters = []) {}

    /**
     * Check if a parameter exists by key.
     *
     * @param string $key The key to check.
     *
     * @return bool True if the key exists, false otherwise.
     */
    public function has(string $key) : bool
    {
        return array_key_exists($key, $this->parameters);
    }

    /**
     * Get all parameters.
     *
     * @return array All parameters in the bag.
     */
    public function all() : array
    {
        return $this->parameters;
    }

    /**
     * Set a parameter by key.
     *
     * @param string $key   The key of the parameter.
     * @param mixed  $value The value to set.
     */
    public function set(string $key, mixed $value) : void
    {
        $this->parameters[$key] = $value;
    }

    /**
     * Remove a parameter by key.
     *
     * @param string $key The key of the parameter to remove.
     */
    public function remove(string $key) : void
    {
        unset($this->parameters[$key]);
    }

    /**
     * Retrieve a parameter as an array.
     *
     * @param string $key The key of the parameter.
     *
     * @return array The parameter value as an array, or an empty array if not present or not an array.
     */
    public function getAsArray(string $key) : array
    {
        return $this->getTyped(key: $key, type: 'array', default: []);
    }

    /**
     * Retrieve a parameter as a specific type.
     *
     * @param string $key     The key of the parameter.
     * @param string $type    The expected type ('string', 'int', 'bool', 'array', etc.).
     * @param mixed  $default Default value if key does not exist.
     *
     * @return mixed The parameter cast to the specified type, or default if not present.
     * @throws \InvalidArgumentException If the type is unsupported.
     */
    public function getTyped(string $key, string $type, mixed $default = null) : mixed
    {
        $value = $this->get(key: $key, default: $default);

        // Handle null and cast based on type
        if (is_null($value)) {
            return $default;
        }

        return match ($type) {
            'string' => (string) $value,
            'int'    => (int) $value,
            'float'  => (float) $value,
            'bool'   => filter_var($value, FILTER_VALIDATE_BOOL, FILTER_NULL_ON_FAILURE) ?? $default,
            'array'  => is_array($value) ? $value : (array) $value,
            default  => throw new InvalidArgumentException(message: sprintf("Unsupported type '%s'", $type)),
        };
    }

    /**
     * Retrieve a parameter by key with optional default value.
     *
     * @param string $key     The key of the parameter.
     * @param mixed  $default Optional default value if key does not exist.
     *
     * @return mixed The parameter value or the default value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->parameters[$key] ?? $default;
    }

    /**
     * Retrieve a parameter as a boolean.
     *
     * @param string $key     The key of the parameter.
     * @param bool   $default Default value if key does not exist.
     *
     * @return bool The parameter value as a boolean.
     */
    public function getAsBoolean(string $key, bool $default = false) : bool
    {
        return $this->getTyped(key: $key, type: 'bool', default: $default);
    }

    /**
     * Retrieve a parameter as an integer.
     *
     * @param string $key     The key of the parameter.
     * @param int    $default Default value if key does not exist.
     *
     * @return int The parameter value as an integer.
     */
    public function getAsInt(string $key, int $default = 0) : int
    {
        return $this->getTyped(key: $key, type: 'int', default: $default);
    }

    /**
     * Retrieve a parameter as a string.
     *
     * @param string $key     The key of the parameter.
     * @param string $default Default value if key does not exist.
     *
     * @return string The parameter value as a string.
     */
    public function getAsString(string $key, string $default = '') : string
    {
        return $this->getTyped(key: $key, type: 'string', default: $default);
    }
}

=== HTTP/Request/Request.php ===
<?php
/** @noinspection GlobalVariableUsageInspection */

declare(strict_types=1);

namespace Gemini\HTTP\Request;

use Gemini\HTTP\Request\Traits\InputManagementTrait;
use Gemini\HTTP\Request\Traits\JwtTrait;
use Gemini\HTTP\Request\Traits\SessionManagementTrait;
use Gemini\HTTP\Response\Classes\Stream;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\NullSession;
use Gemini\HTTP\URI\UriBuilder;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\UriInterface;
use RuntimeException;
use Throwable;

/**
 * Class Request
 *
 * This class extends `AbsoluteServerRequest` to handle HTTP requests and add custom functionality like session
 * management, input handling, and JWT integration.
 * It supports instantiation using global PHP variables, making it
 * suitable for working with web applications in a standardized way.
 *
 * - The class uses Laravel-style session access to simplify working with session.
 * - Provides utility for creating custom URIs from global variables ($_SERVER).
 * - Includes functionalities that can be extended via multiple reusable traits (InputManagementTrait, JwtTrait, etc.).
 *
 * The class enforces strict typing to align with modern PHP practices.
 */
class Request extends AbsoluteServerRequest implements ServerRequestInterface
{
    use InputManagementTrait;
    use SessionManagementTrait;
    use JwtTrait;

    /**
     * The session instance for the request, defaults to a NullSession if no session is provided.
     */
    protected SessionInterface $session;

    /**
     * Stores the files uploaded with the request.
     */
    protected ParameterBag $files;

    /**
     * Holds parsed JSON parameters for this request.
     */
    private ParameterBag $json;

    /**
     * Constructor to initialize the request with various parameters.
     *
     * @param SessionInterface|string|null $session       The session instance or its string equivalent, defaults to
     *                                                    NullSession.
     * @param array                        $serverParams  The server parameters, typically from $_SERVER.
     * @param UriInterface|string|null     $uri           The request URI, provided as a UriInterface or string.
     * @param Stream|string|null           $body          The body of the request as a stream or string.
     * @param array                        $queryParams   An array of query parameters, typically from $_GET.
     * @param array                        $parsedBody    Parsed request body, typically from POST data.
     * @param array                        $cookies       An array of cookies, typically from $_COOKIE.
     * @param array                        $uploadedFiles An array of uploaded files, typically from $_FILES.
     *
     * @return void
     */
    public function __construct(
        SessionInterface|string|null $session = null,
        array                        $serverParams = [],
        UriInterface|string|null     $uri = null,
        Stream|string|null           $body = null,
        array                        $queryParams = [],
        array                        $parsedBody = [],
        array                        $cookies = [],
        array                        $uploadedFiles = []
    ) {
        parent::__construct(
            server       : $serverParams,
            uri          : $uri,
            body         : $body,
            queryParams  : $queryParams,
            parsedBody   : $parsedBody,
            cookies      : $cookies,
            uploadedFiles: $uploadedFiles
        );

        // Default to NullSession to avoid null-checks for session management.
        $this->session = $session ?? new NullSession();


        // Wrap uploaded files into a ParameterBag for easier management and access.
        $this->files = new ParameterBag(parameters: $uploadedFiles);

        // Initialize an empty JSON ParameterBag for parsing and handling JSON bodies.
        $this->json = new ParameterBag(parameters: $this->parseJsonBody());
    }

    /**
     * Creates a Request instance from global PHP variables.
     *
     * This is especially useful for HTTP server handling where $_SERVER, $_GET, $_POST, $_COOKIE, etc.,
     * need to be converted into a request object.
     *
     * @throws RuntimeException If creation fails due to unexpected global data.
     */
    public static function createFromGlobals() : self
    {
        try {
            // Build the URI from the global variables ($_SERVER in this case).
            $uri = self::buildUriFromGlobals();

            return new self(
                session      : app(abstract: SessionInterface::class), // Retrieve session from the IoC container.
                serverParams : $_SERVER,
                uri          : $uri,
                body         : new Stream(stream: fopen('php://input', 'rb')),
                queryParams  : $_GET,
                parsedBody   : $_POST,
                cookies      : $_COOKIE,
                uploadedFiles: $_FILES
            );
        } catch (Throwable $throwable) {
            // Catch unexpected exceptions during construction and wrap them in a runtime exception.
            throw new RuntimeException(
                message: "Failed to create Request from globals.", code: 0, previous: $throwable
            );
        }
    }

    /**
     * Builds a URI from the global server data ($_SERVER).
     *
     * The resulting URI includes the scheme (HTTP/HTTPS), host, port (if non-standard), and path along
     * with the query string. The method ensures compatibility across different server configurations.
     *
     * @return UriInterface The constructed URI object.
     */
    protected static function buildUriFromGlobals() : UriInterface
    {
        // Determine the request scheme. Default to HTTP unless HTTPS is explicitly enabled in the server environment.
        $scheme = (! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https' : 'http';

        // Resolve the host using HTTP_HOST, SERVER_NAME, or a localhost fallback.
        $host = $_SERVER['HTTP_HOST'] ?? $_SERVER['SERVER_NAME'] ?? 'localhost';

        // Non-standard ports are appended to the base URI.
        $port = $_SERVER['SERVER_PORT'] ?? null;

        $baseUri = sprintf('%s://%s', $scheme, $host);
        if ($port && $port !== 80 && $port !== 443) {
            $baseUri .= ':' . $port;
        }

        // Parse the request URI path and query components.
        $path  = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?? '/';
        $query = $_SERVER['QUERY_STRING'] ?? '';

        // Construct and return a usable URI object.
        return UriBuilder::fromBaseUri(baseUri: $baseUri)
            ->withPath(path: $path)
            ->withQuery(query: $query);
    }

    /**
     * Returns the request URI path.
     *
     * Example: If the full URI is "https://example.com/path?query=1", this method will return "/path".
     */
    public function path() : string
    {
        return $this->getUri()->getPath();
    }

    /**
     * Provides Laravel-style access to session.
     *
     * This allows you to retrieve session data, or the session object itself when no key is provided.
     *
     * @param string|null $key     The key to retrieve from the session.
     * @param mixed       $default Default value if the key does not exist in the session.
     *
     * @return mixed The value associated with the key, or the session object itself if no key is provided.
     */
    public function session(string|null $key = null, mixed $default = null) : mixed
    {
        $this->ensureSession(); // Ensure session instance is valid.

        // Return entire session instance if no key is provided, otherwise fetch the requested key.
        return $key === null
            ? $this->session
            : $this->session->get(key: $key, default: $default);
    }

    /**
     * Ensures that a valid SessionInterface instance is available.
     *
     * This is mainly used as a fallback to lazily resolve the session from the dependency container
     * in case it hasn't been explicitly set during initialization.
     */
    protected function ensureSession() : void
    {
        if (! isset($this->session) || $this->session instanceof NullSession) {
            $this->session = app(abstract: SessionInterface::class);
        }
    }

    /**
     * Sets a new session instance explicitly.
     *
     * @param SessionInterface $session The session instance to set.
     */
    public function setSession(SessionInterface $session) : void
    {
        $this->session = $session;
    }

    /**
     * Checks if a given key exists in the session.
     */
    public function hasSession(string $key) : bool
    {
        return $this->session->has(key: $key);
    }

    /**
     * Writes a value to the session.
     */
    public function putSession(string $key, mixed $value) : void
    {
        $this->session->set(key: $key, value: $value);
    }

    /**
     * Removes a key from the session.
     */
    public function forgetSession(string $key) : void
    {
        $this->session->remove(key: $key);
    }

    /**
     * Retrieves the user information, either from the session or from another source if not available.
     *
     * @return mixed The user data retrieved.
     */
    public function user() : mixed
    {
        return $this->session->get('user'); // TODO: if not in session, then from JWT !!!
    }

}
=== HTTP/Request/Traits/InputManagementTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Request\Traits;

use Gemini\DataHandling\ArrayHandling\Arrhae;
use Gemini\HTTP\Request\ParameterBag;
use Gemini\HTTP\Request\Request;
use JsonException;
use RuntimeException;

/**
 * Trait InputManagementTrait
 *
 * Provides methods for managing and accessing different types of inputs in a request.
 */
trait InputManagementTrait
{
    /**
     * Builds a query to fetch user data. This query is designed to be reusable for various components
     * that require user information, ensuring consistency across different parts of the application.
     */
    protected ParameterBag $query;

    /**
     * Processes the incoming request and determines the appropriate action.
     *
     * This function handles the initial entry point for requests. It parses incoming data,
     * performs necessary authentication and validation, and routes to the corresponding
     * business logic handlers.
     *
     * @param Request $request The incoming request object containing all the request data.
     *
     *
     * Key considerations:
     *  - Ensure data is sanitized to prevent security vulnerabilities.
     *  - Authentication and validation need to be done before any business logic is processed.
     *  - Handle edge cases such as missing parameters or invalid data formats gracefully.
     */
    protected ParameterBag $request;

    /**
     * Manages handling and storing cookies with additional functionality beyond standard methods.
     * Provides utility functions to set, get, and delete cookies while ensuring certain business rules and constraints.
     */
    protected ParameterBag $cookies;

    /**
     * Class FileProcessor
     *
     * The main purpose of this class is to handle the processing of files.
     * This implementation assumes that the files are processed in batches,
     * and hence utilizes a batch size parameter to control the amount of
     * processing done at a time.
     */
    protected ParameterBag $files;

    /**
     * Class OrderProcessor
     *
     * This class handles the processing of orders. It validates the order data,
     * applies discounts, and updates the inventory. It's designed to be instantiated
     * with dependency injection for better testability and decoupling.
     */
    private ParameterBag $json;

    /**
     * Retrieve all inputs from various sources and merge them into a single array.
     *
     * @return array An array containing all inputs.
     */
    public function allInputs() : array
    {
        return array_merge(
            $this->query->all(),
            $this->request->all(),
            $this->cookies->all(),
            isset($this->files) ? $this->files->all() : [],
            isset($this->json) ? $this->json->all() : [],
        );
    }

    /**
     * Retrieve a query parameter by key with an optional default.
     *
     * @param string $key     The key of the query parameter.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the query parameter or default.
     */
    public function query(string $key, mixed $default = null) : mixed
    {
        return $this->query->get(key: $key, default: $default);
    }

    /**
     * Retrieve an input, prioritizing query parameters, then request parameters.
     *
     * @param string $key     The key of the input.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the input or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->input(key: $key, default: $default);
    }

    /**
     * Retrieve an input, prioritizing query parameters over request parameters.
     *
     * @param string $key     The key of the input.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the input or default.
     */
    public function input(string $key, mixed $default = null) : mixed
    {
        if ($this->query->has(key: $key)) {
            return $this->query->get(key: $key);
        }

        return $this->request->has(key: $key) ? $this->request->get(key: $key) : $default;
    }

    /**
     * Check if an input exists in either query or request parameters.
     *
     * @param string $key The key of the input.
     *
     * @return bool True if the input exists, false otherwise.
     */
    public function has(string $key) : bool
    {
        if ($this->query->has(key: $key)) {
            return true;
        }

        return (bool) $this->request->has(key: $key);
    }

    /**
     * Retrieve a cookie by key with an optional default.
     *
     * @param string $key     The key of the cookie.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the cookie or default.
     */
    public function cookie(string $key, mixed $default = null) : mixed
    {
        return $this->cookies->get(key: $key, default: $default);
    }

    /**
     * Retrieve a file by key with an optional default.
     *
     * @param string $key     The key of the file.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the file or default.
     */
    public function file(string $key, mixed $default = null) : mixed
    {
        return $this->files->get(key: $key, default: $default);
    }

    /**
     * Retrieve data from a JSON input.
     *
     * Decodes JSON content if not already done and retrieves the specified key,
     * or all JSON data if no key is specified.
     *
     * @param string|null $key     The key of the JSON data.
     * @param mixed       $default Optional default value.
     *
     * @return mixed The value of the JSON data or default.
     * @throws RuntimeException If JSON decoding fails.
     */
    public function json(string|null $key = null, mixed $default = null) : mixed
    {
        $content = $this->getContent();

        try {
            // Decode raw request content as JSON into array format
            $data = json_decode((string) ($content ?: '{}'), true, 512, JSON_THROW_ON_ERROR);
        } catch (JsonException $jsonException) {
            // Wrap JSON parsing failure in a descriptive runtime exception
            throw new RuntimeException(
                message : 'Failed to decode JSON: ' . $jsonException->getMessage(),
                code    : $jsonException->getCode(),
                previous: $jsonException
            );
        }

        // Wrap JSON array inside Arrhae for advanced dot-access
        $this->json = new ParameterBag((array) $data);
        $arrhae     = Arrhae::make($this->json->all());

        // Return an entire array if no key, or safely fetch nested value using Arrhae
        return is_null($key) ? $arrhae->all() : $arrhae->get($key, $default);
    }


    /**
     * Retrieve the raw content of the request body.
     *
     * @return string The request body content.
     */
    public function getContent() : string
    {
        $this->body->rewind();

        return $this->body->getContents();
    }

    /**
     * Merge additional data into query and/or request parameters.
     *
     * Allows for optional merging into query and/or request parameters with control
     * over whether to overwrite existing parameters.
     *
     * @param array     $data        The data to merge.
     * @param bool|null $intoQuery   Whether to merge into query parameters.
     * @param bool|null $intoRequest Whether to merge into request parameters.
     * @param bool      $overwrite   Whether to overwrite existing parameters.
     */
    public function merge(
        array     $data,
        bool|null $intoQuery = null,
        bool|null $intoRequest = null,
        bool      $overwrite = true,
    ) : void {
        $intoRequest ??= true;
        $intoQuery   ??= true;
        foreach ($data as $key => $value) {
            if ($intoQuery && ($overwrite || ! $this->query->has(key: $key))) {
                $this->query->set(key: $key, value: $value);
            }

            if ($intoRequest && ($overwrite || ! $this->request->has(key: $key))) {
                $this->request->set(key: $key, value: $value);
            }
        }
    }

    /**
     * Retrieve the bearer token from the 'Authorization' header, if available.
     *
     * This method checks for a Bearer token in the Authorization header:
     * - It calls `getHeaderLine('Authorization')` to retrieve the Authorization header as a single string.
     * - If the header starts with "Bearer ", the function extracts the token and returns it.
     * - If there is no Bearer token, it returns `null`.
     *
     * @return string|null The Bearer token string if present, or null if not found.
     */
    public function getBearerToken() : string|null
    {
        // Retrieve the Authorization header as a single line using getHeaderLine
        $authHeader = $this->getHeaderLine(name: 'Authorization');

        // Check if the header starts with "Bearer " and, if so, extract the token part
        if (str_starts_with((string) $authHeader, 'Bearer ')) {
            return substr((string) $authHeader, 7);
        }

        // Return null if no Bearer token is present in the Authorization header
        return null;
    }

    /**
     * Retrieve a single header line by its name.
     *
     * This method accesses the request headers to fetch a specific header line.
     * - If the header is found with multiple values, they are concatenated into a single comma-separated string.
     * - If the header does not exist, it returns an empty string.
     *
     * @param string $name The name of the header (case-insensitive).
     *
     * @return string The header value as a single string or an empty string if the header does not exist.
     */
    public function getHeaderLine(string $name) : string
    {
        // Use the request method to access headers, normalizing the header name to lowercase for consistency
        $header = $this->request(key: 'headers.' . strtolower($name));

        // If the header exists and contains multiple values, convert the array to a comma-separated string
        if ($header !== null) {
            return is_array($header) ? implode(', ', $header) : (string) $header;
        }

        // Return an empty string if the header is not found
        return '';
    }

    /**
     * Retrieve a parameter from any input bag.
     *
     * Iterates through all input bags until the parameter is found.
     *
     * @param string $key     The key of the input.
     * @param mixed  $default Optional default value.
     *
     * @return mixed The value of the input or default.
     */
    public function request(string $key, mixed $default = null) : mixed
    {
        foreach ($this->allBags() as $bag) {
            if ($bag->has($key)) {
                return $bag->get($key);
            }
        }

        return $default;
    }

    /**
     * Retrieve all input bags.
     *
     * @return array An array of all input bags.
     */
    public function allBags() : array
    {
        return [
            'query'   => $this->query,
            'request' => $this->request,
            'cookies' => $this->cookies,
            'files'   => $this->files,
        ];
    }

    private function parseJsonBody() : array
    {
        $contentType = $this->getHeaderLine('Content-Type');

        // Proverava da li je zahtev JSON
        if (str_contains($contentType, 'application/json')) {
            $rawBody = (string) $this->getBody();

            if (! empty($rawBody)) {
                $decoded = json_decode($rawBody, true);

                return is_array($decoded) ? $decoded : [];
            }
        }

        return [];
    }

}

=== HTTP/Request/Traits/JwtTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Request\Traits;

use Carbon\Carbon;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use RuntimeException;

/**
 * JwtTrait provides methods for handling JWT (JSON Web Token) generation and decoding.
 * The class that uses this trait must implement the `getHeaderLine` method.
 *
 * This trait handles:
 * - Setting up JWT secret and algorithm.
 * - Generating JWT with provided payload and expiration.
 * - Extracting JWT from HTTP Authorization header.
 * - Decoding the JWT to retrieve authenticated user details.
 */
trait JwtTrait
{
    /**
     * Prefix used for Authorization header.
     */
    private const string JWT_PREFIX = 'Bearer ';

    /**
     * Secret key used for encoding and decoding JWT.
     */
    private string $jwtSecret;

    /**
     * Algorithm used for encoding and decoding JWT. Defaults to 'HS256'.
     */
    private string $jwtAlgorithm = 'HS256';

    /**
     * Sets the JWT secret.
     *
     * @param string $secret The secret key for JWT.
     */
    public function setJwtSecret(string $secret) : void
    {
        $this->jwtSecret = $secret;
    }

    /**
     * Generates a JWT for a given payload and expiration time.
     *
     * The issued time (iat) and expiration time (exp) are added to the payload.
     *
     * @param array $payload    The data to be encoded in the JWT.
     * @param int   $expiration The expiration time of the token in seconds.
     *
     * @return string The generated JWT.
     */
    public function generateJwtToken(array $payload, int $expiration = 3600) : string
    {
        $issuedAt       = Carbon::now()->timestamp;
        $payload['iat'] = $issuedAt;
        $payload['exp'] = $issuedAt + $expiration;

        return JWT::encode(
            payload: $payload,
            key    : $this->jwtSecret,
            alg    : $this->jwtAlgorithm,
        );
    }

    /**
     * Retrieves and decodes JWT from the Authorization header to get the authenticated user.
     *
     * @return object|null Decoded JWT payload if token is valid, otherwise null.
     */
    public function getAuthenticatedUser() : object|null
    {
        $token = $this->extractBearerToken();

        return $token ? $this->decodeJwt(token: $token) : null;
    }

    /**
     * Extracts the Bearer token from the Authorization header.
     *
     * @return string|null The JWT if present, otherwise null.
     * @throws RuntimeException If the `getHeaderLine` method is not defined in the class using this trait.
     */
    private function extractBearerToken() : string|null
    {
        if (! $this->hasMethod(methodName: 'getHeaderLine')) {
            throw new RuntimeException(
                message: 'The getHeaderLine method must be defined in the class using JwtTrait.',
            );
        }

        $authHeader = $this->getHeaderLine(name: 'Authorization');

        // Ensure the Authorization header starts with "Bearer ".
        return str_starts_with((string) $authHeader, self::JWT_PREFIX) ?
            substr((string) $authHeader, strlen(self::JWT_PREFIX)) : null;
    }

    /**
     * Checks if a method exists in the calling class.
     *
     * @param string $methodName The name of the method to check for.
     *
     * @return bool True if the method exists, false otherwise.
     */
    private function hasMethod(string $methodName) : bool
    {
        return method_exists($this, $methodName);
    }

    /**
     * Decodes a JWT to its payload.
     *
     * @param string $token The JWT to decode.
     *
     * @return object|null The decoded payload if the JWT is valid, null otherwise.
     * @throws RuntimeException If the token is malformed or invalid.
     */
    public function decodeJwt(string $token) : object|null
    {
        return JWT::decode(
            jwt          : $token,
            keyOrKeyArray: $this->composeKey(),
        );
    }

    /**
     * Composes the key for decoding the JWT based on the secret and algorithm.
     *
     * @return Key The key used for JWT decoding.
     */
    private function composeKey() : Key
    {
        return new Key(
            keyMaterial: $this->jwtSecret,
            algorithm  : $this->jwtAlgorithm,
        );
    }
}

=== HTTP/Request/Traits/SessionManagementTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Request\Traits;

use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * Trait that provides session management capabilities.
 *
 * This trait assumes that a concrete implementation of SessionInterface
 * is provided and assigned to the $session property. This allows for
 * centralized session management within any class that uses this trait.
 */
trait SessionManagementTrait
{
    protected SessionInterface $session;

    /**
     * Returns the session instance.
     *
     * This method allows access to the underlying session object, which
     * might be required for more advanced operations beyond the provided
     * methods in this trait.
     */
    public function session() : SessionInterface
    {
        return $this->session;
    }

    /**
     * Retrieves a value from the session.
     *
     * Provides a default value if the key does not exist in the session.
     *
     * @param string $key     The session key to retrieve.
     * @param mixed  $default The default value to return if key doesn't exist (default: null).
     *
     * @return mixed The value stored in session or the default value.
     */
    public function getSessionValue(string $key, mixed $default = null) : mixed
    {
        return $this->session->has(key: $key) ? $this->session->get(key: $key) : $default;
    }

    /**
     * Sets a value in the session.
     *
     * This method assigns a given value to a specified session key.
     *
     * @param string $key   The session key where the value should be stored.
     * @param mixed  $value The value to store in session.
     */
    public function setSessionValue(string $key, mixed $value) : void
    {
        $this->session->set(key: $key, value: $value);
    }

    /**
     * Checks if a session key exists.
     *
     * This method returns true if the specified key is present in the session.
     *
     * @param string $key The session key to check for existence.
     *
     * @return bool True if the key exists in the session, false otherwise.
     */
    public function hasSessionValue(string $key) : bool
    {
        return $this->session->has(key: $key);
    }

    /**
     * Retrieves a flashed value from the session.
     *
     * Flash data is meant for short-lived session data, commonly used for
     * notifications that only need to survive for the next request.
     *
     * @param string $key     The session key for the flash value.
     * @param mixed  $default The default value to return if key doesn't exist (default: null).
     *
     * @return mixed The flashed value or the default value.
     */
    public function getFlash(string $key, mixed $default = null) : mixed
    {
        return $this->session->getFlash(key: $key) ?? $default;
    }

    /**
     * Retrieves the current user from the session.
     *
     * This method assumes that user data is stored under the 'user' key.
     * Useful for accessing currently authenticated user information.
     *
     * @return mixed The user object or data stored in session, or `null` if not set.
     */
    public function user() : mixed
    {
        return $this->session->get(key: 'user');
    }

    /**
     * Stores the current user in the session.
     *
     * This method assigns a user object or data to the 'user' key in the session.
     *
     * @param mixed $user The user object or data to store.
     */
    public function setUser(mixed $user) : void
    {
        $this->session->set(key: 'user', value: $user);
    }
}

=== HTTP/Response/Classes/Response.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response\Classes;

use InvalidArgumentException;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;
use RuntimeException;
use SimpleXMLElement;

/**
 * This class represents an HTTP response, implementing the PSR-7 ResponseInterface.
 * It can handle standard HTTP statuses, protocol versions, and content types.
 */
class Response implements ResponseInterface
{
    /**
     * Default status code - OK
     */
    private const int DEFAULT_STATUS_CODE = 200;

    /**
     * @constant {str} DEFAULT_PROTOCOL_VERSION
     * @default '1.1'
     *
     * The default protocol version used throughout the application. This is based on the assumption that most clients
     * and servers support HTTP 1.1, which balances modern usage and legacy compatibility.
     */
    private const string DEFAULT_PROTOCOL_VERSION = '1.1';

    /**
     * Commonly used HTTP status phrases.
     */
    private const array STATUS_PHRASES = [
        200 => 'OK',
        201 => 'Created',
        204 => 'No Content',
        400 => 'Bad Request',
        401 => 'Unauthorized',
        403 => 'Forbidden',
        404 => 'Not Found',
        500 => 'Internal Server Error',
        503 => 'Service Unavailable',
    ];

    /**
     * Class responsible for handling HTTP requests and responses.
     * This class encapsulates the details of creating, sending, and processing HTTP responses, ensuring that all
     * necessary details are managed consistently.
     */
    private int $statusCode;

    /**
     * Returns the reason phrase for the given HTTP status code.
     * This provides a human-readable explanation or description of the status code.
     */
    private string|null $reasonPhrase;

    /**
     * The protocol version used in HTTP communication.
     *
     * Example values could be 'HTTP/1.1' or 'HTTP/2', providing the required specificity
     * for network operations that depend on protocol differences.
     *
     * Notice: Changing this value might affect compatibility with certain servers
     * or clients, depending on the protocol compliance requirements.
     */
    private string $protocolVersion;

    /**
     * Headers to be sent with the HTTP response.
     *
     * These headers may include content-type, caching policies, or any custom
     * headers required by the business logic or standards compliance.
     * Always ensure headers are set before output is sent to the client to avoid
     * any runtime errors or unexpected behavior.
     */
    private array $headers;

    /**
     * Initializes the response with the given stream, protocol version, status code, headers, and reason phrase.
     * Reason phrase defaults to standard phrases based on the status code.
     */
    public function __construct(
        /**
         * Stream class responsible for handling and manipulating data streams.
         * This class provides methods to read and write streams, as well as manage stream state and contents.
         */
        private StreamInterface $stream,
        string|null             $protocolVersion = null,
        int|null                $statusCode = null,
        array|null              $headers = null,
        string                  $reasonPhrase = '',
    ) {
        // Default values are provided when specific values are not given.
        $this->statusCode      = $statusCode ?? self::DEFAULT_STATUS_CODE;
        $this->protocolVersion = $protocolVersion ?? self::DEFAULT_PROTOCOL_VERSION;
        $this->headers         = $this->normalizeHeaders(headers: $headers ?? []);
        $this->reasonPhrase    = $reasonPhrase !== ''
            ? $reasonPhrase
            : $this->getDefaultReasonPhrase(statusCode: $this->statusCode);
    }

    /**
     * Converts header names to lowercase and ensures all header values are arrays.
     * This normalization helps in case-insensitive lookups and consistent internal data handling.
     *
     * @param array $headers An associative array of headers where the key is the header name and the value is the
     *                       header value.
     *
     * @return array An associative array with header names in lowercase and values as arrays.
     */
    private function normalizeHeaders(array $headers) : array
    {
        $normalized = [];
        foreach ($headers as $name => $value) {
            $normalized[strtolower($name)] = (array) $value;
        }

        return $normalized;
    }

    /**
     * Retrieves the default reason phrase for a given status code.
     *
     * @param int $statusCode HTTP status code for which the reason phrase is required.
     *
     * @return string The default reason phrase corresponding to the provided status code.
     *
     * The method looks up the status code in a constant array of status phrases.
     * If the status code is not found, an empty string is returned.
     * This design ensures that even an unknown or unsupported status code won't cause an exception or error.
     */
    private function getDefaultReasonPhrase(int $statusCode) : string
    {
        return self::STATUS_PHRASES[$statusCode] ?? '';
    }

    /**
     * Retrieves the status code.
     *
     * @return int The HTTP status code.
     *
     * This method is part of a broader class responsible for handling HTTP responses.
     * The status code is crucial for determining the outcome of client-server interactions.
     *
     * Note: Ensure the $statusCode property adheres to correct HTTP status code standards (e.g., 200 for OK, 404 for
     * Not Found).
     */
    public function getStatusCode() : int
    {
        return $this->statusCode;
    }

    /**
     * Returns a new instance with the specified status code and reason phrase.
     *
     * @param int    $code         The HTTP status code. Must be between 100 and 599 inclusive.
     * @param string $reasonPhrase An optional reason phrase. If not provided, a default reason phrase will be used.
     *
     * @return ResponseInterface A new response instance with the specified status code and reason phrase.
     *
     * @throws InvalidArgumentException if the status code is not between 100 and 599.
     */
    public function withStatus(int $code, string $reasonPhrase = '') : ResponseInterface
    {
//        if ($code < 100 || $code >= 600) {
//            throw new InvalidArgumentException(message: 'Invalid status code.');
//        }

        $new               = clone $this;
        $new->statusCode   = $code;
        $new->reasonPhrase = $reasonPhrase !== ''
            ? $reasonPhrase
            : $this->getDefaultReasonPhrase(
                statusCode: $code,
            );

        return $new;
    }

    /**
     * Retrieves the reason phrase associated with the response status code.
     *
     * @return string The reason phrase, which offers a short textual description of the status code.
     */
    public function getReasonPhrase() : string
    {
        return $this->reasonPhrase;
    }

    /**
     * Retrieves the protocol version used by this instance.
     *
     * @return string The protocol version as a string.
     */
    public function getProtocolVersion() : string
    {
        return $this->protocolVersion;
    }

    /**
     * Returns a new instance with the specified HTTP protocol version.
     *
     * @param string $version The HTTP protocol version to set, e.g., '1.1', '2.0'.
     *                        Ensure the version is valid and supported by your application.
     *
     * @return ResponseInterface A new instance with the updated protocol version.
     */
    public function withProtocolVersion(string $version) : ResponseInterface
    {
        $new                  = clone $this;
        $new->protocolVersion = $version;

        return $new;
    }

    /**
     * Retrieves the headers associated with the current request or response.
     *
     * @return array An associative array of headers.
     *
     * While this method is straightforward, it is part of the broader design pattern
     * where headers are managed as an associative array. This allows for a flexible
     * and extensible way to handle HTTP headers, adhering to common practices in
     * HTTP request/response handling.
     */
    public function getHeaders() : array
    {
        return $this->headers;
    }

    /**
     * Check if the specified header exists in the request.
     *
     * @param string $name         The name of the header to check.
     *                             The method converts the header name to lowercase to ensure case-insensitive matching.
     *                             HTTP header names are case-insensitive by specification (RFC 2616), so it's important
     *                             to normalize the case to maintain consistency.
     *
     * @return bool Returns true if the header exists, false otherwise.
     */
    public function hasHeader(string $name) : bool
    {
        return array_key_exists(strtolower($name), $this->headers);
    }

    /**
     * Retrieves a single header line by name.
     *
     * This method concatenates multiple header values into a single comma-separated string.
     * This is particularly useful for headers that can have multiple values, like 'Set-Cookie' or 'Content-Type'.
     *
     * @param string $name The name of the header to retrieve.
     *
     * @return string The header values concatenated into a single string.
     */
    public function getHeaderLine(string $name) : string
    {
        return implode(',', $this->getHeader(name: $name));
    }

    /**
     * Retrieves the specified header from the headers array.
     *
     * @param string $name The name of the header to retrieve.
     *
     * @return array The header values associated with the specified name.
     *               Returns an empty array if the header is not set.
     *
     * The method ensures case-insensitive retrieval by converting the header
     * name to lowercase. This approach harmonizes with common HTTP standards
     * where header names are case-insensitive.
     */
    public function getHeader(string $name) : array
    {
        return $this->headers[strtolower($name)] ?? [];
    }

    /**
     * Returns a new instance with an added header, preserving the existing ones.
     */
    public function withAddedHeader(string $name, mixed $value) : ResponseInterface
    {
        $new                       = clone $this;
        $normalized                = strtolower($name);
        $new->headers[$normalized] = array_merge($this->headers[$normalized] ?? [], (array) $value);

        return $new;
    }

    /**
     * Returns a new instance with the specified headers added.
     *
     * This method is designed to ensure immutability by cloning the current
     * instance and applying the headers to the new instance.
     *
     * @param array $headers An associative array of headers where the key is the
     *                       header name and the value is the header value.
     *
     * @return self A new instance with the specified headers.
     */
    public function withHeaders(array $headers) : self
    {
        $new = clone $this;
        foreach ($headers as $name => $value) {
            $new = $new->withHeader(name: $name, value: $value);
        }

        return $new;
    }

    /**
     * Returns a new instance with the specified header, replacing the existing one if present.
     */
    public function withHeader(string $name, mixed $value) : ResponseInterface
    {
        $new                             = clone $this;
        $new->headers[strtolower($name)] = (array) $value;

        return $new;
    }

    /**
     * Returns a new instance without the specified header.
     */
    public function withoutHeader(string $name) : ResponseInterface
    {
        $new = clone $this;
        unset($new->headers[strtolower($name)]);

        return $new;
    }

    public function getBody() : StreamInterface
    {
        return $this->stream;
    }

    /**
     * Returns a new instance with the specified body stream.
     */
    public function withBody(StreamInterface $stream) : ResponseInterface
    {
        $new         = clone $this;
        $new->stream = $stream;

        return $new;
    }

    /**
     * Returns a new instance with JSON-encoded body data.
     *
     * @throws RuntimeException if JSON encoding fails.
     */
    public function withJson(array $data) : ResponseInterface
    {
        $new  = clone $this;
        $json = json_encode($data);
        if ($json === false) {
            throw new RuntimeException(message: 'Failed to encode JSON data: ' . json_last_error_msg());
        }

        $stream = fopen('php://temp', 'r+');
        fwrite($stream, $json);
        fseek($stream, 0);
        $new->stream                  = new \GuzzleHttp\Psr7\Stream(stream: $stream);
        $new->headers['content-type'] = ['application/json'];

        return $new;
    }

    /**
     * Returns a new instance with XML-encoded body data.
     * This method uses SimpleXMLElement to convert an array to XML.
     */
    public function withXml(array $data) : ResponseInterface
    {
        $new = clone $this;
        $xml = new SimpleXMLElement(data: '<response/>');
        array_walk_recursive($data, function ($value, $key) use ($xml) : void {
            $xml->addChild(qualifiedName: $key, value: (string) $value);
        });
        $stream = fopen('php://temp', 'r+');
        fwrite($stream, $xml->asXML());
        fseek($stream, 0);
        $new->stream                  = new Stream(stream: $stream);
        $new->headers['content-type'] = ['application/xml'];

        return $new;
    }

    /**
     * Sends the HTTP response to the client.
     *
     * This method sets the HTTP status code and headers (if they have not
     * already been sent) and then outputs the response body to the client.
     *
     * @return $this
     */
    public function send() : self
    {
        // Set the HTTP status code and headers if they haven't been sent already
        if (! headers_sent()) {
            http_response_code($this->statusCode);

            foreach ($this->headers as $name => $values) {
                foreach ($values as $value) {
                    // Appends each header line, handling multiple values
                    header(sprintf('%s: %s', $name, $value), false);
                }
            }
        }

        // Output the response body to the client
        echo $this->stream->getContents();

        return $this;
    }
}

=== HTTP/Response/Classes/StreamFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response\Classes;

use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\StreamInterface;
use RuntimeException;

/**
 * Class StreamFactory
 *
 * Provides a factory for creating StreamInterface objects from various sources,
 * including strings, files, and resources.
 */
class StreamFactory implements StreamFactoryInterface
{
    /**
     * Defines the maximum allowed memory usage for the application.
     *
     * The value is set to 8KB, which balances sufficient memory allocation
     * with the need to prevent potential memory hogging or runaway processes.
     */
    private const int|float MEMORY_LIMIT = 1024 * 8; // 8KB

    /**
     * Creates a stream from a string, using `php://memory` for small data and `php://temp` for larger data.
     *
     * @param string $content Content to write to the stream.
     *
     * @throws RuntimeException
     */
    public function createStream(string $content = '') : StreamInterface
    {
        $resource = strlen($content) <= self::MEMORY_LIMIT ? 'php://memory' : 'php://temp';
        $stream   = fopen($resource, 'r+');

        if ($stream === false) {
            throw new RuntimeException(message: 'Failed to open stream resource: ' . $resource);
        }

        fwrite($stream, $content);
        rewind($stream);

        return new Stream(stream: $stream);
    }

    /**
     * Creates a new stream from a file.
     *
     * @param string $filename The file to read.
     * @param string $mode     The mode in which to open the file (e.g., 'r', 'w').
     *
     * @return StreamInterface New stream with the file content.
     */
    public function createStreamFromFile(string $filename, string $mode = 'r') : StreamInterface
    {
        $stream = fopen($filename, $mode);
        if ($stream === false) {
            throw new RuntimeException(message: 'Failed to open file: ' . $filename);
        }

        return new Stream(stream: $stream);
    }

    /**
     * Creates a stream from an existing resource.
     *
     * @param resource $resource PHP resource to use as the stream.
     *
     * @return StreamInterface New stream using the given resource.
     */
    public function createStreamFromResource($resource) : StreamInterface
    {
        if (! is_resource($resource)) {
            throw new RuntimeException(message: 'Invalid resource provided for stream creation.');
        }

        return new Stream(stream: $resource);
    }
}

=== HTTP/Response/Classes/StreamNotReadableException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response\Classes;

use RuntimeException;

/**
 * Exception thrown when a stream is not readable.
 *
 * Extends RuntimeException to indicate an unexpected error occurred
 * due to a non-readable stream within the Gemini HTTP response process.
 */
class StreamNotReadableException extends RuntimeException
{
    /**
     * Constructs a new StreamNotReadableException with a specific message.
     *
     * @param string $message Descriptive message explaining why the stream is not readable.
     */
    public function __construct(string $message)
    {
        // Pass the message to the RuntimeException constructor.
        parent::__construct(message: $message);
    }
}

=== HTTP/Response/Classes/Stream.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response\Classes;

use Psr\Http\Message\StreamInterface;
use RuntimeException;
use Throwable;

/**
 * PSR-7 Compliant Stream Implementation.
 *
 * Provides a stream of data, supporting readable, writable, and seekable operations.
 *
 * This class is designed to wrap a PHP stream resource and make it fully compatible
 * with PSR-7 StreamInterface, enabling interaction with HTTP messages.
 */
class Stream implements StreamInterface
{
    /** @var resource A PHP stream resource */
    private $stream;

    /** @var bool Whether the stream is readable */
    private bool $readable;

    /** @var bool Whether the stream is writable */
    private bool $writable;

    /** @var bool Whether the stream is seekable */
    private bool $seekable;

    /** @var int|null Cached size of the stream, if known */
    private int|null $size = null;

    /**
     * Stream constructor.
     *
     * @param resource $stream A valid PHP stream resource.
     *
     * Ensure that the provided stream is a valid resource and initialize its metadata.
     */
    public function __construct($stream)
    {
        $this->ensureIsResource(stream: $stream);
        $this->stream = $stream;
        $this->initializeStreamMetadata();
    }

    /**
     * Ensure the provided argument is a valid resource.
     *
     * @param mixed $stream The potential resource to validate.
     *
     * @throws RuntimeException If the argument is not a resource.
     */
    private function ensureIsResource(mixed $stream) : void
    {
        if (! is_resource($stream)) {
            throw new RuntimeException(message: 'Stream must be a valid resource.');
        }
    }

    /**
     * Initialize stream metadata.
     *
     * Set the readability, writability, and seekability of the stream based on its metadata.
     */
    private function initializeStreamMetadata() : void
    {
        $meta           = stream_get_meta_data($this->stream);
        $this->seekable = $meta['seekable'] ?? false;
        $mode           = str_split($meta['mode']);
        $this->readable = in_array('r', $mode) || in_array('+', $mode);
        $this->writable = in_array('w', $mode) || in_array('a', $mode) || in_array('+', $mode);
    }

    /**
     * Create a Stream instance from a string.
     *
     * @param string $content The content to be written into the stream.
     *
     *
     * @throws RuntimeException If the temporary stream cannot be opened.
     */
    public static function fromString(string $content) : self
    {
        $stream = fopen('php://temp', 'r+');
        if ($stream === false) {
            throw new RuntimeException(message: 'Failed to open temporary stream.');
        }

        fwrite($stream, $content);
        rewind($stream);

        return new self(stream: $stream);
    }

    /**
     * Close the stream.
     *
     * Close the stream resource and reset the metadata properties.
     */
    public function close() : void
    {
        if (is_resource($this->stream)) {
            fclose($this->stream);
        }

        $this->stream   = null;
        $this->readable = false;
        $this->writable = false;
        $this->seekable = false;
    }

    /**
     * Detach the underlying stream resource.
     *
     * @return resource|null The detached stream resource, or null if none is available.
     */
    public function detach()
    {
        $stream       = $this->stream;
        $this->stream = null;

        $this->readable = false;
        $this->writable = false;
        $this->seekable = false;

        return $stream;
    }

    /**
     * Get the size of the stream, if known.
     *
     * @return int|null The size in bytes or null if unknown.
     */
    public function getSize() : int|null
    {
        if ($this->size !== null) {
            return $this->size;
        }

        if (! $this->stream) {
            return null;
        }

        $stats = fstat($this->stream);

        return $stats['size'] ?? null;
    }

    /**
     * Get the current position of the stream.
     *
     * @return int The current position of the stream.
     *
     * @throws RuntimeException If the position cannot be determined.
     */
    public function tell() : int
    {
        $this->ensureStreamIsOpen();
        $position = ftell($this->stream);
        if ($position === false) {
            throw new RuntimeException(message: 'Unable to determine the position of the stream.');
        }

        return $position;
    }

    /**
     * Ensure the stream is open.
     *
     * @throws RuntimeException If the stream is not open.
     */
    private function ensureStreamIsOpen() : void
    {
        if (! $this->stream) {
            throw new RuntimeException(message: 'Stream is not open.');
        }
    }

    /**
     * Check if the stream is at end-of-file.
     *
     * @return bool True if at end-of-file, false otherwise.
     */
    public function eof() : bool
    {
        return ! $this->stream || feof($this->stream);
    }

    /**
     * Write data to the stream.
     *
     * @param string $string The data to write.
     *
     * @return int The number of bytes written.
     *
     * @throws RuntimeException If the stream is not writable or the write fails.
     */
    public function write(string $string) : int
    {
        if (! $this->isWritable()) {
            throw new RuntimeException(message: 'Stream is not writable.');
        }

        $result = fwrite($this->stream, $string);
        if ($result === false) {
            throw new RuntimeException(message: 'Failed to write to the stream.');
        }

        $this->size = null;

        return $result;
    }

    /**
     * Check if the stream is writable.
     *
     * @return bool True if the stream is writable, false otherwise.
     */
    public function isWritable() : bool
    {
        return $this->writable;
    }

    /**
     * Read data from the stream.
     *
     * @param int $length The maximum number of bytes to read.
     *
     * @return string The data read from the stream.
     *
     * @throws RuntimeException If the stream is not readable or the read fails.
     */
    public function read(int $length) : string
    {
        $this->ensureStreamIsOpen();

        if (! $this->isReadable()) {
            throw new StreamNotReadableException(message: "Attempted to read from a non-readable stream.");
        }

        $result = fread($this->stream, $length);
        if ($result === false) {
            throw new RuntimeException(message: "Failed to read from the stream.");
        }

        return $result;
    }

    /**
     * Check if the stream is readable.
     *
     * @return bool True if the stream is readable, false otherwise.
     */
    public function isReadable() : bool
    {
        return $this->readable;
    }

    /**
     * Retrieve the stream metadata.
     *
     * @param string|null $key Optional metadata key to retrieve.
     *
     * @return mixed The metadata value if $key is specified, or an associative array if $key is null.
     */
    public function getMetadata(string|null $key = null) : mixed
    {
        if (! $this->stream) {
            return $key !== null && $key !== '' && $key !== '0' ? null : [];
        }

        $meta = stream_get_meta_data($this->stream);

        return $key === null ? $meta : ($meta[$key] ?? null);
    }

    /**
     * Convert the stream to a string.
     *
     * @return string The entire content of the stream, or an empty string on error.
     */
    public function __toString() : string
    {
        if (! $this->stream) {
            return '';
        }

        try {
            if ($this->isSeekable()) {
                $this->rewind();
            }

            return $this->getContents();
        } catch (Throwable $throwable) {
            throw new RuntimeException(
                message : 'Unable to read the stream.',
                code    : $throwable->getCode(),
                previous: $throwable,
            );
        }
    }

    /**
     * Check if the stream is seekable.
     *
     * @return bool True if the stream is seekable, false otherwise.
     */
    public function isSeekable() : bool
    {
        return $this->seekable;
    }

    /**
     * Rewind the stream to the beginning.
     */
    public function rewind() : void
    {
        $this->seek(offset: 0);
    }

    /**
     * Seek to a position within the stream.
     *
     * @param int $offset The stream offset to seek to.
     * @param int $whence The seek method (SEEK_SET, SEEK_CUR, SEEK_END).
     *
     * @throws RuntimeException If the stream is not seekable or the seek operation fails.
     */
    public function seek(int $offset, int $whence = SEEK_SET) : void
    {
        if (! $this->isSeekable()) {
            throw new RuntimeException(message: 'Stream is not seekable.');
        }

        if (fseek($this->stream, $offset, $whence) === -1) {
            throw new RuntimeException(message: 'Failed to seek within the stream.');
        }
    }

    /**
     * Get the remaining contents of the stream.
     *
     * @return string The remaining contents of the stream.
     *
     * @throws RuntimeException If the stream is not readable or the read fails.
     */
    public function getContents() : string
    {
        if (! $this->isReadable()) {
            throw new RuntimeException(message: 'Stream is not readable.');
        }

        $contents = stream_get_contents($this->stream);
        if ($contents === false) {
            throw new RuntimeException(message: 'Failed to get contents of the stream.');
        }

        return $contents;
    }
}

=== HTTP/Response/Helper/XmlFormatter.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response\Helper;

use SimpleXMLElement;

/**
 * XmlFormatter
 *
 * A utility class designed to convert PHP arrays into XML format strings.
 * This can be particularly useful for creating XML responses in an HTTP context.
 */
class XmlFormatter
{
    /**
     * Converts an array to XML format, returning the XML content as a string.
     *
     * @param array  $data     The data to be converted to XML.
     * @param string $rootNode Root node for the XML (default is 'response').
     *
     * @return string XML string representation of the array.
     * @throws \Exception
     */
    public static function format(array $data, string $rootNode = 'response') : string
    {
        // Initialize a new SimpleXMLElement with the specified root node
        $xml = new SimpleXMLElement(data: sprintf('<%s/>', $rootNode));

        // Recursively converts the array into XML elements
        self::arrayToXml(data: $data, xml: $xml);

        // Return XML string, use empty string if conversion fails asXML returns false on failure
        return $xml->asXML() ?: '';
    }

    /**
     * Recursively adds data to the XML object.
     *
     * @param array            $data Data to convert to XML.
     * @param SimpleXMLElement $xml  XML object to append data to.
     */
    private static function arrayToXml(array $data, SimpleXMLElement $xml) : void
    {
        foreach ($data as $key => $value) {
            // Handle numeric keys to ensure valid XML element names
            $key = is_numeric($key) ? 'item' . $key : htmlspecialchars($key);

            if (is_array($value)) {
                // Recurse if value is an array, creating a new child element
                $child = $xml->addChild(qualifiedName: $key);
                self::arrayToXml(data: $value, xml: $child);
            } else {
                // Add simple text node, escaping any HTML entities
                $xml->addChild(qualifiedName: $key, value: htmlspecialchars((string) $value));
            }
        }
    }
}

=== HTTP/Response/JsonResponse.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response;

use JsonException;
use Psr\Http\Message\ResponseInterface;

/**
 * Utility for creating standardized JSON HTTP responses.
 */
readonly class JsonResponse
{
    private const array DEFAULT_HEADERS = ['Content-Type' => 'application/json'];

    public function __construct(
        public int    $status,
        public string $message = '',
        public array  $data = [],
        public array  $headers = self::DEFAULT_HEADERS,
    ) {}

    /**
     * Creates a success response.
     */
    public static function success(string|null $message = null, array $data = []) : self
    {
        return new self(
            status : 200,
            message: $message ?? 'Success',
            data   : $data
        );
    }

    /**
     * Creates an error response.
     */
    public static function error(string|null $message = null, int $status = 500) : self
    {
        return new self(
            status : $status,
            message: $message ?? 'An error occurred'
        );
    }

    /**
     * Creates a failure response (business logic failure).
     */
    public static function failure(string|null $message = null, array $data = []) : self
    {
        return new self(
            status : 400,
            message: $message ?? 'Operation failed',
            data   : $data
        );
    }

    /**
     * Converts response to a PSR-7 compatible JSON response.
     *
     * @throws JsonException
     */
    public function toResponse() : ResponseInterface
    {
        $response = app(abstract: ResponseFactory::class)->createResponse($this->status);

        foreach ($this->headers as $header => $value) {
            $response = $response->withHeader($header, $value);
        }

        $response->getBody()->write($this->toJson());

        return $response;
    }

    /**
     * Converts response data to JSON string.
     *
     * @throws JsonException
     */
    public function toJson() : string
    {
        return json_encode($this->toArray(), JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE);
    }

    /**
     * Converts response data to an array.
     */
    public function toArray() : array
    {
        return [
            'status'  => $this->status,
            'message' => $this->message,
            'data'    => $this->data,
        ];
    }
}

=== HTTP/Response/ResponseFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Response;

use InvalidArgumentException;
use JsonException;
use Psr\Http\Message\ResponseFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;

/**
 * Factory for creating standardized PSR-7 HTTP responses.
 */
readonly class ResponseFactory implements ResponseFactoryInterface
{
    public function __construct(
        private StreamFactoryInterface $streamFactory,
        private ResponseInterface      $response
    ) {}

    /**
     * Generates and returns an HTTP Response object based on the provided data and status code.
     *
     * This method delegates to the `send` method to decide the appropriate response format (JSON, plain text, etc.)
     * based on the type of `$data`. It provides a flexible mechanism to handle various types of responses, keeping the
     * controller concise and focused on defining only high-level response creation.
     *
     * @param mixed $data   The data to be sent in the response. Supports different types such as arrays, objects,
     *                      plain strings, or already-prepared `ResponseInterface` instances.
     * @param int   $status The HTTP status code to be associated with the response. Defaults to 200 (OK).
     *
     * @return ResponseInterface Returns a fully constructed HTTP response object.
     */
    public function response(mixed $data, int $status = 200) : ResponseInterface
    {
        // Delegate the task of creating a response object to the `send` method.
        // The `send` method handles different data types accordingly (e.g., JSON encoding, plain string content, etc.).
        return $this->send(data: $data, status: $status);
    }

    /**
     * Generates a response based on data type.
     */
    public function send(mixed $data, int $status = 200) : ResponseInterface
    {
        return match (true) {
            $data instanceof ResponseInterface  => $data,
            is_array($data) || is_object($data) => $this->createJsonResponse(data: (array) $data, status: $status),
            is_string($data)                    => $this->createTextResponse(content: $data, status: $status),
            default                             => $this->createResponseWithBody(
                content: (string) ($data ?? ''),
                status : $status
            ),
        };
    }

    /**
     * Creates a JSON response with proper encoding.
     */
    public function createJsonResponse(array $data, int $status = 200) : ResponseInterface
    {
        try {
            $json = json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE);
        } catch (JsonException $jsonException) {
            return $this->createErrorResponse(message: "JSON encoding failed: " . $jsonException->getMessage());
        }

        $stream = $this->streamFactory->createStream(content: $json);

        return $this
            ->cloneResponse()
            ->withStatus(code: $status)
            ->withBody(stream: $stream)
            ->withHeader(name: 'Content-Type', value: 'application/json');
    }

    /**
     * Creates an error response.
     */
    private function createErrorResponse(string $message) : ResponseInterface
    {
        return $this->createJsonResponse(data: ['error' => $message], status: 500);
    }

    /**
     * Clones the base response to ensure immutability.
     */
    private function cloneResponse() : ResponseInterface
    {
        return clone $this->response;
    }

    /**
     * Creates a plain text response.
     */
    public function createTextResponse(string $content, int $status = 200) : ResponseInterface
    {
        $stream = $this->streamFactory->createStream(content: $content);

        return $this
            ->cloneResponse()
            ->withStatus(code: $status)
            ->withBody(stream: $stream)
            ->withHeader(name: 'Content-Type', value: 'text/plain');
    }

    /**
     * Creates a generic response with body content.
     */
    public function createResponseWithBody(string $content, int $status, array $headers = []) : ResponseInterface
    {
        $stream   = $this->streamFactory->createStream(content: $content);
        $response = $this
            ->cloneResponse()
            ->withStatus(code: $status)
            ->withBody(stream: $stream);

        foreach ($headers as $header => $value) {
            $response = $response->withHeader(name: $header, value: $value);
        }

        return $response;
    }

    /**
     * Creates a new empty response with a status code and reason phrase.
     */
    public function createResponse(int|null $code = null, string $reasonPhrase = '') : ResponseInterface
    {
        $code   ??= 200;
        $stream = $this->streamFactory->createStream();

        return $this
            ->cloneResponse()
            ->withStatus(code: $code, reasonPhrase: $reasonPhrase)
            ->withBody(stream: $stream);
    }

    /**
     * Creates a redirect response (supports absolute and relative URLs).
     */
    public function createRedirectResponse(string $url, int $status = 302) : ResponseInterface
    {
        if (! filter_var($url, FILTER_VALIDATE_URL) && ! str_starts_with($url, '/')) {
            throw new InvalidArgumentException(message: 'Invalid URL for redirection.');
        }

        return $this
            ->cloneResponse()
            ->withStatus(code: $status)
            ->withHeader(name: 'Location', value: $url);
    }

    /**
     * Creates an HTML response.
     */
    public function createHtmlResponse(string $html, int $status = 200) : ResponseInterface
    {
        $stream = $this->streamFactory->createStream($html);

        return $this
            ->cloneResponse()
            ->withStatus($status)
            ->withBody($stream)
            ->withHeader('Content-Type', 'text/html; charset=UTF-8');
    }

    /**
     * Renders a view template with the provided data and returns a response.
     *
     * @param string     $template The name of the template to render.
     * @param array|null $data     Optional data to pass to the template. Defaults to an empty array if null.
     * @param int        $status   The HTTP status code for the response. Defaults to 200.
     *
     * @return ResponseInterface The generated HTTP response containing the rendered view.
     */
    public function view(string $template, array|null $data = null, int $status = 200) : ResponseInterface
    {
        $data ??= [];

        return view($template, $data);
    }

}

=== HTTP/Router/Bootstrap/RouteBootstrapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Bootstrap;

use FilesystemIterator;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\HTTP\Router\Cache\RouteCacheLoader;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;
use Gemini\HTTP\Router\Support\RouteCollector;
use Psr\Log\LoggerInterface;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;
use Throwable;

/**
 * Handles the bootstrapping of application routes.
 *
 * Responsibilities:
 * - Ensure routes are loaded efficiently and securely.
 * - Load routes from cache, if available, for improved performance.
 * - Fallback to loading routes from disk-based DSL/closure definitions.
 * - Support error handling, logging, and other critical processes.
 *
 * This class emphasizes secure, clean, and efficient route bootstrapping.
 */
final readonly class RouteBootstrapper
{
    /**
     * @var RouteCacheLoader  $routeCacheLoader  Handles route caching operations.
     * @var HttpRequestRouter $httpRequestRouter Responsible for registering and managing application routes.
     * @var LoggerInterface   $logger            Logs important messages and errors.
     */
    public function __construct(
        private RouteCacheLoader  $routeCacheLoader,
        private HttpRequestRouter $httpRequestRouter,
        private LoggerInterface   $logger,
    ) {}

    /**
     * Bootstraps application routes.
     *
     * - Attempts to load routes from the cache file if available.
     * - Falls back to loading routes from disk files if the cache is absent or outdated.
     * - Always loads closure-based routes directly from disk to ensure runtime correctness.
     *
     * @throws Throwable Any exception encountered during route bootstrapping is logged and re-thrown.
     */
    public function bootstrap() : void
    {
        // Retrieve the paths for route cache and routes directory.
        $cachePath  = AppPath::ROUTE_CACHE_PATH->get();
        $routesPath = AppPath::ROUTES_PATH->get();

        try {
            // Check if the cache file exists and is valid, load routes from it if true.
            if ($this->isCacheAvailable(cachePath: $cachePath)) {
                $this->loadRoutesFromCache(cachePath: $cachePath);
            } else {
                // Otherwise, load routes from disk and generate a new cache file.
                $this->loadRoutesFromDiskAndCache(routesPath: $routesPath, cachePath: $cachePath);
            }

            // Load closure-based routes from disk even if cache was used.
            $this->loadClosureRoutesFromDisk(routesPath: $routesPath);
        } catch (Throwable $exception) {
            // Handle and log critical errors during route setup, then re-throw the exception.
            $this->handleCriticalError(exception: $exception, cachePath: $cachePath, routesPath: $routesPath);
            throw $exception;
        }
    }

    /**
     * Validates the availability of the route cache file.
     *
     * @param string $cachePath Absolute path of the cache file.
     *
     * @return bool Returns true if the cache file exists and is readable.
     */
    private function isCacheAvailable(string $cachePath) : bool
    {
        return is_file($cachePath) && is_readable($cachePath);
    }

    /**
     * Loads routes from the cache file.
     *
     * @param string $cachePath Path to the route cache file.
     */
    private function loadRoutesFromCache(string $cachePath) : void
    {
        // Use the route cache loader to load cached routes.
        $this->routeCacheLoader->load(cachePath: $cachePath);

        // Log the successful loading of cached routes.
        $this->logger->info(message: '✅ Route cache loaded.', context: ['cache' => $cachePath]);
    }

    /**
     * Loads routes from disk and generates a new cache file for future use.
     *
     * @param string $routesPath Path to the directory containing route definition files.
     * @param string $cachePath  Path to where the new cache file should be written.
     */
    private function loadRoutesFromDiskAndCache(string $routesPath, string $cachePath) : void
    {
        // Load routes from disk-based files.
        $this->loadRoutesFromDisk(baseDir: $routesPath);

        // Write the loaded routes to a cache file.
        $this->routeCacheLoader->write(cachePath: $cachePath);

        // Log the creation of a new route cache.
        $this->logger->info(message: '📦 Route cache created from disk.', context: [
            'source' => $routesPath,
            'cache'  => $cachePath,
        ]);
    }

    /**
     * Loads and registers routes from disk route definition files.
     *
     * - Iterates over disk route files and registers their routes with the router.
     * - Clears any existing buffered route definitions prior to registration.
     * - Registers the fallback route, if it exists.
     *
     * @param string $baseDir Base directory containing route definition files.
     */
    private function loadRoutesFromDisk(string $baseDir) : void
    {
        // Reset the route collector to ensure no stale routes remain in memory.
        RouteCollector::reset();

        // Iterate through all route files in the base directory.
        foreach ($this->getRouteFilesFromDirectory(baseDir: $baseDir) as $file) {
            $this->processRouteFile(file: $file);
        }

        // Register any fallback route defined during route processing.
        $this->registerFallbackRoute();
    }

    /**
     * Retrieves all `.routes.php` files recursively from the specified directory.
     *
     * @param string $baseDir Directory to search for route files.
     *
     * @return list<SplFileInfo> A list of route files (instances of `SplFileInfo`).
     * @throws RuntimeException Thrown if the directory is inaccessible or unreadable.
     */
    private function getRouteFilesFromDirectory(string $baseDir) : array
    {
        // Ensure the provided directory exists and is readable.
        if (! is_dir($baseDir) || ! is_readable($baseDir)) {
            throw new RuntimeException(message: "Routes directory '{$baseDir}' is not accessible or readable.");
        }

        // Create a recursive iterator to find all files within the route directory.
        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveDirectoryIterator(
                          directory: $baseDir,
                          flags    : FilesystemIterator::SKIP_DOTS
                      )
        );

        // Filter and return files that end with `.routes.php`, or just 'routes.php'
        $routeFiles = array_filter(
            array   : iterator_to_array($iterator),
            callback: static fn(SplFileInfo $file) : bool => $file->isFile()
                                                             && $file->isReadable()
                                                             && preg_match(
                                                                 '/\.routes\.php$|^routes\.php$/',
                                                                 $file->getFilename()
                                                             )
        );

        // Ensure a returned array is indexed sequentially
        return array_values($routeFiles); // Avoids gaps in array keys


    }

    /**
     * Processes a route file and registers all contained routes with the router.
     *
     * @param SplFileInfo $file Route file to process.
     */
    private function processRouteFile(SplFileInfo $file) : void
    {
        // Include the route file to evaluate its contents in the current context.
        require_once $file->getPathname();

        // Flush buffered routes from the collector and register them with the router.
        foreach (RouteCollector::flushBuffered() as $routeBuilder) {
            $this->httpRequestRouter->registerRoute(
                method       : $routeBuilder->method,
                path         : $routeBuilder->path,
                action       : $routeBuilder->action,
                middleware   : $routeBuilder->middleware,
                name         : $routeBuilder->name,
                constraints  : $routeBuilder->constraints,
                defaults     : $routeBuilder->defaults,
                domain       : $routeBuilder->domain,
                attributes   : $routeBuilder->attributes,
                authorization: $routeBuilder->authorization,
            );
        }
    }

    /**
     * Registers a fallback route if one is defined within `RouteCollector`.
     */
    private function registerFallbackRoute() : void
    {
        // Check if a fallback route exists in the collector.
        $fallback = RouteCollector::getFallback();

        // If a fallback route exists, register it with the router.
        if ($fallback !== null) {
            $this->httpRequestRouter->fallback(handler: $fallback);
        }
    }

    /**
     * Loads and registers closure-based routes directly from disk.
     *
     * @param string $routesPath Path to the directory containing route definition files.
     */
    private function loadClosureRoutesFromDisk(string $routesPath) : void
    {
        // Reuse the `loadRoutesFromDisk` method to handle closure-based route files.
        $this->loadRoutesFromDisk(baseDir: $routesPath);

        // Log the successful loading of closure-based routes.
        $this->logger->info(message: '🔁 Closure-based routes loaded from disk.', context: [
            'directory' => $routesPath,
        ]);
    }

    /**
     * Handles critical errors encountered during route bootstrapping.
     *
     * - Logs the exception and its context to assist debugging.
     *
     * @param Throwable $exception  Exception encountered.
     * @param string    $cachePath  Path to the route cache file.
     * @param string    $routesPath Path to the directory containing route files.
     */
    private function handleCriticalError(Throwable $exception, string $cachePath, string $routesPath) : void
    {
        $this->logger->critical(message: '🔥 Route bootstrap failed.', context: [
            'exception'  => $exception->getMessage(),
            'trace'      => $exception->getTraceAsString(),
            'cache_path' => $cachePath,
            'routes_dir' => $routesPath,
        ]);
    }
}
=== HTTP/Router/Cache/RouteCacheCompiler.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Cache;

use Gemini\HTTP\Router\Support\RouteCollector;
use Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException;
use RuntimeException;
use SplFileInfo;

/**
 * A service responsible for compiling application routes into a single cache file.
 * This compiler improves performance by preloading all the route definitions
 * during runtime instead of dynamically loading them.
 *
 * Supports the serialization of Closure-based route actions using Laravel\SerializableClosure.
 */
final readonly class RouteCacheCompiler
{
    /**
     * Compiles route files from a specific directory into a unified PHP cache file.
     *
     * This process consists of discovering route definition files (`*.routes.php`),
     * invoking all buffered route builders, serializing binding logic, and finally
     * writing the compiled routes in a compact serialized format for subsequent execution.
     *
     * @param string $directory  The absolute path to the directory containing `*.routes.php` files.
     * @param string $outputFile The absolute file path where the compiled routes cache will be stored.
     *
     * @return void
     *
     * @throws RuntimeException                   Thrown in cases where route compilation fails
     *                                            (e.g., no routes are defined, or file I/O fails).
     * @throws PhpVersionNotSupportedException    Thrown when the PHP version does not support
     *                                            Closure serialization methods used.
     */
    public function compile(string $directory, string $outputFile) : void
    {
        // Initialize an empty array to hold serialized routes.
        $routes = [];

        // Iterate over every route file within the provided directory.
        foreach ($this->getRouteFilesFromDirectory(baseDir: $directory) as $file) {
            // Evaluate the route definition file to register its routes with the collector.
            require $file->getPathname();

            // Retrieve and flush buffered RouteBuilder instances from the RouteCollector.
            $builders = RouteCollector::flushBuffered();

            // If no builders are registered, skip this file.
            if (empty($builders)) {
                continue;
            }

            // Traverse each RouteBuilder, compiling their route definitions.
            foreach ($builders as $builder) {
                // Compile each route into a directive that also serializes the action logic.
                foreach ($builder->build() as $route) {
                    // Serialize the route after preparing it with a serialized action.
                    $routes[] = serialize($route->withSerializedAction());
                }
            }
        }

        // If no routes have been registered across any of the files, throw an exception.
        if (empty($routes)) {
            throw new RuntimeException(message: 'No routes were registered. Check your route files.');
        }

        // Generate the content for the PHP cache file containing all compiled routes.
        $cacheContent = $this->generateCacheFileContent(serializedRoutes: $routes);

        // Attempt to write the generated cache content to the specified output file.
        if (! file_put_contents($outputFile, $cacheContent)) {
            throw new RuntimeException(message: "Failed to write route cache to: {$outputFile}");
        }
    }

    /**
     * Discovers all route definition files within the provided directory.
     *
     * This method searches for files matching the naming pattern `*.routes.php`
     * and converts their file paths into SplFileInfo objects for further processing.
     *
     * @param string $baseDir The base directory path in which to scan for route definition files.
     *
     * @return list<SplFileInfo> A list of SplFileInfo objects representing discovered route files.
     *
     * @throws RuntimeException Thrown when the directory is inaccessible or unreadable.
     */
    private function getRouteFilesFromDirectory(string $baseDir) : array
    {
        // Verify that the provided base directory is both accessible and readable.
        if (! is_dir($baseDir) || ! is_readable($baseDir)) {
            throw new RuntimeException(message: "Routes directory '{$baseDir}' is not accessible.");
        }

        // Use glob to find all PHP files adhering to the "*.routes.php" pattern.
        $files = glob("{$baseDir}/*.routes.php");

        // Convert each file path into an SplFileInfo instance and return the resulting array.
        return array_map(
            static fn(string $path) => new SplFileInfo(filename: $path),
            $files ?: [] // Default to an empty array if no files match.
        );
    }

    /**
     * Generates the PHP code to be written in the cache file.
     *
     * Given an array of serialized route definitions, this method composes the final
     * PHP content that will be saved. The resulting file contains an associative array
     * with each serialized route deserialized at runtime upon inclusion.
     *
     * @param array<string> $serializedRoutes A list of serialized route definitions.
     *
     * @return string The resultant PHP file's content as a string.
     */
    private function generateCacheFileContent(array $serializedRoutes) : string
    {
        // Start the creation of cache content with a PHP opening tag and comments.
        $code = "<?php\n\n/** Auto-generated route cache. Do not edit manually. */\n\nreturn [\n";

        // Append each serialized route using unserialize function calls.
        foreach ($serializedRoutes as $route) {
            // Escape single quotes to ensure code safety within double-quote strings.
            $escaped = str_replace("'", "\\'", $route);

            // Append the unserialized route definition to the array.
            $code .= "    unserialize('{$escaped}'),\n";
        }

        // Close the array and return the complete PHP content as a string.
        $code .= "];\n";

        return $code;
    }
}
=== HTTP/Router/Cache/RouteCacheLoader.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Cache;

use Gemini\Facade\Facades\Storage;
use Gemini\HTTP\Router\Router;
use Gemini\HTTP\Router\Routing\RouteDefinition;
use RuntimeException;

final class RouteCacheLoader
{
    public function __construct(
        private readonly Router $router
    ) {}

    /**
     * Loads route definitions from serialized cache and registers them into the router.
     *
     * @param string $cachePath
     *
     * @throws RuntimeException
     */
    public function load(string $cachePath) : void
    {
        if (! Storage::exists(path: $cachePath)) {
            throw new RuntimeException(message: "Route cache file not found: {$cachePath}");
        }

        /** @var array<RouteDefinition> $routes */
        $routes = require $cachePath;

        if (! is_array($routes)) {
            throw new RuntimeException(message: "Invalid route cache: must be an array.");
        }

        foreach ($routes as $definition) {
            if (! $definition instanceof RouteDefinition) {
                throw new RuntimeException(message: "Invalid route in cache.");
            }

            $this->router->registerRouteFromCache(definition: $definition);
        }
    }

    /**
     * Writes the current route definitions to a serialized cache file.
     *
     * @param string $cachePath
     *
     * @throws RuntimeException
     */
    public function write(string $cachePath) : void
    {
        $directory = dirname($cachePath);

        $this->ensureDirectoryIsWritable(directory: $directory);

        $routeDefinitions = $this->router->allRoutes();

        $flattenedRoutes = array_merge(...array_values($routeDefinitions));

        // 🧼 Remove any route that uses a Closure action
        $serializableRoutes = array_filter(
            $flattenedRoutes,
            static fn(RouteDefinition $route) : bool => ! $route->usesClosure()
        );

        $exported = var_export($serializableRoutes, true);
        $hash     = sha1($exported);
        $content  = "<?php\n\n/** Auto-generated route cache [sha1: {$hash}]. Do not edit manually. */\n\nreturn {$exported};\n";

        if (! Storage::write(path: $cachePath, content: $content)) {
            throw new RuntimeException(message: "Failed to write route cache to: {$cachePath}");
        }
    }


    /**
     * Ensures the cache directory is writable.
     *
     * @param string $directory
     *
     * @throws RuntimeException
     */
    private function ensureDirectoryIsWritable(string $directory) : void
    {
        if (! Storage::exists(path: $directory) && ! Storage::createDirectory(directory: $directory)) {
            throw new RuntimeException(message: "Cannot create route cache directory: {$directory}");
        }

        if (! Storage::isWritable(path: $directory)) {
            throw new RuntimeException(message: "Route cache directory is not writable: {$directory}");
        }
    }
}

=== HTTP/Router/Exceptions/UnresolvableMiddlewareException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Exceptions;

use RuntimeException;

/**
 * This exception is thrown when middleware cannot be resolved.
 *
 * @package Gemini\HTTP\Router\Exceptions
 *
 * @see     RuntimeException
 *
 * Typical use case:
 * - This exception may be thrown during runtime when middleware identified
 *   by name, configuration, or parameters cannot be instantiated or located.
 *
 * Design Considerations:
 * - This is part of the overall exception hierarchy, promoting better error
 *   differentiation and allowing targeted exception handling.
 */
class UnresolvableMiddlewareException extends RuntimeException
{
    // This class does not currently declare any properties or methods of its own.
    // It serves as a lightweight way to provide a specific exception type
    // for middleware resolution issues while retaining other features of RuntimeException.
}
=== HTTP/Router/HttpMethod.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router;

/**
 * Enum representing HTTP methods.
 *
 * This provides a type-safe representation of allowed HTTP methods
 * for routing and validation purposes.
 */
enum HttpMethod: string
{
    case GET     = 'GET';

    case POST    = 'POST';

    case PUT     = 'PUT';

    case DELETE  = 'DELETE';

    case PATCH   = 'PATCH';

    case OPTIONS = 'OPTIONS';

    case HEAD    = 'HEAD';

    /**
     * Validates if a given string matches a valid HTTP method.
     *
     * @param string $method The HTTP method to validate.
     *
     * @return bool True if valid, false otherwise.
     */
    public static function isValid(string $method) : bool
    {
        return in_array(strtoupper($method), array_column(self::cases(), 'value'), true);
    }

    /**
     * Returns a list of all HTTP methods as strings.
     *
     * @return array<string>
     */
    public static function list() : array
    {
        return array_map(static fn(HttpMethod $method) => $method->value, self::cases());
    }
}
=== HTTP/Router/Kernel/RouterKernel.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Kernel;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;
use Gemini\HTTP\Router\Routing\RouteDefinition;
use Gemini\HTTP\Router\Routing\RoutePipelineFactory;
use Gemini\HTTP\Router\Support\HeadRequestFallback;
use Psr\Http\Message\ResponseInterface;

/**
 * Class RouterKernel
 *
 * This class is the main entry point of the router kernel, providing a clean,
 * domain-oriented design for HTTP request handling. It resolves routes,
 * applies middleware, and dispatches the request pipeline to produce an HTTP response.
 *
 * The class is marked as `readonly` to ensure that injected dependencies
 * and their state remain immutable, strictly adhering to DDD principles.
 */
final readonly class RouterKernel
{
    /**
     * Constructor initializes the core dependencies for the routing kernel.
     *
     * @param HttpRequestRouter    $httpRequestRouter   Responsible for resolving HTTP routes.
     * @param RoutePipelineFactory $pipelineFactory     Creates pipelines to process route handling.
     * @param HeadRequestFallback  $headRequestFallback Provides fallback processing for HEAD requests.
     */
    public function __construct(
        private HttpRequestRouter    $httpRequestRouter,
        private RoutePipelineFactory $pipelineFactory,
        private HeadRequestFallback  $headRequestFallback
    ) {}

    /**
     * Handles an incoming HTTP request by resolving the corresponding route,
     * applying middleware, and processing the pipeline.
     *
     * @param Request $request The HTTP request to be processed.
     *
     * @return ResponseInterface The HTTP response produced after processing.
     *
     * @throws \ReflectionException Signals issues with runtime reflection in the pipeline processing.
     * @throws \Psr\Container\ContainerExceptionInterface Indicates a container-related error occurred.
     * @throws \Psr\Container\NotFoundExceptionInterface Indicates a requested service was not found.
     */
    public function handle(Request $request) : ResponseInterface
    {
        // Apply fallback logic for HEAD requests, converting them to GET if needed.
        $request = $this->headRequestFallback->resolve($request);

        // Resolve the current request into a matching route definition.
        $route = $this->httpRequestRouter->resolve($request);

        // Inject route parameters and defaults into the request as attributes.
        $request = $this->injectRouteAttributes($request, $route);

        // Create a middleware pipeline based on the resolved route.
        $pipeline = $this->pipelineFactory->create($route);

        // Process the pipeline and dispatch the final response.
        return $pipeline->dispatch($request);
    }

    /**
     * Injects route parameters and default values into the request as attributes.
     *
     * This method ensures the request contains all the attributes defined
     * in the route and sets default values where attributes are missing.
     *
     * @param Request         $request The current HTTP request.
     * @param RouteDefinition $route   The route definition containing parameters and defaults.
     *
     * @return Request A new request object with the injected attributes.
     */
    private function injectRouteAttributes(Request $request, RouteDefinition $route) : Request
    {
        // Inject route parameters as attributes into the request.
        foreach ($route->parameters as $key => $value) {
            $request = $request->withAttribute($key, $value);
        }

        // Inject default values for attributes that are not already set in the request.
        foreach ($route->defaults as $key => $value) {
            if ($request->getAttribute($key) === null) {
                $request = $request->withAttribute($key, $value);
            }
        }

        // Return a modified request containing all the injected attributes.
        return $request;
    }
}
=== HTTP/Router/RouterInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Routing\RouteRegistrarProxy;
use Psr\Http\Message\ResponseInterface;

/**
 * Interface RouterInterface
 *
 * Provides a contract for a router implementation that handles HTTP route
 * registration and resolution while enabling fallback and fluent style registration methods.
 */
interface RouterInterface
{
    /**
     * Registers a GET route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be called when the route matches.
     *                                      Can be a callable, an array (e.g., controller and method), or a string
     *                                      (e.g., controller@method).
     *
     * @return RouteRegistrarProxy Returns a proxy for chaining extra route configurations.
     */
    public function get(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a POST route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be handled when the route matches.
     *
     * @return RouteRegistrarProxy A proxy for fluent method chaining.
     */
    public function post(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a PUT route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be executed on matching the route.
     *
     * @return RouteRegistrarProxy A proxy object for fluent route customization.
     */
    public function put(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a PATCH route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be processed when the route matches.
     *
     * @return RouteRegistrarProxy Returns a proxy for additional route configuration.
     */
    public function patch(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a DELETE route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be applied when the route matches.
     *
     * @return RouteRegistrarProxy A proxy object for chaining route details.
     */
    public function delete(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers an OPTIONS route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action handling the route on match.
     *
     * @return RouteRegistrarProxy RouteRegistrarProxy for additional route setups.
     */
    public function options(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a HEAD route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action performed when the route matches.
     *
     * @return RouteRegistrarProxy An object for further configuration of the route.
     */
    public function head(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers the same action for all HTTP methods.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be executed for any HTTP method.
     *
     * @return RouteRegistrarProxy[] Array of proxies, each corresponding to the registered method.
     */
    public function any(string $path, callable|array|string $action) : array;

    /**
     * Sets a fallback route to be executed if no other routes match.
     *
     * @param callable|array|string $handler The fallback handler to be called when no route matches the request.
     */
    public function fallback(callable|array|string $handler) : void;

    /**
     * Resolves an incoming request into a response.
     *
     * @param Request $request The current HTTP request to be resolved.
     *
     * @return ResponseInterface The PSR-7 compliant response for the resolved request.
     */
    public function resolve(Request $request) : ResponseInterface;
}
=== HTTP/Router/Router.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router;

use Closure;
use Gemini\HTTP\Dispatcher\ControllerDispatcher;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Kernel\RouterKernel;
use Gemini\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;
use Gemini\HTTP\Router\Routing\RouteBuilder;
use Gemini\HTTP\Router\Routing\RouteDefinition;
use Gemini\HTTP\Router\Routing\RouteGroupAttributesConfigurator;
use Gemini\HTTP\Router\Routing\RouteGroupContext;
use Gemini\HTTP\Router\Routing\RouteGroupStack;
use Gemini\HTTP\Router\Routing\RouteRegistrarProxy;
use Gemini\HTTP\Router\Support\RouteCollector;
use LogicException;
use Psr\Http\Message\ResponseInterface;

/**
 * Central Router facade.
 *
 * Acts as the primary route registration and resolution interface.
 * Delegates resolution to RouterKernel and registration via RouteBuilder DSL.
 */
final class Router implements RouterInterface
{
    /**
     * The fallback handler to be used if no other handler is available.
     *
     * @var mixed|null This can be null or any object that implements the necessary handler interface.
     */
    private Closure|null $fallbackHandler = null;

    /**
     * Initializes a new instance of the class with the provided dependencies.
     *
     * @param HttpRequestRouter $httpRequestRouter The HTTP request router instance to be injected.
     * @param RouterKernel      $kernel            The kernel instance to manage routing logic.
     */
    public function __construct(
        private readonly HttpRequestRouter $httpRequestRouter,
        private readonly RouterKernel      $kernel,
    ) {}

    /**
     * Registers a GET route.
     */
    public function get(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::GET->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Internal route registration via RouteBuilder.
     */
    private function register(string $method, string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        // Define the route using a builder pattern.
        // `RouteBuilder::make` creates a new instance of the RouteBuilder class
        // by specifying the HTTP method and the URI path.
        $builder = RouteBuilder::make(
            method: $method, // The HTTP method (e.g., GET, POST, PUT).
            path  : $path      // The URI path defining the route (e.g., `/users`, `/posts/{id}`).
        );

        // Define the action (e.g., controller or callable) to handle the route's behavior.
        // The action can be a callable, array-based controller reference, or string representation.
        $builder->action(
            action: $action // The action that will be invoked when the route is matched.
        );

        // 🔁 Collect the defined route for later usage.
        // Adds the `RouteBuilder` instance to the `RouteCollector` for later bootstrapping,
        // middleware applications, or cache compilation for performance optimization.
        RouteCollector::add(builder: $builder);

        // Return a proxy to handle registration for the associated HTTP request router.
        // The `RouteRegistrarProxy` will be used to facilitate the registration of
        // the newly defined route and allow for advanced handling or configurations.
        return new RouteRegistrarProxy(
            router : $this->httpRequestRouter,
            // The HTTP router responsible for routing requests to corresponding actions.
            builder: $builder                  // The route builder containing the route's definition and metadata.
        );
    }

    /**
     * Registers a POST route.
     */
    public function post(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::POST->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers a PUT route.
     */
    public function put(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::PUT->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers a PATCH route.
     */
    public function patch(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::PATCH->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers a DELETE route.
     */
    public function delete(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::DELETE->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers a HEAD route.
     */
    public function head(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::HEAD->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers an OPTIONS route.
     */
    public function options(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(
            method: HttpMethod::OPTIONS->value,
            path  : $path,
            action: $action
        );
    }

    /**
     * Registers the same action for all HTTP methods.
     *
     * @return RouteRegistrarProxy[]
     */
    public function any(string $path, callable|array|string $action) : array
    {
        $proxies = [];

        foreach (HttpMethod::cases() as $method) {
            $proxies[] = $this->register(
                method: $method->value,
                path  : $path,
                action: $action
            );
        }

        return $proxies;
    }

    /**
     * Resolves the given request and returns the appropriate response.
     *
     * @param Request $request The incoming request to be handled.
     *
     * @return ResponseInterface The response generated by the kernel or the fallback handler.
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    public function resolve(Request $request) : ResponseInterface
    {
        /**
         * Handles the incoming HTTP request using the primary kernel.
         * If no route is found, and a fallback handler is defined, it delegates to the fallback.
         * Otherwise, it throws an exception indicating no route match.
         *
         * @param Request $request The incoming HTTP request object to be processed.
         *
         * @return ResponseInterface The HTTP response generated by either the kernel or the fallback handler.
         * @throws RouteNotFoundException If no route is matched and no fallback handler exists.
         *
         */
        try {
            // Use the kernel's responsibility to handle the incoming HTTP request by delegating it to
            // its `handle` method. This internally resolves the matched route, applies middleware,
            // dispatches the associated action, and returns an appropriate response.
            return $this->kernel->handle(request: $request);
        } catch (RouteNotFoundException) {
            // Check if a fallback handler is defined within the current context. This determines
            // whether an alternate mechanism to process unmatched requests is available.
            if ($this->fallbackHandler !== null) {
                // Invoke the fallback handler with the incoming request to return an alternative
                // response. This can allow the system to gracefully degrade behavior where routes
                // are not available.
                return call_user_func($this->fallbackHandler, $request);
            }

            // If no fallback handler is defined, explicitly throw a `RouteNotFoundException` with
            // a clear message to indicate the failure in routing and lack of fallback resolution.
            throw new RouteNotFoundException(
                message: "No route matched and no fallback defined."
            );
        }
    }

    /**
     * Defines a fallback route.
     *
     * @param callable|array|string $handler
     */
    public function fallback(callable|array|string $handler) : void
    {
        if (is_callable($handler)) {
            $this->fallbackHandler = $handler;
        } elseif (is_array($handler) || is_string($handler)) {
            $this->fallbackHandler = static function (Request $request) use ($handler) : ResponseInterface {
                /** @var ControllerDispatcher $dispatcher */
                $dispatcher = app(abstract: ControllerDispatcher::class);

                return $dispatcher->dispatch(
                    action : $handler,
                    request: $request
                );
            };
        }
    }

    /**
     * Registers a route using the given route definition from the cache.
     *
     * @param RouteDefinition $definition The route definition to be registered.
     *
     * @return void
     */
    public function registerRouteFromCache(RouteDefinition $definition) : void
    {
        // Adds the provided route definition to the HTTP request router.
        $this->httpRequestRouter->add(route: $definition);
    }

    /**
     * Retrieves a route by its name from the HTTP request router.
     *
     * @param string $name The name of the route to retrieve.
     *
     * @return RouteDefinition The route definition associated with the specified name.
     */
    public function getRouteByName(string $name) : RouteDefinition
    {
        // Returns the route with the specified name from the HTTP request router.
        return $this->httpRequestRouter->getByName(name: $name);
    }

    /**
     * Retrieves the currently injected HTTP request router object.
     *
     * @return HttpRequestRouter The injected HTTP request router instance.
     */
    public function getHttpRouter() : HttpRequestRouter
    {
        // Returns the currently injected HTTP request router object.
        return $this->httpRequestRouter;
    }

    /**
     * Returns all registered route definitions.
     *
     * @return array<string, RouteDefinition[]>
     */
    public function allRoutes() : array
    {
        return $this->httpRequestRouter->allRoutes();
    }

    /**
     * Assigns a name prefix to the current route group.
     *
     * @param string $prefix The prefix to be added to the name of routes in the current group.
     *
     * @return self Provides fluent chaining of methods.
     * @throws LogicException If called outside the scope of a route group.
     *
     */
    public function name(string $prefix) : self
    {
        // Retrieve the current route group context from the route group stack.
        $context = RouteGroupStack::current();

        // Throw an exception if the method is called outside of a group context.
        if ($context === null) {
            throw new LogicException(
                message: 'Cannot call ->name() outside of a route group context.'
            );
        }

        // Set the provided name prefix on the current route group context.
        $context->setNamePrefix(prefix: $prefix);

        // Return the current instance for method chaining.
        return $this;
    }

    /**
     * Assigns a domain constraint to the routes within the current group.
     *
     * @param string $domain The domain constraint to associate with the current route group.
     *
     * @return self Provides fluent chaining of methods.
     */
    public function domain(string $domain) : self
    {
        // Set the domain configuration for the current route group if available.
        RouteGroupStack::current()?->setDomain($domain);

        // Return the current instance for method chaining.
        return $this;
    }

    /**
     * Configures an authorization policy for routes in the current group.
     *
     * @param string $policy The policy to enforce on the current route group.
     *
     * @return self Provides fluent chaining of methods.
     */
    public function authorize(string $policy) : self
    {
        // Set the authorization policy for the current route group if available.
        RouteGroupStack::current()?->setAuthorization($policy);

        // Return the current instance for method chaining.
        return $this;
    }

    /**
     * Defines a group of routes with shared attributes and configurations.
     *
     * This method allows developers to group routing logic together under a common context,
     * such as a shared URL prefix, middleware, authorization, or domain. The grouping
     * is facilitated by a `RouteGroupContext` instance that encapsulates these shared attributes.
     *
     * It uses a stack to manage nested route groups, enabling hierarchical routing setups.
     *
     * @param array   $attributes  An associative array of attributes that define the route group's configuration.
     *                             Allowed attributes are:
     *                             - `prefix` (string): Prepends a common URI segment to all routes in the group.
     *                             - `middleware` (array): Adds an array of middleware to all routes in the group.
     *                             - `domain` (string): Defines a domain scope for the routes in the group.
     *                             - `name` (string): Adds a name prefix for all route names in this group.
     *                             - `authorize` (string): Defines an authorization scope for the group.
     * @param Closure $callback    A closure responsible for defining the grouped routes.
     *
     * @return void
     */
    public function group(array $attributes, Closure $callback) : void
    {
        $context = new RouteGroupContext();

        /**
         * Create a new instance of RouteGroupAttributesConfigurator to configure routing attributes for a group.
         *
         * An associative array of group-level attributes and configurations.
         *
         * Expected attributes can include:
         * - `prefix`: URI prefix for the route group. (string)
         * - `name`: Name prefix for the route group. (string)
         * - `domain`: The domain constraint for the group. (string)
         * - `authorize`: Authorization-related information for the group. (string)
         * - `middleware`: Middleware(s) applicable to the entire group. (string|array<string>)
         *
         * This array acts as the primary source of group-level contextual information.
         *
         * @var array<string, mixed> $attributes
         *
         *
         * The routing context that will be configured with the provided attributes.
         *
         * This encapsulated group-level configuration for routes, ensuring each group
         * inherits consistent behavior in a decoupled, reusable manner (aligned with DDD style).
         *
         * @var RouteGroupContext    $context
         *
         */
        (new RouteGroupAttributesConfigurator())->apply(
            attributes: $attributes,
            context   : $context
        );

        // Push the created context onto the routing stack, indicating the start of a new route group.
        RouteGroupStack::push($context);

        try {
            // Invoke the provided callback, passing the current instance to define the group's routes.
            $callback($this);
        } finally {
            // Pop the context from the stack, signaling the end of the current route group.
            RouteGroupStack::pop();
        }
    }

    /**
     * Sets a prefix for all routes defined within the current route group.
     *
     * @param string $prefix The prefix to be prepended to the URI of all routes in the group.
     *
     * @return self Provides fluent chaining of methods.
     */
    public function prefix(string $prefix) : self
    {
        // Assign the URI prefix to the current route group if the context is active.
        RouteGroupStack::current()?->setPrefix(prefix: $prefix);

        // Return the current instance for method chaining.
        return $this;
    }

    /**
     * Registers a new array of middleware to the current route group stack.
     *
     * Leverages RouteGroupStack to add the provided middleware collection for
     * the currently active route group if it exists.
     *
     * @param array $middleware An array of middleware classes or callables to be added.
     *
     * @return self Allows method chaining by returning the same instance of MiddlewareManager.
     */
    public function middleware(array $middleware) : self
    {
        // Retrieve the current route group stack if available, and add the middleware to it.
        RouteGroupStack::current()?->addMiddleware($middleware);

        // Enable method chaining by returning the current object instance.
        return $this;
    }

    /**
     * Adds parameter constraints (regex patterns) to the current route group context.
     * These constraints act as validation rules for route parameters within the group.
     *
     * Example:
     * ```php
     * $routeGroup->where(['id' => '\d+', 'slug' => '[a-z\-]+']);
     * ```
     *
     * @param array<string, string> $constraints A key-value array where the key is the parameter name,
     *                                           and the value is a regex pattern to validate the parameter.
     *
     * @return self Returns the current instance for fluent method chaining.
     */
    public function where(array $constraints) : self
    {
        // Retrieve the current route group from the stack and
        // add the specified parameter constraints.
        RouteGroupStack::current()?->addConstraints($constraints);

        // Return the current instance for further modifications.
        return $this;
    }

    /**
     * Defines default parameter values for the current route group context.
     * These defaults will be applied if a parameter is not explicitly provided in the URL.
     *
     * Example:
     * ```
     * $routeGroup->defaults(['locale' => 'en', 'timezone' => 'UTC']);
     * ```
     *
     * @param array<string, mixed> $defaults A key-value array where the key is the parameter name,
     *                                       and the value is the default value for the parameter.
     *
     * @return self Returns the current instance for fluent method chaining.
     */
    public function defaults(array $defaults) : self
    {
        // Retrieve the current route group from the stack and
        // add the specified default parameter values.
        RouteGroupStack::current()?->addDefaults($defaults);

        // Return the current instance for further modifications.
        return $this;
    }

    /**
     * Attaches arbitrary route-level metadata to the current route group context.
     * Metadata can be informational or directive, to influence routing behavior or store extra data.
     *
     * Example:
     * ```
     * $routeGroup->attributes(['middleware' => 'auth', 'role' => 'admin']);
     * ```
     *
     * @param array<string, mixed> $attributes A key-value array of metadata attributes.
     *
     * @return self Returns the current instance for fluent method chaining.
     */
    public function attributes(array $attributes) : self
    {
        // Retrieve the current route group from the stack and
        // add the specified metadata attributes.
        RouteGroupStack::current()?->addAttributes($attributes);

        // Return the current instance for further modifications.
        return $this;
    }
}

=== HTTP/Router/Routing/Exceptions/InvalidRouteException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing\Exceptions;

use InvalidArgumentException;
use Throwable;

/**
 * Thrown when a route definition is malformed or unsafe.
 *
 * Used for path errors, constraint syntax issues, or unsupported parameter configurations.
 */
final class InvalidRouteException extends InvalidArgumentException
{
    /**
     * Default constructor for direct string messages.
     *
     * @param string          $message  Error message.
     * @param int             $code     Error code (optional).
     * @param \Throwable|null $previous Chained exception (optional).
     */
    public function __construct(string $message = '', int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }

    /**
     * Creates an exception for a malformed route path.
     *
     * @param string $path The invalid route path.
     *
     * @return self
     */
    public static function forPath(string $path) : self
    {
        return new self(
            message: sprintf(
                         'Invalid route path provided: "%s". Path must begin with "/" and contain valid segments.',
                         $path
                     )
        );
    }

    /**
     * Creates an exception for a constraint regex that failed to compile.
     *
     * @param string $parameter Parameter name.
     * @param string $pattern   Invalid regex pattern.
     *
     * @return self
     */
    public static function forConstraint(string $parameter, string $pattern) : self
    {
        return new self(
            message: sprintf('Invalid regex constraint for parameter "%s": "%s"', $parameter, $pattern)
        );
    }

    /**
     * Creates an exception for wildcard misuse in route patterns.
     *
     * @param string $path The full route path.
     *
     * @return self
     */
    public static function forInvalidWildcardUsage(string $path) : self
    {
        return new self(
            message: sprintf(
                         'Invalid wildcard usage: wildcards must appear only once and at the end. Path: "%s"',
                         $path
                     )
        );
    }
}

=== HTTP/Router/Routing/Exceptions/InvalidRouteGroupFileException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing\Exceptions;

use RuntimeException;
use Throwable;

/**
 * Raised when a route group file fails to return a valid RouteGroupBuilder.
 */
final class InvalidRouteGroupFileException extends RuntimeException
{
    public function __construct(string $message, Throwable|null $previous = null)
    {
        parent::__construct($message, previous: $previous);
    }
}

=== HTTP/Router/Routing/Exceptions/RouteNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing\Exceptions;

use RuntimeException;

/**
 * Thrown when no route matches the incoming request.
 */
final class RouteNotFoundException extends RuntimeException
{
    /**
     * Factory for standard 404 message.
     *
     * @param string $method HTTP method used.
     * @param string $path   URI path attempted.
     *
     * @return static
     */
    public static function for(string $method, string $path) : self
    {
        return new self(
            message: sprintf('No route found for [%s] %s', strtoupper($method), $path),
            code   : 404
        );
    }
}

=== HTTP/Router/Routing/Exceptions/UnauthorizedException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing\Exceptions;

use RuntimeException;

/**
 * Thrown when a route explicitly defines an authorization requirement
 * that the request does not fulfill.
 */
final class UnauthorizedException extends RuntimeException
{
    public static function because(string $reason = 'Access denied.') : self
    {
        return new self($reason);
    }
}

=== HTTP/Router/Routing/HttpRequestRouter.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Routing\Exceptions\InvalidRouteException;
use Gemini\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Gemini\HTTP\Router\Support\DomainPatternCompiler;
use Gemini\HTTP\Router\Validation\RouteConstraintValidator;

/**
 * Handles HTTP request routing by matching registered routes to incoming requests.
 *
 * Fully supports:
 * - HTTP method-based route matching
 * - Named route support
 * - Prefix grouping
 * - Domain-aware routes
 * - Parameter constraints (via regex)
 * - Optional and wildcard path segments
 * - Route defaults for missing parameters
 * - Middleware and authorization metadata
 *
 * @internal This class acts as the internal route resolution engine.
 */
final class HttpRequestRouter
{
    /**
     * All registered routes, grouped by HTTP method.
     *
     * @var array<string, RouteDefinition[]>
     */
    private array $routes = [];

    /**
     * Current prefix (used for nested route groups).
     */
    private string $currentPrefix = '';

    /**
     * A map of named routes for reverse routing.
     *
     * @var array<string, RouteDefinition>
     */
    private array $namedRoutes = [];

    /**
     * Constructor for initializing the class with a RouteConstraintValidator.
     *
     * @param RouteConstraintValidator $constraintValidator The route constraint validator instance.
     */
    public function __construct(private readonly RouteConstraintValidator $constraintValidator) {}

    /**
     * Sets the current prefix for subsequent routes.
     *
     * @param string $prefix URI path prefix (without trailing slash).
     */
    public function setPrefix(string $prefix) : void
    {
        $this->currentPrefix = rtrim($prefix, '/');
    }

    /**
     * Clears any existing prefix used for route groupings.
     */
    public function clearPrefix() : void
    {
        $this->currentPrefix = '';
    }

    /**
     * Registers all routes defined in a RouteGroupBuilder instance.
     *
     * @param RouteGroupBuilder $group
     *
     * @return void
     */
    public function registerGroup(RouteGroupBuilder $group) : void
    {
        foreach ($group->build() as $route) {
            $this->registerRoute(
                method       : $route->method,
                path         : $route->path,
                action       : $route->action,
                middleware   : $route->middleware,
                name         : $route->name,
                constraints  : $route->constraints,
                defaults     : $route->defaults,
                domain       : $route->domain,
                attributes   : $route->attributes,
                authorization: $route->authorization
            );
        }
    }

    /**
     * Registers a route to the internal route collection.
     *
     * @param string                $method        HTTP method (GET, POST, etc.)
     * @param string                $path          Route path (e.g. /users/{id})
     * @param callable|array|string $action        Route handler (controller, callable, etc.)
     * @param array<string>         $middleware    Middleware stack
     * @param string|null           $name          Optional route name
     * @param array<string, string> $constraints   Param constraints via regex
     * @param array<string, string> $defaults      Default values for optional parameters
     * @param string|null           $domain        Optional domain pattern (e.g. admin.{org}.com)
     * @param array<string, mixed>  $attributes    Arbitrary metadata for the route
     * @param string|null           $authorization Authorization policy key (optional)
     *
     * @throws InvalidRouteException If the path is invalid.
     */
    public function registerRoute(
        string                $method,
        string                $path,
        callable|array|string $action,
        array|null            $middleware = null,
        string|null           $name = null,
        array|null            $constraints = null,
        array|null            $defaults = null,
        string|null           $domain = null,
        array|null            $attributes = null,
        string|null           $authorization = null
    ) : void {
        $this->validateRoutePath(path: $path);

        $route = new RouteDefinition(
            method       : strtoupper($method),
            path         : $this->applyPrefix(path: $path),
            action       : $action,
            middleware   : $middleware ?? [],
            name         : $name ?? '',
            constraints  : $constraints ?? [],
            defaults     : $defaults ?? [],
            domain       : $domain,
            attributes   : $attributes ?? [],
            authorization: $authorization
        );

        $this->routes[$route->method][] = $route;
        if (! empty($route->name)) {
            $this->namedRoutes[$route->name] = $route;
        }
    }

    /**
     * Validates that a route path begins with a slash and is not empty.
     *
     * @param string $path
     *
     * @throws InvalidRouteException
     */
    private function validateRoutePath(string $path) : void
    {
        if (empty($path) || ! str_starts_with($path, '/')) {
            throw new InvalidRouteException(message: 'Route path must start with a "/" and cannot be empty.');
        }
    }

    /**
     * Applies the currently active prefix to a path.
     *
     * @param string $path
     *
     * @return string
     */
    private function applyPrefix(string $path) : string
    {
        return $this->currentPrefix . $path;
    }

    /**
     * Resolves the given HTTP request and determines the corresponding route definition.
     *
     * @param Request $request The HTTP request to resolve, containing method, URI, and other details.
     *
     * @return RouteDefinition The resolved route definition that matches the request.
     * @throws RouteNotFoundException If no matching route is found.
     */
    public function resolve(Request $request) : RouteDefinition
    {
        // Retrieve the HTTP method of the request, convert it to uppercase for consistency.
        $method = strtoupper($request->getMethod());

        // Retrieve the URI path of the request to determine the path being accessed.
        $uriPath = $request->getUri()->getPath();

        // Retrieve the host (domain name) from the request URI.
        $host = $request->getUri()->getHost();

        // Iterate over all registered routes corresponding to the HTTP method of the request.
        foreach ($this->routes[$method] ?? [] as $route) {
            // If the route specifies a domain and the domain does not match the current host, skip this route.
            if ($route->domain !== null) {
                $compiled = DomainPatternCompiler::compile($route->domain);
                if (! DomainPatternCompiler::match($host, $compiled)) {
                    continue;
                }
            }

            // Compile the route's path into a regex pattern, taking into account any constraints defined.
            $pattern = $this->compileRoutePattern(
                template   : $route->path,       // The route path (e.g., "/users/{id}").
                constraints: $route->constraints // Route parameter constraints (e.g., regex for {id}).
            );

            // Check if the requested URI path matches the compiled route pattern.
            if (preg_match($pattern, $uriPath, $matches)) {
                // Extract any parameters captured from the regex match (e.g., {id} = 123).
                $parameters = $this->extractParameters(matches: $matches);

                // Apply default route parameters and merge them with extracted parameters into the request object.
                $request = $this->applyRouteDefaults(
                    request   : $request,
                    defaults  : $route->defaults,   // Default values (e.g., {lang} = "en" if not provided).
                    parameters: $parameters         // Extracted parameters from the request URI path.
                );

                // Calls the validate method of the RouteConstraintValidator instance.
                // This method ensures that all route parameter values in the request
                // comply with the regex constraints defined in the RouteDefinition.
                $this->constraintValidator->validate(route: $route, request: $request);

                // 🧠 Return the same object, but bind modified request
                return new RouteDefinition(
                    method       : $route->method,
                    path         : $route->path,
                    action       : $route->action,
                    middleware   : $route->middleware,
                    name         : $route->name,
                    constraints  : $route->constraints,
                    defaults     : $route->defaults,
                    domain       : $route->domain,
                    attributes   : $route->attributes,
                    authorization: $route->authorization,
                    parameters   : $parameters
                );
            }
        }

        throw RouteNotFoundException::for(method: $method, path: $uriPath);
    }

    /**
     * Builds a route-matching regular expression from a route path template.
     *
     * Supports:
     * - Required parameters: `/users/{id}`
     * - Optional segments:   `/users/{id?}`
     * - Wildcard catch-all:  `/files/{path*}`
     *
     * @param string               $template
     * @param array<string,string> $constraints
     *
     * @return string Regex pattern.
     */
    private function compileRoutePattern(string $template, array $constraints = []) : string
    {
        return '#^' . preg_replace_callback(
                pattern : '/\{(\w+)([?*]?)}/',
                callback: static function (array $match) use ($constraints) : string {
                    [$param, $modifier] = [$match[1], $match[2]];
                    $pattern = $constraints[$param] ?? '[^/]+';

                    return match ($modifier) {
                        '?'     => '(?:/(?P<' . $param . '>' . $pattern . '))?',
                        '*'     => '(?P<' . $param . '>.*)',
                        default => '(?P<' . $param . '>' . $pattern . ')'
                    };
                },
                subject : $template
            ) . '$#';
    }

    /**
     * Filters out numeric keys from regex match results to isolate named route parameters.
     *
     * @param array $matches Regex matches from `preg_match`.
     *
     * @return array<string, string>
     */
    private function extractParameters(array $matches) : array
    {
        return array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
    }

    /**
     * Applies both resolved route parameters and default values to the request object.
     *
     * @param Request              $request
     * @param array<string,string> $defaults
     * @param array<string,string> $parameters
     *
     * @return Request
     */
    private function applyRouteDefaults(Request $request, array $defaults, array $parameters) : Request
    {
        foreach ($parameters as $key => $value) {
            $request = $request->withAttribute(name: $key, value: $value);
        }

        foreach ($defaults as $key => $default) {
            if ($request->getAttribute(name: $key) === null) {
                $request = $request->withAttribute(name: $key, value: $default);
            }
        }

        return $request;
    }

    /**
     * Retrieves all registered routes.
     *
     * @return array<string, RouteDefinition[]>
     */
    public function allRoutes() : array
    {
        return $this->routes;
    }

    /**
     * Directly adds a compiled route definition to the router's table.
     * This bypasses validation and is used by the RouteCacheLoader.
     *
     * @param RouteDefinition $route The precompiled route to register.
     */
    public function add(RouteDefinition $route) : void
    {
        $method = strtoupper($route->method);

        if (! array_key_exists($method, $this->routes)) {
            $this->routes[$method] = [];
        }

        $this->routes[$method][$route->path] = $route;
    }

    /**
     * Retrieves a route by its unique name.
     *
     * @param string $name The name of the route.
     *
     * @return RouteDefinition
     *
     * @throws RouteNotFoundException
     */
    public function getByName(string $name) : RouteDefinition
    {
        if (! isset($this->namedRoutes[$name])) {
            throw new RouteNotFoundException(message: "Named route [{$name}] not found.");
        }

        return $this->namedRoutes[$name];
    }

    /**
     * Checks if a named route exists.
     *
     * @param string $name
     *
     * @return bool
     */
    public function hasNamedRoute(string $name) : bool
    {
        return isset($this->namedRoutes[$name]);
    }

    /**
     * Sets the fallback handler to be used when no route matches.
     *
     * @param callable|array|string $handler
     *
     * @return void
     */
    public function fallback(callable|array|string $handler) : void
    {
        $this->registerRoute(
            method: 'ANY',
            path  : '__fallback__',
            action: $handler,
            name  : '__router.fallback'
        );
    }
}

=== HTTP/Router/Routing/RouteBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Gemini\HTTP\Router\HttpMethod;
use InvalidArgumentException;

/**
 * Builds fluent-style HTTP route declarations for Gemini's router.
 *
 * Supports:
 * - Route prefixing and naming
 * - Middleware stacking
 * - Domain and authorization constraints
 * - Parameter constraints, defaults, and metadata
 * - Clean Architecture-aligned route definitions
 *
 * This class acts as a DSL-style immutable builder that produces `RouteDefinition` objects.
 */
final class RouteBuilder
{
    /** @var string HTTP method (GET, POST, etc.) */
    public readonly string $method;

    /** @var string The route URI path (e.g., /users/{id}) */
    public string $path;

    /** @var string|null Optional name for the route (used for reverse routing) */
    public string|null $name = null;

    /** @var array List of middleware to apply to the route */
    public array $middleware = [];

    /** @var callable|array|string|null The route's action target (controller, callable, etc.) */
    public mixed $action = null;

    /** @var array<string, string> Regex constraints for route parameters */
    public array $constraints = [];

    /** @var array<string, string> Default values for optional parameters */
    public array $defaults = [];

    /** @var string|null Optional domain constraint (e.g., admin.{org}.com) */
    public string|null $domain = null;

    /** @var array<string, mixed> Custom metadata attached to the route */
    public array $attributes = [];

    /** @var string|null Optional authorization policy identifier */
    public string|null $authorization = null;

    /**
     * Private constructor. Use RouteBuilder::make() instead.
     *
     * @param string $method HTTP method (GET, POST, etc.)
     * @param string $path   URI path starting with /
     *
     * @throws InvalidArgumentException
     */
    private function __construct(string $method, string $path)
    {
        $this->validateMethod(method: $method);
        $this->validatePath(path: $path);

        $this->method = strtoupper($method);
        $this->path   = $path;
    }

    /**
     * Validates that the HTTP method is allowed.
     *
     * @param string $method
     *
     * @return void
     * @throws InvalidArgumentException
     */
    private function validateMethod(string $method) : void
    {
        if (! HttpMethod::isValid(method: $method)) {
            throw new InvalidArgumentException(message: "Invalid HTTP method: {$method}");
        }
    }

    /**
     * Validates that the route path format is acceptable.
     *
     * @param string $path
     *
     * @return void
     * @throws InvalidArgumentException
     */
    private function validatePath(string $path) : void
    {
        if (! preg_match(pattern: '#^/[\w\-/{}]*$#', subject: $path)) {
            throw new InvalidArgumentException(message: "Invalid route path: {$path}");
        }
    }

    /**
     * Static factory to initialize a RouteBuilder.
     *
     * @param string $method
     * @param string $path
     *
     * @return self
     */
    public static function make(string $method, string $path) : self
    {
        $builder = new self(method: $method, path: $path);

        return RouteGroupStack::apply(builder: $builder);
    }


    /**
     * Gets the route name.
     *
     * @return string|null
     */
    public function getName() : string|null
    {
        return $this->name;
    }

    /**
     * @param string|null $name
     *
     * @return RouteBuilder
     */
    public function setName(?string $name) : RouteBuilder
    {
        $this->name = $name;

        return $this;
    }

    /**
     * Gets the middleware stack.
     *
     * @return array
     */
    public function getMiddleware() : array
    {
        return $this->middleware;
    }

    /**
     * @param array $middleware
     *
     * @return RouteBuilder
     */
    public function setMiddleware(array $middleware) : RouteBuilder
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Gets the route action.
     *
     * @return callable|array|string|null
     */
    public function getAction() : callable|array|string|null
    {
        return $this->action;
    }

    /**
     * @param mixed $action
     *
     * @return RouteBuilder
     */
    public function setAction(mixed $action) : RouteBuilder
    {
        $this->action = $action;

        return $this;
    }

    /**
     * Gets parameter constraints.
     *
     * @return array<string, string>
     */
    public function getConstraints() : array
    {
        return $this->constraints;
    }

    /**
     * @param array $constraints
     *
     * @return RouteBuilder
     */
    public function setConstraints(array $constraints) : RouteBuilder
    {
        $this->constraints = $constraints;

        return $this;
    }

    /**
     * Gets default values for parameters.
     *
     * @return array<string, string>
     */
    public function getDefaults() : array
    {
        return $this->defaults;
    }

    /**
     * @param array $defaults
     *
     * @return RouteBuilder
     */
    public function setDefaults(array $defaults) : RouteBuilder
    {
        $this->defaults = $defaults;

        return $this;
    }

    /**
     * Gets the domain constraint, if any.
     *
     * @return string|null
     */
    public function getDomain() : string|null
    {
        return $this->domain;
    }

    /**
     * @param string|null $domain
     *
     * @return RouteBuilder
     */
    public function setDomain(?string $domain) : RouteBuilder
    {
        $this->domain = $domain;

        return $this;
    }

    /**
     * Gets custom route attributes.
     *
     * @return array<string, mixed>
     */
    public function getAttributes() : array
    {
        return $this->attributes;
    }

    /**
     * @param array $attributes
     *
     * @return RouteBuilder
     */
    public function setAttributes(array $attributes) : RouteBuilder
    {
        $this->attributes = $attributes;

        return $this;
    }

    /**
     * @return string|null
     */
    public function getAuthorization() : ?string
    {
        return $this->authorization;
    }


    /**
     * @param string|null $authorization
     *
     * @return RouteBuilder
     */
    public function setAuthorization(?string $authorization) : RouteBuilder
    {
        $this->authorization = $authorization;

        return $this;
    }

    /**
     * Sets the route name.
     *
     * @param string $name
     *
     * @return self
     */
    public function name(string $name) : self
    {
        $this->name = $name;

        return $this;
    }

    // region: Validation

    /**
     * Sets the action target of the route.
     *
     * @param callable|array|string $action
     *
     * @return self
     */
    public function action(callable|array|string $action) : self
    {
        $this->action = $action;

        return $this;
    }

    /**
     * Shortcut for setting a controller and method.
     *
     * @param string $controller
     * @param string $method
     *
     * @return self
     */
    public function controller(string $controller, string $method = 'index') : self
    {
        $this->action = [$controller, $method];

        return $this;
    }

    /**
     * Attaches middleware to the route.
     *
     * @param array $middleware
     *
     * @return self
     */
    public function middleware(array $middleware) : self
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Assigns default values for optional route parameters.
     *
     * @param array<string, string> $defaults
     *
     * @return self
     */
    public function defaults(array $defaults) : self
    {
        $this->defaults = $defaults;

        return $this;
    }

    /**
     * Assigns a domain pattern to the route.
     *
     * @param string $domain
     *
     * @return self
     */
    public function withDomain(string $domain) : self
    {
        $this->domain = $domain;

        return $this;
    }

    /**
     * Attaches custom metadata (attributes) to the route.
     *
     * @param array<string, mixed> $attributes
     *
     * @return self
     */
    public function attributes(array $attributes) : self
    {
        $this->attributes = $attributes;

        return $this;
    }

    /**
     * Specifies an authorization policy identifier.
     *
     * @param string $policy
     *
     * @return self
     */
    public function withAuthorization(string $policy) : self
    {
        $this->authorization = $policy;

        return $this;
    }

    /**
     * Adds multiple route parameter constraints using regex.
     *
     * @param array<string, string> $constraints
     *
     * @return self
     * @throws InvalidArgumentException
     */
    public function whereIn(array $constraints) : self
    {
        foreach ($constraints as $param => $pattern) {
            $this->where(parameter: $param, pattern: $pattern);
        }

        return $this;
    }

    /**
     * Adds a single route parameter constraint using regex.
     *
     * @param string $parameter
     * @param string $pattern
     *
     * @return self
     * @throws InvalidArgumentException
     */
    public function where(string $parameter, string $pattern) : self
    {
        $this->validateConstraintPattern(pattern: $pattern);

        $this->constraints[$parameter] = $pattern;

        return $this;
    }

    /**
     * Ensures that the regex constraint is syntactically valid.
     *
     * @param string $pattern
     *
     * @return void
     * @throws InvalidArgumentException
     */
    private function validateConstraintPattern(string $pattern) : void
    {
        if (@preg_match(pattern: "/{$pattern}/", subject: '') === false) {
            throw new InvalidArgumentException(message: "Invalid constraint regex: {$pattern}");
        }
    }

    /**
     * Finalizes and compiles the route definition.
     *
     * @return RouteDefinition
     */
    public function build() : RouteDefinition
    {
        return new RouteDefinition(
            method       : $this->method,
            path         : $this->path,
            action       : $this->action,
            middleware   : $this->middleware,
            name         : $this->name ?? '',
            constraints  : $this->constraints,
            defaults     : $this->defaults,
            domain       : $this->domain,
            attributes   : $this->attributes,
            authorization: $this->authorization
        );
    }

    /**
     * Specifies a policy for route-level authorization.
     *
     * @param string $policy The authorization policy identifier.
     *
     * @return self
     */
    public function authorize(string $policy) : self
    {
        $this->authorization = $policy;

        return $this;
    }

    /**
     * Gets the HTTP method.
     *
     * @return string
     */
    public function getMethod() : string
    {
        return $this->method;
    }

    /**
     * Gets the path for the route.
     *
     * @return string
     */
    public function getPath() : string
    {
        return $this->path;
    }

}

=== HTTP/Router/Routing/RouteDefinition.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Closure;
use Gemini\HTTP\Router\HttpMethod;
use InvalidArgumentException;
use Laravel\SerializableClosure\SerializableClosure;

/**
 * Immutable data structure representing a registered HTTP route.
 *
 * Supports serializable closures via Laravel\SerializableClosure.
 */
final readonly class RouteDefinition
{
    /**
     * Constructor for initializing route details.
     *
     * @param string      $method        The HTTP method (e.g., GET, POST) for the route.
     * @param string      $path          The URI path for the route.
     * @param mixed       $action        The action or callback associated with the route.
     * @param array       $middleware    An array of middleware to be applied to the route.
     * @param string      $name          The name of the route, optional.
     * @param array       $constraints   An array of constraints for the route parameters.
     * @param array       $defaults      An array of default values for route parameters.
     * @param string|null $domain        The domain name associated with the route, optional.
     * @param array       $attributes    Additional attributes for the route.
     * @param string|null $authorization The authorization key or identifier for the route, optional.
     * @param array       $parameters    An array of parameters to be passed to the route, optional.
     *
     * @return void
     */
    public function __construct(
        public string      $method,
        public string      $path,
        public mixed       $action,
        public array       $middleware = [],
        public string      $name = '',
        public array       $constraints = [],
        public array       $defaults = [],
        public string|null $domain = null,
        public array       $attributes = [],
        public string|null $authorization = null,
        public array       $parameters = []
    ) {
        $this->validateMethod(method: $method);
        $this->validatePath(path: $path);
        $this->validateConstraints(constraints: $constraints);
    }

    /**
     * Validates the HTTP method against supported ones.
     *
     * @throws InvalidArgumentException
     */
    private function validateMethod(string $method) : void
    {
        if (! HttpMethod::isValid(method: $method)) {
            throw new InvalidArgumentException(message: sprintf('Invalid HTTP method: %s', $method));
        }
    }

    /**
     * Validates the route path format.
     *
     * @throws InvalidArgumentException
     */
    private function validatePath(string $path) : void
    {
        if (! preg_match(pattern: '#^/[\w\-/{}]*$#', subject: $path)) {
            throw new InvalidArgumentException(message: sprintf('Invalid route path: %s', $path));
        }
    }

    /**
     * Validates all regex constraints.
     *
     * @throws InvalidArgumentException
     */
    private function validateConstraints(array $constraints) : void
    {
        foreach ($constraints as $pattern) {
            if (@preg_match('/' . $pattern . '/', '') === false) {
                throw new InvalidArgumentException(message: sprintf('Invalid regex constraint: %s', $pattern));
            }
        }
    }

    public static function __set_state(array $properties) : self
    {
        return new self(
            method       : $properties['method'],
            path         : $properties['path'],
            action       : $properties['action'],
            middleware   : $properties['middleware'],
            name         : $properties['name'],
            constraints  : $properties['constraints'],
            defaults     : $properties['defaults'],
            domain       : $properties['domain'],
            attributes   : $properties['attributes'],
            authorization: $properties['authorization'],
            parameters   : $properties['parameters'] ?? []
        );
    }


    /**
     * Returns a copy of the route with the action wrapped in a SerializableClosure (if needed).
     *
     * @return self
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     */
    public function withSerializedAction() : self
    {
        $action = $this->action instanceof Closure
            ? new SerializableClosure($this->action)
            : $this->action;

        return new self(
            method       : $this->method,
            path         : $this->path,
            action       : $action,
            middleware   : $this->middleware,
            name         : $this->name,
            constraints  : $this->constraints,
            defaults     : $this->defaults,
            domain       : $this->domain,
            attributes   : $this->attributes,
            authorization: $this->authorization
        );
    }

    /**
     * Returns a copy of the route with the action unwrapped (if it's a SerializableClosure).
     *
     * @return self
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     */
    public function withUnserializedAction() : self
    {
        $action = $this->action instanceof SerializableClosure
            ? $this->action->getClosure()
            : $this->action;

        return new self(
            method       : $this->method,
            path         : $this->path,
            action       : $action,
            middleware   : $this->middleware,
            name         : $this->name,
            constraints  : $this->constraints,
            defaults     : $this->defaults,
            domain       : $this->domain,
            attributes   : $this->attributes,
            authorization: $this->authorization
        );
    }

    /**
     * Checks if the given parameter has a constraint.
     */
    public function hasConstraint(string $parameter) : bool
    {
        return array_key_exists($parameter, $this->constraints);
    }

    /**
     * Returns the regex constraint for a route parameter.
     */
    public function getConstraint(string $parameter) : string|null
    {
        return $this->constraints[$parameter] ?? null;
    }

    public function usesClosure() : bool
    {
        return $this->action instanceof Closure;
    }
}

=== HTTP/Router/Routing/RouteGroupAttributesConfigurator.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use InvalidArgumentException;

/**
 * The `RouteGroupAttributesConfigurator` class is responsible for configuring
 * a route group context by applying a set of attributes like prefix, middleware,
 * domain, and more.
 *
 * This class uses the Strategy design pattern to map each attribute to its
 * respective handler, ensuring extensibility and separation of responsibilities.
 */
final class RouteGroupAttributesConfigurator
{
    /**
     * Map of supported route group attributes and their respective handlers,
     * defined as callable strategies. Each attributes key maps to a closure/function
     * that modifies the `RouteGroupContext`.
     *
     * @var array<string, callable(RouteGroupContext, mixed): void> A map of attribute keys and their handlers.
     */
    private array $strategies;

    /**
     * Constructor of the class.
     *
     * Initializes the mapping of available attribute handlers (`$strategies`) with
     * their processing logic defined as closures. Using constructor promotion for
     * a lean and expressive instantiation process.
     */
    public function __construct()
    {
        // Initializes the strategy map with closures for each supported attribute:
        $this->strategies = [
            /**
             * Strategy for handling 'prefix' - converts the value to a string
             * and applies it as a prefix to the route group context.
             */
            'prefix'     => fn(RouteGroupContext $context, mixed $value) => $context->setPrefix((string) $value),

            /**
             * Strategy for handling 'middleware' - converts the value to an array
             * and appends the middleware to the route group context.
             */
            'middleware' => fn(RouteGroupContext $context, mixed $value) => $context->addMiddleware(
                (array) $value
            ),

            /**
             * Strategy for handling 'domain' - converts the value to a string
             * and sets it as the domain for the route group context.
             */
            'domain'     => fn(RouteGroupContext $context, mixed $value) => $context->setDomain((string) $value),

            /**
             * Strategy for handling 'name' - converts the value to a string
             * and applies it as a prefix to the names of route group context
             * names.
             */
            'name'       => fn(RouteGroupContext $context, mixed $value) => $context->setNamePrefix(
                (string) $value
            ),

            /**
             * Strategy for handling 'authorize' - converts the value to a string
             * and sets it as authorization for the route group context.
             */
            'authorize'  => fn(RouteGroupContext $context, mixed $value) => $context->setAuthorization(
                (string) $value
            ),

            // Additional attribute types can be added here following the same pattern, maintaining extensibility.
        ];
    }

    /**
     * Applies the provided attributes to the given route group context.
     *
     * Iterates through each key-value pair of attributes, validates the key
     * against the supported strategies, and applies the corresponding
     * handler to modify the `RouteGroupContext`.
     *
     * @param array<string, mixed> $attributes A map of attributes to be configured for the route group context (e.g.,
     *                                         'prefix' => '/api').
     * @param RouteGroupContext    $context    The route group context where the attributes will be applied.
     *
     * @throws InvalidArgumentException If an attribute key is not recognized or unsupported.
     */
    public function apply(array $attributes, RouteGroupContext $context) : void
    {
        // Iterate over each key-value pair of attributes.
        foreach ($attributes as $attribute => $value) {
            // Check if the attribute is supported by existing strategies.
            if (! isset($this->strategies[$attribute])) {
                // If not supported, throw an exception to enforce proper usage.
                throw new InvalidArgumentException(
                    sprintf('Unsupported route group attribute: %s', $attribute)
                );
            }

            // Execute the corresponding strategy using a callable, passing in
            // the target context and the attribute value.
            ($this->strategies[$attribute])($context, $value);
        }
    }
}
=== HTTP/Router/Routing/RouteGroupBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Closure;
use Gemini\HTTP\Router\HttpMethod;
use InvalidArgumentException;
use RuntimeException;

/**
 * Builder class for defining grouped routes in a fluent, immutable way.
 *
 * Supports:
 * - Prefix inheritance
 * - Shared middleware
 * - Domain pattern binding
 * - Route-level authorization
 * - Group composition via callback (closure nesting)
 */
final readonly class RouteGroupBuilder
{
    /**
     * @param string|null    $prefix
     * @param array<string>  $middleware
     * @param string|null    $domain
     * @param string|null    $authorization
     * @param RouteBuilder[] $routes
     */
    private function __construct(
        private string|null $prefix = null,
        private array       $middleware = [],
        private string|null $domain = null,
        private string|null $authorization = null,
        private array       $routes = []
    ) {}

    /**
     * Factory method to create a new, empty RouteGroup instance.
     *
     * @return self A new RouteGroup object representing a blank, default group.
     */
    public static function create() : self
    {
        // Create and return a new RouteGroup instance with default settings.
        return new self();
    }

    /**
     * Creates a new RouteGroup with a specified prefix.
     *
     * @param string $prefix The prefix to apply to all routes in the group.
     *
     * @return self A new RouteGroup object with the specified prefix.
     */
    public function withPrefix(string $prefix) : self
    {
        // Creates a new immutable route group with the modified prefix.
        return new self(
            prefix       : rtrim($prefix, '/'), // Ensure no trailing slash on the prefix.
            middleware   : $this->middleware, // Reuse the existing middleware.
            domain       : $this->domain, // Keep the existing domain value.
            authorization: $this->authorization, // Maintain the same authorization.
            routes       : $this->routes // Carry over the existing routes.
        );
    }

    /**
     * Adds middleware to this group's middleware stack.
     * The middleware list is merged with any existing middlewares.
     *
     * @param array<string> $middleware A list of middleware to add to the group.
     *
     * @return self A new RouteGroup object with the updated middleware stack.
     */
    public function withMiddleware(array $middleware) : self
    {
        // Create a new immutable instance with the combined middleware.
        return new self(
            prefix       : $this->prefix, // Retain the existing route prefix.
            middleware   : array_merge($this->middleware, $middleware), // Merge old and new middleware.
            domain       : $this->domain, // Keep the existing domain restriction.
            authorization: $this->authorization, // Maintain the same authorization.
            routes       : $this->routes // Preserve the existing group routes.
        );
    }

    /**
     * Defines an authorization policy for all routes in this group.
     *
     * @param string $policy The name of the authorization policy to apply.
     *
     * @return self A new RouteGroup object with the specified authorization policy.
     */
    public function withAuthorization(string $policy) : self
    {
        // Create a new immutable instance with the updated authorization policy.
        return new self(
            prefix       : $this->prefix, // Reuse the existing route prefix.
            middleware   : $this->middleware, // Retain the middleware stack.
            domain       : $this->domain, // Keep the domain restriction as is.
            authorization: $policy, // Apply the new authorization policy.
            routes       : $this->routes // Carry over the route definitions.
        );
    }

    /**
     * Adds one or more routes via closure DSL.
     *
     * Example:
     * ```
     * ->withRoutes(fn(RouteGroupBuilder $g) => $g
     *      ->addRoute(...)->addRoute(...)
     * )
     * ```
     */
    public function withRoutes(Closure $callback) : self
    {
        // Invoke the callback, passing a cloned instance of the current object ($this).
        // This allows the callback to define routes within its own scope without altering the original object.
        $nested = $callback(clone $this);

        // Check if the result of the callback is an instance of the current class (RouteGroupBuilder).
        // If not, throw a RuntimeException to ensure the callback strictly returns a valid RouteGroupBuilder instance.
        if (! $nested instanceof self) {
            throw new RuntimeException(message: 'Callback to withRoutes() must return a RouteGroupBuilder instance.');
        }

        // Return a new instance of the RouteGroupBuilder class,
        // preserving the prefix, middleware, domain, and authorization of the current instance.
        // For routes, merge the routes from the current instance ($this->routes) with those from the nested instance ($nested->routes).
        // The new instance represents the combined state of the current and nested route group builders.
        return new self(
            prefix       : $this->prefix,        // Maintain the prefix of the current route group.
            middleware   : $this->middleware,    // Maintain the middleware of the current route group.
            domain       : $this->domain,        // Maintain the domain of the current route group.
            authorization: $this->authorization, // Maintain the authorization policies of the current route group.
            routes       : [...$this->routes, ...$nested->routes] // Merge the existing and nested routes.
        );
    }

    /**
     * Adds a single route to the group.
     *
     * @param string                $method HTTP verb
     * @param string                $path   Route path
     * @param callable|array|string $action Target controller or callable
     *
     * @return self
     */
    public function addRoute(string $method, string $path, callable|array|string $action) : self
    {
        // Validate if the provided HTTP method is valid using the HttpMethod enumeration.
        // Throw an exception if the HTTP method is invalid.
        if (! HttpMethod::isValid(method: $method)) {
            throw new InvalidArgumentException(message: "Invalid HTTP method: {$method}");
        }

        // Create a new RouteBuilder instance with the validated HTTP method and the prefixed path.
        // Assign the provided action (e.g., controller method or callback) to the route.
        // Assign middleware (e.g., authentication, logging) to the route.
        $route = RouteBuilder::make(
            method: $method,
            path  : $this->applyPrefix($path)

        )
            ->action(action: $action)
            ->middleware(middleware: $this->middleware);

        // Add a domain to the route if a specific domain is defined.
        if ($this->domain !== null) {
            $route = $route->withDomain(domain: $this->domain);
        }

        // Assign an authorization policy to the route if one is provided.
        if ($this->authorization !== null) {
            $route = $route->authorize(policy: $this->authorization);
        }

        // Create a new instance of the current class, extending the existing routes
        // with the newly configured route, and preserving other properties like
        // prefix, middleware, domain, and authorization.
        return new self(
        // Maintain the current URL prefix for the routes.
            prefix       : $this->prefix,
            // Maintain the current list of middleware.
            middleware   : $this->middleware,
            // Maintain the current domain (if any).
            domain       : $this->domain,
            // Maintain the current authorization policy (if any).
            authorization: $this->authorization,
            // Append the newly configured route to the list of existing routes.
            routes       : [...$this->routes, $route]
        );
    }

    /**
     * Factory method to create a new instance of the RouteGroupBuilder class.
     *
     * This method acts as the default entry point for creating a new route group object.
     * It ensures a clean, well-defined instantiation process that allows for method chaining
     * and controlled manipulation of routes and associated properties like middleware,
     * authorization, and prefix. Ideal for managing route groups in scalable applications.
     *
     * @return self Returns a new instance of the RouteGroupBuilder class.
     */
    public static function make() : self
    {
        // Instantiate and return a new RouteGroupBuilder with default values.
        return new self();
    }


    /**
     * Applies the group prefix to a given path.
     *
     * This method is responsible for ensuring that routes within a group
     * are correctly prefixed. If no prefix is defined (i.e., `$prefix` is null),
     * it returns the provided path as-is. Otherwise, it joins the prefix and path
     * with a single forward slash (`/`) to preserve uniformity in URL structure.
     *
     * @param string $path The specific route path to which the prefix should be applied.
     *
     * @return string The modified path with the applied prefix, or the original path if no prefix is set.
     */
    private function applyPrefix(string $path) : string
    {
        // Check if the `prefix` property is null (no prefix defined).
        // If null, simply return the provided path without any modifications.
        if ($this->prefix === null) {
            return $path;
        }

        // Append the given path to the prefix while managing slash consistency.
        // - Use `rtrim` to strip any trailing slashes from the prefix.
        // - Use `ltrim` to remove any leading slashes from the provided path.
        // - This ensures a single forward slash (`/`) separates the prefix and path.
        return rtrim($this->prefix, '/') . '/' . ltrim($path, '/');
    }


    /**
     * Sets a domain constraint for all routes in the group.
     *
     * This method is part of the fluent API for configuring route groups.
     * It allows you to specify that all routes in the group should apply
     * to a specific domain. This is useful for implementing multi-tenant
     * architectures, subdomain routing, or domain-specific behavior.
     *
     * @param string $domain The domain constraint to be applied to the routes
     *                       within this group.
     *
     * @return self Returns a new instance of the `RouteGroupBuilder` class
     *              with the specified domain applied, ensuring immutability.
     */
    public function withDomain(string $domain) : self
    {
        // Create and return a new instance of the RouteGroupBuilder class
        // with the updated domain while preserving all other properties.
        return new self(
            prefix       : $this->prefix,        // Keep the current route prefix.
            middleware   : $this->middleware,    // Retain the middleware stack.
            domain       : $domain,              // Set the new domain constraint.
            authorization: $this->authorization, // Retain the authorization policy.
            routes       : $this->routes         // Retain the existing routes.
        );
    }

    /**
     * Builds all defined routes.
     *
     * Converts the routes defined within the `RouteGroupBuilder` to their
     * respective `RouteDefinition` objects by invoking their `build()`
     * methods. This allows the route definitions to be finalized and used
     * by the routing system.
     *
     * This method adheres to the principle of immutability by performing its
     * operations without modifying the internal state of the `RouteGroupBuilder`.
     * This makes the function predictable and side effect free.
     *
     * @return RouteDefinition[] An array of `RouteDefinition` instances,
     *                           representing the fully finalized routes
     *                           within this route group.
     */
    public function build() : array
    {
        // Use array_map to iterate over the list of routes and
        // invoke the `build()` method on each `RouteBuilder` instance.
        // This results in an array where every route is now a finalized
        // `RouteDefinition` object.
        return array_map(
            static fn(RouteBuilder $r) => $r->build(), // Transform RouteBuilder into RouteDefinition.
            $this->routes                // The array of RouteBuilder instances to process.
        );
    }

    /**
     * Internal helper method to apply the group’s prefix to a given path.
     *
     * This function ensures that all paths defined in the route group are
     * consistent and properly prefixed. For instance, if the group has a prefix
     * like `/admin`, each route within it will start with `/admin`.
     *
     * - If no prefix is set (`$this->prefix` is null), the method simply returns the original path.
     * - Otherwise, it concatenates the prefix to the given path string.
     *
     * This approach adheres to clean code principles by isolating this functionality
     * within a private helper, ensuring the prefix logic remains reusable and easily testable.
     *
     * @param string $path The original route path to be prefixed.
     *
     * @return string Returns the prefixed path, or the original if no prefix is defined.
     */
    private function prefixed(string $path) : string
    {
        // Check if the prefix is not set; if null, return the path as is.
        if ($this->prefix === null) {
            return $path;
        }

        // Concatenate the prefix with the provided path and return it.
        return $this->prefix . $path;
    }
}

=== HTTP/Router/Routing/RouteGroupContext.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

/**
 * Represents a context for grouping multiple routes with shared properties.
 *
 * This class is utilized to apply shared configurations such as prefixes, middleware,
 * domain, and authorization to a group of routes in a router.
 *
 * @package Gemini\HTTP\Router\Routing
 */
final class RouteGroupContext
{
    /**
     * Prefix for naming routes within this group.
     *
     * This property is prepended to all route names in the group,
     * providing a consistent and unique identifier structure.
     *
     * @var string|null
     */
    public string|null $namePrefix  = null;

    public array       $constraints = [];

    public array       $defaults    = [];

    public array       $attributes  = [];

    /**
     * Constructor for initializing the RouteGroupContext with optional settings.
     *
     * @param string|null $prefix        The path prefix to be applied to all routes in the group.
     * @param array|null  $middleware    A list of middleware classes to be applied to routes in the group.
     * @param string|null $domain        The domain constraint to be applied to all routes in the group.
     * @param string|null $authorization The authorization policy applied to all routes in the group.
     */
    public function __construct(
        public string|null $prefix = null,
        public array|null  $middleware = null,
        public string|null $domain = null,
        public string|null $authorization = null,
    ) {}

    /**
     * Sets a name prefix for the route group.
     *
     * Route names within this group will be prefixed with the provided value.
     * Trailing dots are ensured to maintain a proper naming convention.
     *
     * @param string $prefix The prefix to apply to the route names.
     *
     * @return void
     */
    public function setNamePrefix(string $prefix) : void
    {
        $this->namePrefix = rtrim($prefix, '.') . '.';
    }

    /**
     * Apply the defined customizations to the given `RouteBuilder`.
     *
     * The method modifies the `RouteBuilder` in place by:
     * - Prepending the configured `$prefix` to the route's path.
     * - Merging middleware, constraints, defaults, and attributes with the builder's existing properties.
     * - Assigning a custom domain and authorization, if specified.
     * - Applying a name prefix for route naming conventions.
     *
     * @param RouteBuilder $builder The route builder instance to be customized.
     *
     * @return RouteBuilder Returns the modified route builder instance.
     */
    public function applyTo(RouteBuilder $builder) : RouteBuilder
    {
        // If a prefix is defined, prepend it to the route's existing path.
        if ($this->prefix !== null) {
            $builder->path = rtrim($this->prefix, '/') . $builder->path;
        }

        // If middleware is defined, merge it with the existing middleware stack.
        if (! empty($this->middleware)) {
            $builder->middleware = array_merge($builder->middleware, $this->middleware);
        }

        // If a domain is set, replace the builder's existing domain with the configured one.
        if ($this->domain !== null) {
            $builder->domain = $this->domain;
        }

        // If an authorization configuration exists, assign it to the builder.
        if ($this->authorization !== null) {
            $builder->authorization = $this->authorization;
        }

        // Merge the defined constraints with the builder's existing constraints.
        if (! empty($this->constraints)) {
            $builder->constraints = array_merge($builder->constraints, $this->constraints);
        }

        // Merge the defined defaults with the builder's existing default values.
        if (! empty($this->defaults)) {
            $builder->defaults = array_merge($builder->defaults, $this->defaults);
        }

        // Merge the defined attributes with the builder's existing attributes.
        if (! empty($this->attributes)) {
            $builder->attributes = array_merge($builder->attributes, $this->attributes);
        }

        // If a name prefix is defined, apply it to the route's name, maintaining naming conventions.
        if ($this->namePrefix !== null && $builder->name !== null) {
            $builder->name = $this->namePrefix . $builder->name;
        }

        // Return the modified RouteBuilder instance.
        return $builder;
    }


    /**
     * Sets the path prefix for the current route group.
     *
     * This path prefix provides a structured namespace for all routes
     * within the group, ensuring a logical URL hierarchy.
     *
     * @param string $prefix The route path prefix, typically a non-empty string.
     *                       For example: "api/v1" or "admin".
     *
     * @return void
     */
    public function setPrefix(string $prefix) : void
    {
        // Normalize the prefix by trimming trailing slashes to prevent
        // issues with inconsistent path generation.
        $this->prefix = rtrim($prefix, '/');
    }

    /**
     * Adds additional middleware to the group context.
     *
     * This method allows appending new middleware handlers onto the
     * existing middleware stack to provide a flexible, composable
     * routing pipeline.
     *
     * @param array $middleware A list of middleware to add, each represented
     *                          typically as a callable or handler class name.
     *
     * @return void
     */
    public function addMiddleware(array $middleware) : void
    {
        // Initialize middleware stack if not set.
        $this->middleware ??= [];

        // Merge the new middleware with the existing stack, ensuring the existing
        // middleware and new handlers are preserved.
        $this->middleware = array_merge($this->middleware, $middleware);
    }

    /**
     * Sets the domain constraint for all routes in the group.
     *
     * This domain constraint ensures that the routes in the group
     * are only accessible from a specific domain.
     *
     * @param string $domain The domain to apply to the route group.
     *
     * @return void
     */
    public function setDomain(string $domain) : void
    {
        $this->domain = $domain;
    }

    /**
     * Sets the authorization policy for all routes in the group.
     *
     * This policy defines the access control handling for the routes
     * making it a critical part of securing route groups.
     *
     * @param string $authorization The authorization policy identifier or configuration.
     *
     * @return void
     */
    public function setAuthorization(string $authorization) : void
    {
        $this->authorization = $authorization;
    }

    /**
     * Adds default values to this route group context.
     *
     * Defaults are used to fill in missing values for route parameters
     * when they are not explicitly provided in the request.
     *
     * @param array<string, mixed> $defaults Key-value pairs of default values to add.
     *
     * @return void
     */
    public function addDefaults(array $defaults) : void
    {
        // Merge the new defaults into the existing defaults
        $this->defaults = array_merge($this->defaults, $defaults);
    }

    /**
     * Adds attributes to the route group context.
     *
     * Attributes are useful for providing metadata or additional
     * information for routing, middleware, or custom processing logic.
     *
     * @param array<string, mixed> $attributes Key-value pairs of attributes to add.
     *
     * @return void
     */
    public function addAttributes(array $attributes) : void
    {
        // Merge the new attributes into the existing attributes
        $this->attributes = array_merge($this->attributes, $attributes);
    }

    /**
     * Adds parameter constraints (regex patterns) to the route group context.
     *
     * These constraints will be merged and applied to all routes within the group.
     *
     * @param array<string, string> $constraints Parameter name to regex mapping.
     *
     * @return void
     */
    public function addConstraints(array $constraints) : void
    {
        $this->constraints = array_merge($this->constraints, $constraints);
    }

}
=== HTTP/Router/Routing/RouteGroupRegistrar.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use CallbackFilterIterator;
use FilesystemIterator;
use Gemini\HTTP\Router\Router;
use LogicException;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;
use Throwable;

final class RouteGroupRegistrar
{
    /**
     * Recursively loads and registers all route definition files from a given base directory.
     *
     * Each route file should use `$router = app(Router::class);` to register routes directly.
     *
     * @param string $baseDir
     *
     * @throws LogicException
     */
    public function registerFromDirectory(string $baseDir) : void
    {
        $this->ensureDirectoryIsValid(baseDir: $baseDir);

        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveDirectoryIterator(directory: $baseDir, flags: FilesystemIterator::SKIP_DOTS)
        );

        $files = iterator_to_array(
            new CallbackFilterIterator(
                iterator: $iterator,
                callback: static fn(SplFileInfo $file) => $file->isFile() && $file->getExtension() === 'php'
            )
        );

        foreach ($files as $file) {
            $router = app(abstract: Router::class);

            try {
                (static function () use ($file, $router) {
                    require $file->getPathname();
                })();

                $buffered = Router::flushBuffered();

                if (empty($buffered)) {
                    echo "⚠️  [{$file->getFilename()}] did not register any routes.\n";
                    continue;
                }

                foreach ($buffered as $builder) {
                    $router->registerRoute($builder);
                }
            } catch (Throwable $e) {
                throw new RuntimeException(
                    message : "Failed to load route file [{$file->getFilename()}]: {$e->getMessage()}",
                    code    : 0,
                    previous: $e
                );
            }
        }
    }

    /**
     * Ensures the routes directory exists and is readable.
     *
     * @param string $baseDir
     *
     * @throws LogicException
     */
    private function ensureDirectoryIsValid(string $baseDir) : void
    {
        if (! is_dir($baseDir) || ! is_readable($baseDir)) {
            throw new LogicException(message: "Routes directory '{$baseDir}' does not exist or is not readable.");
        }
    }
}

=== HTTP/Router/Routing/RouteGroupStack.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

/**
 * A class representing a stack-based storage for managing route group contexts.
 *
 * This stack allows you to maintain the state of nested route group configurations
 * while routing requests. It provides the ability to push a new context to the stack,
 * pop the latest context, or retrieve the current (top-most) context.
 *
 * The class is implemented as a static utility to maintain a global stateful behavior
 * for managing `RouteGroupContext`.
 */
final class RouteGroupStack
{
    /**
     * Static stack containing the list of RouteGroupContext instances.
     *
     * @var RouteGroupContext[] Stack of route group contexts for managing
     *                          nested routing configurations.
     */
    private static array $stack = [];

    /**
     * Contains an internal list of mapped constraints for the current route group.
     *
     * @var array<string, mixed> Associative array where keys represent constraint
     *                           identifiers (e.g., parameter names or attributes),
     *                           and values represent the corresponding constraint
     *                           values or callable validators applied during route
     *                           matching logic.
     */
    private array $constraints = [];

    /**
     * Pushes a new RouteGroupContext onto the stack.
     *
     * This method represents entering a new route group context in the routing lifecycle.
     *
     * @param RouteGroupContext $group The context to be added to the stack.
     *
     * @return void
     */
    public static function push(RouteGroupContext $group) : void
    {
        // Append the provided RouteGroupContext onto the stack.
        self::$stack[] = $group;
    }

    /**
     * Pops the most recently added RouteGroupContext from the stack.
     *
     * This method represents exiting the current route group context in the routing lifecycle.
     *
     * @return void
     */
    public static function pop() : void
    {
        // Remove the most recent context from the stack.
        array_pop(self::$stack);
    }

    /**
     * This is a stateless utility method that applies context-specific configuration
     * to a given RouteBuilder instance. This method uses the current application
     * context to dynamically alter the behavior of the routing builder.
     *
     * Example usage:
     *
     * ```
     * $builder = AppRouter::apply($builder);
     * ```
     *
     * @param RouteBuilder $builder Instance of the RouteBuilder object to be configured.
     *
     * @return RouteBuilder Returns the original RouteBuilder instance, potentially
     *                      altered by the context, or returns it unmodified if no context exists.
     */
    public static function apply(RouteBuilder $builder) : RouteBuilder
    {
        // Get the current application context, which encapsulates dynamic state or configuration.
        $context = self::current();

        // If the $context instance exists, apply the context-specific modifications
        // to the provided RouteBuilder ($builder). If no context is available, return
        // the unmodified $builder instance.
        return $context?->applyTo($builder) ?? $builder;
    }

    /**
     * Retrieves the current (top-most) RouteGroupContext from the stack.
     *
     * The top-most context refers to the one most recently added via `push`.
     * If the stack is empty, this method will return `null`.
     *
     * @return RouteGroupContext|null The current context or `null` if the stack is empty.
     */
    public static function current() : RouteGroupContext|null
    {
        // Get the last context from the stack without removing it.
        return end(self::$stack) ?: null;
    }

    /**
     * Adds a set of parameter constraints to the current route group configuration.
     *
     * This method is used to define validation constraints or patterns for parameters
     * within the current routing scope. These constraints are later applied during
     * route matching to ensure the parameters satisfy the defined rules.
     *
     * Example usage:
     * ```
     * $routeGroup->addConstraints([
     *     'id' => '\d+',
     *     'slug' => '[a-z0-9-]+',
     * ]);
     * ```
     *
     * @param array<string, mixed> $constraints An associative array of constraints where the keys
     *                                          represent parameter names (e.g., 'id', 'slug') and
     *                                          the values represent the constraint patterns or
     *                                          validation rules (e.g., regex or callbacks).
     *
     * @return void This method does not return a value.
     */
    public function addConstraints(array $constraints) : void
    {
        // Iterate over the provided associative array of constraints.
        foreach ($constraints as $param => $pattern) {
            // Add or update the constraint for the specified parameter name ($param).
            // Each constraint pattern is stored in the $constraints property for later use.
            $this->constraints[$param] = $pattern;
        }
    }

    /**
     * Retrieves the constraints associated with this route group.
     *
     * Constraints are applied to routes contained within the group and serve
     * as a configuration mechanism for managing shared logic or rules that
     * affect grouped routes.
     *
     * The constraints are returned as-is (no deep or defensive copy is made), so external
     * modifications to the returned array may inadvertently affect the state of the object.
     * Use caution when manipulating the returned array directly.
     *
     * @return array The array of constraints associated with this route group.
     */
    public function getConstraints() : array
    {
        // Return the array of constraints currently associated with this route group.
        return $this->constraints;
    }
}
=== HTTP/Router/Routing/RoutePipelineFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Gemini\Container\Contracts\ContainerInterface;
use Gemini\HTTP\Dispatcher\ControllerDispatcher;
use Gemini\HTTP\Middleware\MiddlewareResolver;

/**
 * Factory class that constructs and initializes a complete route pipeline for dispatch.
 *
 * The `RoutePipelineFactory` is a fundamental part of request handling. It integrates
 * the resolved middleware, the routing definitions, and dependencies like the controller
 * dispatcher and IoC container to create a fully prepared route execution pipeline.
 */
final readonly class RoutePipelineFactory
{
    /**
     * Constructor for the RoutePipelineFactory.
     *
     * This method leverages the constructor promotion feature in PHP to simplify property initialization.
     * The dependencies required for constructing a route pipeline—IoC
     * container, controller dispatcher, and middleware resolver—are injected via the constructor.
     *
     * @param ContainerInterface   $container          The application container for managing services.
     * @param ControllerDispatcher $dispatcher         The dispatcher responsible for managing controller execution.
     * @param MiddlewareResolver   $middlewareResolver Middleware resolver for resolving middleware definitions.
     */
    public function __construct(
        private ContainerInterface   $container,
        private ControllerDispatcher $dispatcher,
        private MiddlewareResolver   $middlewareResolver,
    ) {}

    /**
     * Factory method for creating a fully resolved route pipeline.
     *
     * This method uses the provided route definition to fetch middleware, resolve their instances
     * using the MiddlewareResolver, and then constructs a new RoutePipeline. The pipeline
     * is configured with middleware and is ready for dispatch.
     *
     * @param RouteDefinition $route The route definition, containing route-specific information such as middleware.
     *
     * @return RoutePipeline A fully constructed pipeline configured with resolved middleware.
     */
    public function create(RouteDefinition $route) : RoutePipeline
    {
        // Resolving middleware definitions from the route into callable middleware instances.
        $resolvedMiddleware = $this->middlewareResolver->resolve($route->middleware);

        // Constructing a new RoutePipeline with the resolved dependencies and injecting middleware.
        // This step prepares the pipeline to handle HTTP requests for the given route.
        return (new RoutePipeline(
            route     : $route,       // Injecting the route definition into the pipeline.
            dispatcher: $this->dispatcher, // Injecting the dispatcher for controller execution.
            container : $this->container  // Injecting the IoC container for dependency resolution.
        ))->through(middleware: $resolvedMiddleware); // Configuring the pipeline with the resolved middleware.
    }
}
=== HTTP/Router/Routing/RoutePipeline.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Closure;
use Gemini\Auth\Interface\HTTP\Middleware\AuthorizeMiddleware;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\HTTP\Dispatcher\ControllerDispatcher;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;
use RuntimeException;

/**
 * Class RoutePipeline
 *
 * Manages the execution pipeline for handling incoming HTTP requests
 * through applied middleware, optional route stages, and finally dispatching
 * the matched route action to the appropriate controller.
 *
 * Responsibilities:
 * - Applies middleware and route-specific stages (e.g., logging, tracing).
 * - Injects route-level authorization middleware when necessary.
 * - Provides a fluent API for pipeline configuration.
 */
final class RoutePipeline
{
    /**
     * List of middleware to be applied in the processing pipeline.
     *
     * @var array<string|class-string>
     */
    private array $middleware = [];

    /**
     * Optional predefined stages (e.g., for logging, tracing) to augment the pipeline.
     *
     * @var array<class-string<RouteStage>>
     */
    private array $stages = [];

    /**
     * Constructor
     *
     * Initializes the pipeline using the provided route definition and dispatcher.
     *
     * @param RouteDefinition      $route      The route definition to bind to the pipeline.
     * @param ControllerDispatcher $dispatcher Handles the final dispatching of the controller action.
     */
    public function __construct(
        private readonly RouteDefinition      $route,
        private readonly ControllerDispatcher $dispatcher,
        private readonly ContainerInterface   $container
    ) {}

    /**
     * Factory method for constructing the pipeline instance
     * with the route and dispatcher, promoting fluent API usage.
     *
     * @param RouteDefinition      $route      The route definition to be handled.
     * @param ControllerDispatcher $dispatcher Used to invoke controller methods.
     *
     * @return self                        A new instance of RoutePipeline.
     */
    public static function for(
        RouteDefinition      $route,
        ControllerDispatcher $dispatcher,
        ContainerInterface   $container
    ) : self {
        return new self(
            route     : $route,
            dispatcher: $dispatcher,
            container : $container
        );
    }

    /**
     * Adds middleware to the processing pipeline.
     *
     * Allows dynamic insertion of middleware for the current route processing.
     *
     * @param array<string|class-string> $middleware Array of middleware class names or middleware identifiers.
     *
     * @return self The current instance, for fluent API usage.
     */
    public function through(array $middleware) : self
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Adds optional stages to the processing pipeline.
     *
     * Stages add auxiliary functionality to the route processing, like logging
     * or telemetry tracking, without interfering with core middleware logic.
     *
     * @param array<class-string<RouteStage>> $stages List of stage class names.
     *
     * @return self The current instance, for fluent API chaining.
     */
    public function stages(array $stages) : self
    {
        $this->stages = $stages;

        return $this;
    }

    /**
     * Dispatches a request through the pipeline.
     *
     * The dispatch process follows these steps:
     * - Optionally injects authorization middleware if the route requires it.
     * - Builds the middleware pipeline, including optional stages.
     * - Executes the pipeline, ultimately invoking the associated route action.
     *
     * @param Request $request The current HTTP request to process.
     *
     * @return ResponseInterface The final HTTP response from the dispatched route.
     *
     * @throws \ReflectionException                     If reflection fails during middleware creation.
     * @throws \Psr\Container\ContainerExceptionInterface If the DI container encounters an issue.
     * @throws \Psr\Container\NotFoundExceptionInterface  If a middleware class cannot be resolved.
     */
    public function dispatch(Request $request) : ResponseInterface
    {
        // Inject route authorization into the request if a policy is defined.
        if ($this->route->authorization !== null) {
            // Attach the authorization policy as a request attribute.
            $request = $request->withAttribute(name: 'route:authorization', value: $this->route->authorization);

            // Prepend the authorization middleware to the pipeline.
            array_unshift($this->middleware, AuthorizeMiddleware::class);
        }

        // Define the core execution logic for the pipeline - dispatching the route's action.
        $core = fn(Request $request) : ResponseInterface => $this->dispatcher->dispatch(
            action : $this->route->action,
            request: $request
        );

        // Combine stages and middleware into a unified processing pipeline.
        $pipeline = array_merge($this->stages, $this->middleware);

        // Reduce the middleware and stages into a single processing stack (chain of responsibility).
        $stack = array_reduce(
        // Reverse the pipeline to ensure middleware are applied in the correct order.
            array_reverse($pipeline),
            // Accumulate middleware execution into the next stack function.
            fn(Closure $next, string $class) => function (Request $request) use (
                $class,
                $next
            ) : ResponseInterface {
                // Resolve the middleware or stage instance from the container.
                $instance = $this->container->get($class);

                // Ensure the middleware or stage has a `handle()` method.
                if (! method_exists($instance, 'handle')) {
                    throw new RuntimeException(
                        message: "Middleware or stage [{$class}] must have a handle() method."
                    );
                }

                // Call the middleware or stage's handle method, passing the request and next closure.
                return $instance->handle($request, $next);
            },
            // Start from the core action dispatcher.
            $core
        );

        // Execute the complete middleware stack with the initial request.
        return $stack($request);
    }
}
=== HTTP/Router/Routing/RouteRegistrarProxy.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

/**
 * Proxy that wraps a RouteBuilder and lazily registers the route
 * only once it's finalized (via name(), build(), or register()).
 *
 * Promotes clean chaining via fluent DSL.
 */
final class RouteRegistrarProxy
{
    private readonly RouteBuilder      $builder;

    private readonly HttpRequestRouter $router;

    private bool                       $registered = false;

    /**
     * Initializes proxy with Router and Builder.
     *
     * @param HttpRequestRouter $router
     * @param RouteBuilder      $builder
     */
    public function __construct(HttpRequestRouter $router, RouteBuilder $builder)
    {
        $this->router  = $router;
        $this->builder = $builder;
    }

    /**
     * Assigns a route name and triggers registration.
     *
     * @param string $name
     *
     * @return self
     */
    public function name(string $name) : self
    {
        $this->builder->name($name);

        return $this->register();
    }

    /**
     * Explicitly triggers registration (if not already).
     *
     * @return self
     */
    public function register() : self
    {
        if (! $this->registered) {
            $definition = $this->builder->build();

            $this->router->registerRoute(
                method       : $definition->method,
                path         : $definition->path,
                action       : $definition->action,
                middleware   : $definition->middleware,
                name         : $definition->name,
                constraints  : $definition->constraints,
                defaults     : $definition->defaults,
                domain       : $definition->domain,
                attributes   : $definition->attributes,
                authorization: $definition->authorization
            );

            $this->registered = true;
        }

        return $this;
    }

    /**
     * Finalizes and returns the RouteDefinition (registers first).
     *
     * @return RouteDefinition
     */
    public function build() : RouteDefinition
    {
        $this->register();

        return $this->builder->build();
    }

    /**
     * Adds a single route parameter constraint.
     */
    public function where(string $param, string $pattern) : self
    {
        $this->builder->where($param, $pattern);

        return $this;
    }

    /**
     * Adds multiple constraints.
     */
    public function whereIn(array $constraints) : self
    {
        $this->builder->whereIn($constraints);

        return $this;
    }

    /**
     * Defines default values for parameters.
     */
    public function defaults(array $defaults) : self
    {
        $this->builder->defaults($defaults);

        return $this;
    }

    /**
     * Defines custom route metadata.
     */
    public function attributes(array $attributes) : self
    {
        $this->builder->attributes($attributes);

        return $this;
    }

    /**
     * Attaches middleware to the route.
     */
    public function middleware(array $middleware) : self
    {
        $this->builder->middleware($middleware);

        return $this;
    }

    /**
     * Sets the authorization policy.
     */
    public function authorize(string $policy) : self
    {
        $this->builder->authorize($policy);

        return $this;
    }

    /**
     * Sets the controller + method for the route.
     */
    public function controller(string $controller, string $method = 'index') : self
    {
        $this->builder->controller($controller, $method);

        return $this;
    }

    /**
     * Sets the action callback or controller.
     */
    public function action(callable|array|string $action) : self
    {
        $this->builder->action($action);

        return $this;
    }
}

=== HTTP/Router/Routing/RouteStage.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Routing;

use Closure;
use Gemini\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

interface RouteStage
{
    /**
     * Executes logic before the next pipeline stage.
     *
     * @param Request                             $request
     * @param Closure(Request): ResponseInterface $next
     *
     * @return ResponseInterface
     */
    public function handle(Request $request, Closure $next) : ResponseInterface;
}
=== HTTP/Router/Support/DomainPatternCompiler.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Support;

/**
 * Class DomainPatternCompiler
 *
 * Provides methods for compiling dynamic domain patterns into regular expressions
 * and matching incoming host strings against compiled patterns.
 *
 * This utility is often used in routing systems to handle dynamic subdomains
 * or structured domain hierarchies.
 */
final class DomainPatternCompiler
{
    /**
     * Compiles a domain pattern string into a corresponding regular expression
     * to facilitate dynamic domain matching.
     *
     * Dynamic patterns are denoted using placeholders, e.g., `{account}.example.com`,
     * where `{account}` can match any subdomain name.
     *
     * @param string $pattern The domain pattern string to compile.
     *                        Placeholders should be wrapped in curly braces, e.g., `{name}`.
     *
     * @return string The compiled regular expression string, ready for use in pattern matching.
     *                Example: `{account}.example.com` becomes `/^(?P<account>[\w\-.]+)\.example\.com$/i`.
     */
    public static function compile(string $pattern) : string
    {
        // Escape all special characters in the input domain pattern to ensure regex safety.
        $escaped = preg_quote($pattern, delimiter: '/');

        // Transform placeholders (e.g., `{account}`) into named capturing groups in the regex pattern.
        // - \w matches word characters (a-z, A-Z, 0-9, and underscore).
        // - \- and \. Allow hyphen or dot in the subdomain portion.
        // Example: `{account}` becomes `(?P<account>[\w\-\.]+)`.
        $regex = preg_replace_callback(
            pattern : '/\\{(\w+)}/',
            // Matches `{placeholder_name}` where placeholders are word characters.
            callback: static fn(array $match) : string => '(?P<' . $match[1] . '>[\w\-\.]+)',
            // Replace it with a named group.
            subject : $escaped // Apply on the escaped string.
        );

        // Wrap the generated regex in delimiters, enforce case-insensitivity, and ensure it matches the full string.
        return '/^' . $regex . '$/i';
    }

    /**
     * Matches a host string against a precompiled domain regular expression.
     *
     * This method is used to determine if an incoming host (e.g., `x.example.com`) aligns
     * with the compiled domain pattern (e.g., `/^(?P<account>[\w\-\.]+)\.example\.com$/i`).
     *
     * @param string $host     The incoming host string to evaluate (e.g., `foo.example.com`).
     * @param string $compiled The precompiled domain regex (result from `compile`).
     *
     * @return bool Returns `true` if the host matches the regex, `false` otherwise.
     */
    public static function match(string $host, string $compiled) : bool
    {
        // Use preg_match to check if the host matches the compiled domain pattern.
        // Casting to boolean simplifies the return value to true/false.
        return (bool) preg_match($compiled, $host);
    }
}
=== HTTP/Router/Support/HeadRequestFallback.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Support;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;

/**
 * Provides fallback logic for HEAD → GET requests.
 *
 * If a HEAD route is not defined, attempts to resolve the corresponding GET route.
 */
final class HeadRequestFallback
{
    public function __construct(
        private readonly HttpRequestRouter $router
    ) {}

    /**
     * Resolves the request, falling back from HEAD to GET if needed.
     *
     * @param Request $request Incoming HTTP request.
     *
     * @return \Gemini\HTTP\Request\Request
     *
     */
    public function resolve(Request $request) : Request
    {
        if ($request->getMethod() !== 'HEAD') {
            return $request;
        }

        try {
            $this->router->resolve(request: $request);
        } catch (RouteNotFoundException) {
            // Attempt GET route fallback
            $request = $request->withMethod(method: 'GET');
        }

        return $request;
    }
}

=== HTTP/Router/Support/RouteCollector.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Support;

use Gemini\HTTP\Router\Routing\RouteBuilder;
use LogicException;

/**
 * Class RouteCollector
 *
 * Provides a temporary in-memory registry for storing route configurations (via `RouteBuilder` instances)
 * during application initialization phases, such as bootstrapping, cache compilation,
 * or CLI-based route inspection.
 *
 * This class is designed for temporary usage and does not handle runtime route resolution.
 * It serves only as an internal tool for assembling and managing router-related data.
 */
final class RouteCollector
{
    /**
     * @var list<RouteBuilder> $bufferedRoutes
     *
     * Buffers all the route definitions provided during application initialization.
     * This buffer is emptied after flushing or resetting, maintaining the ephemeral nature of this class.
     */
    private static array $bufferedRoutes = [];

    /**
     * @var callable|array|string|null $fallback
     *
     * Defines the fallback handler for unmatched routes.
     * This handler is called at runtime when no route matches are found.
     * Accepts `callable`, an array (controller-action pair), or a string (class or function name).
     */
    private static mixed $fallback = null;

    /**
     * Registers a RouteBuilder into the internal buffered routes registry.
     *
     * RouteBuilder instances are used to encapsulate route definitions and related metadata.
     *
     * @param RouteBuilder $builder The RouteBuilder instance to buffer.
     *
     * @return void
     */
    public static function add(RouteBuilder $builder) : void
    {
        // Add the provided RouteBuilder instance to the buffered routes list.
        self::$bufferedRoutes[] = $builder;
    }

    /**
     * Returns all buffered RouteBuilder instances and clears the buffer.
     *
     * This method is essential during cache compilation or inspection tasks,
     * where it retrieves and empties the stored entries for processing downstream.
     *
     * @return list<RouteBuilder> A list of buffered RouteBuilder instances.
     */
    public static function flushBuffered() : array
    {
        // Assign the current buffer to a temporary variable for returning.
        $routes = self::$bufferedRoutes;

        // Clear the buffered routes to ensure the collector is reset post-flush.
        self::$bufferedRoutes = [];

        // Return the temporary stash of routes.
        return $routes;
    }

    /**
     * Defines a fallback handler for unmatched routes.
     *
     * This operation is important and enforces a single fallback definition.
     * Calling this method multiple times will result in an exception if the fallback is already defined.
     *
     * @param callable|array|string $handler A handler for unmatched routes. This can be:
     *                                       - A `callable` (e.g., closure, function),
     *                                       - A controller-action pair array (e.g., [Controller::class, 'method']),
     *                                       - A string (e.g., fully qualified class name or function).
     *
     * @return void
     * @throws LogicException If a fallback handler has already been set.
     *
     */
    public static function fallback(callable|array|string $handler) : void
    {
        // Prevent overriding an existing fallback handler by throwing an exception.
        if (self::$fallback !== null) {
            throw new LogicException(message: 'Fallback route handler has already been defined.');
        }

        // Set the fallback handler.
        self::$fallback = $handler;
    }

    /**
     * Retrieves the currently set fallback handler.
     *
     * This method is designed to allow downstream consumers to inspect the state
     * of the collector for unmatched route handling.
     *
     * @return callable|array|string|null The fallback handler, or null if none is set.
     */
    public static function getFallback() : callable|array|string|null
    {
        // Return the current fallback handler.
        return self::$fallback;
    }

    /**
     * Clears the currently set fallback handler.
     *
     * This method ensures a clean state, consistent with the stateless purpose of the collector.
     *
     * @return void
     */
    public static function clearFallback() : void
    {
        // Reset the fallback handler to null.
        self::$fallback = null;
    }

    /**
     * Checks whether the collector contains any buffered RouteBuilder instances.
     *
     * This method helps optimize workflows or conditional operations during bootstrap or cache validation.
     *
     * @return bool True if there are buffered routes, false otherwise.
     */
    public static function hasRoutes() : bool
    {
        // Return true if the bufferedRoutes array is not empty.
        return ! empty(self::$bufferedRoutes);
    }

    /**
     * Resets the entire collector to a clean state.
     *
     * This method clears all buffered routes and removes the fallback handler, ensuring no side effects or
     * lingering state between bootstrap cycles or application contexts.
     *
     * @return void
     */
    public static function reset() : void
    {
        // Clear the buffered routes.
        self::$bufferedRoutes = [];
        // Reset the fallback handler to null.
        self::$fallback = null;
    }
}
=== HTTP/Router/Validation/RouteConstraintValidator.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Router\Validation;

use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\Routing\RouteDefinition;
use RuntimeException;

/**
 * Validates route parameter values against registered regex constraints.
 */
final class RouteConstraintValidator
{
    /**
     * Validates the route parameter constraints against the actual request attributes.
     *
     * @param RouteDefinition $route   The route being validated.
     * @param Request         $request The current HTTP request.
     *
     * @return void
     *
     * @throws RuntimeException If any constraint fails.
     */
    public function validate(RouteDefinition $route, Request $request) : void
    {
        foreach ($route->constraints as $param => $pattern) {
            $value = $request->getAttribute(name: $param);

            if (! is_string($value) && ! is_numeric($value)) {
                continue;
            }

            if (@preg_match(pattern: $pattern, subject: (string) $value) !== 1) {
                throw new RuntimeException(
                    message: sprintf('Route parameter "%s" failed constraint "%s"', $param, $pattern)
                );
            }
        }
    }
}

=== HTTP/Router/web.php ===
<?php

declare(strict_types=1);

use Gemini\Facade\Facades\Route;

Route::get(path: '/', action: static fn() : string => 'Welcome to the homepage!')->name('test-route');


//Route::get(
//    path  : '/login',
//    action: [AuthenticationController::class, 'index'],
//    name  : 'auth.login.form',
//);
//
//Route::post(
//    path  : '/login',
//    action: [AuthenticationController::class, 'login'],
//    name  : 'auth.login',
//);
//
//Route::get(
//    '/test-blade',
//    static function () {
//        $users = [];
//        dd($users);
//
//        return view(template: 'auth.login', data: $users);
//    },
//);
//
//Route::post(
//    path  : '/tesst',
//    action: [HealthCheckController::class, 'testRTGApi'],
//);

=== HTTP/Security/CsrfTokenManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Security;

use Carbon\Carbon;
use Exception;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Psr\Log\LoggerInterface;

/**
 * The `CsrfTokenManager` is a high-level component that manages CSRF tokens
 * to prevent cross-site request forgery attacks. It ensures secure
 * communication between the client and server by generating, validating,
 * expiring, and revoking tokens.
 */
final readonly class CsrfTokenManager
{
    /**
     * The session key under which all CSRF tokens are stored.
     *
     * @var string
     */
    private const string SESSION_KEY = '_csrf_tokens';

    /**
     * The number of minutes before a CSRF token expires.
     *
     * @var int
     */
    private const int TOKEN_EXPIRATION_MINUTES = 30;

    /**
     * The maximum number of tokens allowed per session to prevent
     * unbounded growth of session data.
     *
     * @var int
     */
    private const int MAX_TOKENS_PER_SESSION = 5;

    /**
     * Constructor with constructor promotion for simple, expressive instantiation.
     *
     * @param SessionInterface $session The session management implementation.
     * @param LoggerInterface  $logger  Responsible for logging important events.
     */
    public function __construct(
        private SessionInterface $session,
        private LoggerInterface  $logger
    ) {}

    /**
     * Retrieves or generates a CSRF token tied to the session. De-duplicates
     * tokens per session, handles expiration, and warns if maximum token count
     * is exceeded.
     *
     * @return string The CSRF token, valid for secure use in client-server interaction.
     * @throws Exception If the token generation process fails.
     */
    public function getToken() : string
    {
        // Retrieve current tokens from the session; fall back to an empty array if none exist.
        $tokens = $this->getTokens();

        // Prune expired tokens based on expiration policy to maintain session hygiene.
        $tokens = $this->pruneExpiredTokens(tokens: $tokens);

        // Log a warning if the number of tokens exceeds the predefined limit.
        if (count($tokens) >= self::MAX_TOKENS_PER_SESSION) {
            $this->logger->warning(
                message: 'Maximum CSRF token limit reached.',
                context: ['tokens' => $tokens]
            );
        }

        // Generate a new cryptographically secure CSRF token.
        $newToken = $this->generateToken();

        // Store the token along with the current timestamp for expiration management.
        $tokens[$newToken] = Carbon::now()->timestamp;

        // Persist the updated token array back to the session.
        $this->storeTokens(tokens: $tokens);

        // Log the successful creation of the new token.
        $this->logger->info(
            message: 'Generated new CSRF token.',
            context: ['token' => $newToken]
        );

        // Return the newly generated token to the caller.
        return $newToken;
    }

    /**
     * Fetches all existing CSRF tokens from the session.
     * If the session value is invalid, it resets to an empty array to ensure continuity.
     *
     * @return array The stored tokens, keyed by token string with timestamp as value.
     */
    private function getTokens() : array
    {
        // Retrieve tokens from the session or use an empty array as the default value.
        $tokens = $this->session->get(key: self::SESSION_KEY, default: []);

        // Handle cases where the session value is corrupted or in an invalid format.
        if (! is_array($tokens)) {
            $this->logger->warning(
                message: 'CSRF tokens session value was not an array. Resetting.',
                context: ['type' => gettype($tokens)]
            );

            // Reset tokens to an empty array if invalid data is found.
            $this->storeTokens(tokens: []);

            return [];
        }

        return $tokens;
    }

    /**
     * Stores the provided token array into the session under the preconfigured key.
     *
     * @param array $tokens The array of tokens to store in session.
     */
    private function storeTokens(array $tokens) : void
    {
        // Set the tokens into the session storage under the configured key.
        $this->session->set(key: self::SESSION_KEY, value: $tokens);
    }

    /**
     * Filters out expired tokens from the provided token list under the configured
     * expiration policy. Ensures tokens are valid for a limited time window.
     *
     * @param array $tokens The array of tokens to validate and prune.
     *
     * @return array The pruned token array containing only valid tokens.
     */
    private function pruneExpiredTokens(array $tokens) : array
    {
        // Get the current timestamp for comparison.
        $currentTime = Carbon::now()->timestamp;

        // Filter out tokens that have exceeded their expiration time.
        return array_filter(
            $tokens,
            static fn($timestamp) => $currentTime - $timestamp <= self::TOKEN_EXPIRATION_MINUTES * 60
        );
    }

    /**
     * Generates a cryptographically secure random CSRF token.
     *
     * @return string The 32-byte token, encoded as a hexadecimal string.
     * @throws Exception If an internal error occurs during token generation.
     */
    private function generateToken() : string
    {
        // Use a cryptographic function to generate a secure 32-byte token.
        return bin2hex(random_bytes(32));
    }

    /**
     * Validates a given client-provided CSRF token against the session's stored
     * tokens. Handles expired tokens, token invalidation, and token rotation for
     * enhanced security.
     *
     * @param string|null $token The token provided by the client for validation.
     *
     * @return bool Returns true if the token is valid and rotated; false otherwise.
     * @throws Exception If token generation or session operations fail unexpectedly.
     */
    public function validateToken(string|null $token) : bool
    {
        // Retrieve the session’s stored tokens for comparison.
        $tokens = $this->getTokens();

        // Validation fails if the token is missing or unrecognized.
        if ($token === null || ! isset($tokens[$token])) {
            $this->logger->warning(
                message: 'CSRF validation failed: Missing or invalid token.',
                context: ['token' => $token]
            );

            return false;
        }

        // Determine if the token has exceeded the expiration window.
        $isExpired = Carbon::now()->timestamp - $tokens[$token] > self::TOKEN_EXPIRATION_MINUTES * 60;

        // If the token is expired, remove it and prevent usage.
        if ($isExpired) {
            $this->logger->info(message: 'CSRF token expired.', context: ['token' => $token]);
            unset($tokens[$token]);
            $this->storeTokens(tokens: $tokens);

            return false;
        }

        // Rotate tokens for added security: remove the old token and generate a new one.
        unset($tokens[$token]);
        $newToken = $this->generateToken();
        $tokens[$newToken] = Carbon::now()->timestamp;
        $this->storeTokens(tokens: $tokens);

        // Regenerate the session ID to prevent fixation attacks.
        $this->session->regenerateId();

        // Log the successful token validation and rotation.
        $this->logger->info(
            message: 'CSRF token validated and rotated.',
            context: ['new_token' => $newToken]
        );

        return true;
    }

    /**
     * Invalidates all CSRF tokens in the current session scope.
     * Also regenerates the session ID to further enhance security.
     */
    public function invalidateAllTokens() : void
    {
        // Completely remove the CSRF tokens from the session.
        $this->session->delete(key: self::SESSION_KEY);

        // Regenerate the session ID to prevent session fixation or hijacking attacks.
        $this->session->regenerateId();

        // Log that all tokens have been invalidated.
        $this->logger->info(message: 'All CSRF tokens invalidated.');
    }
}
=== HTTP/Security/VerifyCsrfToken.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Security;

use Closure;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\ResponseFactory;
use Gemini\HTTP\Security\CsrfTokenManager;
use Psr\Http\Message\ResponseInterface;

/**
 * Middleware to enforce CSRF token validation for incoming requests.
 *
 * Responsibilities:
 * - Skip validation for safe HTTP methods (e.g., GET, OPTIONS).
 * - Validate CSRF tokens for unsafe methods (e.g., POST, DELETE).
 * - Respond with a 403 error for invalid or expired tokens.
 */
class VerifyCsrfToken
{
    private const array SAFE_METHODS = ['HEAD', 'GET', 'OPTIONS'];

    public function __construct(
        protected readonly CsrfTokenManager $csrfTokenManager,
        protected readonly ResponseFactory  $responseFactory
    ) {}

    /**
     * Handles CSRF validation for incoming requests.
     *
     * @param Request $request The incoming request.
     * @param Closure $next    The next middleware in the pipeline.
     *
     * @throws \Exception
     * @throws \Exception
     */
    public function handle(Request $request, Closure $next) : ResponseInterface
    {
        if ($this->isSafeMethod(request: $request)) {
            return $next($request);
        }

        $token = $this->extractToken(request: $request);

        if (! $this->csrfTokenManager->validateToken(token: $token)) {
            return $this->createTokenMismatchResponse();
        }

        return $next($request);
    }

    /**
     * Determines if the request method is safe (e.g., GET, OPTIONS).
     *
     * @param Request $request The incoming request.
     *
     * @return bool True if the method is safe, false otherwise.
     */
    private function isSafeMethod(Request $request) : bool
    {
        return in_array($request->getMethod(), self::SAFE_METHODS, true);
    }

    /**
     * Extracts the CSRF token from the request.
     *
     * @param Request $request The incoming request.
     *
     * @return string|null The extracted token.
     */
    private function extractToken(Request $request) : string|null
    {
        $headerToken = $request->getHeaderLine(name: 'X-CSRF-TOKEN');

        if ($headerToken !== '' && $headerToken !== '0') {
            return $headerToken;
        }

        if ($request->getHeaderLine(name: 'Content-Type') === 'application/json') {
            $data = json_decode($request->getBody()->getContents(), true);

            return $data['_token'] ?? null;
        }

        return $request->input(key: '_token');
    }

    /**
     * Generates a response for token mismatches.
     *
     * @return ResponseInterface A 403 response indicating CSRF validation failure.
     */
    private function createTokenMismatchResponse() : ResponseInterface
    {
        $response = $this->responseFactory->createResponse(code: 403);

        $response->getBody()->write(
            string: json_encode(
                        [
                            'error' => [
                                'code'    => 'CSRF_TOKEN_MISMATCH',
                                'message' => 'The CSRF token is invalid, missing, or expired.',
                            ],
                        ]
                    )
        );

        return $response->withHeader(name: 'Content-Type', value: 'application/json');
    }
}

=== HTTP/Session/AbstractSession.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Closure;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Contracts\SessionStoreInterface;

/**
 * AbstractSession
 *
 * Framework-agnostic base implementation for session management.
 *
 * This class provides secure, extensible, and developer-friendly session
 * behavior using a pluggable store and cryptography service for managing
 * encrypted sessions. It adheres to clean code principles and Domain-Driven
 * Design (DDD) practices for maximum clarity and flexibility.
 *
 * Implements:
 * - `SessionInterface` for session operations.
 * - `ArrayAccess` for array-like access to session attributes.
 *
 * Key Features:
 * - Secure storage using encryption.
 * - Flash data system for temporary session storage.
 * - Framework-independent, making it reusable across different applications.
 */
abstract class AbstractSession implements SessionInterface
{
    /**
     * Constructor.
     *
     * Initializes the session with a store and crypto engine.
     *
     * @param SessionStoreInterface $store The backend store for session data.
     */
    public function __construct(
        protected readonly SessionStoreInterface $store,
        protected readonly BagRegistryInterface  $registry
    ) {}

    /**
     * Retrieve all session data while performing cleanup of expired items.
     *
     * This method ensures the session has been started, fetches all the stored session
     * data, and removes expired entries both from the session data as well as from
     * the associated metadata. The cleanup process ensures that session data does
     * not accumulate invalid or stale entries.
     *
     * @return array The complete session data after expired items are cleaned up.
     */
    public function all() : array
    {
        // Begin the session if it is not already started.
        $this->start();

        // Retrieve all session data from the session store.
        $all = $this->store->all();

        // Iterate through each key-value pair in the session data.
        foreach ($all as $key => $value) {
            // Skip processing if the key corresponds to metadata (indicated by '::__meta' suffix).
            if (str_ends_with($key, '::__meta')) {
                continue;
            }

            // Derive the corresponding metadata key for the current session key.
            $metaKey = "{$key}::__meta";

            // Check if the metadata exists and if the session data has expired based on `expires_at`.
            if (
                isset($all[$metaKey]['expires_at']) && // Metadata contains expiry details.
                time() >= $all[$metaKey]['expires_at'] // Current time has passed the expiry timestamp.
            ) {
                // Remove the expired session key from the session store.
                $this->delete($key);

                // Remove the related metadata key from the session store.
                $this->delete($metaKey);

                // Unset the expired session data and metadata from the `$all` array.
                unset($all[$key], $all[$metaKey]);
            }
        }

        // Return the cleaned-up session data.
        return $all;
    }

    /**
     * Starts the session using the provided session store.
     *
     * This method delegates the session initialization process to the underlying
     * store implementation, ensuring a uniform session management interface.
     *
     * @return void
     */
    public function start() : void
    {
        // Start the session by delegating to the session store's start method.
        $this->store->start();
    }

    /**
     * Deletes a specific session key and its associated value from storage.
     * Before deletion, ensures that the session is started.
     * Delegates the actual deletion logic to the store implementation.
     *
     * @param string $key The session key to delete from storage.
     *
     * @return void
     */
    public function delete(string $key) : void
    {
        // Ensure the session is started.
        $this->start();

        // Request the store to delete the specified key.
        $this->store->delete(key: $key);
    }

    /**
     * Invalidate the current session by performing the following steps:
     * 1. Clear all session data to ensure no sensitive information is retained.
     * 2. Regenerate the session ID, optionally removing the old session data for security.
     *
     * This method is a defensive mechanism against session fixation attacks.
     * By regenerating the session ID, any previously held session identifiers become unusable.
     *
     * @return void
     */
    public function invalidate() : void
    {
        // Step 1: Flush all session data, ensuring a clean state for the session.
        $this->flush();

        // Step 2: Regenerate the session ID securely using the store.
        // The "deleteOldSession" flag is explicitly passed for clarity and safety.
        $this->store->regenerateId(deleteOldSession: true);
    }

    /**
     * Clear all session data.
     *
     * This method ensures the session is started before performing
     * a flush operation to avoid operating on an inactive session.
     * All session data will be permanently erased.
     *
     * Contract:
     * - The session must be active before data can be flushed.
     * - Delegates the "flush" operation to the session store for implementation.
     *
     * WARNING: Use this with caution as it destroys all stored session data.
     *
     * @return void
     */
    public function flush() : void
    {
        // Ensure the session is started.
        // This guarantees the session is active and prevents flushing
        // data in an uninitialized or inactive session state.
        $this->start();

        // Delegate the flush operation to the session store.
        // The store is responsible for clearing all persisted session data.
        $this->store->flush();
    }

    /**
     * Regenerate the session ID for the current session.
     *
     * This method ensures the security of the session by allowing users
     * to optionally delete the old session data and replacing the current
     * session ID with a new one.
     *
     * @param bool $deleteOldSession Whether to delete the old session data
     *                               (enabled by default for enhanced security).
     */
    public function regenerateId(bool $deleteOldSession = true) : void
    {
        // Delegate the request to regenerate the session ID to the session store.
        // By using named arguments, we make the intention explicit.
        $this->store->regenerateId(deleteOldSession: $deleteOldSession);
    }

    /**
     * Pulls a value from the session storage based on the given key,
     * removes the specified key from the session, and returns the value.
     *
     * @param string     $key     The unique identifier for the session item.
     * @param mixed|null $default A default value to return if the key is not found in storage.
     *
     * @return mixed The value associated with the given key, or the default if not found.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        // Retrieve the value corresponding to the key or return the default if unavailable.
        $value = $this->get(key: $key, default: $default);

        // Delete the key-value pair from the session to ensure it cannot be retrieved again.
        $this->delete(key: $key);

        // Return the retrieved value.
        return $value;
    }

    /**
     * This method retrieves a value from the session storage by its key.
     * It performs validation on metadata to check for expiration and
     * decrypts the value before returning it.
     * If the value doesn't exist or is expired, the provided default is returned.
     *
     * @param string     $key     The unique identifier for the session data to retrieve.
     * @param mixed|null $default A fallback value to return if the data associated with the key is not found or is
     *                            expired.
     *
     * @return mixed The value retrieved from the session storage or the default provided if unavailable.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Ensure the session is started before interacting with the storage.
        $this->start();

        // Attempt to retrieve the value associated with the given key from the session store.
        $value = $this->store->get(key: $key);

        // Attempt to retrieve metadata associated with the key (e.g., expiration time).
        // If no metadata exists, use an empty array as the default.
        $meta = $this->store->get(key: "{$key}::__meta", default: []);

        // Check if the 'expires_at' metadata attribute exists, and whether the current time has exceeded its value.
        if (isset($meta['expires_at']) && time() >= $meta['expires_at']) {
            // If the value is expired, delete the main key and its associated metadata from the session store.
            $this->delete(key: $key);
            $this->delete(key: "{$key}::__meta");

            // Return the default value since the stored data is no longer valid.
            return $default;
        }

        // If no value is found in the session store, or if it's null, return the default value.
        // Otherwise, decrypt the value before returning it to the caller.
        return $value ?? $default;
    }

    /**
     * Stores and returns a computed value for the given session key,
     * or retrieves the existing value if it has already been set.
     *
     * @param string  $key      The key associated with the value to remember.
     * @param Closure $callback A callback to compute the value only if it does not already exist in the session.
     *
     * @return mixed The value retrieved from storage or created by the callback.
     */
    public function remember(string $key, Closure $callback) : mixed
    {
        // Check if the key already exists in the session storage.
        if ($this->has(key: $key)) {
            // Return the preexisting value if the key exists.
            return $this->get(key: $key);
        }

        // Compute the new value by invoking the provided callback.
        $value = $callback();

        // Save the computed value under the specified session key.
        $this->set(key: $key, value: $value);

        // Return the newly created value.
        return $value;
    }

    /**
     * Checks if a specific key exists in the session store.
     *
     * The `has` method checks whether a specific key exists in the store by making use
     * of the `get` method from the session storage interface and verifying if the result is not null.
     *
     * @param string $key The identifier of the data to check for in the session store.
     *
     * @return bool Returns `true` if the key is found in the session store, otherwise `false`.
     */
    public function has(string $key) : bool
    {
        // Attempt to fetch the value associated with the key from the store.
        // Return whether the key exists by checking that the retrieved value is not `null`.
        return $this->store->get(key: $key) !== null;
    }

    /**
     * Handles session data storage by securely encrypting the provided value
     * and associating it with the specified key.
     *
     * This method ensures the session storage is properly started before
     * performing operations and leverages encryption for secure data storage.
     *
     * @param string $key   The unique identifier for the session attribute.
     *                      Should be descriptive and consistent within the domain.
     * @param mixed  $value The data to be stored in the session. Can represent
     *                      any value type supported by PHP, making it flexible
     *                      for various use cases.
     *
     * @return void
     */
    public function set(string $key, mixed $value) : void
    {
        // Start the session to ensure it’s ready for storing data.
        $this->start();

        // store it in the session storage with the provided key.
        $this->store->put(
            key  : $key,
            value: $value
        );
    }

    /**
     * Stores a given key-value pair in the session storage.
     *
     * This method delegates the responsibility of storing the data
     * ensuring the value is stored explicitly
     * as plain (unencrypted) data.
     *
     * The session must be initialized before calling this method.
     *
     * @param string $key   The unique key under which the value
     *                      will be stored in the session.
     * @param mixed  $value The value to be stored in the session.
     *                      Can be of any type (e.g. scalar, array, object).
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        // Ensure that the session is started before performing any session operations.
        $this->start();

        // Use the session store to store the provided key-value pair directly.
        $this->store->put(key: $key, value: $value);
    }

    /**
     * Increments an integer value stored in the session by a specified amount.
     * If the key does not exist, it initializes the value to 0 before incrementing.
     *
     * @param string $key    The key identifying the value to increment.
     * @param int    $amount The amount to increment by. Default is 1.
     *
     * @return int The incremented value after the operation is completed.
     */
    public function increment(string $key, int $amount = 1) : int
    {
        // Retrieve the current value as an integer, defaulting to 0 if the key does not exist.
        $current = (int) $this->get(key: $key, default: 0);

        // Add the specified amount to the current value.
        $new = $current + $amount;

        // Store the updated value back in the session.
        $this->set(key: $key, value: $new);

        // Return the incremented value.
        return $new;
    }

    /**
     * Decrements an integer value stored in the session by a specified amount.
     * If the key does not exist, it initializes the value to 0 before decrementing.
     *
     * @param string $key    The key identifying the value to decrement.
     * @param int    $amount The amount to decrement by. Default is 1.
     *
     * @return int The decremented value after the operation is completed.
     */
    public function decrement(string $key, int $amount = 1) : int
    {
        // Retrieve the current value as an integer, defaulting to 0 if the key does not exist.
        $current = (int) $this->get(key: $key, default: 0);

        // Subtract the specified amount from the current value.
        $new = $current - $amount;

        // Store the updated value back in the session.
        $this->set(key: $key, value: $new);

        // Return the decremented value.
        return $new;
    }

    /**
     * Determine if the given session key exists in the session store.
     *
     * This method is required by the ArrayAccess interface. It allows checking
     * if a session key exists using array-style syntax.
     *
     * @param string $offset The session key to check.
     *
     * @return bool Returns true if the key exists, false otherwise.
     */
    public function offsetExists(mixed $offset) : bool
    {
        // Cast the offset to string to ensure compatibility with session keys.
        // Use the `has` method to determine if the key exists in the session store.
        return $this->has(key: (string) $offset);
    }

    /**
     * Retrieve the session value associated with the given key.
     *
     * This method is required by the ArrayAccess interface. It allows session values
     * to be accessed using array-style syntax.
     *
     * @param string $offset The session key to retrieve the value for.
     *
     * @return mixed The value associated with the session key, or a default value if not set.
     */
    public function offsetGet(mixed $offset) : mixed
    {
        // Cast the offset to string and retrieve its associated value using the `get` method.
        return $this->get(key: (string) $offset);
    }

    /**
     * Store a value in the session associated with the provided key.
     *
     * This method is required by the ArrayAccess interface. It allows session values
     * to be set using array-style syntax.
     *
     * @param string $offset The session key to associate with the value.
     * @param mixed  $value  The session value to be stored.
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        // Cast the offset to string and store the associated value using the `set` method.
        $this->set(key: (string) $offset, value: $value);
    }

    /**
     * Remove a session value associated with the given key.
     *
     * This method is required by the ArrayAccess interface. It allows session values
     * to be removed using array-style syntax.
     *
     * @param string $offset The session key to remove.
     *
     * @return void
     */
    public function offsetUnset(mixed $offset) : void
    {
        // Cast the offset to string and delete the associated value using the `delete` method.
        $this->delete(key: (string) $offset);
    }

    /**
     * Retrieves an old input value from the session storage.
     *
     * This method is particularly useful for retrieving input values from
     * requests in previous forms (e.g., old form submissions). If the specified key
     * does not exist in the old input storage, a default value is returned.
     *
     * @param string $key     The unique key associated with the old input data.
     * @param mixed  $default The default value to return if the key is not found (optional).
     *
     * @return mixed The retrieved old input value or the default value.
     */
    public function getOldInput(string $key, mixed $default = null) : mixed
    {
        // Retrieve the '_old_input' array from the session store.
        $data = $this->store->get(key: '_old_input', default: []);

        // Ensure the retrieved data is an array and contains the desired key.
        // If found, return the value associated with the key; otherwise, return the default value.
        return is_array($data) && array_key_exists($key, $data)
            ? $data[$key]
            : $default;
    }

    /**
     * This method securely stores a key-value pair with an expiration time-to-live (TTL).
     * The value is encrypted before storage, and expiration metadata is stored alongside it.
     *
     * @param string $key   The unique key under which the value will be stored.
     * @param mixed  $value The value to be stored. Supported types depend on the implemented encryption mechanism.
     * @param int    $ttl   Time-to-live in seconds, determining when the data will expire.
     *
     * @return void
     */
    public function putWithTTL(string $key, mixed $value, int $ttl) : void
    {
        // Ensure the session is properly started before any storage operations.
        $this->start();

        // Store the encrypted data against the specified key in the session store.
        $this->store->put(key: $key, value: $value);

        // Store the metadata for the key including its expiration time.
        // The expiration time is calculated as the current time plus the TTL in seconds.
        $this->store->put(
            key  : "{$key}::__meta", // Append `::__meta` to key, indicating metadata storage.
            value: [
                       'expires_at' => time() + $ttl, // Store the expiration timestamp.
                   ]
        );
    }

    /**
     * Retrieves the current session bag registry, enabling access to all registered bags.
     *
     * This method exposes the `BagRegistryInterface` to consumers of the session manager,
     * enabling structured interaction with various session components.
     *
     * Example:
     * ```
     * $registry = $session->getRegistry();
     * $flashBag = $registry->flash();
     * $errorBag = $registry->errors();
     * ```
     *
     * **Key Responsibilities**:
     * 1. Encapsulation: The registry serves as a boundary for session sub-containers.
     * 2. Extensibility: Consumers of this method may register or retrieve additional session bags.
     * 3. Dependency Injection: Encourages a clean separation of concerns between session components.
     *
     * @return \Gemini\HTTP\Session\Contracts\BagRegistryInterface
     *   The session bag registry instance managing all session-related sub-containers.
     */
    public function getRegistry() : BagRegistryInterface
    {
        // Return the registry enabling access to its methods for bag management.
        return $this->registry;
    }
}
=== HTTP/Session/Contracts/BagRegistryInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

/**
 * Interface BagRegistryInterface
 *
 * A service contract for managing session "bags", which group session
 * state by separate concerns (such as input data, error messages, or
 * flash data). This allows developers to organize session storage into
 * isolated namespaces for better scalability, modularity, and reuse.
 *
 * This registry acts as a central hub to store and retrieve such bags
 * during the lifecycle of the session.
 *
 * Usage Scenarios:
 * - Flash bag management for temporary data like notifications.
 * - Input bag management for preserving form state across requests.
 * - Error bag management for storing validation or runtime errors.
 */
interface BagRegistryInterface
{
    /**
     * Retrieve a specific session bag by its unique name.
     *
     * @template T of SessionBagInterface
     *
     * @param string $name
     *   The unique identifier for the session bag.
     *
     * @return \Gemini\HTTP\Session\Contracts\SessionBagInterface
     *   The resolved session bag instance implementing SessionBagInterface.
     *
     * @throws \InvalidArgumentException
     *   If no session bag with the given name is registered, an exception
     *   could be thrown to indicate the absence of the bag.
     *
     * Why use this method:
     * - Centralizes access to specific session sub-containers.
     * - Enables dependency injection or lazy initialization of session bags.
     */
    public function get(string $name) : SessionBagInterface;

    /**
     * Register a session bag into the registry under a specific name.
     *
     * @param string                                             $name
     *   The unique identifier for the session bag.
     *
     * @param \Gemini\HTTP\Session\Contracts\SessionBagInterface $bag
     *   The instance of the session bag to register. This could be a
     *   pre-configured reusable bag, such as a FlashBag or ErrorBag.
     *
     * @return void
     *
     * Why use this method:
     * - Extensibility: Register additional features that interact with
     *   the session, organizing them into separate namespaces (bags).
     * - Ease of use: Ensures that all session bags follow a consistent
     *   initialization pattern.
     * - Modularity: Each session bag can be registered independently,
     *   promoting a decoupled architecture.
     */
    public function register(string $name, SessionBagInterface $bag) : void;

    /**
     * Retrieves the flash message session bag.
     *
     * The `FlashBag` session bag is designed to store temporary messages or
     * data, persisting only until the next request by default. It simplifies
     * the handling of transient application states like success notifications,
     * validation alerts, or session-based one-time flags.
     *
     * Example usage:
     * ```php
     * $flashBag = $bagRegistry->flash();
     * $flashBag->put('success', 'Your account has been updated.');
     * ```
     *
     * Dependency on `FlashBagInterface`:
     * - `FlashBagInterface` extends `SessionBagInterface`, ensuring robust
     *    session-management capabilities with added functionality for
     *    managing flash-specific use cases, like `keep()` or `reflash()`.
     *
     * @return FlashBagInterface
     *   A flash message session bag adhering to FlashBagInterface, providing
     *   encapsulated methods tailored for transient data persistence.
     */
    public function flash() : FlashBagInterface;

    /**
     * Retrieves the error message session bag.
     *
     * The `ErrorBag` is a generic session bag used to store validation
     * errors, user feedback, or any application state that needs to persist
     * across multiple requests. By handling errors via a dedicated bag,
     * developers can centralize error management into a structured container.
     *
     * Example usage:
     * ```php
     * $errorBag = $bagRegistry->errors();
     * $errorBag->put('email', 'The email address is invalid.');
     * ```
     *
     * Dependency on `SessionBagInterface`:
     * - The `ErrorBag` follows the contract defined by `SessionBagInterface`,
     *   guaranteeing functionality such as value retrieval, storage, and
     *   clearing, while allowing customization for error-related use cases.
     *
     * @return SessionBagInterface
     *   A generic session bag adhering to SessionBagInterface, providing
     *   flexible storage capabilities for error messages or other keyed data.
     */
    public function errors() : SessionBagInterface;

}
=== HTTP/Session/Contracts/Factories/BagRegistryFactoryInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts\Factories;

use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * Interface BagRegistryFactoryInterface
 *
 * This interface defines a factory contract for creating instances of a BagRegistry.
 *
 * Why use this factory design:
 * - Decoupling: The specific implementation of the BagRegistryInterface can
 *   vary. The factory provides an abstraction, allowing for flexible and
 *   interchangeable implementations.
 * - Encapsulation: Encapsulates the logic for constructing and configuring
 *   the BagRegistry instance, ensuring clients do not need to handle this.
 * - Testability: Factories enable easier mocking and testing by resolving
 *   dependencies for BagRegistry.
 *
 * Implementations of this interface should adhere to DDD principles,
 * following concepts like Dependency Injection for more modular, clean code.
 *
 * @package Gemini\HTTP\Session\Contracts\Factories
 */
interface BagRegistryFactoryInterface
{
    /**
     * Create a new instance of BagRegistryInterface.
     *
     * This method is the central point for creating and resolving a BagRegistry.
     * The BagRegistry is a container for session bags, which organizes
     * data into logical namespaces for session management (e.g., FlashBag, ErrorBag).
     *
     * Design Notes:
     * - Dependency Injection: The factory may use DI to resolve instances.
     * - Extensibility: By returning `BagRegistryInterface`, the factory
     *   allows implementations to vary while adhering to the contract.
     *
     * Example usage:
     * ```php
     * $factory = new ConcreteBagRegistryFactory();
     * $bagRegistry = $factory->create();
     * $flashBag = $bagRegistry->flash();
     * ```
     *
     * @return BagRegistryInterface
     *   A new instance of BagRegistryInterface, fully initialized and ready to use.
     */
    public function create(SessionInterface $session) : BagRegistryInterface;
}
=== HTTP/Session/Contracts/FlashBagInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

/**
 * Interface FlashBagInterface
 *
 * This interface defines the contract for managing a flash-based temporary session store.
 * Flash bags are designed to hold transient data, meant to persist only across a single request-response cycle.
 * It extends the SessionBagInterface for consistent session operations, adding functionality specific to flash data.
 *
 * Example Use Cases:
 * - Storing success messages after form submissions.
 * - Passing transient errors or warnings between requests.
 * - Temporary state management that requires automatic expiration.
 *
 * @package Gemini\HTTP\Session\Contracts
 */
interface FlashBagInterface extends SessionBagInterface
{
    /**
     * Preserves a specific key-value pair in the flash bag across the next request.
     *
     * Flash data is commonly designed to be cleared after the next access.
     * The `keep` method ensures that a particular key's value is retained for subsequent processing.
     *
     * Example:
     * ```php
     * $flashBag->keep('successMessage');
     * ```
     * Retention can be useful for cases where data should be available for longer interactions.
     *
     * @param string $key
     *   The unique identifier for the flash data to be retained.
     *
     * @return void
     *   This method does not return a value.
     *
     * @see self::reflash() for retaining all flash data at once.
     */
    public function keep(string $key) : void;

    /**
     * Re-flashes all existing flash data for the next request.
     *
     * This method reinitializes and retains all current flash messages, ensuring that no data is removed.
     * Useful when flash data needs to survive multiple request cycles for extended processing.
     *
     * Example:
     * ```php
     * $flashBag->reflash();
     * ```
     * Unlike `keep`, this applies globally for the entire flash bag.
     *
     * @return void
     *   This method does not return a value.
     *
     * @see self::keep() for retaining specific keys.
     */
    public function reflash() : void;
}
=== HTTP/Session/Contracts/SessionBagInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

/**
 * Interface SessionBagInterface
 *
 * Represents an isolated namespace or "bag" within a session.
 * Each bag is responsible for its own data lifecycle, scoping, and operations.
 *
 * Inspired by Symfony and Laravel flash/input systems.
 */
interface SessionBagInterface
{
    /**
     * Retrieves a value by key from the bag.
     *
     * @param string     $key     The key name.
     * @param mixed|null $default The default value if the key does not exist.
     *
     * @return mixed|null The value or default.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Stores a value in the bag under the given key.
     *
     * @param string $key   The key name.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void;

    /**
     * Determines whether the bag contains the specified key.
     *
     * @param string $key The key name.
     *
     * @return bool True if the key exists.
     */
    public function has(string $key) : bool;

    /**
     * Retrieves all key-value pairs from the bag.
     *
     * @return array<string, mixed> All stored items.
     */
    public function all() : array;

    /**
     * Removes the specified key from the bag.
     *
     * @param string $key The key to remove.
     *
     * @return void
     */
    public function forget(string $key) : void;

    /**
     * Clears all values from the bag.
     *
     * @return void
     */
    public function clear() : void;
}

=== HTTP/Session/Contracts/SessionBuilderInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

use ArrayAccess;

/**
 * Interface SessionBuilderInterface
 *
 * Represents the contract for a fluent, Domain-Specific Language (DSL)-oriented
 * interface for manipulating session data in a contextual and flexible manner.
 *
 * Design principles:
 * - Implements immutable fluency for operations when applicable.
 * - Encourages brevity and readability during session management via fluent chaining.
 *
 * Extends:
 * - ArrayAccess: Enables idiomatic usage of array-like syntax,
 *   allowing operations like:
 *      - `$builder['key']`: Direct access to session data.
 *      - `isset($builder['key'])`: Check presence of session keys.
 *      - `unset($builder['key'])`: Deleting session keys.
 */
interface SessionBuilderInterface extends ArrayAccess
{
    /**
     * Retrieves a value from the session using a specified key, with support for
     * an optional fallback default.
     *
     * @param string     $key     The unique identifier for the value within the session.
     * @param mixed|null $default A default value to return if the key is not found (optional).
     *
     * @return mixed The value associated with the specified key, or the default value if not present.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Stores a value in the session under the specified key.
     *
     * @param string $key   The unique identifier for the value within the session.
     * @param mixed  $value The value to store in the session.
     *
     * @return void No return value; modifies session state directly.
     */
    public function set(string $key, mixed $value) : void;

    /**
     * Checks if a given key exists in the session.
     *
     * @param string $key The unique identifier to check for existence in the session.
     *
     * @return bool True if the key exists, False otherwise.
     */
    public function has(string $key) : bool;

    /**
     * Deletes a value from the session using the specified key.
     *
     * @param string $key The unique identifier of the value to delete from the session.
     *
     * @return void No return value; removes data from session.
     */
    public function delete(string $key) : void;

    /**
     * Sets the current namespace for session operations, enabling segmentation
     * or scoped session values.
     *
     * @param string $namespace The namespace to apply for subsequent session operations.
     *
     * @return self Returns the instance of the session builder for fluent operations.
     */
    public function withNamespace(string $namespace) : self;

    /**
     * Defines the Time-To-Live (TTL) duration for session data, allowing specification
     * of expiry in seconds.
     *
     * @param int $seconds The time (in seconds) before the session data is marked as expired.
     *
     * @return self Returns the instance of the session builder for fluent chaining.
     */
    public function withTTL(int $seconds) : self;

    /**
     * Marks the session as "secure," ensuring that session data adheres to stricter
     * security constraints, such as automatically using HTTPS or encryption policies.
     *
     * @return self Returns the instance of the session builder for fluent chaining.
     */
    public function secure() : self;

    /**
     * Magic invocation method to retrieve session data. Acts as a shorthand for retrieving
     * a key with an optional default value directly.
     *
     * @param string     $key     The unique identifier for the value.
     * @param mixed|null $default The fallback default value (optional).
     *
     * @return mixed The value associated with the key, or the default value if not set.
     */
    public function __invoke(string $key, mixed $default = null) : mixed;

    /**
     * Serializes the current session builder state to a string representation. Typically used for
     * debugging or interoperability with systems expecting a string output.
     *
     * @return string A string representation of the session builder's current state.
     */
    public function __toString() : string;
}
=== HTTP/Session/Contracts/SessionInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

use ArrayAccess;
use Closure;

/**
 * Interface SessionInterface
 *
 * Defines the contract for managing session storage with advanced capabilities such as encryption,
 * time-to-live (TTL) expiration, and full control over the session lifecycle. This interface
 * ensures implementation flexibility by remaining framework-agnostic and highly portable.
 *
 * Common Use Cases:
 * - Storing user-specific data securely during a session.
 * - Managing temporary application state without coupling to a specific framework.
 * - Providing strong adherence to SOLID and DDD principles in session management architecture.
 *
 * Expectations:
 * - Encryption of session data for enhanced security.
 * - Configurable data expiration using TTL.
 * - Full lifecycle control (starting, invalidating, regenerating sessions).
 *
 * This interface inherits `ArrayAccess` to allow session storage manipulation via array-like syntax.
 *
 * @package Gemini\HTTP\Session\Contracts
 */
interface SessionInterface extends ArrayAccess
{
    /**
     * Starts the session lifecycle.
     *
     * This method should initialize the session, preparing it to store and retrieve session data.
     * If a session is already active, implementations should avoid reinitialization.
     *
     * @return void
     */
    public function start() : void;

    /**
     * Flushes all session data.
     *
     * Performs a complete reset by clearing all stored session data. Useful when the session should
     * be completely emptied, such as during logout procedures.
     *
     * @return void
     */
    public function flush() : void;

    /**
     * Deletes a specific key from the session storage.
     *
     * @param string $key The key identifying the session entry to be deleted.
     *
     * @return void
     */
    public function delete(string $key) : void;

    /**
     * Retrieves a value from the session storage.
     *
     * @param string     $key     The key for the session entry.
     * @param mixed|null $default The default value to return if the key does not exist.
     *
     * @return mixed The stored value, or the provided default.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Stores a value in the session storage.
     *
     * @param string $key   The key for the session entry.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function set(string $key, mixed $value) : void;

    /**
     * An alias to `set`. Ensures consistency in naming styles.
     *
     * @param string $key   The key for the session entry.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void;

    /**
     * Stores a value in the session with a defined time-to-live (TTL).
     *
     * Data stored using this method will expire and be invalidated after the specified TTL.
     *
     * @param string $key   The key for the session entry.
     * @param mixed  $value The value to store.
     * @param int    $ttl   Time-to-live in seconds for the session entry.
     *
     * @return void
     */
    public function putWithTTL(string $key, mixed $value, int $ttl) : void;

    /**
     * Checks whether the session contains a specific key.
     *
     * @param string $key The key to check for existence in the session.
     *
     * @return bool True if the key exists, false otherwise.
     */
    public function has(string $key) : bool;

    /**
     * Retrieves all key-value pairs stored in the session.
     *
     * @return array<string, mixed> An associative array of all session entries.
     */
    public function all() : array;

    /**
     * Retrieves and removes a value from the session.
     *
     * Useful for cases where session data is meant to be consumed only once.
     *
     * @param string     $key     The key for the session entry.
     * @param mixed|null $default The default value if the key does not exist.
     *
     * @return mixed The value, or the default if not found.
     */
    public function pull(string $key, mixed $default = null) : mixed;

    /**
     * Retrieves a value from the session or executes a callback to generate it.
     *
     * If the key does not exist, the callback will generate and store the value, ensuring lazy evaluation.
     *
     * @param string  $key      The key for the session entry.
     * @param Closure $callback A callback returning the value to store if the key does not exist.
     *
     * @return mixed The retrieved or newly generated value.
     */
    public function remember(string $key, Closure $callback) : mixed;

    /**
     * Increments the value of a specific session entry.
     *
     * @param string $key    The key for the session entry.
     * @param int    $amount The amount to increment by (default: 1).
     *
     * @return int The incremented value.
     */
    public function increment(string $key, int $amount = 1) : int;

    /**
     * Decrements the value of a specific session entry.
     *
     * @param string $key    The key for the session entry.
     * @param int    $amount The amount to decrement by (default: 1).
     *
     * @return int The decremented value.
     */
    public function decrement(string $key, int $amount = 1) : int;

    /**
     * Regenerates the session ID.
     *
     * This is useful for preventing session fixation attacks. Optionally, the old session data can be deleted.
     *
     * @param bool $deleteOldSession Whether to delete the old session (default: true).
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true) : void;

    /**
     * Invalidates the current session.
     *
     * Typically used for logout or resetting session state.
     *
     * @return void
     */
    public function invalidate() : void;

    /**
     * Retrieves data from the previous request.
     *
     * This is commonly used to repopulate old form inputs after redirects.
     *
     * @param string     $key     The key for the session entry.
     * @param mixed|null $default The default value if the key does not exist.
     *
     * @return mixed The retrieved old input, or the provided default.
     */
    public function getOldInput(string $key, mixed $default = null) : mixed;

    public function getRegistry() : BagRegistryInterface;

}
=== HTTP/Session/Contracts/SessionLoggerInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

use Psr\Log\LoggerInterface;

/**
 * Interface SessionLoggerInterface
 *
 * This interface defines a specialized logging contract that extends the PSR-3 LoggerInterface,
 * specifically for session-related logging functionalities. It enables the implementation of a unified
 * session logging system to maintain high observability and track session-related events.
 *
 * @see \Psr\Log\LoggerInterface For the standard logging contract, this interface extends.
 */
interface SessionLoggerInterface extends LoggerInterface
{
    // By extending LoggerInterface, this interface inherits the PSR-3 logging methods,
    // such as `emergency()`, `alert()`, `critical()`, `error()`, `warning()`, `notice()`, `info()`,
    // and `debug()`. This enables session-specific logging needs to seamlessly integrate with
    // any PSR-3-compliant logging system.
}
=== HTTP/Session/Contracts/SessionManagerInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

use Gemini\HTTP\Session\SessionBuilder;

/**
 * Interface SessionManagerInterface
 *
 * Defines a clean, type-safe contract for centralized session management.
 * Promotes modularity, testability, and inversion of control.
 */
interface SessionManagerInterface
{
    /**
     * Creates a fluent builder for scoped session access.
     *
     * @return SessionBuilder
     */
    public function builder() : SessionBuilder;

    /**
     * Retrieves a session value by key.
     *
     * @param string     $key
     * @param mixed|null $default
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Stores a value securely in the session.
     *
     * @param string $key
     * @param mixed  $value
     *
     * @return void
     */
    public function set(string $key, mixed $value) : void;

    /**
     * Determines whether a session key exists.
     *
     * @param string $key
     *
     * @return bool
     */
    public function has(string $key) : bool;

    /**
     * Deletes a session key.
     *
     * @param string $key
     *
     * @return void
     */
    public function delete(string $key) : void;

    /**
     * Resets the session and clears all stored data.
     *
     * @return void
     */
    public function reset() : void;
}

=== HTTP/Session/Contracts/SessionStoreInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Contracts;

/**
 * SessionStoreInterface
 *
 * Defines the contract for session storage backends.
 * Storage engines must implement these methods to adhere to
 * standardized session management behavior.
 */
interface SessionStoreInterface
{
    /**
     * Initializes the session.
     *
     * This should start the session storage mechanism,
     * creating or resuming an existing session.
     *
     * @return void
     */
    public function start() : void;

    /**
     * Retrieves a session value by its key.
     *
     * @param string     $key     The session key to retrieve.
     * @param mixed|null $default The default value to return if the key is not found.
     *
     * @return mixed The value associated with the key, or the default value if not set.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Saves a value in the session.
     *
     * @param string $key   The session key to store the value under.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void;

    /**
     * Removes a key-value pair from the session.
     *
     * No effect if the specified key does not exist in the session.
     *
     * @param string $key The session key to delete.
     *
     * @return void
     */
    public function delete(string $key) : void;

    /**
     * Retrieves all session data as a key-value associative array.
     *
     * @return array<string, mixed> The entire session data.
     */
    public function all() : array;

    /**
     * Clears all session data.
     *
     * WARNING: This will permanently delete all session data.
     * Use with caution.
     *
     * @return void
     */
    public function flush() : void;

    /**
     * Regenerates the session ID.
     *
     * This prevents session fixation attacks by creating a new session ID.
     *
     * @param bool $deleteOldSession If true, destroys the old session data. Default is true.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true) : void;
}
=== HTTP/Session/Drivers/ArraySession.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Drivers;

use Closure;
use Gemini\HTTP\Session\AbstractSession;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Contracts\SessionStoreInterface;

/**
 * ArraySession
 *
 * In-memory session implementation. Primarily used for testing purposes
 * and non-persistent session storage. This should not be used in production
 * environments due to the volatile nature of in-memory storage.
 *
 * @package Gemini\HTTP\Session\Drivers
 */
final class ArraySession extends AbstractSession
{
    /**
     * Constructor for ArraySession.
     * Dependency Injection ensures this class adheres to the principle of Inversion of Control.
     *
     * @param SessionStoreInterface $store The store implementation for session handling.
     */
    public function __construct(
        SessionStoreInterface $store,
        Closure               $registryFactory
    ) {
        /** @var Closure(SessionInterface): BagRegistryInterface $registryFactory */
        $registry = $registryFactory($this);
        // TODO: Make this final logic for ArraySession when time comes
        parent::__construct(
            store   : $store,
            registry: $registry
        );
    }

    /**
     * Potential edge cases and usage scenarios:
     * - This session driver is intentionally in-memory and ephemeral.
     *   When the application terminates, session data will be lost.
     * - Suitable for unit or integration tests, and scenarios where persistence is not required.
     * - Ensure no reliance on long-lived session data to avoid unexpected behavior in production-like environments.
     *
     * Security warning:
     * - Do not use this in environments requiring persistent or distributed sessions.
     */
}
=== HTTP/Session/Drivers/NativeSession.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Drivers;

use Closure;
use Gemini\HTTP\Session\AbstractSession;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Contracts\SessionStoreInterface;

/**
 * Class NativeSession
 *
 * A concrete implementation of `AbstractSession` that utilizes PHP's native session handling mechanism.
 *
 * This class adheres to the principles of DDD by encapsulating the session handling behavior
 * and delegating responsibilities to specialized interfaces.
 */
final class NativeSession extends AbstractSession
{
    /**
     * NativeSession Constructor.
     *
     * This constructor uses PHP 8.3's constructor property promotion for concise and expressive initialization
     * while adhering to SRP (Single Responsibility Principle) by delegating storage and cryptographic logic to their
     * respective interfaces.
     *
     * @param SessionStoreInterface $store The storage mechanism the session will use to persist session data.
     * @param \Closure              $registryFactory
     */
    public function __construct(
        SessionStoreInterface $store,
        Closure               $registryFactory
    ) {
        /** @var Closure(SessionInterface): BagRegistryInterface $registryFactory */
        $registry = $registryFactory($this);

        parent::__construct(
            store   : $store,
            registry: $registry
        );
    }
}
=== HTTP/Session/Enums/SessionBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Enums;

/**
 * Enum `SessionBag`
 *
 * Represents the types of session data bags used in the session management system.
 * By using enums, this design allows for strict type safety and eliminates the risk
 * of invalid session bag type usage. Adhering to Clean Code principles, this ensures
 * the operation surrounding session bag types remains self-contained, predictable,
 * and scalable.
 *
 * @package Gemini\HTTP\Session\Enums
 */
enum SessionBag: string
{
    /**
     * Flash Bag
     *
     * Represents the session bag for flash messages — temporary session
     * data that persists only until it is read during the next request.
     *
     * Example usage:
     * - Temporary notifications (e.g., "Your account has been updated.")
     * - Alerts displayed post-redirect.
     *
     * @var string
     */
    case Flash = 'flash';

    /**
     * Input Bag
     *
     * Captures user input data and retains it for redisplaying forms in case
     * of validation failures. This is commonly used to show old input in forms.
     *
     * Example usage:
     * - Preserving user input after form validation errors.
     *
     * @var string
     */
    case Input = 'input';

    /**
     * Validation Bag
     *
     * Holds validation error messages associated with forms or other input validation.
     * This helps maintain a clear separation of data related to failed validations.
     *
     * Example usage:
     * - Displaying form field or general error messages in the UI.
     *
     * @var string
     */
    case Validation = 'validation';
}
=== HTTP/Session/Enums/SessionDriver.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Enums;

/**
 * Enum `SessionDriver`
 *
 * Represents the available session storage drivers in the application's session handling system.
 * Enumerations here define clearly the specific storage mechanisms supported.
 * This adheres to the Single Responsibility Principle by isolating session-driver-related constants
 * in a self-contained construct. This type-safety ensures scalability and reduces potential usage errors.
 *
 * @package Gemini\HTTP\Session\Enums
 */
enum SessionDriver: string
{
    /**
     * Native Session Driver
     *
     * Represents the use of PHP's default session handling mechanism.
     * Suited for applications where the native PHP session engine suffices,
     * such as basic file-based storage without external adapters.
     *
     * @var string
     */
    case Native = 'native';

    /**
     * Array-Based Session Driver
     *
     * Represents a memory-only session storage mechanism where session data
     * is stored in arrays. This is ideal for unit testing or scenarios
     * where persistent state is not required.
     *
     * @var string
     */
    case Array = 'array';
}
=== HTTP/Session/Enums/SessionTag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Enums;

/**
 * Enum `SessionTag`
 *
 * Represents different types of tags that categorize session data in the application.
 * By utilizing an enum, this structure ensures explicit type safety and eliminates
 * the risk of hardcoded or invalid session tag values. This adheres to Domain-Driven Design (DDD)
 * principles by enforcing strong domain boundaries and context-specific behavior.
 *
 * Enums provide clarity and predictability, making the codebase more expressive
 * and maintainable, ensuring clean design principles are upheld.
 *
 * @package Gemini\HTTP\Session\Enums
 */
enum SessionTag: string
{
    /**
     * Flash Tag
     *
     * The flash tag is used to categorize session data that is temporary and designed
     * to last only until the next request is completed. Commonly used for passing
     * notifications or alerts across requests after a redirect.
     *
     * Example Use-Cases:
     * - Temporary feedback ("Your profile has been updated.")
     * - Notifications requiring user acknowledgment during the next request.
     *
     * @var string
     *
     * Usage:
     * ```
     * $session->set(SessionTag::Flash, 'Your changes have been saved!');
     * ```
     */
    case Flash = 'flash';

    /**
     * User Tag
     *
     * The user tag categorizes session data related specifically to the logged-in user.
     * This tag can be leveraged to store user-related metadata, preferences, or credentials
     * that are required during the session's lifecycle.
     *
     * Example Use-Cases:
     * - Authentication tokens.
     * - User preferences (e.g., locale, themes).
     *
     * @var string
     *
     * Usage:
     * ```
     * $session->set(SessionTag::User, ['id' => 123, 'name' => 'John Doe']);
     * ```
     */
    case User = 'user';
}
=== HTTP/Session/Exceptions/FlashBagKeyNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * Exception thrown when attempting to retrieve a non-existent flash key.
 */
final class FlashBagKeyNotFoundException extends RuntimeException {}
=== HTTP/Session/Exceptions/SessionException.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * SessionException
 * Custom exception class for session management errors.
 */
class SessionException extends RuntimeException {}
=== HTTP/Session/LoggableSessionDecorator.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Closure;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Contracts\SessionLoggerInterface;

/**
 * Class LoggableSessionDecorator
 *
 * This class implements the Decorator pattern to transparently wrap a SessionInterface instance
 * and provide logging behavior via a SessionLoggerInterface.
 *
 * Each session operation is logged with appropriate context to aid debugging, traceability,
 * analytics, and observability in production-grade systems.
 */
final readonly class LoggableSessionDecorator implements SessionInterface
{
    public function __construct(
        private SessionInterface       $inner,
        private SessionLoggerInterface $logger
    ) {}

    /**
     * Start the session lifecycle and log the event.
     */
    public function start() : void
    {
        $this->logger->debug(message: 'Session started.');
        $this->inner->start();
    }

    /**
     * Retrieve the entire session data array and log the access.
     */
    public function all() : array
    {
        $this->logger->debug(message: 'Session::all called');

        return $this->inner->all();
    }

    /**
     * Remove all session data and log the flush action.
     */
    public function flush() : void
    {
        $this->logger->info(message: 'Flushing all session data.');
        $this->inner->flush();
    }

    /**
     * Invalidate the session and log the invalidation event.
     */
    public function invalidate() : void
    {
        $this->logger->warning(message: 'Session invalidated.');
        $this->inner->invalidate();
    }

    /**
     * Regenerate session ID and optionally delete the old session.
     * Logs the operation and its parameter.
     */
    public function regenerateId(bool $deleteOldSession = true) : void
    {
        $this->logger->info(message: 'Session ID regenerated.', context: [
            'delete_old' => $deleteOldSession,
        ]);

        $this->inner->regenerateId(deleteOldSession: $deleteOldSession);
    }

    /**
     * Retrieve a session value by key and log whether fallback default was used.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $value = $this->inner->get(key: $key, default: $default);

        $this->logger->debug(message: 'Session::get', context: [
            'key'              => $key,
            'returned_default' => $value === $default,
        ]);

        return $value;
    }

    /**
     * Store a value in the session and log the operation with value type.
     */
    public function set(string $key, mixed $value) : void
    {
        $this->logger->info(message: 'Session::set', context: [
            'key'        => $key,
            'value_type' => get_debug_type($value),
        ]);

        $this->inner->set(key: $key, value: $value);
    }

    /**
     * Set session value (same as `set`) with detailed logging including value content.
     */
    public function put(string $key, mixed $value) : void
    {
        $this->logger->info(message: 'Session::put', context: [
            'key'        => $key,
            'value_type' => get_debug_type($value),
            'value'      => $value,
        ]);

        $this->inner->put(key: $key, value: $value);
    }

    /**
     * Remove a key from the session and log the deletion.
     */
    public function delete(string $key) : void
    {
        $this->logger->notice(message: 'Session::delete', context: ['key' => $key]);
        $this->inner->delete(key: $key);
    }

    /**
     * Flash a value to the session for next request and log the key.
     */
    public function flash(string $key, mixed $value) : void
    {
        $this->logger->info(message: 'Session::flash', context: ['key' => $key]);
        $this->inner->flash(key: $key, value: $value);
    }

    /**
     * Retrieve a flashed value and log the key being accessed.
     */
    public function getFlash(string $key, mixed $default = null) : mixed
    {
        $this->logger->debug(message: 'Session::getFlash', context: ['key' => $key]);

        return $this->inner->getFlash(key: $key, default: $default);
    }

    /**
     * Retain a flashed value for another request cycle and log the key.
     */
    public function keepFlash(string $key) : void
    {
        $this->logger->info(message: 'Session::keepFlash', context: ['key' => $key]);
        $this->inner->keepFlash(key: $key);
    }

    /**
     * Flash an entire input array to the session (used for old input support).
     */
    public function flashInput(array $input) : void
    {
        $this->logger->info(message: 'Session::flashInput invoked.');
        $this->inner->flashInput(input: $input);
    }

    /**
     * Retrieve old form input (flashed) and log the key.
     */
    public function getOldInput(string $key, mixed $default = null) : mixed
    {
        $this->logger->debug(message: 'Session::getOldInput', context: ['key' => $key]);

        return $this->inner->getOldInput(key: $key, default: $default);
    }

    /**
     * Store a key with TTL (Time To Live) and log the duration.
     */
    public function putWithTTL(string $key, mixed $value, int $ttl) : void
    {
        $this->logger->debug(message: 'Session::putWithTTL', context: [
            'key' => $key,
            'ttl' => $ttl,
        ]);

        $this->inner->putWithTTL(key: $key, value: $value, ttl: $ttl);
    }

    /**
     * Retrieve a key and remove it from the session. Logs retrieval.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        $this->logger->debug(message: 'Session::pull', context: ['key' => $key]);

        return $this->inner->pull(key: $key, default: $default);
    }

    /**
     * Attempt to get a value, or compute and store via callback.
     * Logs if cache hit occurred.
     */
    public function remember(string $key, Closure $callback) : mixed
    {
        $exists = $this->inner->has(key: $key);

        $this->logger->debug(message: 'Session::remember', context: [
            'key'    => $key,
            'cached' => $exists,
        ]);

        return $this->inner->remember(key: $key, callback: $callback);
    }

    /**
     * Check for the existence of a key and log result.
     */
    public function has(string $key) : bool
    {
        $exists = $this->inner->has(key: $key);

        $this->logger->debug(message: 'Session::has', context: [
            'key'    => $key,
            'exists' => $exists,
        ]);

        return $exists;
    }

    /**
     * Increment a numeric value in session and log amount.
     */
    public function increment(string $key, int $amount = 1) : int
    {
        $this->logger->info(message: 'Session::increment', context: [
            'key'    => $key,
            'amount' => $amount,
        ]);

        return $this->inner->increment(key: $key, amount: $amount);
    }

    /**
     * Decrement a numeric value in session and log amount.
     */
    public function decrement(string $key, int $amount = 1) : int
    {
        $this->logger->info(message: 'Session::decrement', context: [
            'key'    => $key,
            'amount' => $amount,
        ]);

        return $this->inner->decrement(key: $key, amount: $amount);
    }

    /**
     * Check if key exists using array-access interface. Logs the check.
     */
    public function offsetExists(mixed $offset) : bool
    {
        $exists = $this->inner->offsetExists($offset);

        $this->logger->debug(message: 'Session::offsetExists', context: [
            'key'    => $offset,
            'exists' => $exists,
        ]);

        return $exists;
    }

    /**
     * Retrieve a key via array-access interface. Logs access.
     */
    public function offsetGet(mixed $offset) : mixed
    {
        $this->logger->debug(message: 'Session::offsetGet', context: ['key' => $offset]);

        return $this->inner->offsetGet($offset);
    }

    /**
     * Assign a value via array-access interface. Logs metadata.
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        $this->logger->debug(message: 'Session::offsetSet', context: [
            'key'        => $offset,
            'value_type' => get_debug_type($value),
        ]);

        $this->inner->offsetSet($offset, $value);
    }

    /**
     * Unset a key using array-access syntax. Logs removal.
     */
    public function offsetUnset(mixed $offset) : void
    {
        $this->logger->notice(message: 'Session::offsetUnset', context: ['key' => $offset]);
        $this->inner->offsetUnset($offset);
    }

    /**
     * Return internal BagRegistry for managing session bags.
     */
    public function getRegistry() : BagRegistryInterface
    {
        $this->logger->debug(message: 'Session::getRegistry');

        return $this->inner->getRegistry();
    }
}

=== HTTP/Session/NullSession.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Closure;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * NullSession provides a no-op implementation of the SessionInterface.
 *
 * Useful for testing, stateless APIs, or fallback scenarios where
 * session state is intentionally disabled.
 */
final class NullSession implements SessionInterface
{
    public function get(string $key, mixed $default = null) : mixed
    {
        return $default;
    }

    public function set(string $key, mixed $value) : void {}

    public function has(string $key) : bool
    {
        return false;
    }

    public function remove(string $key) : void {}

    public function all() : array
    {
        return [];
    }

    public function start() : void {}

    public function delete(string $key) : void {}

    public function flash(string $key, mixed $value) : void {}

    public function getFlash(string $key, mixed $default = null) : mixed
    {
        return $default;
    }

    public function keepFlash(string $key) : void {}

    public function flashInput(array $input) : void {}

    public function getOldInput(string $key, mixed $default = null) : mixed
    {
        return $default;
    }

    public function flush() : void {}

    public function invalidate() : void {}

    public function regenerateId(bool $deleteOldSession = true) : void {}

    public function offsetExists(mixed $offset) : bool
    {
        return false;
    }

    public function offsetGet(mixed $offset) : mixed
    {
        return null;
    }

    public function offsetSet(mixed $offset, mixed $value) : void {}

    public function offsetUnset(mixed $offset) : void {}

    public function put(string $key, mixed $value) : void {}

    public function putWithTTL(string $key, mixed $value, int $ttl) : void {}

    public function pull(string $key, mixed $default = null) : mixed
    {
        return $default;
    }

    public function remember(string $key, Closure $callback) : mixed
    {
        return $callback();
    }

    public function increment(string $key, int $amount = 1) : int
    {
        return $amount;
    }

    public function decrement(string $key, int $amount = 1) : int
    {
        return -$amount;
    }

    public function getRegistry() : BagRegistryInterface
    {
        return app(BagRegistryInterface::class);
    }
}

=== HTTP/Session/SessionBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\SessionBuilderInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Enums\SessionTag;
use Override;

/**
 * Fluent DSL (Domain-specific language) for building contextual session operations.
 *
 * This `SessionBuilder` class enables advanced session management capabilities.
 * It provides support for:
 * - Namespacing: To logically separate session data into scoped groups.
 * - Time-To-Live (TTL): To specify expiration durations for session values.
 * - Secure Modes: Offers an easy mechanism to toggle encryption for session data.
 * - Tagging: Allows classification of session data using contextual tags.
 */
final readonly class SessionBuilder implements SessionBuilderInterface
{
    /**
     * Constructor to initialize the session builder.
     *
     * @param SessionInterface     $session  Provides direct session data storage capabilities.
     * @param BagRegistryInterface $registry Manages session bags for modularity and extension.
     * @param SessionContext       $context  Holds contextual configuration for session operations.
     */
    public function __construct(
        private SessionInterface     $session,
        private BagRegistryInterface $registry,
        private SessionContext       $context
    ) {}

    /**
     * Magic method: Allows the `SessionBuilder` to be invoked like a function.
     *
     * Acts as shorthand for retrieving session data (`get()`) with an optional default.
     *
     * @param string     $key     The unique key to retrieve from session storage.
     * @param mixed|null $default The fallback value if the key does not exist (optional).
     *
     * @return mixed The value retrieved from the session or the default value if missing.
     */
    public function __invoke(string $key, mixed $default = null) : mixed
    {
        return $this->get(key: $key, default: $default);
    }

    /**
     * Retrieves data from the session with optional key resolution via namespace.
     *
     * @param string     $key     The unique key to retrieve from session storage.
     * @param mixed|null $default The default value if the key is not found (optional).
     *
     * @return mixed The value associated with the session key or the default value if not present.
     * @see resolveKey()
     *
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->session->get(
            key    : $this->resolveKey(key: $key),
            default: $default
        );
    }

    /**
     * Resolves the full session key by applying the active namespace if specified.
     *
     * @param string $key The base key provided by the consumer.
     *
     * @return string The fully resolved key, including namespace if applicable.
     */
    private function resolveKey(string $key) : string
    {
        return $this->context->namespace !== ''
            ? "{$this->context->namespace}.{$key}"
            : $key;
    }

    /**
     * Determines if a session key exists. Implements ArrayAccess for `isset()` use cases.
     *
     * @param mixed $offset The key to check.
     *
     * @return bool True if the session key exists; False otherwise.
     */
    public function offsetExists(mixed $offset) : bool
    {
        return $this->has(key: (string) $offset);
    }

    /**
     * Verifies the existence of a specific session entry.
     *
     * @param string $key The session key to check.
     *
     * @return bool True if the key exists; False otherwise.
     */
    public function has(string $key) : bool
    {
        return $this->session->has(key: $this->resolveKey(key: $key));
    }

    /**
     * Retrieves a session value via ArrayAccess, converting the offset to a string key.
     *
     * @param mixed $offset The key to retrieve.
     *
     * @return mixed The value associated with the key.
     */
    public function offsetGet(mixed $offset) : mixed
    {
        return $this->get(key: (string) $offset);
    }

    /**
     * Allows session values to be set via ArrayAccess. Resolves key via offset.
     *
     * @param mixed $offset The key where the value will be saved.
     * @param mixed $value  The value to be saved in the session.
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        $this->set(key: (string) $offset, value: $value);
    }

    /**
     * Stores data in the session, respecting secure and TTL context configurations.
     *
     * @param string $key   The session key for storage.
     * @param mixed  $value The value to be stored.
     *
     * @return void
     * @see resolveKey()
     *
     */
    public function set(string $key, mixed $value) : void
    {
        $resolvedKey = $this->resolveKey(key: $key);

        // Secure storage
        if ($this->context->secure) {
            $this->session->put(key: $resolvedKey, value: $value);
            // TTL-based storage
        } elseif ($this->context->ttl !== null) {
            $this->session->putWithTTL(
                key  : $resolvedKey,
                value: $value,
                ttl  : $this->context->ttl
            );
            // Default storage
        } else {
            $this->session->put(key: $resolvedKey, value: $value);
        }
    }

    /**
     * Supports session data removal via ArrayAccess.
     *
     * @param mixed $offset The session key to unset.
     *
     * @return void
     */
    public function offsetUnset(mixed $offset) : void
    {
        $this->delete(key: (string) $offset);
    }

    /**
     * Deletes session data associated with a specific key after resolving via namespace.
     *
     * @param string $key The session key to remove.
     *
     * @return void
     */
    public function delete(string $key) : void
    {
        $this->session->delete(key: $this->resolveKey(key: $key));
    }

    /**
     * Updates the context to enable secure session mode.
     *
     * @return self A new `SessionBuilder` with secure mode enabled.
     */
    public function secure() : self
    {
        return $this->withContext($this->context->secure());
    }

    /**
     * Creates a new instance with an updated session context.
     *
     * @param SessionContext $context The updated context object.
     *
     * @return self A new `SessionBuilder` instance with updated configuration.
     */
    private function withContext(SessionContext $context) : self
    {
        return new self(
            session : $this->session,
            registry: $this->registry,
            context : $context
        );
    }

    /**
     * Sets a TTL (Time-To-Live) in seconds for session storage.
     *
     * @param int $seconds Number of seconds before session data expires.
     *
     * @return self A new `SessionBuilder` instance with TTL applied.
     */
    public function withTTL(int $seconds) : self
    {
        return $this->withContext($this->context->withTTL(ttl: $seconds));
    }

    /**
     * Tags the session context with a specific semantic grouping.
     *
     * @param SessionTag $tag The new tag to apply to the session.
     *
     * @return self A new `SessionBuilder` instance with the added tag.
     */
    public function tag(SessionTag $tag) : self
    {
        return $this->withContext($this->context->tag(tag: $tag));
    }

    /**
     * Adds a namespace for all subsequent session operations.
     *
     * @param string $namespace The namespace to apply.
     *
     * @return self A new `SessionBuilder` instance with the namespace applied.
     */
    public function withNamespace(string $namespace) : self
    {
        return $this->withContext($this->context->for(namespace: $namespace));
    }

    /**
     * Converts the current state of the `SessionBuilder` into a human-readable string.
     *
     * Useful for debugging, monitoring, or logging session context.
     *
     * @return string A string representation of the current session builder state.
     */
    #[Override]
    public function __toString() : string
    {
        return sprintf(
            'SessionBuilder(namespace="%s", seconds=%s, encrypt=%s, tags=%s)',
            $this->context->namespace,
            $this->context->ttl !== null ? $this->context->ttl . 's' : 'null',
            $this->context->secure ? 'true' : 'false',
            implode(
                ',',
                array_map(
                    static fn(SessionTag $tag) => $tag->name,
                    $this->context->tags
                )
            )
        );
    }
}
=== HTTP/Session/SessionContext.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Gemini\HTTP\Session\Enums\SessionTag;

use function array_unique;

/**
 * Immutable value object for contextual session configuration.
 *
 * Encapsulates namespace, TTL, encryption, and tags.
 */
final readonly class SessionContext
{
    /**
     * @param string           $namespace Logical scope identifier (e.g. "user", "cart", "flash").
     * @param bool             $secure    Whether encryption is enforced for the session values.
     * @param int|null         $ttl       Optional time-to-live in seconds for temporary data.
     * @param list<SessionTag> $tags      Domain-relevant tags for organizational metadata.
     */
    public function __construct(
        public string   $namespace,
        public bool     $secure = false,
        public int|null $ttl = null,
        public array    $tags = []
    ) {}

    /**
     * Factory-style constructor for namespaced context.
     *
     * @param string $namespace Logical namespace for grouping session data.
     *
     * @return self
     */
    public static function for(string $namespace) : self
    {
        return new self(namespace: trim($namespace, '.'));
    }

    /**
     * Clones the context with encryption enabled.
     */
    public function secure() : self
    {
        return new self(
            namespace: $this->namespace,
            secure   : true,
            ttl      : $this->ttl,
            tags     : $this->tags
        );
    }

    /**
     * Clones the context with a new TTL.
     *
     * @param int $ttl Time-to-live in seconds.
     */
    public function withTTL(int $ttl) : self
    {
        return new self(
            namespace: $this->namespace,
            secure   : $this->secure,
            ttl      : $ttl,
            tags     : $this->tags
        );
    }

    /**
     * Clones the context with a new tag appended.
     *
     * @param SessionTag $tag
     *
     * @return \Gemini\HTTP\Session\SessionContext
     */
    public function tag(SessionTag $tag) : self
    {
        return new self(
            namespace: $this->namespace,
            secure   : $this->secure,
            ttl      : $this->ttl,
            tags     : array_unique([...$this->tags, $tag])
        );
    }

    /**
     * Clones the context with a different namespace.
     *
     * @param string $namespace
     *
     * @return \Gemini\HTTP\Session\SessionContext
     */
    public function forNamespace(string $namespace) : self
    {
        return new self(
            namespace: trim($namespace, '.'),
            secure   : $this->secure,
            ttl      : $this->ttl,
            tags     : $this->tags
        );
    }
}

=== HTTP/Session/SessionManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use Gemini\HTTP\Session\Contracts\SessionBagInterface;
use Gemini\HTTP\Session\Contracts\SessionBuilderInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;

/**
 * The `SessionManager` class acts as a central access point for session-related operations.
 *
 * It encapsulates session management logic, adhering to Domain-Driven Design principles, by delegating
 * responsibilities to specialized component contracts such as `SessionInterface` for session state management
 * and `BagRegistryInterface` for organizing session data into modular "bags".
 *
 * Main responsibilities include:
 * - Managing session data using structured namespaces.
 * - Providing access to specialized data containers such as flash messages or error containers.
 * - Abstracting session lifecycle operations and configuration.
 *
 * @internal Immutable class with `readonly` properties ensures integrity and predictable behavior at runtime.
 */
final readonly class SessionManager
{
    /**
     * Constructor.
     *
     * Constructor promotion ensures concise and expressive initialization of immutable properties.
     *
     * @param SessionInterface     $session Core session handler.
     * @param BagRegistryInterface $bags    Bag registry for managing session sub-containers.
     */
    public function __construct(
        private SessionInterface     $session,
        private BagRegistryInterface $bags
    ) {}

    /**
     * Creates a new session builder for a specific namespace.
     *
     * A `SessionBuilder` enables more flexible interaction with session data
     * in a particular structured context. This allows grouping session data
     * logically under a unique namespace.
     *
     * @param string $namespace The namespace for the session context.
     *
     * @return SessionBuilderInterface A session builder for the given namespace.
     */
    public function for(string $namespace) : SessionBuilderInterface
    {
        // Creates a builder with scoped context and namespace.
        return new SessionBuilder(
            session : $this->session,
            registry: $this->bags,
            context : new SessionContext(namespace: $namespace)
        );
    }

    /**
     * Creates a new session builder with the default namespace.
     *
     * This is a shortcut method for working with session data outside of
     * any specific namespace, by default using `default` as the context.
     *
     * @return SessionBuilderInterface A session builder for the default namespace.
     */
    public function builder() : SessionBuilderInterface
    {
        // Creates a builder with the default session namespace.
        return new SessionBuilder(
            session : $this->session,
            registry: $this->bags,
            context : new SessionContext(namespace: 'default')
        );
    }

    /**
     * Stores a key-value pair in the session, ensuring secure handling.
     *
     * Delegates secure, persistent storage to the session handler.
     *
     * @param string $key   The identifier for the session entry.
     * @param mixed  $value The value to associate with the given key.
     *
     * @return void
     */
    public function set(string $key, mixed $value) : void
    {
        $this->session->put(key: $key, value: $value);
    }

    /**
     * Checks if the session contains the given key.
     *
     * @param string $key The session key to check for.
     *
     * @return bool True if the key exists in the session; false otherwise.
     */
    public function has(string $key) : bool
    {
        return $this->session->has(key: $key);
    }

    /**
     * Deletes the specified key from the session.
     *
     * This removes the associated value for the given key from the session storage.
     *
     * @param string $key The identifier of the entry to remove.
     *
     * @return void
     */
    public function delete(string $key) : void
    {
        $this->session->delete(key: $key);
    }

    /**
     * Retrieves the flash message session bag.
     *
     * Flash messages are transient data that persists for only the next request cycle.
     * Commonly used for notifications, feedback messages, or one-time state indicators.
     *
     * @return FlashBagInterface A dedicated flash bag for temporary data.
     */
    public function flash() : FlashBagInterface
    {
        return $this->bags->flash();
    }

    /**
     * Retrieves the error message session bag.
     *
     * An error bag is specifically designed to store validation errors or
     * feedback messages across requests, enabling streamlined error handling for users.
     *
     * @return SessionBagInterface A bag for organizing error-related session data.
     */
    public function errors() : SessionBagInterface
    {
        return $this->bags->errors();
    }

    /**
     * Resets the entire session state.
     *
     * Invalidates the current session and removes all associated data. This is
     * especially useful for logout scenarios or resetting user session contexts.
     *
     * @return void
     */
    public function reset() : void
    {
        $this->session->invalidate();
    }
}
=== HTTP/Session/Session.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session;

use Gemini\Facade\BaseFacade;
use Gemini\HTTP\Session\Contracts\SessionBuilderInterface;
use Gemini\HTTP\Session\Contracts\SessionManagerInterface;

/**
 * @method static SessionBuilderInterface for (string $namespace)
 * @method static SessionBuilderInterface builder()
 * @method static void put(string $key, mixed $value)
 * @method static mixed get(string $key, mixed $default = null)
 * @method static bool has(string $key)
 * @method static void delete(string $key)
 * @method static void reset()
 *
 * @see SessionManagerInterface
 * @see SessionBuilderInterface
 */
final class Session extends BaseFacade
{
    protected static string $accessor = SessionManagerInterface::class;
}

=== HTTP/Session/Stores/ArraySessionStore.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Stores;

use Gemini\HTTP\Session\Contracts\SessionStoreInterface;
use RuntimeException;

/**
 * Class ArraySessionStore
 *
 * This is an in-memory implementation of the `SessionStoreInterface` for handling session data.
 * The store does **not persist state** between requests, making it ideal for testing or use in stateless environments.
 * Implements core session store operations such as retrieving, storing, and deleting session data.
 * The store is simple and does not deal with session IDs or persistence layers.
 */
final class ArraySessionStore implements SessionStoreInterface
{
    /**
     * @var array<string, mixed> $data
     *
     * The underlying in-memory array used to store session key-value pairs.
     * Keys are strings, and values can be of any type.
     */
    private array $data = [];

    /**
     * @var bool $started
     *
     * Indicates whether the session has started.
     * A session must be "started" before data can be read from or written to it.
     * This ensures consistency in session operations.
     */
    private bool $started = false;

    /**
     * Retrieve a session value using its key.
     *
     * Looks for the given `$key` in the internal session storage.
     * If the key is not found, the `$default` value is returned.
     * Automatically ensures the session has started before accessing the data.
     *
     * @param string     $key     The session key to retrieve.
     * @param mixed|null $default A fallback value to return if `$key` does not exist (defaults to null).
     *
     * @return mixed The value associated with `$key`, or `$default` if the key does not exist.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Ensure the session has been started before accessing data.


        // Return the value from session data or the default if not found.
        return $this->data[$key] ?? $default;
    }

    /**
     * Remove a session key.
     *
     * Deletes a specific `$key` from the session storage.
     * If the `$key` does not exist in the session, this method does nothing.
     * Automatically ensures the session is started before modifying data.
     *
     * @param string $key The session key to delete.
     *
     * @return void
     */
    public function delete(string $key) : void
    {
        // Ensure the session is started before attempting to delete a key.


        // Remove the specified key from the session data.
        unset($this->data[$key]);
    }

    /**
     * Retrieve all session data.
     *
     * Returns the entire session storage array as key-value pairs.
     * Automatically ensures the session is started before reading data.
     *
     * @return array<string, mixed> The entire session dataset.
     */
    public function all() : array
    {
        // Ensure the session is started before retrieving all data.


        // Return the full in-memory session store.
        return $this->data;
    }

    /**
     * Regenerate the session ID.
     *
     * This operation is typically used to mitigate session fixation attacks in persistent stores.
     * For this in-memory implementation, regenerating the session ID has no real effect,
     * but optionally clears session data when `$deleteOldSession` is true.
     *
     * @param bool $deleteOldSession Whether to delete all old session data (defaults to true).
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true) : void
    {
        // Ensure the session is started before attempting to regenerate the ID.


        // If the old session data is to be cleared, flush all session data.
        if ($deleteOldSession) {
            $this->flush();
        }
        // No actual session ID logic is implemented for an in-memory store.
    }

    /**
     * Flush all session data.
     *
     * Completely purges all key-value pairs stored in the session.
     * This operation **permanently removes all stored data within the session's lifecycle.**
     * Automatically ensures the session is started before clearing data.
     *
     * @return void
     */
    public function flush() : void
    {
        // Ensure the session is started before flushing its data.


        // Empty the entire session store.
        $this->data = [];
    }

    /**
     * Stores a value in the session with a Time-To-Live (TTL).
     *
     * This method adds two entries into the session storage:
     * - The primary key with the associated value.
     * - A metadata key (`{$key}::__meta`) that tracks the expiry of the primary key.
     *
     * The TTL is used to calculate an expiration timestamp, which can be referenced
     * later to determine if the session value has expired.
     *
     * Usage of metadata allows separation of session value and its lifecycle management
     * information, keeping the session data structure clean and scalable.
     *
     * @param string $key   The unique key under which the value will be stored.
     *                      Ensures proper scoping and organization of session keys.
     * @param mixed  $value The value to store in the session.
     *                      This can be any serializable PHP data type.
     * @param int    $ttl   The time-to-live in seconds for the session entry.
     *                      Represents the lifespan of the session value from the time of storage.
     *
     * @throws RuntimeException If the session is not started or fails to write.
     *                          Ensures robust error handling in a session-based context.
     */
    public function putWithTTL(string $key, mixed $value, int $ttl) : void
    {
        // Store the main value in the session under the specified key.
        // This key represents the user's data to be tracked.
        $this->put(
            key  : $key,
            value: $value
        );

        // Store metadata about the session value to track its expiration.
        // The metadata includes an `expires_at` timestamp to record the TTL.
        $this->put(
            key  : "{$key}::__meta",
            value: ['expires_at' => time() + $ttl]
        );
    }

    /**
     * Save a value in the session by key.
     *
     * Adds or updates the given `$key` with the new `$value` in the internal session storage array.
     * Automatically ensures the session is started before writing data.
     *
     * @param string $key   The key under which to store the value.
     * @param mixed  $value The value to store (can be of any type).
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        // Ensure the session is started before writing data.


        // Store the key-value pair in the in-memory session data.
        $this->data[$key] = $value;
    }

    /**
     * Ensure the session is initialized and started.
     *
     * Automatically starts the session if it has not already been started.
     * This method guarantees that session operations are only executed after the session has been initialized.
     *
     * @return void
     */
    private function ensureSessionStarted() : void
    {
        // Start the session if it has not yet been marked as started.
        if (! $this->started) {
            $this->start();
        }
    }

    /**
     * Start the session.
     *
     * Marks the session as "started", allowing read or write operations to proceed.
     * If the session is already marked as `started`, this method does nothing.
     * Calling this method multiple times is safe.
     *
     * @return void
     */
    public function start() : void
    {
        // Check the session state and set as started if needed.
        if (! $this->started) {
            $this->started = true;
        }
    }

}
=== HTTP/Session/Stores/NativeSessionStore.php ===
<?php
/** @noinspection GlobalVariableUsageInspection */

/**
 * NativeSessionStore
 *
 * This class provides an implementation of the SessionStoreInterface using
 * native PHP's session mechanism ($_SESSION). It focuses on encapsulating
 * session handling to ensure clean and reusable code for managing session
 * states and data.
 *
 * @package Gemini\HTTP\Session\Stores
 */

declare(strict_types=1);

namespace Gemini\HTTP\Session\Stores;

use Gemini\HTTP\Session\Contracts\SessionStoreInterface;
use RuntimeException;

/**
 * Final class implementing the SessionStoreInterface.
 * Encapsulates native PHP session logic to manage session data securely and efficiently.
 */
final class NativeSessionStore implements SessionStoreInterface
{
    /**
     * Retrieve a session value by its key.
     *
     * If the session key does not exist, the default value is returned instead.
     *
     * @param string     $key     The unique key in the session to retrieve the value for.
     * @param mixed|null $default A fallback value if the key is not found (default: null).
     *
     * @return mixed The value associated with the key, or the default value if not found.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Ensure the session is started before accessing $_SESSION.
        $this->start();

        // Retrieve the value from the session storage or return the default.
        return $_SESSION[$key] ?? $default;
    }

    /**
     * Start the session if it hasn't already been started.
     *
     * This ensures that session-related operations can safely proceed.
     *
     * @return void
     */
    public function start() : void
    {
        // Check if the session is not active and initialize it.
        if (session_status() === PHP_SESSION_NONE) {
            // Start the native PHP session.
            session_start();
        }
    }

    /**
     * Remove a value from the session by its key.
     *
     * If the key does not exist, this operation has no effect.
     *
     * @param string $key The unique key of the session value to delete.
     *
     * @return void
     */
    public function delete(string $key) : void
    {
        // Ensure the session is started before attempting to delete the key.
        $this->start();

        // Remove the specified key from the session storage.
        unset($_SESSION[$key]);
    }

    /**
     * Retrieve all session data as a key-value associative array.
     *
     * @return array<string, mixed> The entire session data.
     */
    public function all() : array
    {
        // Ensure the session is started before accessing $_SESSION.
        $this->start();

        // Return the entire $_SESSION data.
        return $_SESSION;
    }

    /**
     * Clear all session data.
     *
     * WARNING: This will remove all session key-value pairs.
     * Use with caution as this action is irreversible for the scope of the session.
     *
     * @return void
     */
    public function flush() : void
    {
        // Ensure the session is started before clearing all session data.
        $this->start();

        // Empty the session array, effectively removing all data.
        $_SESSION = [];
    }

    /**
     * Regenerate the session ID.
     *
     * This is useful for preventing session fixation attacks by assigning
     * a new session ID to the current session context.
     *
     * @param bool $deleteOldSession Indicates whether to delete the old session data.
     *                               Default is true to enhance security.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true) : void
    {
        // Ensure the session is started before regenerating the session ID.
        $this->start();

        // Regenerate the session ID with the option to delete the old session.
        session_regenerate_id(delete_old_session: $deleteOldSession);
    }

    /**
     * Stores a value in the session with a Time-To-Live (TTL).
     *
     * This method adds two entries into the session storage:
     * - The primary key with the associated value.
     * - A metadata key (`{$key}::__meta`) that tracks the expiry of the primary key.
     *
     * The TTL is used to calculate an expiration timestamp, which can be referenced
     * later to determine if the session value has expired.
     *
     * Usage of metadata allows separation of session value and its lifecycle management
     * information, keeping the session data structure clean and scalable.
     *
     * @param string $key   The unique key under which the value will be stored.
     *                      Ensures proper scoping and organization of session keys.
     * @param mixed  $value The value to store in the session.
     *                      This can be any serializable PHP data type.
     * @param int    $ttl   The time-to-live in seconds for the session entry.
     *                      Represents the lifespan of the session value from the time of storage.
     *
     * @throws RuntimeException If the session is not started or fails to write.
     *                          Ensures robust error handling in a session-based context.
     */
    public function putWithTTL(string $key, mixed $value, int $ttl) : void
    {
        // Store the main value in the session under the specified key.
        // This key represents the user's data to be tracked.
        $this->put(
            key  : $key,
            value: $value
        );

        // Store metadata about the session value to track its expiration.
        // The metadata includes an `expires_at` timestamp to record the TTL.
        $this->put(
            key  : "{$key}::__meta",
            value: ['expires_at' => time() + $ttl]
        );
    }

    /**
     * Store a value in the session for a given key.
     *
     * If the key already exists, the value will be overwritten.
     *
     * @param string $key   The unique key to store the value under.
     * @param mixed  $value The value to be stored in the session.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        // Ensure the session is started before manipulating $_SESSION.
        $this->start();

        // Store the value in the session under the specified key.
        $_SESSION[$key] = $value;
    }
}
=== HTTP/Session/Support/ArrayBagRegistry.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support;

use Gemini\DataHandling\ArrayHandling\Arrhae;
use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use Gemini\HTTP\Session\Contracts\SessionBagInterface;
use InvalidArgumentException;

/**
 * ArrayBagRegistry
 *
 * A mutable registry for managing named session bags in a type-safe,
 * extensible, and runtime-configurable manner.
 *
 * This class adheres strictly to Clean Architecture and DDD practices,
 * allowing for dynamic registration, safe retrieval, and logical filtering.
 *
 * @package Gemini\HTTP\Session\Support
 */
final class ArrayBagRegistry implements BagRegistryInterface
{
    /**
     * Internal map of session bags using the `Arrhae` data structure
     * for advanced array manipulation and type safety.
     *
     * @var Arrhae<string, SessionBagInterface>
     */
    private Arrhae $map;

    /**
     * Constructor.
     *
     * @param array<string, SessionBagInterface> $bags
     *        Initial session bags provided during instantiation.
     */
    public function __construct(array $bags = [])
    {
        $this->map = new Arrhae(items: $bags);
    }

    /**
     * Dynamically register a session bag at runtime.
     *
     * Allows middleware, modules, or packages to extend the registry without
     * needing to recreate it from scratch.
     *
     * @param string $name             Unique bag identifier.
     * @param SessionBagInterface $bag The session bag instance.
     *
     * @return void
     */
    public function register(string $name, SessionBagInterface $bag) : void
    {
        $this->map->set(key: $name, value: $bag);
    }

    /**
     * Retrieve a registered session bag by its name.
     *
     * @param string $name
     *        The unique identifier for the session bag to retrieve.
     *
     * @return SessionBagInterface
     *
     * @throws InvalidArgumentException
     *         If the specified bag name is not found in the registry.
     */
    public function get(string $name) : SessionBagInterface
    {
        if (! $this->map->has(key: $name)) {
            logger()->error(
                'Session bag could not be found in the registry.',
                ['name' => $name]
            );

            throw new InvalidArgumentException(
                message: "Session bag [{$name}] not found in registry."
            );
        }

        return $this->map->get(key: $name);
    }

    /**
     * Determine whether a session bag exists by name.
     *
     * @param string $name The bag key to check.
     *
     * @return bool True if the bag exists; false otherwise.
     */
    public function has(string $name) : bool
    {
        return $this->map->has(key: $name);
    }

    /**
     * Returns a filtered registry instance with only the specified bag keys.
     *
     * This enables scoped registries for specific purposes (e.g., flash-only or validation-only).
     *
     * @param array<string> $keys Keys to include.
     *
     * @return BagRegistryInterface A new filtered registry.
     */
    public function only(array $keys) : BagRegistryInterface
    {
        return new self(bags: $this->map->only(keys: $keys)->toArray());
    }

    /**
     * Returns a filtered registry excluding specified bag keys.
     *
     * Useful for removing internal or reserved bags from DX exposure.
     *
     * @param array<string> $keys Keys to exclude.
     *
     * @return BagRegistryInterface A new filtered registry.
     */
    public function except(array $keys) : BagRegistryInterface
    {
        return new self(bags: $this->map->except(keys: $keys)->toArray());
    }

    /**
     * Retrieve all available bag keys currently registered.
     *
     * @return array<string> List of all registered bag names.
     */
    public function keys() : array
    {
        return $this->map->keys();
    }

    /**
     * Retrieve all registered session bags in the registry.
     *
     * This method returns the complete mapping of bag names to their respective
     * SessionBagInterface instances.
     * It is useful for introspection, debugging,
     * or batch operations on all session bags.
     *
     * @return array<string, SessionBagInterface>
     *         An associative array where the key is the bag name, and the value is the bag instance.
     */
    public function all() : array
    {
        return $this->map->toArray();
    }

    /**
     * Retrieves the flash message session bag.
     *
     * The `FlashBag` session bag is designed to store temporary messages or
     * data, persisting only until the next request by default. It simplifies
     * the handling of transient application states like success notifications,
     * validation alerts, or session-based one-time flags.
     *
     * Example usage:
     * ```php
     * $flashBag = $bagRegistry->flash();
     * $flashBag->put('success', 'Your account has been updated.');
     * ```
     *
     * Dependency on `FlashBagInterface`:
     * - `FlashBagInterface` extends `SessionBagInterface`, ensuring robust
     *    session-management capabilities with added functionality for
     *    managing flash-specific use cases, like `keep()` or `reflash()`.
     *
     * @return FlashBagInterface
     *   A flash message session bag adhering to FlashBagInterface, providing
     *   encapsulated methods tailored for transient data persistence.
     */
    public function flash() : FlashBagInterface
    {
        return app(abstract: FlashBagInterface::class);
    }

    /**
     * Retrieves the error message session bag.
     *
     * The `ErrorBag` is a generic session bag used to store validation
     * errors, user feedback, or any application state that needs to persist
     * across multiple requests. By handling errors via a dedicated bag,
     * developers can centralize error management into a structured container.
     *
     * Example usage:
     * ```php
     * $errorBag = $bagRegistry->errors();
     * $errorBag->put('email', 'The email address is invalid.');
     * ```
     *
     * Dependency on `SessionBagInterface`:
     * - The `ErrorBag` follows the contract defined by `SessionBagInterface`,
     *   guaranteeing functionality such as value retrieval, storage, and
     *   clearing, while allowing customization for error-related use cases.
     *
     * @return SessionBagInterface
     *   A generic session bag adhering to SessionBagInterface, providing
     *   flexible storage capabilities for error messages or other keyed data.
     */
    public function errors() : SessionBagInterface
    {
        return app(abstract: SessionBagInterface::class);
    }
}
=== HTTP/Session/Support/Bags/AbstractFlashBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Bags;

use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use Gemini\HTTP\Session\Contracts\SessionBagInterface;

/**
 * AbstractFlashBag
 *
 * A base class for implementing session flash bags. Flash bags are used to manage
 * temporary session data that is only available for the next request cycle.
 * This abstraction ensures that common tasks, such as adding, retrieving, and clearing
 * flash data, are handled in a consistent and reusable way.
 *
 * @package Gemini\HTTP\Session\Support\Bags
 */
abstract class AbstractFlashBag implements SessionBagInterface
{
    /**
     * Constructor to initialize the FlashBagInterface dependency.
     *
     * @param FlashBagInterface $flash An implementation of FlashBagInterface used to manage flash session data.
     */
    public function __construct(protected FlashBagInterface $flash) {}

    /**
     * Retrieve and remove a value from the flash bag in one call.
     * This operation is destructive – once the value is read, it is deleted from storage.
     *
     * @param string     $key     The key to pull from the flash bag.
     * @param mixed|null $default Optional fallback value if the key does not exist.
     *
     * @return mixed|null The pulled value or the default if not found.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        // Retrieve the value, then remove it from storage before returning.
        $value = $this->get(key: $key, default: $default);
        $this->forget(key: $key);

        return $value;
    }

    /**
     * Retrieve a value from the flash bag, or return a default value if the key does not exist.
     *
     * @param string     $key     The key to retrieve from the flash bag.
     * @param mixed|null $default The default value to return if the key does not exist (optional).
     *
     * @return mixed|null The value associated with the key, or the default value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Retrieve all flash data and attempt to return the value for the given key.
        return $this->all()[$key] ?? $default;
    }

    /**
     * Retrieve all key-value pairs currently stored in the flash bag.
     *
     * @return array<string, mixed> An associative array of all flash data.
     */
    public function all() : array
    {
        // Fetch all flash data using the unique flash key and ensure it is an array.
        $data = $this->flash->get(key: $this->flashKey(), default: []);

        // Verify the data is a valid array before returning it; otherwise, return an empty array.
        return is_array($data) ? $data : [];
    }

    /**
     * Retrieve the unique flash key associated with this specific bag.
     *
     * This function must be implemented by subclasses to specify a unique identifier
     * for their flash storage within the session.
     *
     * @return string The flash key associated with the bag.
     */
    abstract protected function flashKey() : string;

    /**
     * Remove a specific key-value pair from the flash bag.
     *
     * @param string $key The key to remove from the flash bag.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        // Retrieve all existing flash data.
        $data = $this->all();

        // Check if the key exists and remove it if present.
        if (array_key_exists($key, $data)) {
            unset($data[$key]);

            // Save the updated data back to the flash storage.
            $this->flash->put(
                key  : $this->flashKey(),
                value: $data
            );
        }
    }

    /**
     * Store a new key-value pair in the flash bag.
     *
     * If the key already exists, its value will be overwritten with the new value.
     *
     * @param string $key   The key under which the value will be stored.
     * @param mixed  $value The value to associate with the given key.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        // Retrieve all existing flash data.
        $data = $this->all();

        // Associate the new value with the specified key.
        $data[$key] = $value;

        // Save the updated data back to the flash storage.
        $this->flash->put(
            key  : $this->flashKey(),
            value: $data
        );
    }

    /**
     * Determine whether the flash bag contains a specific key.
     *
     * @param string $key The key to check for existence.
     *
     * @return bool True if the key exists; false otherwise.
     */
    public function has(string $key) : bool
    {
        // Use array_key_exists to verify if the key exists within the retrieved flash data.
        return array_key_exists($key, $this->all());
    }

    /**
     * Clear all data stored in the flash bag.
     *
     * This operation will remove all stored key-value pairs and reset the storage.
     *
     * @return void
     */
    public function clear() : void
    {
        // Update the flash storage by setting an empty array to the flash key.
        $this->flash->put(
            key  : $this->flashKey(),
            value: []
        );
    }
}

=== HTTP/Session/Support/Bags/BagRegistryDecorator.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Bags;

use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use Gemini\HTTP\Session\Contracts\SessionBagInterface;
use Gemini\HTTP\Session\Enums\SessionBag;
use InvalidArgumentException;
use RuntimeException;

/**
 * Class BagRegistryDecorator
 *
 * A strongly typed decorator for accessing and managing session bags through the BagRegistryInterface.
 * This provides a type-safe, expressive API over the generic bag registry, aligning with DDD principles.
 *
 * @package Gemini\HTTP\Session\Support\Bags
 */
final readonly class BagRegistryDecorator
{
    /**
     * @var BagRegistryInterface $delegate
     *
     * The wrapped instance of the bag registry that provides general-purpose session bag operations.
     */
    public function __construct(private BagRegistryInterface $delegate) {}

    /**
     * Retrieve the Flash Bag.
     *
     * This method resolves and returns the registered flash bag from the registry while
     * enforcing conformance to the FlashBagInterface. Throws an exception if the type mismatch occurs.
     *
     * @return FlashBagInterface
     *   The flash bag instance used for storing temporary session data.
     *
     * @throws InvalidArgumentException
     *   If the retrieved bag does not implement FlashBagInterface.
     */
    public function flash() : FlashBagInterface
    {
        // Retrieve the "flash" bag from the delegate registry.
        $bag = $this->delegate->get(name: 'flash');

        // Validate that the retrieved bag implements FlashBagInterface.
        if (! $bag instanceof FlashBagInterface) {
            throw new InvalidArgumentException(message: 'Registered bag "flash" must implement FlashBagInterface.');
        }

        // Return the strongly typed flash bag instance.
        return $bag;
    }

    /**
     * Retrieves a session bag by key.
     *
     * Delegates the retrieval logic to a lower-level abstraction, ensuring
     * that the session bag associated with the provided key is returned.
     * If the bag is not found, an exception will be propagated by the delegate.
     *
     * @param string $key The unique key identifying the session bag in the registry.
     *                    Must be a non-empty string that conforms to system key standards.
     *
     * @return SessionBagInterface The session bag associated with the specified key.
     *
     * @throws InvalidArgumentException If the session bag does not exist in the registry.
     * @throws RuntimeException If an unexpected error occurs during the retrieval process.
     */
    public function get(string $key) : SessionBagInterface
    {
        // Delegates the "get" call to the underlying session delegate, leveraging named arguments for clarity.
        return $this->delegate->get(name: $key);
    }

    /**
     * Retrieve the Input Bag.
     *
     * The input bag captures user inputs, allowing their persistence for redisplaying forms,
     * particularly on validation errors.
     *
     * @return SessionBagInterface
     *   The session bag instance for input data.
     *
     * @throws InvalidArgumentException
     *   If the bag cannot be resolved or registered correctly.
     */
    public function input() : SessionBagInterface
    {
        // Resolve the "input" bag using its enumeration value.
        return $this->delegate->get(name: SessionBag::Input->value);
    }

    /**
     * Retrieve the Validation Errors Bag.
     *
     * This bag contains validation error messages, useful for isolating error-related session
     * context and presenting it within user interfaces.
     *
     * @return SessionBagInterface
     *   The session bag instance for validation errors.
     *
     * @throws InvalidArgumentException
     *   If the bag cannot be accessed correctly from the registry.
     */
    public function errors() : SessionBagInterface
    {
        // Resolve the "validation" bag using its enumeration value.
        return $this->delegate->get(name: SessionBag::Validation->value);
    }
}
=== HTTP/Session/Support/Bags/FlashBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Bags;

use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Exceptions\FlashBagKeyNotFoundException;
use InvalidArgumentException;

/**
 * Class FlashBag
 *
 * A specialized, production-grade component for managing temporary flash data in a PHP-based session.
 *
 * Flash data refers to data that persists for the duration of one request/response cycle
 * and is automatically removed afterward. This class provides methods to handle such data
 * with support for re-flashing and deletion.
 *
 * @final
 */
final class FlashBag implements FlashBagInterface
{
    /**
     * @const string FLASH_KEY
     * The session key used to store temporary flash data for the current request cycle.
     */
    private const string FLASH_KEY = '_flash';

    /**
     * @const string FLASH_KEEP_KEY
     * The session key used to track flash data preserved for the next request.
     * When data is "kept," it survives one additional request.
     */
    private const string FLASH_KEEP_KEY = '_flash_keep';

    /**
     * FlashBag constructor.
     *
     * @param SessionInterface $session The session instance responsible for managing flash data.
     */
    public function __construct(private readonly SessionInterface $session) {}

    /**
     * Retrieves and removes a flash value from storage.
     *
     * If the key is not found, a default value is returned or an exception is thrown (if no default is provided).
     *
     * @param string     $key     The key whose value should be retrieved and removed.
     * @param mixed|null $default A fallback value to return if the key is not found.
     *
     * @return mixed The value associated with the specified key.
     * @throws FlashBagKeyNotFoundException If the key does not exist and no default is specified.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        // Fetch all flash data currently stored in the session.
        $flashes = $this->getFlashes();

        // Check whether the key exists in the stored flash data.
        if (! array_key_exists($key, $flashes)) {
            // If no default value is provided, throw an exception for missing flash key.
            if ($default === null) {
                throw new FlashBagKeyNotFoundException(message: sprintf('Flash key "%s" not found.', $key));
            }

            return $default;
        }

        // Retrieve the value associated with the key.
        $value = $flashes[$key];

        // Remove the key-value pair from the flash storage.
        unset($flashes[$key]);

        // Save the modified flash data to the session.
        $this->updateFlashes(data: $flashes);

        return $value;
    }

    /**
     * Helper method: Retrieves all flash data from the session.
     *
     * @return array<string, mixed> A collection of key-value pairs in flash storage.
     */
    private function getFlashes() : array
    {
        return $this->session->get(key: self::FLASH_KEY, default: []);
    }

    /**
     * Retrieves a flash value by its key, without removing it from flash storage.
     *
     * If the key is not found, the default value is returned instead.
     *
     * @param string     $key     The key identifying the flash value.
     * @param mixed|null $default A fallback value if the key is not found.
     *
     * @return mixed The value associated with the key or the default value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Fetch all flash data from the session storage.
        $flashes = $this->getFlashes();

        // Return the value from the flash array if it exists, otherwise return the provided default.
        return $flashes[$key] ?? $default;
    }

    /**
     * Helper method: Updates flash data in the session.
     *
     * @param array<string, mixed> $data The updated flash data to store in the session.
     *
     * @return void
     */
    private function updateFlashes(array $data) : void
    {
        $this->session->put(key: self::FLASH_KEY, value: $data);
    }

    /**
     * Stores a value under a specific key in flash storage for one request cycle.
     *
     * @param string $key   A unique identifier for the flash data.
     * @param mixed  $value The value to store in the session.
     *
     * @return void
     * @throws InvalidArgumentException If the provided key is empty.
     */
    public function put(string $key, mixed $value) : void
    {
        // Check that a valid key is provided, preventing empty or invalid keys.
        if (empty($key)) {
            throw new InvalidArgumentException(message: 'Flash key cannot be empty.');
        }

        // Retrieve all stored flash data or initialize an empty array.
        $flashes = $this->getFlashes();

        // Add the given value under the specified key.
        $flashes[$key] = $value;

        // Update the session with the modified flashes.
        $this->updateFlashes(data: $flashes);
    }

    /**
     * Determines whether a flash value is stored under the given key.
     *
     * @param string $key The key to check for existence in flash storage.
     *
     * @return bool True if the key exists, otherwise false.
     */
    public function has(string $key) : bool
    {
        // Checks for key existence in the collection of flash data.
        return array_key_exists($key, $this->getFlashes());
    }

    /**
     * Retrieves all current flash data stored in the session.
     *
     * @return array<string, mixed> An associative array of all key-value pairs in flash storage.
     */
    public function all() : array
    {
        // Return all flash data as an associative array.
        return $this->getFlashes();
    }

    /**
     * Preserves the specified flash key for the subsequent request cycle.
     *
     * Instead of being deleted after the current request, the value is migrated to the "kept" storage.
     *
     * @param string $key The flash key to preserve for the next request.
     *
     * @return void
     */
    public function keep(string $key) : void
    {
        // Retrieve both current flash data and kept flash data.
        $flashes   = $this->getFlashes();
        $flashKeep = $this->getKeptFlashes();

        // Add the specified key's value to the kept flash data if it exists.
        if (array_key_exists($key, $flashes)) {
            $flashKeep[$key] = $flashes[$key];

            // Update the session with the modified kept flash storage.
            $this->updateKeptFlashes(data: $flashKeep);
        }
    }

    /**
     * Helper method: Retrieves all kept flash data from the session.
     *
     * @return array<string, mixed> A collection of key-value pairs explicitly preserved for the next request.
     */
    private function getKeptFlashes() : array
    {
        return $this->session->get(key: self::FLASH_KEEP_KEY, default: []);
    }

    /**
     * Helper method: Updates the kept flash data in the session.
     *
     * @param array<string, mixed> $data The updated kept flash data to store in the session.
     *
     * @return void
     */
    private function updateKeptFlashes(array $data) : void
    {
        $this->session->put(key: self::FLASH_KEEP_KEY, value: $data);
    }

    /**
     * Preserves all flash data, extending its lifespan for the next request.
     *
     * @return void
     */
    public function reflash() : void
    {
        // Retrieve the current flash data from session storage.
        $flashes = $this->getFlashes();

        // Update the kept flashes with all current flashes for re-flashing.
        $this->updateKeptFlashes(data: $flashes);
    }

    /**
     * Removes a specific flash key from storage.
     *
     * @param string $key The key to delete from flash data.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        // Retrieve all existing flash data from session storage.
        $flashes = $this->getFlashes();

        // Delete the specified key from the flash storage.
        unset($flashes[$key]);

        // Persist the modified flash data to the session.
        $this->updateFlashes(data: $flashes);
    }

    /**
     * Clears all flash values, including both current flashes and kept flashes stored in the session.
     *
     * This method ensures that the flash storage is completely reset, effectively removing
     * both the active flash bag (`_flash`) and the kept/retained flash bag (`_flash_keep`).
     *
     * This can be useful in cases where the flash state needs to be programmatically reset
     * or the session needs to ensure no stale flash values remain.
     *
     * It interacts with two specific session keys:
     * - `self::FLASH_KEY`: Represents the key holding the active flash messages.
     * - `self::FLASH_KEEP_KEY`: Represents the key tracking flash messages marked to persist.
     *
     * @return void
     */
    public function clear() : void
    {
        // Deletes the `_flash` key from the session storage, effectively clearing
        // all active flash messages currently held in the flash bag.
        $this->session->delete(key: self::FLASH_KEY);

        // Deletes the `_flash_keep` key from the session storage, ensuring
        // that no kept flash messages persist into later requests.
        $this->session->delete(key: self::FLASH_KEEP_KEY);
    }

    /**
     * Loads and manages flash data for the current session lifecycle.
     *
     * This method handles the lifecycle of flash messages as follows:
     * - Retrieves the kept flashes from the previous request.
     * - Overwrites the current flash data with the kept flashes.
     * - Clears the kept flashes to reset state for the next request.
     *
     * @return void
     */
    public function load() : void
    {
        // Retrieve flash messages marked to be kept from the previous request.
        $kept = $this->getKeptFlashes();

        // Overwrite the current flash data with the kept flash messages.
        $this->updateFlashes(data: $kept);

        // Reset the kept flash messages for future request cycles.
        $this->updateKeptFlashes(data: []);
    }

    /**
     * Sweeps and clears all flash data at the end of the request lifecycle.
     *
     * This ensures no flash data persists beyond the intended scope.
     *
     * @return void
     */
    public function sweep() : void
    {
        // Clears the existing flash messages stored in the session to avoid persistence.
        $this->updateFlashes(data: []);
    }
}
=== HTTP/Session/Support/Bags/InputBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Bags;

use Gemini\HTTP\Session\Contracts\FlashBagInterface;
use InvalidArgumentException;

/**
 * **InputBag**
 *
 * Responsible for flashing and retrieving old input values from the session.
 * This class is primarily designed to aid in repopulating form inputs after validation failures.
 */
final class InputBag extends AbstractFlashBag
{
    /**
     * Session flash key used to store old input data.
     * This constant helps identify the location of input data in the session.
     *
     * @var string
     */
    private const string FLASH_KEY = '_old_input';

    /**
     * Constructor.
     *
     * @param FlashBagInterface $flash FlashBag instance responsible for managing session flash data.
     */
    public function __construct(FlashBagInterface $flash)
    {
        parent::__construct(flash: $flash);
    }

    /**
     * **Flash Input Data**
     *
     * Stores input data in the session for one-time use in the next request.
     * Throws an exception if the provided input data is empty.
     *
     * @param array<string, mixed> $input The associative array of input data to be stored.
     *
     * @return void
     *
     * @throws InvalidArgumentException If $input is an empty array.
     */
    public function flashInput(array $input) : void
    {
        if (empty($input)) {
            throw new InvalidArgumentException(message: 'Input data cannot be empty when flashing to the session.');
        }

        $this->flash->put(key: $this->flashKey(), value: $input);
    }

    /**
     * Retrieves the session flash key used to store old input data.
     *
     * @return string The session flash key as a string.
     */
    protected function flashKey() : string
    {
        return self::FLASH_KEY;
    }

    /**
     * Retrieves all input keys currently stored in the session.
     *
     * @return array<string> A list of flashed input keys.
     */
    public function keys() : array
    {
        return array_keys($this->all());
    }

    /**
     * **Retrieve Flashed Input Data**
     *
     * Fetches flashed input data from the session and ensures it is returned as an array.
     *
     * @return array<string, mixed>|null Returns the flashed data as an array if available,
     *                                   or null if no data exists or the session doesn't hold an array.
     */
    private function getFlashedData() : array|null
    {
        $data = $this->flash->get(key: $this->flashKey(), default: []);

        return is_array($data) ? $data : null;
    }
}

=== HTTP/Session/Support/Bags/ValidationBag.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Bags;

use Gemini\HTTP\Session\Contracts\FlashBagInterface;

/**
 * Class ValidationBag
 *
 * Provides functionality to manage flashable validation errors for form input fields.
 * This class enables temporary storage of validation errors in a session flash bag, allowing them
 * to persist across a single request-response cycle.
 *
 * @package Gemini\HTTP\Session\Support\Bags
 */
final class ValidationBag extends AbstractFlashBag
{
    /**
     * The key used to store validation errors in the flash bag.
     *
     * @var string
     */
    private const string FLASH_KEY = '_errors';

    /**
     * Constructor.
     *
     * @param FlashBagInterface $flash FlashBag instance responsible for session flash error storage.
     */
    public function __construct(FlashBagInterface $flash)
    {
        parent::__construct(flash: $flash);
    }

    /**
     * Stores a set of validation errors in the flash bag for temporary usage.
     *
     * @param array<string, string|array<string>> $errors Associative array containing validation errors.
     *
     * @return void
     */
    public function flashErrors(array $errors) : void
    {
        $this->flash->put(key: $this->flashKey(), value: $errors);
    }

    /**
     * Retrieve the unique flash key associated with this specific bag.
     *
     * @return string The flash key associated with the bag.
     */
    protected function flashKey() : string
    {
        return self::FLASH_KEY;
    }

    /**
     * Retrieves the list of all input key names that have validation errors.
     *
     * @return array<string> An array of key names that contain validation errors.
     */
    public function keys() : array
    {
        return array_keys($this->all());
    }
}

=== HTTP/Session/Support/Factories/BagRegistryFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Factories;

use Gemini\HTTP\Session\Contracts\BagRegistryInterface;
use Gemini\HTTP\Session\Contracts\Factories\BagRegistryFactoryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Enums\SessionBag;
use Gemini\HTTP\Session\Support\ArrayBagRegistry;
use Gemini\HTTP\Session\Support\Bags\FlashBag;
use Gemini\HTTP\Session\Support\Bags\InputBag;
use Gemini\HTTP\Session\Support\Bags\ValidationBag;

/**
 * BagRegistryFactory
 *
 * Factory responsible for creating a default BagRegistry instance, containing core session bags.
 * These session bags include:
 * - **FlashBag**: For temporary session data (e.g., notifications).
 * - **InputBag**: For preserving user input (e.g., forms).
 * - **ValidationBag**: For maintaining validation errors.
 *
 * **Design Goals**:
 * - Ensure all core session bags are registered via enum-based identifiers.
 * - Maintain extensibility and strong type safety without sacrificing simplicity.
 *
 * @final
 */
final class BagRegistryFactory implements BagRegistryFactoryInterface
{
    /**
     * Creates and returns an instance of BagRegistry containing default session bags.
     *
     * This factory initializes the following session bags:
     * - `FlashBag`: For handling flash session data, persists for a single request.
     * - `InputBag`: Depends on `FlashBag` for preserving form input data.
     * - `ValidationBag`: Depends on `FlashBag` for managing validation errors.
     *
     * **Key Design Objectives**:
     * - Dependency Injection is utilized to inject the `SessionInterface`.
     * - Enum identifiers ensure clear, extensible mapping of session bags.
     *
     * @return BagRegistryInterface The created BagRegistry initialized with default session bags.
     */
    public function create(SessionInterface $session) : BagRegistryInterface
    {
        // Instantiate the FlashBag, passing the session dependency.
        // FlashBag is used to manage data that persists for only one request lifecycle.
        $flashBag = new FlashBag(session: $session);

        // Return an ArrayBagRegistry containing predefined session bags.
        // Each bag is registered using a unique key derived from the SessionBag enum.
        return new ArrayBagRegistry(
            bags: [
                      // Register the FlashBag using the SessionBag::Flash identifier.
                      SessionBag::Flash->value      => $flashBag,

                      // Register the InputBag instance; it relies on FlashBag for retaining user-submitted forms.
                      SessionBag::Input->value      => new InputBag(flash: $flashBag),

                      // Register the ValidationBag instance; it also depends on FlashBag to persist validation errors.
                      SessionBag::Validation->value => new ValidationBag(flash: $flashBag),
                  ]
        );
    }
}
=== HTTP/Session/Support/Factories/SessionDriverFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\Session\Support\Factories;

use Gemini\HTTP\Session\Contracts\Factories\BagRegistryFactoryInterface;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Gemini\HTTP\Session\Drivers\ArraySession;
use Gemini\HTTP\Session\Drivers\NativeSession;
use Gemini\HTTP\Session\Enums\SessionDriver;
use Gemini\HTTP\Session\Exceptions\SessionException;
use Gemini\HTTP\Session\Stores\ArraySessionStore;
use Gemini\HTTP\Session\Stores\NativeSessionStore;

/**
 * Factory for creating session driver instances with DI-compliant store/registry configuration.
 *
 * This factory encapsulates the creation logic for various session drivers, ensuring
 * proper configuration of their dependencies such as stores and registries.
 * This approach adheres to the Dependency Inversion Principle (DIP),
 * promoting decoupling and testability.
 *
 * @final Ensures the integrity of the factory, disallowing inheritance as per DDD.
 */
final readonly class SessionDriverFactory
{
    /**
     * Factory interface to create session bag registry instances.
     *
     * @var BagRegistryFactoryInterface $registryFactory
     * A contract to abstract the creation of bag registries for session drivers.
     */
    public function __construct(
        private BagRegistryFactoryInterface $registryFactory // Constructor Promotion for clarity and efficiency.
    ) {}

    /**
     * Factory method to create and configure a new session driver instance.
     *
     * This method maps string-based driver types to their respective
     * session implementation, such as `NativeSession` or `ArraySession`.
     *
     * It uses a robust error-checking mechanism to validate supported drivers (e.g., Enum `SessionDriver`).
     *
     * @param string $driver
     *   The session driver's type, represented as a string (e.g., 'Native', 'Array').
     *
     * @return SessionInterface
     *   The fully configured session implementation.
     *
     * @throws SessionException
     *   Thrown if an unsupported or invalid session driver is passed to the factory.
     */
    public function create(string $driver) : SessionInterface
    {
        // Convert the provided driver type to an Enum instance; returns null if invalid.
        $enum = SessionDriver::tryFrom(value: $driver);

        // Check if the given driver is supported. If not, throw a custom SessionException.
        if ($enum === null) {
            throw new SessionException(
                message: sprintf(
                         // Compose a detailed error message, explicitly listing supported drivers.
                             "Invalid session driver: '%s'. Supported drivers are: %s.",
                             $driver,
                             implode(
                                 ', ',
                                 array_map(
                                     static fn(SessionDriver $d) : string => $d->value,
                                     SessionDriver::cases()
                                 )
                             )
                         )
            );
        }

        // Use `match` to delegate the driver creation logic to specific private methods.
        return match ($enum) {
            SessionDriver::Native => $this->createNativeDriver(),
            SessionDriver::Array  => $this->createArrayDriver(),
        };
    }

    /**
     * Private factory method for creating a `NativeSession` driver.
     *
     * - Encapsulates the instantiation of a native PHP session.
     * - Injects the session store (`NativeSessionStore`) with a DI-compliant registry factory.
     *
     * @return NativeSession
     *   A fully configured instance of the `NativeSession` driver.
     */
    private function createNativeDriver() : NativeSession
    {
        return new NativeSession(
        // NativeSession requires a specific storage implementation.
            store          : new NativeSessionStore(),
            // Passing in a lazily evaluated factory to enable bag registry resolution.
            registryFactory: fn(SessionInterface $s) => $this->registryFactory->create(session: $s)
        );
    }

    /**
     * Private factory method for creating an `ArraySession` driver.
     *
     * - Encapsulates the instantiation of an in-memory session.
     * - Leverages an `ArraySessionStore` for non-persistent data storage.
     *
     * @return ArraySession
     *   A fully configured instance of the `ArraySession` driver.
     */
    private function createArrayDriver() : ArraySession
    {
        return new ArraySession(
        // ArraySession uses an in-memory storage implementation.
            store          : new ArraySessionStore(),
            // A lazily evaluated factory creates a session bag registry for this session.
            registryFactory: fn(SessionInterface $s) => $this->registryFactory->create(session: $s)
        );
    }

    /**
     * Provides access to the BagRegistryFactoryInterface for testability and runtime overrides.
     *
     * This method promotes flexibility by exposing the registry factory instance,
     * allowing consumers to interact with the factory (e.g., mocking in tests).
     *
     * @return BagRegistryFactoryInterface
     *   The factory responsible for creating bag registries for sessions.
     */
    public function getRegistry() : BagRegistryFactoryInterface
    {
        return $this->registryFactory;
    }
}
=== HTTP/URI/BaseUri.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI;

use Stringable;

/**
 * Abstract class BaseUri
 * Represents a generic URI and provides mechanisms to construct and validate it.
 */
abstract class BaseUri implements Stringable
{
    /**
     * BaseUri constructor.
     * Initializes the URI components.
     */
    public function __construct(
        protected string      $scheme = '',
        protected string      $host = '',
        protected string      $path = '/',
        protected int|null    $port = null,
        protected string      $query = '',
        protected string      $fragment = '',
        protected string      $user = '',
        protected string|null $password = null
    ) {}

    /**
     * Converts the URI to a string.
     */
    public function __toString() : string
    {
        $uri = '';
        if ($this->scheme !== '') {
            $uri .= $this->scheme . '://';
        }

        $uri .= $this->getAuthority();
        $uri .= $this->path;
        if ($this->query !== '') {
            $uri .= '?' . $this->query;
        }

        if ($this->fragment !== '') {
            $uri .= '#' . $this->fragment;
        }

        return $uri;
    }

    /**
     * Returns the authority part of the URI.
     */
    public function getAuthority() : string
    {
        $authority = $this->host;
        if ($this->user !== '') {
            $authority = $this->user . ($this->password !== null ? ':' . $this->password : '') . ('@' . $authority);
        }

        if ($this->port !== null && ! $this->isDefaultPort()) {
            $authority .= ':' . $this->port;
        }

        return $authority;
    }

    /**
     * Checks if the port is the default for the scheme.
     */
    protected function isDefaultPort() : bool
    {
        return ($this->scheme === 'http' && $this->port === 80) || ($this->scheme === 'https' && $this->port === 443);
    }
}

=== HTTP/URI/Components/Host.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Components;

use InvalidArgumentException;
use Stringable;

/**
 * Represents a URI host (e.g., example.com).
 *
 * This final class ensures immutability and integrity of hostnames in the application,
 * preventing extension and ensuring validation is enforced upon instantiation.
 */
final readonly class Host implements Stringable
{
    /** @var string The validated and normalized host string. */
    private string $host;

    /**
     * Constructs a new Host instance.
     *
     * @param string $host The host string to be validated and stored.
     *
     * Ensures the host is validated upon instantiation to immediately catch any invalid inputs.
     */
    public function __construct(string $host)
    {
        $this->host = $this->validate(host: $host);
    }

    /**
     * Validates and normalizes the provided host.
     *
     * @param string $host The host to validate.
     *
     * @return string The validated and normalized host.
     *
     * @throws InvalidArgumentException If the host is empty or invalid.
     *
     * Performs validation checks, including Internationalized Domain Name (IDN) conversion, to
     * ensure the host is a valid domain. This process includes converting the host to ASCII using
     * UTS #46 and applying domain name validation rules.
     */
    private function validate(string $host) : string
    {
        if (trim($host) === '') {
            // Host cannot be an empty string.
            throw new InvalidArgumentException(message: "Host cannot be empty.");
        }

        $asciiHost = idn_to_ascii($host, IDNA_DEFAULT, INTL_IDNA_VARIANT_UTS46);

        // Ensures the host is a valid domain name after conversion to ASCII.
        if ($asciiHost === false || ! filter_var($asciiHost, FILTER_VALIDATE_DOMAIN, FILTER_FLAG_HOSTNAME)) {
            throw new InvalidArgumentException(message: 'Invalid host: ' . $host);
        }

        // Return the host in lowercase to avoid case sensitivity issues.
        return strtolower($asciiHost);
    }

    /**
     * Converts the Host object to a string.
     *
     * @return string The validated and normalized host as a string.
     *
     * Provides a string representation of the host, useful for debugging and logging purposes.
     */
    public function __toString() : string
    {
        return $this->host;
    }
}
=== HTTP/URI/Components/Path.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Components;

/**
 * Represents a URI path (e.g., /path/to/resource).
 *
 * A final class to ensure immutability and integrity of URI path components
 * throughout the application, preventing inheritance or modification.
 */
final readonly class Path implements \Stringable
{
    /**
     * The normalized path string.
     */
    private string $path;

    /**
     * Constructor.
     *
     * @param string $path The URI path to normalize and store.
     *
     * Ensures the path is normalized upon instantiation to maintain consistency
     * and avoid dealing with non-normalized paths later in the usage.
     */
    public function __construct(string $path)
    {
        $this->path = $this->normalize($path);
    }

    /**
     * Normalizes a path.
     *
     * @param string $path The path to normalize.
     *
     * @return string The normalized path, ensuring segments like ".." and "." are properly handled.
     */
    private function normalize(string $path) : string
    {
        $segments   = explode('/', $path);
        $normalized = [];

        foreach ($segments as $segment) {
            if ($segment === '') {
                // Skip empty segments and current directory markers.
                continue;
            }
            if ($segment === '.') {
                // Skip empty segments and current directory markers.
                continue;
            }
            if ($segment === '..') {
                // Remove the last segment for parent directory markers.
                array_pop($normalized);
            } else {
                // Encode the segment to ensure it's safe for URLs.
                $normalized[] = rawurlencode($segment);
            }
        }

        return '/' . implode('/', $normalized);
    }

    /**
     * Normalizes a path intended for file systems.
     *
     * @param string $path The file system path to normalize.
     *
     * @return string The normalized path with Windows file paths converted to Unix format.
     *
     * Handles specific file path converted to be compatible with URI paths.
     */
    public function normalizeForFile(string $path) : string
    {
        if (preg_match('#^[a-zA-Z]:\\\\#', $path)) {
            // Convert Windows paths to Unix format.
            $path = '/' . str_replace('\\', '/', ltrim($path, '/'));
        }

        return $this->normalize($path);
    }

    /**
     * Converts the Path object to a string.
     *
     * @return string The normalized path as a string.
     */
    public function __toString() : string
    {
        return $this->path;
    }
}
=== HTTP/URI/Components/Scheme.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Components;

use InvalidArgumentException;
use Stringable;

/**
 * Represents a URI scheme (e.g., http, https, file).
 *
 * A final class to ensure immutability and prevent extension, which is crucial for maintaining
 * the integrity of specific URI schemes throughout the application.
 */
final readonly class Scheme implements Stringable
{
    // Allowed URI schemes. These are necessary for validating the input scheme to ensure it conforms
    // to the expected set of schemes, avoiding erroneous or unsupported inputs.
    private const array ALLOWED_SCHEMES = ['http', 'https', 'file', 'ftp', 'ws', 'wss', 'mailto', 'data'];

    // Holds the normalized scheme value, ensuring case insensitivity by storing in lowercase.
    private string $scheme;

    /**
     * Constructs a new Scheme instance.
     *
     * @param string $scheme The scheme to be validated and stored.
     *
     * Validates the provided scheme upon instantiation to ensure immediate feedback if the input
     * is not among the allowed schemes.
     */
    public function __construct(string $scheme)
    {
        $this->scheme = $this->validate(scheme: $scheme);
    }

    /**
     * Validates the provided scheme.
     *
     * @param string $scheme The scheme to validate.
     *
     * @return string The validated scheme in lowercase.
     *
     * @throws InvalidArgumentException if the scheme is empty or not in the allowed schemes list.
     */
    private function validate(string $scheme) : string
    {
        if ($scheme === '' || ! in_array(strtolower($scheme), self::ALLOWED_SCHEMES, true)) {
            throw new InvalidArgumentException(message: 'Invalid scheme: ' . $scheme);
        }

        return strtolower($scheme);
    }

    /**
     * Converts the Scheme object to a string.
     *
     * @return string The scheme as a string.
     *
     * Provides a string representation of the scheme, which is useful in contexts where the scheme
     * needs to be concatenated or outputted directly.
     */
    public function __toString() : string
    {
        return $this->scheme;
    }
}
=== HTTP/URI/Protocol.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI;

/**
 * Enum Protocol
 * Defines supported protocols for URIs and provides methods for conversion and validation.
 */
enum Protocol: string
{
    case HTTP   = 'http';

    case HTTPS  = 'https';

    case FTP    = 'ftp';

    case WS     = 'ws';

    case WSS    = 'wss';

    case FILE   = 'file';

    case MAILTO = 'mailto';

    case DATA   = 'data';

    /**
     * Validates if the given scheme is a valid protocol.
     *
     * @param string $scheme The scheme to validate.
     *
     * @return bool True if the scheme is valid, false otherwise.
     */
    public static function isValid(string $scheme) : bool
    {
        return self::fromString($scheme) instanceof self;
    }

    /**
     * Converts a string to a Protocol enum instance, ignoring case.
     *
     * @param string $protocol The protocol string to convert.
     *
     * @return Protocol|null Returns the corresponding `Protocol` instance or null if invalid.
     */
    public static function fromString(string $protocol) : self|null
    {
        return self::tryFrom(strtolower($protocol));
    }

    /**
     * Returns the default port for the protocol, if any.
     *
     * @return int|null The default port or null if no default port is defined.
     */
    public function defaultPort() : int|null
    {
        return match ($this) {
            self::HTTP, self::WS                 => 80,
            self::HTTPS, self::WSS               => 443,
            self::FTP                            => 21,
            self::FILE, self::MAILTO, self::DATA => null,
        };
    }
}

=== HTTP/URI/QueryParams.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI;

use InvalidArgumentException;

final class QueryParams
{
    private array $params = [];

    public function __construct(string $queryString = '')
    {
        if ($queryString !== '') {
            parse_str($queryString, $this->params);
        }
    }

    public function set(string $key, string $value) : void
    {
        if ($key === '' || $key === '0') {
            throw new InvalidArgumentException(message: "Query parameter key cannot be empty.");
        }

        $this->params[$key] = $value;
    }

    public function delete(string $key) : void
    {
        unset($this->params[$key]);
    }

    public function append(string $key, string $value) : void
    {
        if (! isset($this->params[$key])) {
            $this->params[$key] = $value;
        } elseif (is_array($this->params[$key])) {
            $this->params[$key][] = $value;
        } else {
            $this->params[$key] = [$this->params[$key], $value];
        }
    }

    public function toArray() : array
    {
        return $this->params;
    }

    public function toString() : string
    {
        $query = [];
        foreach ($this->params as $key => $value) {
            $query[] = sprintf('%s=%s', rawurlencode($key), rawurlencode((string) $value));
        }

        return implode('&', $query);
    }


    public function clear() : void
    {
        $this->params = [];
    }
}

=== HTTP/URI/Traits/Psr7UriTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Traits;

use Gemini\HTTP\URI\Components\Host;
use Gemini\HTTP\URI\Components\Path;
use Gemini\HTTP\URI\Components\Scheme;
use Gemini\HTTP\URI\QueryParams;
use Psr\Http\Message\UriInterface;

trait Psr7UriTrait
{
    public function getScheme() : string
    {
        return $this->scheme;
    }

    public function getUserInfo() : string
    {
        return sprintf("%s%s", $this->user, $this->password !== null ? ':' . $this->password : '');
    }

    public function getHost() : string
    {
        return $this->host;
    }

    public function getPort() : ?int
    {
        return $this->port;
    }

    public function getPath() : string
    {
        return $this->path;
    }

    public function getQuery() : string
    {
        return $this->queryParams->toString();
    }

    public function getFragment() : string
    {
        return $this->fragment;
    }

    public function withUserInfo(string $user, string|null $password = null) : UriInterface
    {
        return new self(
            $this->scheme,
            $this->host,
            $this->path,
            $this->port,
            $this->queryParams->toString(),
            $this->fragment,
            $user,
            $password
        );
    }

    public function withPort(int|null $port) : UriInterface
    {
        return new self(
            $this->scheme,
            $this->host,
            $this->path,
            $this->validatePort($port, $this->scheme),
            $this->queryParams->toString(),
            $this->fragment,
            $this->user,
            $this->password
        );
    }

    public function withQuery(string $query) : UriInterface
    {
        $clone              = clone $this;
        $clone->queryParams = new QueryParams($this->validateQuery($query));

        return $clone;
    }

    public function withFragment(string $fragment) : UriInterface
    {
        return new self(
            $this->scheme,
            $this->host,
            $this->path,
            $this->port,
            $this->queryParams->toString(),
            $this->validateFragment($fragment),
            $this->user,
            $this->password
        );
    }

    public function withPath(string $path) : self
    {
        return new self(
            scheme  : $this->scheme,
            host    : $this->host,
            path    : (string) (new Path(path: $path)),
            port    : $this->port,
            query   : $this->queryParams->toString(),
            fragment: $this->fragment,
            user    : $this->user,
            password: $this->password
        );
    }

    public function withHost(string $host) : self
    {
        return new self(
            scheme  : $this->scheme,
            host    : (string) (new Host(host: $host)),
            path    : $this->path,
            port    : $this->port,
            query   : $this->queryParams->toString(),
            fragment: $this->fragment,
            user    : $this->user,
            password: $this->password
        );
    }

    public function withScheme(string $scheme) : self
    {
        return new self(
            scheme  : (string) (new Scheme(scheme: $scheme)),
            host    : $this->host,
            path    : $this->path,
            port    : $this->port,
            query   : $this->queryParams->toString(),
            fragment: $this->fragment,
            user    : $this->user,
            password: $this->password
        );
    }

    public function getAuthority() : string
    {
        $authority = $this->host;
        if ($this->user) {
            $authority = $this->user . ($this->password ? ':' . $this->password : '') . ('@' . $authority);
        }

        if ($this->port !== null) {
            $authority .= ':' . $this->port;
        }

        return $authority;
    }


}

=== HTTP/URI/Traits/QueryParameterTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Traits;

use Gemini\HTTP\URI\QueryParams;

trait QueryParameterTrait
{
    public function addParam(string $key, string $value) : self
    {
        $clone = clone $this;
        $clone->queryParams->set(rawurldecode($key), rawurldecode($value));

        return $clone;
    }


    public function addParams(array $params) : self
    {
        $clone = clone $this;
        foreach ($params as $key => $value) {
            $clone->queryParams->set($key, $value);
        }

        return $clone;
    }

    public function getParams() : array
    {
        return $this->queryParams->toArray();
    }

    public function removeParam(string $key) : self
    {
        $clone = clone $this;
        $clone->queryParams->delete($key);

        return $clone;
    }

    public function buildQuery() : string
    {
        return $this->queryParams->toString();
    }
}

=== HTTP/URI/Traits/UriValidationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI\Traits;

use InvalidArgumentException;

trait UriValidationTrait
{
    public function validateScheme(string $scheme) : string
    {
        $allowedSchemes = ['http', 'https', 'ftp', 'ws', 'wss', 'file', 'mailto', 'data', 'blob'];
        if ($scheme === '' || ! in_array(strtolower($scheme), $allowedSchemes, true)) {
            throw new InvalidArgumentException(message: 'Invalid scheme: ' . $scheme);
        }

        return strtolower($scheme);
    }

    public function validateHost(string $host) : string
    {
        if ($host === '') {
            return '';
        }

        if (str_starts_with($host, '[') && str_ends_with($host, ']')) {
            $ipv6 = trim($host, '[]');
            if (! filter_var($ipv6, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
                throw new InvalidArgumentException(message: 'Invalid IPv6 host: ' . $host);
            }

            return $host;
        }

        $asciiHost = idn_to_ascii($host, IDNA_DEFAULT, INTL_IDNA_VARIANT_UTS46);
        if ($asciiHost === false || ! filter_var($asciiHost, FILTER_VALIDATE_DOMAIN, FILTER_FLAG_HOSTNAME)) {
            throw new InvalidArgumentException(message: 'Invalid host: ' . $host);
        }

        return strtolower($asciiHost);
    }

    public function validatePath(string $path) : string
    {
        $segments = array_map(
            static fn(string $segment) : string => rawurlencode($segment),
            explode('/', $path)
        );

        return '/' . ltrim(implode('/', $segments), '/');
    }

    public function validateQuery(string $query) : string
    {
        parse_str($query, $queryArray);
        if (! is_array($queryArray)) {
            throw new InvalidArgumentException(message: 'Invalid query string: ' . $query);
        }

        return http_build_query($queryArray, '', '&', PHP_QUERY_RFC3986);
    }

    public function validateFragment(string $fragment) : string
    {
        return rawurlencode($fragment);
    }

    public function validatePort(?int $port, string $scheme) : ?int
    {
        if ($port === null) {
            return null;
        }

        if ($port < 1 || $port > 65535) {
            throw new InvalidArgumentException(message: 'Invalid port: ' . $port);
        }

        $defaultPorts = [
            'http'  => 80,
            'https' => 443,
            'ftp'   => 21,
            'ws'    => 80,
            'wss'   => 443,
        ];

        return $port === ($defaultPorts[$scheme] ?? null) ? null : $port;
    }
}

=== HTTP/URI/UriBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\HTTP\URI;

use Gemini\HTTP\URI\Components\Host;
use Gemini\HTTP\URI\Components\Path;
use Gemini\HTTP\URI\Components\Scheme;
use Gemini\HTTP\URI\Traits\Psr7UriTrait;
use Gemini\HTTP\URI\Traits\QueryParameterTrait;
use Gemini\HTTP\URI\Traits\UriValidationTrait;
use InvalidArgumentException;
use Psr\Http\Message\UriInterface;

final class UriBuilder extends BaseUri implements UriInterface
{
    use QueryParameterTrait;
    use Psr7UriTrait;
    use UriValidationTrait;

    private QueryParams $queryParams;

    public function __construct(
        string  $scheme = '',
        string  $host = '',
        string  $path = '/',
        ?int    $port = null,
        string  $query = '',
        string  $fragment = '',
        string  $user = '',
        ?string $password = null
    ) {
        parent::__construct(
            scheme  : (string) new Scheme(scheme: $scheme),
            host    : (string) new Host(host: $host),
            path    : (string) new Path(path: $path),
            port    : $port,
            query   : '',
            fragment: $fragment,
            user    : $user,
            password: $password
        );

        $this->queryParams = new QueryParams(queryString: $query);
    }

    public static function fromBaseUri(string $baseUri, array $overrides = []) : UriInterface
    {
        $instance = self::createFromString(uri: $baseUri);

        return $instance
            ->withScheme(scheme: $overrides['scheme'] ?? $instance->getScheme())
            ->withHost(host: $overrides['host'] ?? $instance->getHost())
            ->withPath(path: $overrides['path'] ?? $instance->getPath())
            ->withPort(port: $overrides['port'] ?? $instance->getPort())
            ->withQuery(query: $overrides['query'] ?? $instance->getQuery())
            ->withFragment(fragment: $overrides['fragment'] ?? $instance->getFragment());
    }

    public static function createFromString(string $uri) : self
    {
        $parts = parse_url($uri);

        if ($parts === false) {
            throw new InvalidArgumentException(message: "Invalid URI: {$uri}");
        }

        return new self(
            scheme  : $parts['scheme'] ?? '',
            host    : $parts['host'] ?? '',
            path    : $parts['path'] ?? '/',
            port    : $parts['port'] ?? null,
            query   : $parts['query'] ?? '',
            fragment: $parts['fragment'] ?? '',
            user    : $parts['user'] ?? '',
            password: $parts['pass'] ?? null
        );
    }

    public function appendPath(string $segment) : self
    {
        [$path, $query] = explode('?', $segment, 2) + [1 => ''];

        $newPath = rtrim($this->path, '/') . '/' . ltrim($path, '/');
        $clone   = $this->withPath($newPath);

        if ($query !== '') {
            parse_str($query, $queryParams);
            $clone = $clone->withAddedQueryParams($queryParams);
        }

        return $clone;
    }

    public function withAddedQueryParams(array $params) : self
    {
        return $this->addParams(params: $params);
    }

    public function build() : string
    {
        $uri = $this->scheme ? "{$this->scheme}://" : '';

        if ($this->user) {
            $uri .= $this->user;
            if ($this->password !== null) {
                $uri .= ":{$this->password}";
            }
            $uri .= '@';
        }

        $uri .= $this->host;

        if ($this->port !== null) {
            $uri .= ":{$this->port}";
        }

        $uri .= '/' . ltrim($this->path, '/');

        $query = $this->buildQuery();
        if ($query) {
            $uri .= '?' . urldecode($query);
        }

        if ($this->fragment) {
            $uri .= '#' . rawurlencode($this->fragment);
        }

        return $uri;
    }
}

=== Logging/ErrorHandler.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use ErrorException;
use Gemini\Exceptions\ValidationException;
use Gemini\HTTP\Response\JsonResponse;
use JetBrains\PhpStorm\NoReturn;
use Psr\Log\LoggerInterface;
use Spatie\Ignition\Ignition;
use Throwable;

/**
 * Centralized application error handler.
 *
 * Manages exceptions, errors, and shutdown handling consistently across application lifecycle.
 * Response rendered based on configured EXCEPTION_RESPONSE_FORMAT (.env).
 */
final readonly class ErrorHandler
{
    /**
     * Available rendering formats for exceptions.
     */
    private const string RENDER_FORMAT_IGNITION = 'ignition';

    private const string RENDER_FORMAT_JSON     = 'json';

    /**
     * Constructor with property promotion for dependency injection.
     *
     * @param LoggerInterface $logger Logger for error logging.
     */
    public function __construct(private LoggerInterface $logger) {}

    /**
     * Initializes global error handling for application.
     */
    public function initialize() : void
    {
        ob_start();
        set_exception_handler([$this, 'handle']);
        set_error_handler([$this, 'convertErrorToException']);
        register_shutdown_function([$this, 'handleShutdown']);
        $this->registerCliSignalHandlers();
    }

    /**
     * Registers CLI signal handlers for graceful shutdown.
     */
    private function registerCliSignalHandlers() : void
    {
        if (PHP_SAPI === 'cli' && function_exists('pcntl_signal')) {
            pcntl_signal(SIGTERM, fn() => $this->exitGracefully(signal: 'SIGTERM'));
            pcntl_signal(SIGINT, fn() => $this->exitGracefully(signal: 'SIGINT'));
        }
    }

    /**
     * Handles CLI graceful shutdown signals.
     */
    #[NoReturn]
    private function exitGracefully(string $signal) : void
    {
        $this->logger->warning(
            message: "⚠️ {$signal} received – exiting gracefully.",
            context: ['file' => __FILE__, 'line' => __LINE__]
        );

        exit(0);
    }

    /**
     * Converts PHP errors to ErrorException instances.
     *
     * @throws ErrorException
     */
    public function convertErrorToException(
        int    $severity,
        string $message,
        string $file,
        int    $line
    ) : never {
        throw new ErrorException(
            message : $message,
            code    : 0,
            severity: $severity,
            filename: $file,
            line    : $line
        );
    }

    /**
     * Handles fatal shutdown errors.
     *
     * @throws \JsonException
     */
    public function handleShutdown() : void
    {
        $error = error_get_last();

        if ($error !== null && isset($error['message'], $error['file'], $error['line'])) {
            $this->logger->error(
                message: "⚠️ Fatal error: {$error['message']}",
                context: ['file' => $error['file'], 'line' => $error['line'], 'type' => $error['type'] ?? E_ERROR]
            );

            $this->handle(
                throwable: new ErrorException(
                               message : $error['message'],
                               code    : 0,
                               severity: $error['type'] ?? E_ERROR,
                               filename: $error['file'],
                               line    : $error['line']
                           )
            );
        }
    }

    /**
     * Handles uncaught exceptions globally.
     *
     * @throws \JsonException
     */
    public function handle(Throwable $throwable) : void
    {
        try {
            $this->report(throwable: $throwable);

            match ($this->renderFormat()) {
                self::RENDER_FORMAT_JSON => $this->renderJson($throwable),
                default                  => $this->renderIgnition($throwable)
            };
        } catch (Throwable $e) {
            $this->logger->critical(
                message: "⚠️ Error handler crashed: {$e->getMessage()}",
                context: ['file' => $e->getFile(), 'line' => $e->getLine(), 'exception' => $e]
            );

            echo (new JsonResponse(status: 500, message: 'Internal Server Error'))->toJson();
        }

        if (ob_get_length() > 0) {
            ob_end_flush();
        } elseif (ob_get_status()) {
            ob_end_clean();
        }
    }

    /**
     * Reports throwable unless explicitly excluded.
     */
    private function report(Throwable $throwable) : void
    {
        if ($throwable instanceof ValidationException) {
            return;
        }

        $this->logger->error(
            message: $throwable->getMessage(),
            context: ['file' => $throwable->getFile(), 'line' => $throwable->getLine(), 'exception' => $throwable]
        );
    }

    /**
     * Determines an exception response format based on configuration.
     */
    private function renderFormat() : string
    {
        return env(key: 'EXCEPTION_RESPONSE_FORMAT', default: self::RENDER_FORMAT_IGNITION);
    }

    /**
     * Renders JSON formatted error response.
     *
     * @throws \JsonException
     */
    private function renderJson(Throwable $throwable) : void
    {
        $response = $throwable instanceof ValidationException
            ? new JsonResponse(status: 422, message: 'Validation failed', data: $throwable->getErrors())
            : new JsonResponse(status: 500, message: 'An unexpected error occurred');

        if (! headers_sent()) {
            http_response_code($response->status);
            header('Content-Type: application/json');
        }

        echo $response->toJson();
    }

    /**
     * Renders Ignition HTML formatted error response.
     */
    private function renderIgnition(Throwable $throwable) : void
    {
        Ignition::make()
            ->shouldDisplayException(shouldDisplayException: true)
            ->setTheme(theme: 'dark')
            ->register()
            ->handleException(throwable: $throwable);
    }
}

=== Logging/ErrorLogger.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use Carbon\Carbon;
use JsonException;
use Psr\Log\InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Psr\Log\LogLevel;
use Stringable;
use Throwable;

/**
 * ✅ Class ErrorLogger
 *
 * Implements PSR-3 LoggerInterface for standardized logging.
 * This logger formats and stores log messages using a LogWriterInterface.
 *
 * 🛠 Key Features:
 * - Structured JSON logging for improved readability
 * - Automatic exception handling with full stack traces
 * - Uses PSR-3 log levels with strict validation
 * - Ensures all logs are properly formatted and easy to debug
 */
final readonly class ErrorLogger implements LoggerInterface
{
    /**
     * 🚀 Initializes the logger with a LogWriterInterface instance.
     *
     * @param LogWriterInterface $logWriter The log writer responsible for persisting log messages.
     */
    public function __construct(private LogWriterInterface $logWriter) {}

    // ✅ All standard PSR-3 log levels, mapped to the central logging function

    /**
     * 🚨 Logs an EMERGENCY-level message.
     * 🛑 Used for **critical system failures** where the application is unusable.
     *
     * 🔥 **Example Scenarios:**
     * - Database corruption.
     * - **System-wide failures** that require **immediate** action.
     * - Security breaches (e.g., private data leaks).
     * - Server crashes or complete service downtime.
     *
     * ✅ **Best Practices:**
     * - **Triggers immediate alerts** (e.g., SMS, email, monitoring tools).
     * - **Used sparingly**—this is the **highest severity level**.
     *
     * @param Stringable|string    $message The emergency message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function emergency(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::EMERGENCY, message: $message, context: $context);
    }

    /**
     * 🛠 Central method for logging messages at different levels.
     * ✅ Reduces code duplication by handling all log levels in a single function.
     *
     * @param string               $level   The PSR-3 log level.
     * @param Stringable|string    $message The log message.
     * @param array<string, mixed> $context Additional log context.
     */
    private function callLogMethod(string $level, Stringable|string $message, array $context = []) : void
    {
        $this->log(level: $level, message: $message, context: $context);
    }

    /**
     * ✅ Main logging function that:
     * - Validates the log level
     * - Formats the log message with timestamp
     * - Converts exceptions to structured JSON
     * - Writes the log entry using LogWriterInterface
     *
     * @param mixed                $level   The severity level (e.g., LogLevel::ERROR).
     * @param Stringable|string    $message The log message.
     * @param array<string, mixed> $context Additional context for debugging.
     *
     * @throws InvalidArgumentException If the log level is invalid.
     */
    public function log(mixed $level, Stringable|string $message, array $context = []) : void
    {
        // 🔍 Validate log level before proceeding
        if (! $this->isValidLogLevel($level)) {
            throw new InvalidArgumentException(message: "❌ Invalid log level: {$level}");
        }

        // 📝 Format the log entry with Belgrade timezone
        $formattedMessage = sprintf(
            "[%s] %s %s %s\n",
            Carbon::now()->setTimezone('Europe/Belgrade')->format('Y-m-d H:i:s'),
            $this->getLogPrefix($level),
            (string) $message,
            $this->formatContext($context)
        );

        // 📡 Write the log entry to the designated log writer
        $this->logWriter->write(content: $formattedMessage);
    }


    /**
     * 🔍 Validates if the provided log level is a valid PSR-3 level.
     */
    private function isValidLogLevel(mixed $level) : bool
    {
        return is_string($level)
               && in_array(
                   $level,
                   [
                       LogLevel::EMERGENCY,
                       LogLevel::ALERT,
                       LogLevel::CRITICAL,
                       LogLevel::ERROR,
                       LogLevel::WARNING,
                       LogLevel::NOTICE,
                       LogLevel::INFO,
                       LogLevel::DEBUG,
                   ],
                   true
               );
    }

    /**
     * 🔥 Provides an emoji-based prefix for log levels.
     * ✅ Improves readability in logs.
     */
    private function getLogPrefix(string $level) : string
    {
        return match ($level) {
            LogLevel::EMERGENCY => "🚨 [EMERGENCY]",
            LogLevel::ALERT     => "🚨 [ALERT]",
            LogLevel::CRITICAL  => "🔥 [CRITICAL]",
            LogLevel::ERROR     => "❌ [ERROR]",
            LogLevel::WARNING   => "⚠️ [WARNING]",
            LogLevel::NOTICE    => "ℹ️ [NOTICE]",
            LogLevel::INFO      => "✅ [INFO]",
            LogLevel::DEBUG     => "🐞 [DEBUG]",
            default             => "[LOG]",
        };
    }

    /**
     * 📌 Converts log context to structured JSON.
     * - Handles exceptions and extracts full details.
     * - Uses `JSON_PRETTY_PRINT` for improved log readability.
     *
     * @param array<string, mixed> $context
     *
     * @return string JSON encoded context string or fallback JSON on failure.
     */
    private function formatContext(array $context) : string
    {
        // ✅ Extract full exception details if present
        if (isset($context['exception']) && $context['exception'] instanceof Throwable) {
            $exception = $context['exception'];

            $context['exception'] = [
                'message'  => $exception->getMessage(),
                'file'     => $exception->getFile(),
                'line'     => $exception->getLine(),
                'trace'    => explode("\n", $exception->getTraceAsString()), // Stack trace formatted as an array
                'code'     => $exception->getPrevious() ? $exception->getPrevious()->getCode() : $exception->getCode(),
                'previous' => $exception->getPrevious() ? [
                    'message' => $exception->getPrevious()->getMessage(),
                    'file'    => $exception->getPrevious()->getFile(),
                    'line'    => $exception->getPrevious()->getLine(),
                ] : null,
            ];
        }

        try {
            return json_encode($context, JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);
        } catch (JsonException $e) {
            return json_encode(['error' => 'Context encoding failed', 'message' => $e->getMessage()]);
        }
    }

    /**
     * 🚨 Logs an ALERT-level message.
     * 🔥 Used for situations that require immediate attention.
     *
     * Example: Database connection failures, critical security breaches.
     *
     * @param Stringable|string    $message The alert message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function alert(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::ALERT, message: $message, context: $context);
    }

    /**
     * 🔥 Logs a CRITICAL-level message.
     * ✅ Indicates a severe problem that requires immediate intervention.
     *
     * Example: Application component failure, major errors preventing execution.
     *
     * @param Stringable|string    $message The critical message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function critical(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::CRITICAL, message: $message, context: $context);
    }

    /**
     * ❌ Logs an ERROR-level message.
     * ⚠️ Used for runtime errors that must be logged and monitored.
     *
     * Example: Exception thrown in production, failed API requests.
     *
     * @param Stringable|string    $message The error message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function error(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::ERROR, message: $message, context: $context);
    }

    /**
     * ⚠️ Logs a WARNING-level message.
     * 🔍 Used for potential issues that should be investigated but are not yet critical.
     *
     * Example: Deprecation warnings, retries on failed operations.
     *
     * @param Stringable|string    $message The warning message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function warning(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::WARNING, message: $message, context: $context);
    }

    /**
     * ℹ️ Logs a NOTICE-level message.
     * ✅ Represents normal but significant application events.
     *
     * Example: User authentication success, feature usage tracking.
     *
     * @param Stringable|string    $message The notice message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function notice(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::NOTICE, message: $message, context: $context);
    }

    /**
     * ✅ Logs an INFO-level message.
     * 📌 Used for informational messages about system state and expected operations.
     *
     * Example: System startup, cron job execution, API call success.
     *
     * @param Stringable|string    $message The info message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function info(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::INFO, message: $message, context: $context);
    }

    /**
     * 🐞 Logs a DEBUG-level message.
     * 🛠 Used for detailed debugging information during development.
     *
     * Example: Variable dumps, performance metrics, internal function calls.
     *
     * @param Stringable|string    $message The debug message.
     * @param array<string, mixed> $context Additional context for debugging.
     */
    public function debug(Stringable|string $message, array $context = []) : void
    {
        $this->callLogMethod(level: LogLevel::DEBUG, message: $message, context: $context);
    }

}

=== Logging/FileLogWriter.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use Exception;
use Gemini\Facade\Facades\Storage;

/**
 * Final class FileLogWriter
 *
 * This class implements the LogWriterInterface to write log entries to a file.
 * It uses the Storage facade to handle filesystem operations and includes a fallback mechanism
 * if the primary log file path is not accessible.
 */
final class FileLogWriter implements LogWriterInterface
{
    /**
     * The fallback path for logging if the primary path is unavailable
     *
     * Using a constant for an alternative location ensures logging can still function
     * even when the specified path encounters issues.
     *
     * @var string
     */
    private const string FALLBACK_PATH = '/tmp/fallback-log.log';

    /**
     * Constructor to initialize an instance with a specified file path
     * and perform initial log file setup.
     *
     * @param string $filePath The path to the log file that needs to be initialized.
     *
     * @return void
     */
    public function __construct(private string $filePath)
    {
        $this->initializeLogFile();
    }

    /**
     * Initializes the log file by ensuring the directory exists and is writable.
     *
     * This method checks and creates the directory if it does not exist.
     * It switches to a fallback path if the specified path cannot be accessed.
     */
    private function initializeLogFile() : void
    {
        $directory = dirname(path: $this->filePath);
        // Attempt to ensure the directory exists or use fallback if creation fails
        if (! Storage::exists(path: $directory) && ! Storage::createDirectory(directory: $directory)) {
            $this->filePath = self::FALLBACK_PATH;
            $this->ensureWritable();

            return;
        }

        // Set directory permissions to ensure it is writable
        Storage::setPermissions(path: $directory, permissions: 0755);
        $this->ensureWritable();
    }

    /**
     * Ensures the file is writable, using fallback if necessary.
     *
     * This check ensures that writing logs does not fail silently by always
     * having a writable destination, either the target or fallback file.
     */
    private function ensureWritable() : void
    {
        if (! Storage::exists(path: $this->filePath) && ! $this->attemptFileCreation()) {
            $this->filePath = self::FALLBACK_PATH;
            Storage::write(path: $this->filePath, content: ''); // Create an empty file if it doesn't exist
        }
    }

    /**
     * Attempts to create the file and set appropriate permissions.
     *
     * @return bool True if file creation is successful; false otherwise.
     */
    private function attemptFileCreation() : bool
    {
        Storage::write(path: $this->filePath, content: ''); // Create an empty file
        Storage::setPermissions(path: $this->filePath, permissions: 0644);

        return Storage::exists(path: $this->filePath);
    }

    /**
     * Writes the content to the file. Uses fallback if a primary path fails.
     *
     * @param string $content The log entry content to write.
     */
    public function write(string $content) : void
    {
        try {
            Storage::write(path: $this->filePath, content: $content . PHP_EOL, append: true);
        } catch (Exception) {
            Storage::write(path: self::FALLBACK_PATH, content: $content . PHP_EOL, append: true);
        }
    }
}
=== Logging/GlobalErrorHandlerInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use Throwable;

/**
 * Interface GlobalErrorHandlerInterface
 *
 * Defines the contract for global error handling within the application.
 */
interface GlobalErrorHandlerInterface
{
    /**
     * Initializes error handling configuration.
     *
     * @throws \Exception
     */
    public function initialize(): void;

    /**
     * Handles exceptions and logs the error details.
     *
     * @param Throwable $throwable - The exception to handle.
     *
     * @throws \Exception
     */
    public function handle(Throwable $throwable): void;

    /**
     * Logs custom messages for debugging.
     *
     * @param string $message - Custom message to log.
     * @param mixed $context - Additional context for the log entry.
     */
    public function log(string $message, mixed $context = null): void;

    /**
     * Dumps variables during development for debugging purposes.
     *
     * @param mixed $dumpMe - Variable to dump.
     */
    public function dumpIt(mixed $dumpMe): void;
}
=== Logging/LoggerFactory.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Logging\Writers\RotatingFileLogWriter;
use RuntimeException;

/**
 * LoggerFactory
 *
 * An environment-aware and PSR-3-compatible logger factory.
 *
 * Creates scoped, rotating file-based loggers based on application
 * environment and logical "channels" (e.g., error, auth, session).
 *
 * Design principles:
 * - Follows the Factory Pattern for logger creation
 * - Favors composition (delegates to `RotatingFileLogWriter`)
 * - Promotes separation of concerns (no writing logic here)
 * - Prepares loggers for safe use in production, dev, test
 *
 * @package Gemini\Logging
 */
final class LoggerFactory
{
    /**
     * Creates the default global error logger.
     *
     * Uses the current application environment (`APP_ENV`) to determine the
     * base filename of the log, allowing per-environment log separation.
     *
     * - `production` → `prod_error-error.log.YYYY-MM-DD`
     * - `development` → `dev_error-error.log.YYYY-MM-DD`
     * - fallback → `error-error.log.YYYY-MM-DD`
     *
     * @return ErrorLogger The error logger instance, pre-configured with a rotating writer.
     */
    public function create() : ErrorLogger
    {
        // Get the environment from env()
        $env = env(key: 'APP_ENV');

        // Determine base name based on environment
        $baseName = match ($env) {
            'production'  => 'production-errors',
            'stage'       => 'stage-errors',
            'staging'     => 'staging-errors',
            'development' => 'dev-errors',
            default       => 'errors',
        };

        // Delegate to the specific channel-based logger builder
        return $this->createLoggerFor(channel: "{$baseName}-log");
    }

    /**
     * Creates a named logger channel (e.g. "session", "auth", etc.)
     * Each channel gets its own file, allowing for clean separation of logs.
     *
     * - Supports multiple log consumers (e.g., Auth, Session, Queue) with their own files.
     * - Uses a rotating file log writer (1 file per day).
     * - Sets timezone for all entries based on `APP_TZ` env or system fallback.
     *
     * @param string $channel Name of the channel (used as log file base name).
     *
     * @return ErrorLogger A PSR-3-compatible logger instance.
     */
    public function createLoggerFor(string $channel) : ErrorLogger
    {
        // Resolve a full path based on configured log directory + channel name
        $path = rtrim(AppPath::LOGS_PATH->get(), '/') . '/' . trim($channel, '/');

        // Ensure the directory is safe to use
        $this->ensureLogDirectoryIsWritable(logPath: $path);

        // Return the logger instance with a rotating file writer
        return new ErrorLogger(
            logWriter: new RotatingFileLogWriter(
                           baseLogPath: $path,
                           timezone   : env(
                                            key    : 'APP_TZ',
                                            default: date_default_timezone_get()
                                        )
                       )
        );
    }

    /**
     * Ensures that the directory for the log file exists and is writable.
     *
     * - If the directory does not exist, it is created recursively.
     * - If the directory exists but is not writable, a RuntimeException is thrown.
     * - This ensures the system does not silently fail when logging.
     *
     * @param string $logPath Full path to the intended log file.
     *
     * @throws RuntimeException If a directory is not writable or cannot be created.
     */
    private function ensureLogDirectoryIsWritable(string $logPath) : void
    {
        // Extract the parent directory from the log file path
        $dir = dirname(path: $logPath);

        // Attempt to create the directory if it does not exist
        if (! is_dir($dir) && ! mkdir($dir, 0750, true) && ! is_dir($dir)) {
            throw new RuntimeException(
                message: "Failed to create log directory: {$dir}"
            );
        }

        // Verify write permission (prevents silent failures or security issues)
        if (! is_writable($dir)) {
            throw new RuntimeException(
                message: "Log directory not writable: {$dir}"
            );
        }
    }
}

=== Logging/LogInitializer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

use Exception;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Facade\Facades\Storage;

/**
 * Class LogInitializer
 *
 * Handles the initialization of the logs' directory.
 * This includes ensuring that the directory exists, is writable, and has appropriate permissions.
 * This class is intended to be used at the startup of the application to guarantee
 * that logging mechanisms have a valid directory to write to.
 */
class LogInitializer
{
    /** @var string The fallback directory path for logs if the primary path fails */
    private const string FALLBACK_LOG_PATH = '/tmp';

    /** @var int The default directory permissions for log directories */
    private const int DEFAULT_PERMISSIONS = 0755;

    /**
     * Ensures the logs directory exists and is writable.
     *
     * This method checks if the primary log path is valid and writable, attempting to create it if it does not exist.
     * If the primary path is invalid, it falls back to a secondary path. If both fail, an exception is thrown.
     *
     * @throws Exception if the directory cannot be created or is not writable.
     */
    public static function ensureLogsDirectoryExists() : void
    {
        $logPath = AppPath::LOGS_PATH->get();
        // Try to create or validate the primary log path
        if (! self::verifyDirectory(path: $logPath)) {
            $logPath = self::FALLBACK_LOG_PATH;

            // Try the fallback path if primary fails
            if (! self::verifyDirectory(path: $logPath)) {
                throw new Exception(
                    sprintf('Unable to create logs directory at either %s or fallback path.', $logPath)
                );
            }
        }
    }

    /**
     * Verifies or creates a writable directory.
     *
     * This method attempts to verify if the provided directory path is valid and writable.
     * If the directory does not exist, it will attempt to create it with default permissions.
     * It also ensures the directory is writable.
     * If any step fails, it logs an emergency message.
     *
     * @param string $path Path to the directory to verify.
     *
     * @return bool True if the directory is writable, false otherwise.
     */
    private static function verifyDirectory(string $path) : bool
    {
        try {
            // Check if the path is a directory or attempt to create it
            if (! Storage::exists(path: $path) && ! Storage::createDirectory(directory: $path)) {
                return false;
            }

            // Ensure the directory has the correct permissions
            Storage::setPermissions(path: $path, permissions: self::DEFAULT_PERMISSIONS);

            return true;
        } catch (Exception $exception) {
            // Log an emergency message on failure
            error_log(
                sprintf('Failed to initialize log directory at %s: %s', $path, $exception->getMessage()),
                3,
                self::FALLBACK_LOG_PATH . '/emergency_log.log'
            );

            return false;
        }
    }
}

=== Logging/LogWriterInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging;

/**
 * Interface LogWriterInterface
 *
 * Provides a contract for writing log entries. Implementations can be file-based, database-based, or any other
 * storage mechanism. This abstraction allows for flexible logging strategies in the application.
 */
interface LogWriterInterface
{
    /**
     * Writes a log entry to the defined storage mechanism.
     *
     * @param string $content The log entry content to be written.
     */
    public function write(string $content) : void;
}

=== Logging/Writers/RotatingFileLogWriter.php ===
<?php

declare(strict_types=1);

namespace Gemini\Logging\Writers;

use Carbon\Carbon;
use DateTimeZone;
use Gemini\Logging\LogWriterInterface;
use RuntimeException;

/**
 * ✅ RotatingFileLogWriter
 *
 * Writes log entries to a daily rotated log file based on the current timezone-aware date.
 * Automatically manages log retention by deleting the oldest files beyond a configurable threshold.
 *
 * ✅ Use Cases:
 * - Structured file logging in production/staging/dev environments.
 * - Prevents unbounded disk growth with built-in retention.
 * - Ready for future ingestion by structured log collectors (e.g., ELK, Loki).
 *
 * 🧱 Best Practices Followed:
 * - Safe path resolution & validation
 * - Immutable config via constructor
 * - Atomic writes with file locks
 * - Lazy rotation logic for performance
 * - PSR-3 compliant output
 */
final class RotatingFileLogWriter implements LogWriterInterface
{
    /**
     * Absolute path prefix for log files (e.g., /var/logs/app-error).
     * The File path is dynamically suffixed with the date.
     *
     * @var string
     */
    private string $baseLogPath;

    /**
     * Valid IANA timezone identifier (e.g., Europe/Belgrade).
     *
     * @var string
     */
    private string $timezone;

    /**
     * Current date suffix for caching (format: d.m.Y).
     *
     * @var string|null
     */
    private string|null $cachedDate = null;

    /**
     * Cached a full path to the log file (rotated daily).
     *
     * @var string|null
     */
    private string|null $cachedFilePath = null;

    /**
     * Maximum number of log files to retain (FIFO deletion).
     * Ensures consistent disk usage over time.
     *
     * @readonly
     */
    private readonly int $maxLogFiles;

    /**
     * Constructor.
     *
     * @param string      $baseLogPath Base absolute path for log files (no date or extension).
     * @param string|null $timezone    Optional timezone (default: UTC).
     * @param int         $maxLogFiles Max number of retained rotated log files.
     *
     * @throws RuntimeException If path or timezone are invalid.
     */
    public function __construct(
        string      $baseLogPath,
        string|null $timezone = null,
        int         $maxLogFiles = 30
    ) {
        // Set the default timezone to 'UTC' if no value is provided for $timezone.
        $timezone ??= 'UTC';

        // Validate the base log path value to ensure it is not empty and does not contain unsafe segments.
        $this->validateBaseLogPath(baseLogPath: $baseLogPath);

        // Attempt to resolve the absolute path of the provided base log path. If realpath() fails (e.g.,
        // if the path does not exist yet), fallback to using the raw $baseLogPath value,
        // ensuring that it does not end with DIRECTORY_SEPARATOR unnecessarily.
        $this->baseLogPath = rtrim($baseLogPath, DIRECTORY_SEPARATOR);

        // Check if the provided timezone is valid by ensuring it exists in the list of IANA timezone identifiers.
        // If it is invalid, throw a RuntimeException with a clear message.
        if (! in_array($timezone, DateTimeZone::listIdentifiers(), true)) {
            throw new RuntimeException(message: "Invalid timezone provided: {$timezone}");
        }

        // Assign the validated timezone to the class property for further use.
        $this->timezone = $timezone;

        // Set the maximum number of log files that can be rotated before overwriting old ones.
        $this->maxLogFiles = $maxLogFiles;
    }

    /**
     * Validates the base log path before use.
     *
     * @param string $baseLogPath
     *
     * @throws RuntimeException If a path is unsafe or empty.
     */
    private function validateBaseLogPath(string $baseLogPath) : void
    {
        if (empty($baseLogPath)) {
            throw new RuntimeException(message: "Base log path cannot be empty.");
        }

        if (strpos($baseLogPath, '..') !== false) {
            throw new RuntimeException(message: "Base log path contains unsafe segments: {$baseLogPath}");
        }
    }

    /**
     * Writes a log entry to the current day's log file (auto-rotated).
     *
     * @param string $content The log content (already formatted, e.g., PSR-3).
     *
     * @throws RuntimeException If a file cannot be written.
     */
    public function write(string $content) : void
    {
        // Get the current date and time in the specified timezone, formatted as 'd.m.Y'.
        $currentDate = Carbon::now()->setTimezone(timeZone: $this->timezone)->format(format: 'd.m.Y');

        // Check if the cached date does not match the current date.
        if ($this->cachedDate !== $currentDate) {
            // Update the cached date to the current date.
            $this->cachedDate = $currentDate;

            // Generate a new log file path using the base log path and the current date.
            $this->cachedFilePath = "{$this->baseLogPath}-{$currentDate}.log";
        }

        // Ensure the directory for the log file exists, creating it if necessary.
        $this->ensureDirectoryExists(directory: dirname($this->cachedFilePath));

        // Rotate old logs if the number of log files exceeds the defined limit.
        $this->rotateLogs();

        // Append the provided log content to the current log file, creating it if it doesn't exist.
        $this->appendToFile(filePath: $this->cachedFilePath, content: $content);
    }

    /**
     * Ensures the specified directory exists by creating it if it does not exist.
     * Throws an exception if directory creation fails.
     *
     * @param string $directory The path of the directory to ensure exists.
     *
     * @return void
     */
    private function ensureDirectoryExists(string $directory) : void
    {
        if (! is_dir($directory) && ! mkdir($directory, 0775, true) && ! is_dir($directory)) {
            throw new RuntimeException(message: "Failed to create log directory: {$directory}");
        }
    }

    /**
     * Enforces log file retention by removing log files older than a specified time limit.
     * This method ensures that the logging directory does not exceed a defined maximum file retention period.
     * Adheres to best practices such as validating file paths and ensuring atomic operations with `unlink`.
     *
     * @param int $maxFileAgeInDays Defaults to 30 days if not specified.
     *                              Represents the maximum age (in days) for retaining log files.
     *
     * @return void
     */
    private function rotateLogs(int $maxFileAgeInDays = 30) : void
    {
        // Retrieve a list of log files matching the naming convention: `<baseLogPath>-*.log`.
        // This uses the `glob` function to find all files matching the wildcard pattern.
        $logFiles = glob("{$this->baseLogPath}-*.log");

        // If the `glob` function fails (returns false), exit early as no files were found to process.
        if ($logFiles === false) {
            return;
        }

        // Get the current Unix timestamp, which represents the current time in seconds since the Unix epoch.
        $now = time();

        // Calculate the maximum file age in seconds by multiplying the provided days by the number of seconds in a day (86,400).
        $maxFileAgeInSeconds = $maxFileAgeInDays * 86400;

        // Iterate over each file path returned by `glob`.
        foreach ($logFiles as $file) {
            // Skip processing if the current path is not a regular file.
            // This avoids issues with directories or non-files that may have matched the pattern.
            if (! is_file($file)) {
                continue;
            }

            // Check if the file's modification time exceeds the maximum allowed age.
            // Compare the current timestamp with the last modification time (`filemtime`).
            if (($now - filemtime($file)) > $maxFileAgeInSeconds) {
                // If the file is older than allowed, delete it using the `unlink` function.
                // The `unlink` function permanently removes the file from the file system.
                unlink($file);
            }
        }
    }


    /**
     * Appends content to the log file using exclusive lock.
     *
     * @param string $filePath Full path to the current log file.
     * @param string $content  Formatted log content.
     *
     * @throws RuntimeException If writing fails.
     */
    private function appendToFile(string $filePath, string $content) : void
    {
        // Attempting to write content to the specified file.
        // The filename is provided by the $filePath variable.
        // The data being written includes the content followed by a new line (PHP_EOL).
        // The FILE_APPEND flag ensures that the content is appended to the file instead of overwriting it.
        // The LOCK_EX flag prevents concurrent writes to the file
        //  by getting an exclusive lock during the writing process.
        $result = file_put_contents(
            filename: $filePath,
            data    : $content . PHP_EOL,
            flags   : FILE_APPEND | LOCK_EX
        );

        // Checking if the result of the file_put_contents call is false.
        // A result of false indicates that an error occurred while trying to write to the file.
        if ($result === false) {
            // Throwing a RuntimeException if writing to the file failed.
            // The exception provides a meaningful error message that includes the filepath for debugging.
            throw new RuntimeException(message: "Unable to write log entry to file: {$filePath}");
        }
    }
}

=== Middlewares/MiddlewareInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Middlewares;

interface MiddlewareInterface
{
    public function handle(string $commandName, array $arguments, callable $next) : void;
}

=== Repository/Repository.php ===
<?php

declare(strict_types=1);

namespace Gemini\Repository;

use Exception;
use Gemini\Database\QueryBuilder\QueryBuilder;
use RuntimeException;

/**
 * Base Repository
 *
 * Abstract class providing database operations for entities, including find, save, delete, list, and advanced queries.
 */
abstract class Repository
{
    /**
     * Repository constructor.
     *
     * Sets the table name for the QueryBuilder instance.
     *
     * @param QueryBuilder $queryBuilder The QueryBuilder instance for database operations.
     */
    public function __construct(protected QueryBuilder $queryBuilder)
    {
        $this->queryBuilder->table(tableName: $this->getTableName());
    }

    /**
     * Get the table name for the entity.
     *
     * @return string The name of the table.
     */
    protected function getTableName() : string
    {
        $entityClass = $this->getEntityClass();

        if (! method_exists($entityClass, 'getTableName')) {
            throw new RuntimeException(
                message: sprintf(
                             'Entity class %s must implement a getTableName() method.',
                             $entityClass
                         )
            );
        }

        return $entityClass::getTableName();
    }

    /**
     * Get the entity class for the repository.
     *
     * @return string The fully qualified class name of the entity.
     */
    abstract protected function getEntityClass() : string;

    /**
     * @throws \Exception
     */
    public function findById(int $id) : object|null
    {
        return $this->findOneBy(conditions: ['id' => $id]);
    }

    /**
     * Find one entity by conditions.
     *
     * @param array<string, mixed> $conditions Conditions for filtering.
     *
     * @return object|null The found entity or null.
     * @throws \Exception
     * @throws \Exception
     */
    public function findOneBy(array $conditions) : object|null
    {
        try {
            $query = $this->queryBuilder;

            foreach ($conditions as $column => $value) {
                $query->where(column: $column, operator: '=', value: $value);
            }

            $result = $query->first();

            return $result ? $this->mapToEntity(data: $result) : null;
        } catch (Exception $exception) {
            $this->logError(message: 'Failed to find one entity by conditions.', context: [
                'conditions' => $conditions,
                'exception'  => $exception,
            ]
            );
            throw $exception;
        }
    }

    // ===== CRUD Methods ===== //

    /**
     * Map a database row to an entity object.
     *
     * @param array<string, mixed> $data The database row data.
     *
     * @return object The mapped entity.
     */
    abstract protected function mapToEntity(array $data) : object;

    protected function logError(string $message, array $context = []) : void
    {
        logger(message: $message, context: $context, level: 'error');
    }

    /**
     * @throws \Exception
     */
    public function findAll(int|null $limit = null, int $offset = 0) : array
    {
        $limit ??= 100;

        return $this->findBy(conditions: [], limit: $limit, offset: $offset);
    }

    /**
     * Find entities by conditions with optional pagination and sorting.
     *
     * @param array<string, mixed> $conditions Conditions for filtering.
     * @param string|null          $orderBy    Column to order by.
     * @param string|null          $direction  Sorting direction (ASC|DESC).
     * @param int|null             $limit      Max results to return.
     * @param int|null             $offset     Offset for pagination.
     *
     * @return array<object> The found entities.
     * @throws \Exception
     * @throws \Exception
     */
    public function findBy(
        array       $conditions,
        string|null $orderBy = null,
        string|null $direction = null,
        int|null    $limit = null,
        int|null    $offset = null
    ) : array {
        try {
            $query = $this->queryBuilder;

            foreach ($conditions as $column => $value) {
                $query->where(column: $column, operator: '=', value: $value);
            }

            if ($orderBy !== null && $orderBy !== '' && $orderBy !== '0') {
                $query->orderBy(column: $orderBy, direction: $direction ?? 'ASC');
            }

            if ($limit !== null) {
                $query->limit(limit: $limit);
            }

            if ($offset !== null) {
                $query->offset(offset: $offset);
            }

            $results = $query->get();

            return array_map([$this, 'mapToEntity'], $results);
        } catch (Exception $exception) {
            $this->logError(message: 'Failed to find entities by conditions.', context: [
                'conditions' => $conditions,
                'orderBy'    => $orderBy,
                'direction'  => $direction,
                'limit'      => $limit,
                'offset'     => $offset,
                'exception'  => $exception,
            ]);
            throw $exception;
        }
    }

    // ===== Generalized Query Methods ===== //

    /**
     * @throws \Exception
     */
    public function save(object $entity) : void
    {
        $this->beforeSave(entity: $entity);

        $data = $this->mapToDatabase(entity: $entity);

        if (method_exists($entity, 'getId') && $entity->getId() !== null) {
            $this->queryBuilder
                ->where(column: 'id', operator: '=', value: $entity->getId())
                ->update(values: $data, conditions: []);
        } else {
            $id = $this->queryBuilder->getLastInsertIdAfterInsert($data);

            if (method_exists($entity, 'setId')) {
                $entity->setId($id);
            }
        }

        $this->afterSave(entity: $entity);
    }

    protected function beforeSave(object $entity) : void
    {
        // Placeholder for pre-save logic.
    }

    /**
     * Map an entity object to a database row.
     *
     * @param object $entity The entity to map.
     *
     * @return array<string, mixed> The database row representation.
     */
    abstract protected function mapToDatabase(object $entity) : array;

    protected function afterSave(object $entity) : void
    {
        // Placeholder for post-save logic.
    }

    // ===== Hooks ===== //

    /**
     * @throws \Exception
     */
    public function delete(object $entity) : void
    {
        if (! method_exists($entity, 'getId') || $entity->getId() === null) {
            throw new RuntimeException(message: "Entity must have an ID to be deleted.");
        }

        $this->queryBuilder
            ->where(column: 'id', operator: '=', value: $entity->getId())
            ->delete();
    }

    /**
     * Check if an entity exists by conditions.
     *
     * @param array<string, mixed> $conditions Conditions for filtering.
     *
     * @return bool True if the entity exists, false otherwise.
     * @throws \Exception
     * @throws \Exception
     */
    public function exists(array $conditions) : bool
    {
        try {
            $query = $this->queryBuilder;

            foreach ($conditions as $column => $value) {
                $query->where(column: $column, operator: '=', value: $value);
            }

            return $query->exists();
        } catch (Exception $exception) {
            $this->logError(message: 'Failed to check if entity exists.', context: [
                'conditions' => $conditions,
                'exception'  => $exception,
            ]);
            throw $exception;
        }
    }

    // ===== Error Logging ===== //

    /**
     * Count entities by conditions.
     *
     * @param array<string, mixed> $conditions Conditions for filtering.
     *
     * @return int The number of matching entities.
     * @throws \Exception
     * @throws \Exception
     */
    public function count(array $conditions) : int
    {
        try {
            $query = $this->queryBuilder;

            foreach ($conditions as $column => $value) {
                $query->where(column: $column, operator: '=', value: $value);
            }

            return $query->count(column: '*');
        } catch (Exception $exception) {
            $this->logError(message: 'Failed to count entities.', context: [
                'conditions' => $conditions,
                'exception'  => $exception,
            ]);
            throw $exception;
        }
    }
}

=== View/BladeTemplateEngine.php ===
<?php
/** @noinspection GlobalVariableUsageInspection */

declare(strict_types=1);

namespace Gemini\View;

use Jenssegers\Blade\Blade;
use Throwable;

class BladeTemplateEngine extends Blade
{
    public string $baseAssetPath;

    public function __construct(string $viewsPath, string $cachePath)
    {
        parent::__construct(viewPaths: $viewsPath, cachePath: $cachePath);
        $this->initializeBaseAssetPath();
        $this->configureCustomDirectives();
    }

    private function initializeBaseAssetPath() : void
    {
        // Define the base asset path dynamically
        $this->baseAssetPath = $this->getBaseUrl() . '/assets';
    }

    private function getBaseUrl() : string
    {
        $host   = $_SERVER['HTTP_HOST'] ?? 'localhost';
        $url    = parse_url((string) env('APP_URL', 'http://localhost'));
        $scheme = $url['scheme'] ?? 'http';

        return sprintf('%s://%s', $scheme, $host);
    }

    private function configureCustomDirectives() : void
    {
        // Asset directive
        $this->compiler()->directive(name: 'asset', handler: fn($expression) : string => sprintf(
            "<?php echo preg_match('/^public/', %s) ? '%s/' . ltrim(%s, '\"\\'/') : '%s/' . ltrim(%s, '\"\\'/'); ?>",
            $expression,
            $this->getBaseUrl(),
            $expression,
            $this->getBaseUrl(),
            $expression
        ));

        // Datetime directive
        $this->compiler()->directive(name: 'datetime', handler: static fn($expression) : string => sprintf(
            "<?php echo with(%s)->format('Y-m-d H:i:s'); ?>",
            $expression
        ));

        // CSRF directive
        $this->compiler()->directive(name: 'csrf', handler: static fn(
        ) : string => "<?php echo '<input type=\"hidden\" name=\"_token\" value=\"' . csrf_token() . '\">'; ?>");

        // Route directive
        $this->compiler()->directive(name: 'route', handler: static fn($expression) : string => sprintf(
            '<?php echo route(%s); ?>',
            $expression
        ));

        // Checked directive
        $this->compiler()->directive(name: 'checked', handler: static fn($expression) : string => sprintf(
            "<?php echo %s ? 'checked' : ''; ?>",
            $expression
        ));

        // Selected directive
        $this->compiler()->directive(name: 'selected', handler: static fn($expression) : string => sprintf(
            "<?php echo %s ? 'selected' : ''; ?>",
            $expression
        ));

        // Dump directive
        $this->compiler()->directive(
            name   : 'dump',
            handler: static fn($expression) : string => sprintf(
                '<?php var_dump(%s); ?>',
                $expression
            )
        );

        // Die and dump directive
        $this->compiler()->directive(name: 'dd', handler: static fn($expression) : string => sprintf(
            '<?php die(var_dump(%s)); ?>',
            $expression
        ));

        // Markdown directive
        $this->compiler()->directive(name: 'markdown', handler: static fn($expression) : string => sprintf(
            '<?php echo (new Parsedown())->text(%s); ?>',
            $expression
        ));

        // AuthFacadeService directives
        $this->compiler()->directive(name: 'auth', handler: static fn() : string => "<?php if (auth()->check()): ?>");

        $this->compiler()->directive(name: 'endauth', handler: static fn() : string => "<?php endif; ?>");

        $this->compiler()->directive(name: 'guest', handler: static fn() : string => "<?php if (!auth()->check()): ?>");

        $this->compiler()->directive(name: 'endguest', handler: static fn() : string => "<?php endif; ?>");

        // Environment directive
        $this->compiler()->directive(name: 'ifenv', handler: static fn($expression) : string => sprintf(
            "<?php if (config('cashback.env') === %s): ?>",
            $expression
        ));

        $this->compiler()->directive(name: 'endifenv', handler: static fn() : string => "<?php endif; ?>");

        // IncludeWhen directive
        $this->compiler()->directive(name: 'includeWhen', handler: static fn($expression) : string => sprintf(
            "<?php if (%s) { include '%s'; } ?>",
            $expression[0],
            $expression[1]
        ));

        // HTTP method directive
        $this->compiler()->directive(name: 'method', handler: static fn($expression) : string => sprintf(
            "<?php echo '<input type=\"hidden\" name=\"_method\" value=\"' . %s . '\">'; ?>",
            $expression
        ));
    }

    public function toHtml(string $view, array $data = []) : string
    {
        try {
            return $this->render($view, $data);
        } catch (Throwable $throwable) {
            logger('View rendering to html failed.', ['view' => $view, 'exception' => $throwable]);

            return "<div>View rendering error: " . $throwable->getMessage() . "</div>";
        }
    }
}

=== View/TemplateEngine.php ===
<?php

declare(strict_types=1);

/**
 * Extends BladeOne templating engine to incorporate custom directives and asset path management.
 *
 * This class not only serves as a thin wrapper around BladeOne but also integrates the base URL,
 * asset path configurations, and other custom directives, making it adaptable for different environments.
 */

namespace Gemini\View;

use eftec\bladeone\BladeOne;

class TemplateEngine extends BladeOne
{
    /**
     * The base URL for assets used in templating.
     */
    private string $baseAssetPath;

    /**
     * TemplateEngine constructor.
     *
     * @param string $templatePath The path to template files.
     * @param string $compiledPath The path where compiled templates are stored.
     * @param int    $mode         BladeOne mode (e.g., MODE_AUTO).
     *
     * @throws \Gemini\Container\Exceptions\FrameworkContainerException
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    public function __construct(
        string $templatePath,
        string $compiledPath,
        int    $mode = BladeOne::MODE_AUTO,
    ) {
        // Initialize the parent BladeOne class with provided paths and mode
        parent::__construct(
            templatePath: $templatePath,
            compiledPath: $compiledPath,
            mode        : $mode,
        );

        $this->initializeBaseAssetPath();
        $this->configureAssetDirective();
        $this->configureDateTimeDirective();
        $this->configureEnvironmentDirective();
        $this->configureMarkdownDirective();
        $this->configureRouteDirective();
        $this->configureCsrfDirective();
        $this->configureDumpDirective();
        $this->configureAuthDirectives();
        $this->configureIncludeWhenDirective();
        $this->configureMethodDirective();
        $this->configureCheckedDirective();
        $this->configureSelectedDirective();
    }

    /**
     * @throws \Gemini\Container\Exceptions\FrameworkContainerException
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    private function initializeBaseAssetPath() : void
    {
        // Retrieve the base URL and append the asset directory from configuration
        $this->baseAssetPath = $this->getBaseUrl() . config(key: 'views.assets');
    }

    /**
     * Determine the base URL considering HTTP/HTTPS and host.
     *
     * @return string The base URL.
     *
     * This method dynamically constructs the base URL making it flexible for different environments and protocols.
     */
    public function getBaseUrl() : string
    {
        $scheme = (! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https' : 'http';
        $host   = $_SERVER['HTTP_HOST'] ?? 'localhost';

        return sprintf('%s://%s', $scheme, $host);
    }

    /**
     * Configure a Blade directive for asset paths.
     *
     * This directive allows usage of @asset in Blade templates to reference assets relative to the base asset path.
     */
    private function configureAssetDirective() : void
    {
        $this->directive(
            name   : 'asset',
            handler: fn($expression) : string => sprintf(
                "<?php echo '%s/' . ltrim(%s, '\"\\'/'); ?>",
                $this->baseAssetPath,
                $expression
            ),
        );
    }

    /**
     * Configures a custom Blade directive for formatting DateTime objects.
     *
     * Allows templates to use a simple `@datetime` directive to format dates,
     * enhancing readability and consistency across templates.
     */
    private function configureDateTimeDirective() : void
    {
        $this->directive(
            name   : 'datetime',
            handler: static fn($expression) : string => sprintf(
                "<?php echo (new DateTime(%s))->format('Y-m-d H:i:s'); ?>",
                $expression
            ),
        );
    }

    /**
     * Configures custom Blade directives for environment-based conditional statements.
     *
     * Adds 'ifenv' and 'endifenv' directives for conditional content rendering based on
     * application's environment settings. Supports clean conditional checks in templates.
     */
    private function configureEnvironmentDirective() : void
    {
        $this->directive(
            name   : 'ifenv',
            handler: static fn($expression) : string => sprintf(
                "<?php if (config('cashback.env') === %s): ?>",
                $expression
            ),
        );
        $this->directive(
            name   : 'endifenv',
            handler: static fn() : string => "<?php endif; ?>",
        );
    }

    /**
     * Configures a custom Blade directive for handling Markdown within templates.
     *
     * This method defines the 'markdown' directive, which leverages the Parsedown library
     * to convert Markdown syntax into HTML. Allows easy embedding of Markdown content.
     */
    private function configureMarkdownDirective() : void
    {
        $this->directive(
            name   : 'markdown',
            handler: static fn($expression) : string => sprintf(
                '<?php echo (new Parsedown())->text(%s); ?>',
                $expression
            ),
        );
    }

    /**
     * Configures a directive for generating URL routes dynamically in templates.
     *
     * Allows usage of `@route` for clean URL generation within Blade templates,
     * enabling route-based link creation without hardcoding URLs.
     */
    private function configureRouteDirective() : void
    {
        $this->directive(
            name   : 'route',
            handler: static fn($expression) : string => sprintf('<?php echo route(%s); ?>', $expression),
        );
    }

    /**
     * Configures a Blade directive for generating CSRF tokens within forms.
     *
     * Enables easy addition of CSRF tokens via `@csrf` in form templates for security.
     */
    private function configureCsrfDirective() : void
    {
        $this->directive(
            name   : 'csrf',
            handler: static fn(
            ) : string => "<?php echo '<input type=\"hidden\" name=\"_token\" value=\"' . csrf_token() . '\">'; ?>",
        );
    }

    /**
     * Configures directives `@dump` and `@dd` for debugging.
     *
     * `@dump` outputs variable data; `@dd` outputs data and terminates script execution.
     * Useful for debugging variables within templates.
     */
    private function configureDumpDirective() : void
    {
        $this->directive(
            name   : 'dump',
            handler: static fn($expression) : string => sprintf('<?php var_dump(%s); ?>', $expression),
        );
        $this->directive(
            name   : 'dd',
            handler: static fn($expression) : string => sprintf('<?php die(var_dump(%s)); ?>', $expression),
        );
    }

    /**
     *
     */
    private function configureAuthDirectives() : void
    {
        $this->directive(
            name   : 'auth',
            handler: static fn() : string => "<?php if (auth()->check()): ?>",
        );
        $this->directive(
            name   : 'endauth',
            handler: static fn() : string => "<?php endif; ?>",
        );
        $this->directive(
            name   : 'guest',
            handler: static fn() : string => "<?php if (!auth()->check()): ?>",
        );
        $this->directive(
            name   : 'endguest',
            handler: static fn() : string => "<?php endif; ?>",
        );
    }

    /**
     * Configures the `@includeWhen` directive to conditionally include templates.
     *
     * `@includeWhen(condition, view)` includes a view template based on a condition.
     */
    private function configureIncludeWhenDirective() : void
    {
        $this->directive(
            name   : 'includeWhen',
            handler: static fn($expression) : string => sprintf(
                "<?php if (%s) { include '%s' ; } ?>",
                $expression[0],
                $expression[1]
            ),
        );
    }

    /**
     * Configures the `@method` directive for hidden HTTP method inputs in forms.
     *
     * Enables form support for HTTP methods like PUT and DELETE.
     */
    private function configureMethodDirective() : void
    {
        $this->directive(
            name   : 'method',
            handler: static fn(
                $expression,
            ) : string => sprintf(
                "<?php echo '<input type=\"hidden\" name=\"_method\" value=\"' . %s . '\">'; ?>",
                $expression
            ),
        );
    }

    /**
     * Configures the `@checked` directive to add `checked` attribute based on condition.
     *
     * Adds `checked` attribute to checkboxes or radio buttons conditionally.
     */
    private function configureCheckedDirective() : void
    {
        $this->directive(
            name   : 'checked',
            handler: static fn($expression) : string => sprintf("<?php echo %s ? 'checked' : ''; ?>", $expression),
        );
    }

    /**
     * Configures the `@selected` directive to add `selected` attribute based on condition.
     *
     * Adds `selected` attribute to dropdown options conditionally.
     */
    private function configureSelectedDirective() : void
    {
        $this->directive(
            name   : 'selected',
            handler: static fn($expression) : string => sprintf("<?php echo %s ? 'selected' : ''; ?>", $expression),
        );
    }
}

