=== Design/Column/Builder/ColumnAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Builder;

use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Represents an immutable value object for column metadata in database migrations.
 *
 * This class encapsulates database column attributes in a strongly-typed, immutable
 * structure, providing a clean interface for accessing column properties. It serves
 * as a read-only facade over the underlying ColumnAttributesDTO data.
 *
 * @property string                     $name
 * @property ColumnType                 $type
 * @property int|null                   $length
 * @property int|null                   $precision
 * @property int|null                   $scale
 * @property bool|null                  $nullable
 * @property bool|null                  $unsigned
 * @property bool|null                  $autoIncrement
 * @property bool|null                  $primary
 * @property bool|null                  $unique
 * @property string|int|float|bool|null $default
 * @property array<string>|null         $enum
 * @property string|null                $generated
 * @property string|null                $after
 * @property bool|null                  $useCurrent
 * @property bool|null                  $useCurrentOnUpdate
 * @property string|null                $alias
 * @property string|null                $comment
 * @property array<string, mixed>       $foreign
 * @property array<string, mixed>       $columns
 *
 * @final     This class is not designed for inheritance
 * @immutable This class represents an immutable value object
 * @pattern   Value Object - Encapsulates column attributes in an immutable structure
 */
final class ColumnAttributes
{
    /**
     * Stores the internal attribute collection extracted from the DTO.
     *
     * The properties array maintains a key-value mapping of all column attributes,
     * providing O(1) access time for attribute lookups while maintaining
     * encapsulation of the underlying data structure.
     *
     * @var array<string, mixed> Key-value pairs of column attributes
     */
    private array $properties;

    /**
     * Constructs a new immutable ColumnAttributes instance.
     *
     * Uses constructor property promotion for concise initialization
     * while maintaining clean code principles through explicit type declarations
     * and validation at instantiation.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column metadata
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $fromDto          = $this->dto;
        $this->properties = get_object_vars($fromDto);
    }

    /**
     * Creates a minimal column definition with essential attributes.
     *
     * Factory method implementing the named parameters pattern for improved
     * readability and maintainability. Provides a convenient way to create
     * basic column definitions without full DTO instantiation.
     *
     * @param string     $name The logical identifier for the column
     * @param ColumnType $type The SQL data type specification
     *
     * @return self New instance with minimal column configuration
     * @throws \ReflectionException When DTO instantiation fails
     */
    public static function make(
        string     $name,
        ColumnType $type
    ) : self {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Provides dynamic access to column attributes via property syntax.
     *
     * Implements magic getter following clean code principles by providing
     * clear error messages and type-safe access to internal properties.
     *
     * @param string $name The attribute name to retrieve
     *
     * @return mixed The value of the requested attribute
     * @throws RuntimeException When accessing undefined attributes
     */
    public function __get(string $name) : mixed
    {
        if (! array_key_exists($name, $this->properties)) {
            throw new RuntimeException(
                message: sprintf('Column attribute "%s" does not exist.', $name)
            );
        }

        return $this->properties[$name];
    }

    /**
     * Supports PHP's isset() and empty() operations on attributes.
     *
     * Provides a clean interface for attribute existence checking while
     * maintaining encapsulation of internal property storage.
     *
     * @param string $name The attribute name to check
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function __isset(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Explicitly verifies the existence of a column attribute.
     *
     * Provides a more semantic alternative to isset() for attribute checking,
     * following clean code principles with clear method naming.
     *
     * @param string $name The attribute name to verify
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function has(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Retrieves an attribute value with optional default fallback.
     *
     * Implements null coalescing operator for safe attribute access,
     * following defensive programming practices.
     *
     * @param string     $name    The attribute name to retrieve
     * @param mixed|null $default The fallback value if attribute doesn't exist
     *
     * @return mixed The attribute value or default
     */
    public function get(string $name, mixed $default = null) : mixed
    {
        return $this->properties[$name] ?? $default;
    }

    /**
     * Exports all column attributes as an associative array.
     *
     * Provides a clean interface for serialization while maintaining
     * immutability of the internal property collection.
     *
     * @return array<string, mixed> Complete map of column attributes
     */
    public function toArray() : array
    {
        return $this->properties;
    }
}

=== Design/Column/Column.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLDefaults;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Factory and macro layer for fluent column construction.
 *
 * Delegates schema building to ColumnDefinition while also exposing
 * DDD-safe shortcuts like `id()`, `timestamps()`, etc.
 *
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final readonly class Column
{
    use ColumnDSLDefaults;

    /**
     * Creates a ColumnDefinition via a DSL method call
     *
     * This method dynamically interprets the method name (e.g., `string`, `decimal`)
     * and maps it to an enum `ColumnType`, while applying appropriate DSL parameters.
     *
     * DSL-idiomatic:
     * - $table->string('name', 255)
     * - $table->decimal('price', 10, 2)
     * - $table->enum('type', ['free', 'paid'])
     *
     * @param string            $method    The column type method (e.g., 'string', 'decimal')
     * @param array<int, mixed> $arguments DSL arguments passed (name, length/precision/etc.)
     *
     * @return ColumnDefinition Returns a fully constructed column schema node
     *
     * @throws RuntimeException If the first argument (column name) is missing or invalid
     * @throws \ReflectionException
     */
    public function create(string $method, array $arguments) : ColumnDefinition
    {
        /**
         * Destructure the DSL arguments for clarity and DSL alignment.
         *
         * - $name: Column name (required)
         * - $size: Size, length, precision (optional)
         * - $details: Enum options or scale (optional)
         */
        [$name, $size, $details] = array_pad($arguments, 3, null);

        // Defensive: Fail early if column name is not provided
        if (empty($name) || ! is_string($name)) {
            throw new RuntimeException(message: "Missing or invalid column name for method: '{$method}'");
        }

        // Normalize method to ColumnType Enum (via alias support)
        $type = ColumnType::map(input: $method);

        // Dynamically collect any additional DSL parameters
        $attributes = match ($type) {
            ColumnType::VARCHAR,
            ColumnType::CHAR  => ['length' => $size ?? 255],

            ColumnType::DECIMAL,
            ColumnType::DOUBLE,
            ColumnType::FLOAT => [
                'precision' => $size ?? 10,
                'scale'     => $details ?? 2,
            ],

            ColumnType::ENUM,
            ColumnType::SET   => ['enum' => is_array($size) ? $size : []],

            default           => []
        };

        // Wrap all attributes in a strict, validated DTO
        $dto = new ColumnAttributesDTO(
            data: array_merge(
                      ['name' => $name, 'type' => $type],
                      $attributes
                  )
        );

        // Create immutable column node using named constructor
        return ColumnDefinition::make(
            name: $dto->name,
            type: $dto->type
        );
    }

}
=== Design/Column/DSL/ColumnDefinition.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLKeyConstraints;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLSemantics;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLTypeAttributes;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use InvalidArgumentException;

/**
 * Represents a fluent interface for defining database column schemas.
 *
 * This value object encapsulates the definition of a database column using a Domain-Specific Language (DSL)
 * approach. It implements the Builder pattern through a fluent interface, allowing for expressive
 * and type-safe column definitions.
 *
 * @package   Gemini\Database\Migration\Design\Column\DSL
 * @final     This class is not intended for extension
 * @immutable This class represents an immutable value object
 *
 *
 * ```php
 * $column = ColumnDefinition::make('user_id', ColumnType::INTEGER)
 *     ->unsigned()
 *     ->notNull()
 *     ->primary();
 * ```
 */
final class ColumnDefinition
{
    use ColumnDSLSemantics;
    use ColumnDSLKeyConstraints;
    use ColumnDSLTypeAttributes;

    /**
     * Encapsulates the internal state of the column definition.
     *
     * This property maintains the complete state of the column definition
     * through a dedicated value object, ensuring immutability and encapsulation
     * of the column attributes.
     *
     * @var ColumnAttributes
     */
    private ColumnAttributes $builder;

    /**
     * Initializes a new column definition instance.
     *
     * Constructs the column definition from a validated DTO containing
     * the essential column attributes. Uses constructor promotion for
     * clean and efficient initialization.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column attributes
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $this->builder = new ColumnAttributes(dto: $dto);
    }

    /**
     * Creates a new column definition using a fluent interface.
     *
     * Factory method implementing the Named Constructor pattern to provide
     * a more expressive way of creating column definitions.
     *
     * @param string     $name The logical name of the column
     * @param ColumnType $type The SQL data type for the column
     *
     * @return self New column definition instance
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public static function make(string $name, ColumnType $type) : self
    {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Renders the column definition as an SQL string.
     *
     * Delegates the actual rendering to a dedicated renderer class,
     * following the Single Responsibility Principle.
     *
     * @return string The complete SQL column definition
     */
    public function __toString() : string
    {
        return ColumnSQLRenderer::render(column: $this->getBuilder());
    }

    /**
     * Retrieves the internal column attributes builder.
     *
     * Provides access to the underlying value object containing
     * the complete column definition state.
     *
     * @return ColumnAttributes The immutable column attributes value object
     */
    public function getBuilder() : ColumnAttributes
    {
        return $this->builder;
    }

    /**
     * Gets the logical name of the column.
     *
     * Provides direct access to the column's identifier without
     * exposing the internal builder implementation.
     *
     * @return string The column's identifier
     */
    public function columnName() : string
    {
        return $this->builder->name;
    }

    /**
     * Modifies the column definition by adding or updating column specifications.
     *
     * This method implements the immutable modification pattern, creating a new
     * instance with updated column specifications while preserving the original
     * definition. It follows the immutability principle essential for maintaining
     * a predictable state in domain-driven design.
     *
     * @param array<string, mixed> $columns New column specifications to be applied
     *
     * @return self New instance with updated column specifications
     * @throws \ReflectionException When reflection fails during DTO construction
     */

    public function columns(array $columns) : self
    {
        if (empty($columns)) {
            throw new InvalidArgumentException(message: 'Column names array cannot be empty.');
        }

        $this->validateColumnNames($columns);

        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Validates the integrity of column names in a database schema definition.
     *
     * This method ensures that the provided column names meet the following criteria:
     * - Must be provided as a sequential array (list)
     * - Each element must be a non-empty string
     *
     * Part of the database schema validation layer that maintains data structure integrity.
     *
     * @param array<int, string> $columnNames Sequential array of column identifiers
     *
     * @throws InvalidArgumentException When validation fails due to invalid format or content
     */
    private function validateColumnNames(array $columnNames) : void
    {
        // Validate that the array is a sequential list and all elements are strings
        if (! array_is_list($columnNames)
            || array_filter($columnNames, static fn(mixed $column) : bool => ! is_string($column))
        ) {
            throw new InvalidArgumentException(
                message: 'All column names must be non-empty strings.'
            );
        }
    }
}
=== Design/Column/DSL/FluentModifiers/ColumnDSLDefaults.php ===
<?php

declare(strict_types=1);

/**
 * Domain-Specific Language (DSL) for Database Schema Design.
 *
 * This namespace encapsulates the column definition DSL components,
 * providing a fluent interface for database schema manipulation.
 */

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Domain-Specific Column Definition Defaults Trait.
 *
 * Provides a collection of standardized column definitions following Domain-Driven Design principles.
 * This trait encapsulates common database schema patterns, offering a semantic layer
 * above raw SQL definitions to express business domain concepts.
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 * @since   1.0.0
 */
trait ColumnDSLDefaults
{
    /**
     * Defines a standardized auto-incrementing primary key identifier.
     *
     * Implements the Identity Field pattern using a BIGINT type to ensure
     * sufficient capacity for large datasets. This follows the ubiquitous
     * language principle of DDD by providing a clear, domain-focused identifier.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function id() : ColumnDefinition
    {
        // Create a primary key column with auto-increment capability
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::BIGINT
        )
            ->primary()
            ->autoIncrement();
    }

    /**
     * Establishes temporal tracking for entity lifecycle events.
     *
     * Implements the Audit Trail pattern through timestamp columns that automatically
     * track entity creation and modification times. This supports both auditing
     * requirements and temporal queries within the domain.
     *
     * @return array{ColumnDefinition, ColumnDefinition} An array containing created_at and updated_at columns
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function timestamps() : array
    {
        // Define creation timestamp column
        $createdAt = ColumnDefinition::make(
            name: 'created_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Define update timestamp column
        $updatedAt = ColumnDefinition::make(
            name: 'updated_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Return both columns as a tuple
        return [
            $createdAt,
            $updatedAt,
        ];
    }

    /**
     * Implements the Soft Delete pattern for logical record deletion.
     *
     * Creates a nullable timestamp column that enables logical deletion without
     * a physical record removal, supporting data recovery and maintaining referential integrity.
     * This pattern is essential for maintaining audit trails and implementing undo operations.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function softDeletes() : ColumnDefinition
    {
        // Create a nullable timestamp column for soft deletes
        return ColumnDefinition::make(
            name: 'deleted_at',
            type: ColumnType::TIMESTAMP
        )->nullable();
    }

    /**
     * Establishes a UUID-based primary key for distributed systems.
     *
     * Implements a distributed-friendly primary key strategy using UUIDs,
     * enabling reliable unique identification across distributed systems
     * without central coordination. This pattern supports horizontal scaling
     * and microservices architecture.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function uuidPrimary() : ColumnDefinition
    {
        // Create a UUID-based primary key column
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::UUID
        )->primary();
    }

    /**
     * @throws \ReflectionException
     */
    public function char(string $name, int $length = 255) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::CHAR)
            ->length(length: $length);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function longText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::LONGTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function ipAddress(string $name = 'ip_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 45);
    }

    /**
     * @throws \ReflectionException
     */
    public function macAddress(string $name = 'mac_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 17);
    }

    /**
     * @throws \ReflectionException
     */
    public function vector(string $name, int $dimensions = 1536) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VECTOR)
            ->length(length: $dimensions);
    }

    /**
     * @throws \ReflectionException
     */
    public function geography(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::GEOGRAPHY);
    }
}
=== Design/Column/DSL/FluentModifiers/ColumnDSLKeyConstraints.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Enums\ReferentialAction;

/**
 * Trait ColumnDSLKeyConstraints
 *
 * Provides fluent methods for defining column-level constraints.
 * Applies strict immutability via DTO-based state mutation.
 */
trait ColumnDSLKeyConstraints
{
    /**
     * Shortcut for setting column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function pk() : ColumnDefinition
    {
        return $this->primary();
    }

    /**
     * Marks the column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function primary() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['primary' => true]);
    }

    /**
     * Shortcut for setting AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function inc() : ColumnDefinition
    {
        return $this->autoIncrement();
    }

    /**
     * Marks column as AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function autoIncrement() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['autoIncrement' => true]);
    }

    /**
     * Defines a FOREIGN KEY constraint
     *
     * @param string $references Referenced column
     * @param string $onTable    Target table
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function foreignKey(string $references, string $onTable) : ColumnDefinition
    {
        return $this->withModifiedAttributes(
            [
                'type'    => ColumnType::FOREIGN_KEY,
                'foreign' => [
                    'references' => $references,
                    'on'         => $onTable,
                ],
            ]
        );
    }

    /**
     * Sets ON DELETE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onDelete(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onDelete' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Sets ON UPDATE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onUpdate(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onUpdate' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Defines INDEX constraint
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::INDEX)
            ->columns($columns);
    }

    /**
     * Defines UNIQUE constraint
     *
     * @param string        $name    Constraint name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::UNIQUE)
            ->columns($columns);
    }

    /**
     * Defines FULLTEXT index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::FULLTEXT)
            ->columns($columns);
    }

    /**
     * Defines SPATIAL index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatial(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::SPATIAL)
            ->columns($columns);
    }
}

=== Design/Column/DSL/FluentModifiers/ColumnDSLSemantics.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use InvalidArgumentException;

/**
 * Trait ColumnDSLSemantics
 *
 * Domain-Specific Language (DSL) fluent modifiers for expressive schema definitions.
 *
 * Each method adheres to value object principles by avoiding direct mutation.
 * Instead, modifications are applied via a `withModifiedAttributes()` builder contract,
 * ensuring immutability and enabling composability of modifiers.
 *
 * @see     ColumnDefinition
 * @see     ColumnDefinition::withModifiedAttributes()
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 */
trait ColumnDSLSemantics
{
    /**
     * Defines an ENUM type column with a fixed set of string values.
     *
     * @param array<int, string> $values Acceptable string values for ENUM constraint
     *
     * @return ColumnDefinition New column instance with ENUM type
     *
     * @throws InvalidArgumentException When the $values array is empty
     * @throws \ReflectionException
     */
    public function enum(array $values) : ColumnDefinition
    {
        if (empty($values)) {
            throw new InvalidArgumentException(message: "Enum values cannot be empty.");
        }

        return $this->withModifiedAttributes(
            [
                'type' => ColumnType::ENUM,
                'enum' => $values,
            ]
        );
    }

    /**
     * Contract: Fluent modifier mutation through immutability contract.
     *
     * @param array<string, mixed> $attributes New values to apply to builder state
     *
     * @return ColumnDefinition Mutated copy with applied attributes
     */
    abstract protected function withModifiedAttributes(array $attributes) : ColumnDefinition;

    /**
     * Defines a STORED generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated and persisted
     *
     * @return ColumnDefinition New column with stored generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function storedAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) STORED"]);
    }

    /**
     * Defines a VIRTUAL generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated on read
     *
     * @return ColumnDefinition New column with virtual generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function virtualAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) VIRTUAL"]);
    }

    /**
     * Specifies the placement of the column relative to another column.
     *
     * @param string $column Name of the reference column
     *
     * @return ColumnDefinition Column with `AFTER` clause applied
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function after(string $column) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['after' => $column]);
    }

    /**
     * Sets the default value to CURRENT_TIMESTAMP for temporal columns.
     *
     * @return ColumnDefinition Column with default timestamp behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrent() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrent' => true]);
    }

    /**
     * Enables ON UPDATE CURRENT_TIMESTAMP behavior for automatic updates.
     *
     * @return ColumnDefinition Column with auto-update timestamp logic
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrentOnUpdate() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrentOnUpdate' => true]);
    }

    /**
     * Sets the compound index column list for multi-column indexes.
     *
     * @param array<int, string> $columns Array of column names to index together
     *
     * @return ColumnDefinition Column with compound index config
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function columns(array $columns) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Assigns an alias to the column for use in views or generated columns.
     *
     * @param string $name Alias identifier
     *
     * @return ColumnDefinition Column with alias assigned
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function alias(string $name) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['alias' => $name]);
    }

    /**
     * Attaches a comment to the column definition for metadata purposes.
     *
     * @param string $text SQL comment text
     *
     * @return ColumnDefinition Column with comment metadata
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function comment(string $text) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['comment' => $text]);
    }

    /**
     * Sets a default value to be applied during insert operations.
     *
     * @param string|int|float|bool|null $value Default value to apply
     *
     * @return ColumnDefinition Column with default constraint
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function default(string|int|float|bool|null $value) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['default' => $value]);
    }
}

=== Design/Column/DSL/FluentModifiers/ColumnDSLTypeAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use InvalidArgumentException;
use ReflectionException;

/**
 * Provides a fluent interface for column-type-specific attribute modifications.
 *
 * This trait encapsulates the type-specific modifiers for database column definitions,
 * implementing an immutable fluent interface pattern. It handles common column attributes
 * such as length, precision, scale, nullability, and unsigned specifications.
 *
 * @internal This trait is intended for internal use within the column definition system
 * @api      Exposes fluent interface methods for column type modifications
 *
 * @since    1.0.0
 */
trait ColumnDSLTypeAttributes
{
    /**
     * Defines the maximum length for character-based column types.
     *
     * Immutably creates a new column definition with the specified length attribute.
     * Commonly used for VARCHAR and CHAR column types.
     *
     * @param int<1, max> $length The maximum length of the column content
     *
     * @return ColumnDefinition A new immutable instance with the length attribute
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function length(int $length) : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['length' => $length]);
    }

    /**
     * Creates a new column definition with modified attributes.
     *
     * Internal helper method implementing the immutable modification pattern.
     * Clones the current state and applies new modifications to create a fresh instance.
     *
     * @param array<string, mixed> $modifiers Key-value pairs of attributes to modify
     *
     * @return ColumnDefinition A new immutable instance with applied modifications
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    protected function withModifiedAttributes(array $modifiers) : ColumnDefinition
    {
        // Extract current state as array
        $data = $this->getBuilder()->toArray();

        // Apply new modifications
        foreach ($modifiers as $key => $value) {
            $data[$key] = $value;
        }

        // Create a new immutable instance
        return new ColumnDefinition(dto: new ColumnAttributesDTO(data: $data));
    }

    /**
     * Configures precision and scale for decimal number columns.
     *
     * Creates a new column definition with specified numeric precision attributes.
     * Ensures proper relationship between precision and scale values.
     *
     * @param positive-int $precision Total number of significant digits
     * @param positive-int $scale     Number of digits after decimal point
     *
     * @return ColumnDefinition A new immutable instance with precision settings
     * @throws ReflectionException If reflection fails during DTO instantiation
     * @throws InvalidArgumentException If precision is less than scale
     */
    public function decimal(int $precision, int $scale) : ColumnDefinition
    {
        if ($precision < $scale) {
            throw new InvalidArgumentException(
                message: 'Precision must be greater than or equal to scale.'
            );
        }

        return $this->withModifiedAttributes(
            modifiers: [
                           'precision' => $precision,
                           'scale'     => $scale,
                       ]
        );
    }

    /**
     * Marks a numeric column as unsigned.
     *
     * Creates a new column definition with the unsigned flag set.
     * Applicable only to numeric column types.
     *
     * @return ColumnDefinition A new immutable instance marked as unsigned
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function unsigned() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['unsigned' => true]);
    }

    /**
     * Marks a column as nullable.
     *
     * Creates a new column definition that allows NULL values.
     * This is a schema-level nullability setting.
     *
     * @return ColumnDefinition A new immutable instance marked as nullable
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function nullable() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['nullable' => true]);
    }

    /**
     * Sets the precision (total number of digits) for numeric data types.
     *
     * This method follows the immutable modification pattern, creating a new instance
     * with the specified precision while preserving the original column definition.
     * Particularly useful for decimal, numeric, and floating-point data types.
     *
     * @param int $precision The total number of digits the column can store
     *
     * @return ColumnDefinition New immutable instance with updated precision
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function precision(int $precision) : ColumnDefinition
    {
        // Create new immutable instance with updated precision attribute
        return $this->withModifiedAttributes(['precision' => $precision]);
    }

    /**
     * Sets the scale (number of decimal places) for numeric data types.
     *
     * This method implements the immutable modification pattern, creating a new instance
     * with the specified scale while maintaining immutability. Essential for decimal
     * and numeric data types where decimal precision is required.
     *
     * @param int $scale The number of digits after the decimal point
     *
     * @return ColumnDefinition New immutable instance with updated scale
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function scale(int $scale) : ColumnDefinition
    {
        // Create a new immutable instance with updated scale attribute
        return $this->withModifiedAttributes(['scale' => $scale]);
    }

}
=== Design/Column/DTO/ColumnAttributesDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DTO;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Enum;
use Gemini\DataHandling\Validation\Attributes\Rules\Filled;

/**
 * Data Transfer Object representing database column attributes within the migration context.
 *
 * This immutable value object encapsulates the complete set of attributes that define
 * a database column's structure and behavior. It provides a type-safe way to transfer
 * column definitions between different layers of the application.
 *
 * @template-extends AbstractDTO<ColumnAttributesDTO>
 * @final
 */
final class ColumnAttributesDTO extends AbstractDTO
{
    /**
     * @var string The column identifier in the database schema
     */
    #[Filled]
    public string $name;

    /**
     * @var ColumnType The SQL data type of the column
     */
    #[Enum(ColumnType::class)]
    public ColumnType $type;

    /**
     * @var int|null The maximum length for string-based column types
     */
    public int|null $length = null;

    /**
     * @var int|null The total number of digits for numeric column types
     */
    public int|null $precision = null;

    /**
     * @var int|null The number of digits after the decimal point for numeric types
     */
    public int|null $scale = null;

    /**
     * @var bool|null Indicates if the column can contain NULL values
     */
    public bool|null $nullable = false;

    /**
     * @var bool|null Specifies if numeric column should be unsigned
     */
    public bool|null $unsigned = false;

    /**
     * @var bool|null Determines if column value should auto-increment
     */
    public bool|null $autoIncrement = false;

    /**
     * @var bool|null Indicates if column is part of primary key
     */
    public bool|null $primary = false;

    /**
     * @var bool|null Specifies if column values must be unique
     */
    public bool|null $unique = false;

    /**
     * @var string|int|float|bool|null Default value for the column
     */
    public string|int|float|bool|null $default = null;

    /**
     * @var array<string>|null Possible values for ENUM type columns
     */
    public array|null $enum = null;

    /**
     * @var string|null Expression for generated columns
     */
    public string|null $generated = null;

    /**
     * @var string|null Column name after which this column should be placed
     */
    public string|null $after = null;

    /**
     * @var bool|null Use current timestamp for temporal columns
     */
    public bool|null $useCurrent = false;

    /**
     * @var bool|null Update temporal columns on record modification
     */
    public bool|null $useCurrentOnUpdate = false;

    /**
     * @var string|null Alternative name for the column
     */
    public string|null $alias = null;

    /**
     * @var string|null Documentation or description for the column
     */
    public string|null $comment = null;

    /**
     * @var array<string, mixed> Foreign key relationship configuration
     */
    public array $foreign = [];

    /**
     * @var array<string, mixed> Nested column definitions for complex types
     */
    public array $columns = [];
}
=== Design/Column/Enums/ColumnType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Enum representing standardized SQL column types.
 *
 * Provides type-safe mapping to SQL-compatible type strings.
 * Improves reliability and prevents typos in column definitions.
 */
enum ColumnType: string
{
    /**
     * Uses the SupportsCaseMappedEnum trait to enable case-insensitive enum value mapping with alias support.
     *
     * This trait provides functionality for mapping string inputs to enum cases in a case-insensitive manner,
     * with support for custom aliases. It's particularly useful in Domain-Driven Design (DDD) when working
     * with value objects and enums that need flexible input handling.
     *
     * @template-implements SupportsCaseMappedEnum<static>
     *
     * @see   BackedEnum For backed enum compatibility
     * @since 8.3.0
     */
    use SupportsCaseMappedEnum;

    /**
     * Standard 4-byte integer type supporting values from -2^31 to 2^31-1
     */
    case INT = 'INT';

    /**
     * Represents an INTEGER column type in the database schema.
     *
     * This type is used for storing whole numbers without decimal points.
     * Typically used for primary keys, foreign keys, and numerical data that
     * doesn't require decimal precision.
     *
     * @var string
     * @since 1.0.0
     * @immutable
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::isNumeric()
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::requiresLength()
     */
    case INTEGER = 'INTEGER';

    /**
     * Large 8-byte integer type supporting values from -2^63 to 2^63-1
     */
    case BIGINT = 'BIGINT';

    /**
     * Small 2-byte integer type supporting values from -32,768 to 32,767
     */
    case SMALLINT = 'SMALLINT';

    /**
     * Medium 3-byte integer type supporting values from -8,388,608 to 8,388,607
     */
    case MEDIUMINT = 'MEDIUMINT';

    /**
     * Tiny 1-byte integer type supporting values from -128 to 127
     */
    case TINYINT = 'TINYINT';

    /**
     * Fixed-point decimal number with configurable precision and scale
     */
    case DECIMAL = 'DECIMAL';

    /**
     * Single-precision floating-point number (4 bytes)
     */
    case FLOAT = 'FLOAT';

    /**
     * Double-precision floating-point number (8 bytes)
     */
    case DOUBLE = 'DOUBLE';

    /**
     * Variable-length string type with a maximum length specification
     */
    case VARCHAR = 'VARCHAR';

    /**
     * Fixed-length string type, padded with spaces to specified length
     */
    case CHAR = 'CHAR';

    /**
     * Variable-length text type with a maximum size of 65,535 bytes
     */
    case TEXT = 'TEXT';

    /**
     * Variable-length text type with maximum size of 4GB
     */
    case LONGTEXT = 'LONGTEXT';

    /**
     * Variable-length text type with maximum size of 16MB
     */
    case MEDIUMTEXT = 'MEDIUMTEXT';

    /**
     * Variable-length text type with maximum size of 255 bytes
     */
    case TINYTEXT = 'TINYTEXT';

    /**
     * Date type storing year, month, and day
     */
    case DATE = 'DATE';

    /**
     * Date and time type with microsecond precision
     */
    case DATETIME = 'DATETIME';

    /**
     * Timestamp type for tracking record modifications
     */
    case TIMESTAMP = 'TIMESTAMP';

    /**
     * Time type storing hours, minutes, seconds
     */
    case TIME = 'TIME';

    /**
     * Year type storing values from 1901 to 2155
     */
    case YEAR = 'YEAR';

    /**
     * JSON document type with validation and indexing capabilities
     */
    case JSON = 'JSON';

    /**
     * Binary JSON type optimized for indexing and querying
     */
    case JSONB = 'JSONB';

    /**
     * Binary large object type for storing binary data
     */
    case BLOB = 'BLOB';

    /**
     * Enumerated type with predefined set of valid values
     */
    case ENUM = 'ENUM';

    /**
     * Set type allowing multiple values from predefined options
     */
    case SET = 'SET';

    /**
     * Vector type for AI/ML applications and similarity searches
     */
    case VECTOR = 'VECTOR';

    /**
     * Geographic spatial data type for location-based features
     */
    case GEOGRAPHY = 'GEOGRAPHY';

    /**
     * UUID type for globally unique identifiers (36 chars)
     */
    case UUID = 'UUID';

    /**
     * ULID type for sortable unique identifiers (26 chars)
     */
    case ULID = 'ULID';

    /**
     * Boolean type typically implemented as TINYINT(1)
     */
    case BOOLEAN = 'BOOLEAN';

    /**
     * Foreign key constraint type for referential integrity
     */
    case FOREIGN_KEY = 'FOREIGN KEY';

    /**
     * Standard index type for query optimization
     */
    case INDEX = 'INDEX';

    /**
     * Unique constraint index type ensuring value uniqueness
     */
    case UNIQUE = 'UNIQUE';

    /**
     * Full-text search index type for text search optimization
     */
    case FULLTEXT = 'FULLTEXT';

    /**
     * Spatial index type for geographic data queries
     */
    case SPATIAL = 'SPATIAL';

    /**
     * Resolves a ColumnType enum from a DSL method name.
     *
     * @param string $method The DSL method name (e.g., 'string', 'text', 'uuid')
     *
     * @return self The corresponding ColumnType enum
     *
     * @throws \InvalidArgumentException If the method is not recognized
     */
    public static function fromDslMethod(string $method) : self
    {
        return self::map(input: $method);
    }


    /**
     * Returns a mapping of DSL (Domain-Specific Language) column type aliases to their corresponding database types.
     * This method establishes a unified type system across the domain model and persistence layer.
     *
     * @return array<string, string> Associative array mapping DSL type aliases to concrete database column types
     */
    public static function dslAliases() : array
    {
        // String-based column type mappings
        return [
            // Standard string variations for flexible text storage
            'string'     => self::VARCHAR,    // Variable-length character string, default choice for text
            'varchar'    => self::VARCHAR,    // Alternative notation for VARCHAR type
            'char'       => self::CHAR,       // Fixed-length character string

            // Text storage variations with different capacity limits
            'text'       => self::TEXT,       // Standard text type for larger string storage
            'longText'   => self::LONGTEXT,   // Maximum capacity text storage
            'mediumText' => self::MEDIUMTEXT, // Medium capacity text storage
            'tinyText'   => self::TINYTEXT,   // Minimal capacity text storage

            // Unique identifier types
            'uuid'       => self::UUID,       // Universally Unique Identifier (128-bit)
            'ulid'       => self::ULID,       // Universally Unique Lexicographically Sortable Identifier

            // JSON data types
            'json'       => self::JSON,       // Standard JSON storage type
            'jsonb'      => self::JSONB,      // Binary JSON storage (PostgreSQL specific)

            // Integer-based numeric types
            'int'        => self::INTEGER,    // Standard integer type
            'integer'    => self::INTEGER,    // Alternative notation for INTEGER
            'bigint'     => self::BIGINT,     // Large-range integer type
            'smallint'   => self::SMALLINT,   // Small-range integer type
            'tinyint'    => self::TINYINT,    // Minimal-range integer type

            // Decimal number types
            'decimal'    => self::DECIMAL,    // Exact decimal number type
            'float'      => self::FLOAT,      // Floating-point number type
            'double'     => self::DOUBLE,     // Double precision floating-point type

            // Boolean type aliases
            'boolean'    => self::BOOLEAN,    // Standard boolean type
            'bool'       => self::BOOLEAN,    // Alternative notation for BOOLEAN

            // Date and time types
            'date'       => self::DATE,       // Date storage without time
            'datetime'   => self::DATETIME,   // Combined date and time storage
            'timestamp'  => self::TIMESTAMP,  // Timestamp with timezone awareness
            'time'       => self::TIME,       // Time storage without date
            'year'       => self::YEAR,       // Year storage only
        ];
    }

    /**
     * Returns only the raw SQL type string for this column, without metadata.
     *
     * Useful for quick compatibility checks, logging, or fallback rendering.
     *
     * Delegates to toSqlTypeDefinition() and extracts the base SQL type.
     *
     * @return string SQL-compatible column type name (e.g., "CHAR", "TINYINT")
     */
    public function toSqlType() : string
    {
        return $this->toSqlTypeDefinition()->type;
    }

    /**
     * Returns the physical SQL type representation for the current ColumnType,
     * including fixed-length or precision information when relevant.
     *
     * This is critical for type-safe schema generation (e.g. CHAR(36) for UUID).
     *
     * @return SqlTypeDefinition Full SQL type contract with constraints
     */
    public function toSqlTypeDefinition() : SqlTypeDefinition
    {
        return match ($this) {
            self::UUID    => new SqlTypeDefinition(type: 'CHAR', length: 36),
            self::ULID    => new SqlTypeDefinition(type: 'CHAR', length: 26),
            self::BOOLEAN => new SqlTypeDefinition(type: 'TINYINT', length: 1),
            self::VARCHAR => new SqlTypeDefinition(type: 'VARCHAR', length: 255),
            self::CHAR    => new SqlTypeDefinition(type: 'CHAR', length: 255),
            self::DECIMAL => new SqlTypeDefinition(type: 'DECIMAL', precision: 10, scale: 2),
            self::FLOAT,
            self::DOUBLE  => new SqlTypeDefinition(type: $this->value, precision: 10, scale: 2),
            default       => new SqlTypeDefinition(type: $this->value),
        };
    }

    /**
     * Determines whether the current column type represents an index type.
     *
     * @return bool True if the type is an index type, false otherwise
     */
    public function isIndex() : bool
    {
        return match ($this) {
            self::INDEX,
            self::UNIQUE,
            self::FULLTEXT,
            self::SPATIAL => true,
            default       => false,
        };
    }

    /**
     * Determines whether the column type requires a length specification.
     *
     * @return bool True if length is required, false otherwise
     */
    public function requiresLength() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::UUID,
            self::ULID,
            self::VECTOR => true,
            default      => false,
        };
    }

    /**
     * Determines if the column type supports precision and scale parameters.
     *
     * @return bool True if precision/scale are supported, false otherwise
     */
    public function supportsPrecision() : bool
    {
        return match ($this) {
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Indicates whether the column type is temporal (timestamp/datetime/etc).
     *
     * @return bool
     */
    public function isTemporal() : bool
    {
        return match ($this) {
            self::TIMESTAMP,
            self::DATETIME,
            self::DATE,
            self::TIME,
            self::YEAR => true,
            default    => false,
        };
    }

    /**
     * Determines if the type is string-compatible.
     *
     * @return bool
     */
    public function isString() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::TEXT,
            self::LONGTEXT,
            self::MEDIUMTEXT,
            self::TINYTEXT,
            self::UUID,
            self::ULID => true,
            default    => false,
        };
    }

    /**
     * Returns the default length for types that require it.
     *
     * @return int|null Default length or null
     */
    public function defaultLength() : int|null
    {
        return match ($this) {
            self::UUID    => 36,
            self::ULID    => 26,
            self::CHAR,
            self::VARCHAR => 255,
            self::VECTOR  => 1536,
            default       => null,
        };
    }

    /**
     * Determines if the type is numeric.
     *
     * @return bool True if numeric
     */
    public function isNumeric() : bool
    {
        return match ($this) {
            self::INT,
            self::BIGINT,
            self::SMALLINT,
            self::MEDIUMINT,
            self::TINYINT,
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Retrieves the primary DSL method alias for the current schema type.
     *
     * This method returns the first (most preferred) method name from the available
     * DSL method aliases. It's particularly useful in fluent schema definitions
     * where a consistent primary method name is required.
     *
     * @return string The primary DSL method alias for the current schema type
     * @see   preferredDslMethods() For the complete list of available DSL method aliases
     * @since 8.3
     */
    public function getPreferredAlias() : string
    {
        // Retrieve the first (primary) DSL method alias from the available methods
        return $this->preferredDslMethods()[0];
    }

    /**
     * Reverse map to prefer DSL-friendly names (e.g. use `string()` instead of `varchar()`).
     * Returns an array of preferred DSL (Domain Specific Language) method names for the current field type.
     *
     * This method maps enumeration cases to their corresponding fluent schema builder methods,
     * facilitating a more expressive and domain-driven database schema definition.
     *
     * @return array<int, string> Array of method names available for this field type
     * @throws never
     * @api
     * @since 1.0.0
     */
    public function preferredDslMethods() : array
    {
        // Match expression provides exhaustive type mapping for schema builder methods
        return match ($this) {
            // Maps VARCHAR type to both 'string' and 'varchar' method names for flexibility
            self::VARCHAR  => ['string', 'varchar'],

            // Boolean type supports both full and short method names
            self::BOOLEAN  => ['boolean', 'bool'],

            // Integer type supports both full and short method names
            self::INTEGER  => ['integer', 'int'],

            // Text type maps to the 'text' schema builder method
            self::TEXT     => ['text'],

            // LongText type maps to the camelCase 'longText' method
            self::LONGTEXT => ['longText'],

            // Char type maps directly to the 'char' method
            self::CHAR     => ['char'],

            // Enum type maps to the 'enum' schema builder method
            self::ENUM     => ['enum'],

            // Fallback for any undefined types, converts enum case name to lowercase
            default        => [strtolower($this->name)],
        };
    }
}

=== Design/Column/Enums/ReferentialAction.php ===
<?php

/**
 * ReferentialAction Enum for Database Foreign Key Constraints
 *
 * This enum defines the possible actions that can be taken when a referenced
 * record is deleted or updated in a foreign key relationship.
 *
 * @package Gemini\Database\Migration\Table\Column
 * @since   1.0.0
 * @immutable
 */
declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

enum ReferentialAction: string
{
    /**
     * Automatically delete or update related records when the referenced record is deleted/updated
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Set the foreign key column value to NULL when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Prevent deletion/update of referenced record if it has related records
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Similar to RESTRICT, prevents changes that would violate referential integrity
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Set the foreign key column to its default value when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_DEFAULT = 'SET DEFAULT';
}
=== Design/Column/Enums/SqlTypeDefinition.php ===
<?php

/**
 * Strict type declaration for enhanced type safety and better performance.
 */
declare(strict_types=1);

/**
 * Namespace declaration following PSR-4 autoloading standards.
 * Contains value objects related to SQL column type definitions in the migration context.
 */

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Represents an immutable Value Object encapsulating SQL column type definition parameters.
 *
 * This class follows Domain-Driven Design principles by representing a concept from
 * the ubiquitous language of database schema design. It is marked as final to prevent
 * inheritance and ensure immutability through the readonly modifier.
 *
 * @package Gemini\Database\Migration\Design\Column\Enums
 * @final
 * @readonly
 */
final readonly class SqlTypeDefinition
{
    /**
     * Constructs a new SQL type definition with its associated parameters.
     *
     * Uses constructor property promotion for concise and expressive initialization
     * of the value object's properties.
     *
     * @param string   $type      The SQL data type identifier (e.g., 'VARCHAR', 'DECIMAL')
     * @param int|null $length    Optional length parameter for types that support it (e.g., VARCHAR(255))
     * @param int|null $precision Optional precision for numeric types (total number of significant digits)
     * @param int|null $scale     Optional scale for numeric types (number of digits after decimal point)
     */
    public function __construct(
        public string   $type,
        public int|null $length = null,
        public int|null $precision = null,
        public int|null $scale = null,
    ) {}
}
=== Design/Column/Enums/SupportsCaseMappedEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

use BackedEnum;
use LogicException;
use ValueError;

/**
 * A trait that provides sophisticated case-mapped enum support with DSL capabilities.
 *
 * This trait enhances backed enums with case-insensitive mapping functionality,
 * supporting both direct enum value/name matching and custom DSL aliases.
 *
 * @template T of BackedEnum
 *
 * @author AI Assistant <ai@example.com>
 * @since  1.0.0
 */
trait SupportsCaseMappedEnum
{
    /**
     * Error message for empty or whitespace-only input validation.
     *
     * @var string Constant representing the error message for empty input scenarios
     */
    private const string ERROR_EMPTY_INPUT = "Enum mapping input cannot be empty or whitespace.";

    /**
     * Error message template for invalid alias mapping scenarios.
     *
     * @var string Constant representing the error message for invalid alias configurations
     */
    private const string ERROR_INVALID_ALIAS = 'Invalid alias mapping for "%s". Expected instance of %s, got %s.';

    /**
     * Error message template for unmatched enum cases.
     *
     * @var string Constant representing the error message when no matching enum case is found
     */
    private const string ERROR_NO_MATCH = 'No matching enum case found for "%s". Valid inputs: [%s]';

    /**
     * Determines if the provided input string can be mapped to an enum case.
     *
     * @param string $input The input string to validate for mapping possibility
     *
     * @return bool True if mapping is possible, false otherwise
     */
    public static function canMap(string $input) : bool
    {
        return static::tryMap(input: $input) !== null;
    }

    /**
     * Attempts to map the input string to an enum case, returning null on failure.
     *
     * @param string $input The input string to attempt mapping
     *
     * @return static|null The mapped enum case or null if mapping fails
     */
    public static function tryMap(string $input) : static|null
    {
        try {
            return static::map(input: $input);
        } catch (ValueError) {
            return null;
        }
    }

    /**
     * Maps the input string to an enum case or throws an exception on failure.
     *
     * @param string $input The input string to map to an enum case
     *
     * @return static The successfully mapped enum case
     * @throws ValueError When mapping fails or input is invalid
     */
    public static function map(string $input) : static
    {
        // Validate input for emptiness
        if (trim($input) === '') {
            throw new ValueError(message: self::ERROR_EMPTY_INPUT);
        }

        // Normalize input for case-insensitive comparison
        $normalized = strtolower($input);

        // Attempt to find a match through various strategies
        $matchedCase = self::findMatchInAliases($normalized)
                       ?? self::findMatchByValue($normalized)
                          ?? self::findMatchByName($normalized);

        if ($matchedCase !== null) {
            return $matchedCase;
        }

        // No match found, throw detailed exception
        throw new ValueError(
            message: sprintf(
                         self::ERROR_NO_MATCH,
                         $input,
                         self::getValidInputsString($normalized)
                     )
        );
    }

    /**
     * Attempts to find a matching enum case through configured aliases.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     * @throws LogicException When alias mapping is invalid
     */
    private static function findMatchInAliases(string $normalized) : static|null
    {
        // Check if DSL aliases are supported
        if (! method_exists(static::class, 'dslAliases')) {
            return null;
        }

        $aliases = static::dslAliases();

        // Check if normalized input exists in aliases
        if (! array_key_exists($normalized, $aliases)) {
            return null;
        }

        $aliasTarget = $aliases[$normalized];

        // Validate alias target type
        if (! ($aliasTarget instanceof static)) {
            throw new LogicException(
                message: sprintf(
                             self::ERROR_INVALID_ALIAS,
                             $normalized,
                             static::class,
                             get_debug_type($aliasTarget)
                         )
            );
        }

        return $aliasTarget;
    }

    /**
     * Provides DSL aliases for enum cases. Override this method to define custom mappings.
     *
     * @return array<string, static> Array of alias => enum case mappings
     */
    protected static function dslAliases() : array
    {
        return [];
    }

    /**
     * Attempts to find a matching enum case by its value.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByValue(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->value) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Attempts to find a matching enum case by its name.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByName(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->name) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Generates a string of all valid input values for error messaging.
     *
     * @param string $normalized The normalized input string (unused but kept for consistency)
     *
     * @return string Comma-separated list of valid inputs
     */
    protected static function getValidInputsString(string $normalized) : string
    {
        $cases   = static::cases();
        $aliases = method_exists(static::class, 'dslAliases') ? static::dslAliases() : [];

        $valid = array_merge(
            array_keys($aliases),
            array_map(static fn($c) => strtolower($c->value), $cases),
            array_map(static fn($c) => strtolower($c->name), $cases)
        );

        return implode(', ', array_unique($valid));
    }
}
=== Design/Column/Renderer/ColumnDSLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;

/**
 * Renders column definitions into Gemini migration DSL format.
 *
 * This final class is responsible for converting column attributes into
 * syntactically correct Laravel migration method chains. It follows DDD principles
 * by encapsulating all column DSL rendering logic in a dedicated service.
 *
 * @final
 */
final class ColumnDSLRenderer
{
    /**
     * Formats column attributes into a Laravel migration DSL string.
     *
     * This method transforms the domain model (ColumnAttributes) into a valid
     * Laravel migration method chain, handling type-specific formatting,
     * modifiers, and defaults according to Laravel's schema builder syntax.
     *
     * @param ColumnAttributes $column The column attributes to format
     *
     * @return string The formatted Laravel migration DSL statement
     */
    public function format(ColumnAttributes $column) : string
    {
        // Retrieves the preferred Domain-Specific Language (DSL) method mapping for the column type.
        $type = $column->type->getPreferredAlias();

        // Prepare base arguments starting with the column name
        $args = [$column->name];

        // Add length parameter for string-based column types
        if ($column->type->requiresLength() && $column->length !== null) {
            $args[] = $column->length;
        }

        // Add precision and scale for numeric types
        if ($column->type->supportsPrecision()) {
            $args[] = $column->precision ?? 10; // Default precision if isn't specified
            $args[] = $column->scale ?? 2;      // Default scale if isn't specified
        }

        // Construct the base column definition
        $dsl = sprintf(
            '$table->%s(%s)',
            $type,
            implode(', ', array_map(static fn($a) => var_export($a, true), $args))
        );

        // Define available column modifiers with their corresponding method names
        $modifiers = [
            'nullable'           => 'nullable',
            'unsigned'           => 'unsigned',
            'autoIncrement'      => 'autoIncrement',
            'primary'            => 'primary',
            'unique'             => 'unique',
            'useCurrent'         => 'useCurrent',
            'useCurrentOnUpdate' => 'useCurrentOnUpdate',
        ];

        // Apply modifiers if their corresponding attributes are true
        foreach ($modifiers as $attr => $method) {
            if ($column->{$attr} === true) {
                $dsl .= "->{$method}()";
            }
        }

        // Add default value if specified
        if ($column->default !== null) {
            $escaped = is_string($column->default) ? "'{$column->default}'" : var_export($column->default, true);
            $dsl     .= "->default({$escaped})";
        }

        // Terminate the statement with semicolon
        return $dsl . ';';
    }
}
=== Design/Column/Renderer/ColumnSQLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

final class ColumnSQLRenderer
{
    /**
     * Static entrypoint for rendering a column definition.
     *
     * @param ColumnAttributes $column The column to render
     *
     * @return string SQL representation of the column
     */
    public static function render(ColumnAttributes $column) : string
    {
        return (new self())->format($column);
    }

    public function format(ColumnAttributes $column) : string
    {
        return match (true) {
            $column->type === ColumnType::FOREIGN_KEY => $this->buildForeignKey($column),
            $column->type->isIndex()                  => $this->buildIndex($column),
            default                                   => $this->buildColumn($column),
        };
    }

    private function buildForeignKey(ColumnAttributes $c) : string
    {
        $sql = sprintf(
            'FOREIGN KEY (`%s`) REFERENCES `%s`(`%s`)',
            $c->name,
            $c->foreign['on'] ?? 'unknown_table',
            $c->foreign['references'] ?? 'id'
        );

        if (! empty($c->foreign['onDelete'])) {
            $sql .= ' ON DELETE ' . $c->foreign['onDelete'];
        }

        if (! empty($c->foreign['onUpdate'])) {
            $sql .= ' ON UPDATE ' . $c->foreign['onUpdate'];
        }

        return $sql;
    }

    private function buildIndex(ColumnAttributes $c) : string
    {
        return strtoupper($c->type->toSqlType()) . " `{$c->name}` (" . implode(', ', $c->columns) . ")";
    }

    private function buildColumn(ColumnAttributes $c) : string
    {
        $sql = "`{$c->name}` " . $this->typeDeclaration($c);

        $sql .= $c->unsigned ? ' UNSIGNED' : '';
        $sql .= $c->nullable ? ' NULL' : ' NOT NULL';
        $sql .= $this->defaultClause($c);
        $sql .= $c->autoIncrement ? ' AUTO_INCREMENT' : '';
        $sql .= $c->unique ? ' UNIQUE' : '';
        $sql .= $c->primary ? ' PRIMARY KEY' : '';
        $sql .= $c->generated ? " {$c->generated}" : '';
        $sql .= $c->after ? " AFTER `{$c->after}`" : '';
        $sql .= $c->alias !== null ? " AS `{$c->alias}`" : '';

        return trim($sql);
    }

    private function typeDeclaration(ColumnAttributes $c) : string
    {
        if ($c->type === ColumnType::ENUM && $c->enum !== null) {
            $quoted = array_map(static fn(string $v) : string => "'{$v}'", $c->enum);

            return 'ENUM(' . implode(', ', $quoted) . ')';
        }

        return match (true) {
            $c->type === ColumnType::DECIMAL                  =>
                "DECIMAL(" . ($c->precision ?? 8) . ", " . ($c->scale ?? 2) . ")",
            $c->type->requiresLength() && $c->length !== null =>
                $c->type->toSqlType() . "({$c->length})",
            default                                           => $c->type->toSqlType(),
        };
    }

    private function defaultClause(ColumnAttributes $c) : string
    {
        if ($c->default !== null) {
            $escaped = match (true) {
                is_string($c->default) => "'{$c->default}'",
                $c->default === true   => '1',
                $c->default === false  => '0',
                default                => $c->default
            };

            return " DEFAULT {$escaped}";
        }

        if ($c->useCurrent) {
            return ' DEFAULT CURRENT_TIMESTAMP';
        }

        return '';
    }
}

=== Design/Mapper/FieldToDslMapperInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;

/**
 * Defines the contract for mapping field data transfer objects to database schema DSL.
 *
 * This interface is part of the database migration domain and implements the Strategy pattern,
 * allowing for flexible field-to-DSL mapping strategies. It serves as a crucial component
 * in translating field definitions into concrete database schema specifications.
 *
 * Key responsibilities:
 * - Translates FieldDTO objects into table schema modifications
 * - Ensures consistent field mapping across different database platforms
 * - Maintains single responsibility principle for field transformation logic
 *
 * @package Gemini\Database\Migration\Design\Mapper
 * @since   8.3.0
 */
interface FieldToDslMapperInterface
{
    /**
     * Applies the field mapping strategy to transform a FieldDTO into table schema modifications.
     *
     * This method implements the core mapping logic, taking a table instance and field DTO
     * as input and applying the necessary schema modifications through the table's DSL.
     *
     * @param Table    $table The target table to apply the field mapping to
     * @param FieldDTO $field The field data transfer object containing the field definition
     *
     * @return void
     *
     * @throws \InvalidArgumentException If the field definition is invalid
     * @throws \RuntimeException If the mapping operation fails
     */
    public function apply(Table $table, FieldDTO $field) : void;
}
=== Design/Mapper/FluentFieldToDslMapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;
use Throwable;

/**
 * FluentFieldToDslMapper
 *
 * Maps FieldDTO objects into fluent Table DSL declarations.
 * Applies type-based factory calls (e.g. string, decimal) and fluent modifiers.
 *
 * @final
 */
final class FluentFieldToDslMapper implements FieldToDslMapperInterface
{
    /**
     * Applies a single field definition to the DSL Table blueprint.
     *
     * Dynamically dispatches column creation using the fluent method name,
     * applies type-based arguments (length, precision, scale),
     * and chains additional modifiers (nullable, unique, etc.).
     *
     * @param Table    $table
     * @param FieldDTO $field
     *
     * @return void
     *
     * @throws RuntimeException
     */
    public function apply(Table $table, FieldDTO $field) : void
    {
        try {
            $typeEnum   = ColumnType::map($field->type->value);
            $typeMethod = strtolower($typeEnum->name);

            // 🔥 Build args from DTO
            $args = match ($typeEnum) {
                ColumnType::VARCHAR, ColumnType::CHAR                      =>
                [$field->name, $field->length ?? 255],

                ColumnType::DECIMAL, ColumnType::FLOAT, ColumnType::DOUBLE =>
                [$field->name, $field->total ?? 10, $field->places ?? 2],

                ColumnType::ENUM, ColumnType::SET                          =>
                [$field->name, $field->enum ?? []],

                default                                                    =>
                [$field->name],
            };

            // 🧠 Fluent DSL: $table->string('name', 255)
            $column = $table->{$typeMethod}(...$args);
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : sprintf("Column creation failed for method '%s': %s", $field->type->value, $e->getMessage()),
                previous: $e
            );
        }

        /**
         * This code:
         *
         * Applies DSL-defined column modifiers (attributes) in a fluent chain.
         *
         * This loop dynamically applies method-based modifiers such as `nullable()`, `unsigned()`, `primary()`, etc.
         * to the column instance based on the `$field->attributes` array. Each attribute string is expected to
         * correspond to a fluent method on the column object (e.g., `->nullable()`).
         *
         * After each modifier is applied, the updated column instance is re-registered into the `$table`
         * using `replaceColumn()` to maintain schema consistency. This ensures that the internal
         * table column registry reflects the updated column definition after each transformation.
         *
         * This explicit re-registration is crucial for systems where:
         *  - Column definitions are stored immutably
         *  - Table maintains internal references to column snapshots
         *  - Modifiers mutate via clone or return new objects (not in-place)
         *
         */

        foreach ($field->attributes ?? [] as $modifier) {
            if (! method_exists($column, $modifier)) {
                throw new RuntimeException(
                    message: sprintf("Column modifier '%s' is not defined on column type '%s'.", $modifier, $typeMethod)
                );
            }

            // Dynamically invoke fluent modifier (e.g. ->nullable(), ->primary(), etc.)
            $column = $column->{$modifier}();

            // Re-register the mutated column in the table schema registry
            $table->replaceColumn($column);
        }
    }


    /**
     * Applies type-specific DSL arguments: length, precision/scale, etc.
     *
     * This method ensures fluent column generation based on heuristics:
     * - `string` → length(255)
     * - `decimal` → decimal(10, 2)
     *
     * @param object   $column
     * @param FieldDTO $field
     *
     * @return object Updated fluent column object
     */
    private function applyColumnArguments(object $column, FieldDTO $field) : object
    {
        return match ($field->type->value) {
            'string'                     => $field->length !== null
                ? $column->length($field->length)
                : $column,

            'decimal', 'float', 'double' => $this->hasPrecisionScale($field)
                ? $column->decimal($field->total, $field->places)
                : $column,

            default                      => $column
        };
    }

    /**
     * Checks if precision/scale pair is valid and can be used safely.
     *
     * @param FieldDTO $field
     *
     * @return bool
     */
    private function hasPrecisionScale(FieldDTO $field) : bool
    {
        return is_int($field->total)
               && is_int($field->places)
               && $field->total >= $field->places;
    }
}

=== Design/Table/Alter/AlterTable.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Closure;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddForeignKeyDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddIndexDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\RenameColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use InvalidArgumentException;
use ReflectionException;
use RuntimeException;

/**
 * Provides a fluent Domain-Specific Language (DSL) for database table alterations.
 *
 * This value object encapsulates the complete specification for altering database tables,
 * following Domain-Driven Design principles. It provides an immutable, type-safe interface
 * for defining structural changes to database tables.
 *
 * Example usage:
 * ```
 * $alter = AlterTable::for('users')
 *     ->addColumn('email', 'string')
 *     ->modifyColumn('status', fn(Column $column) => $column->enum(['active', 'inactive']))
 *     ->dropColumn('deprecated_field');
 * ```
 *
 * @final This class is not intended for inheritance
 */
final class AlterTable
{
    /**
     * Represents an immutable collection of atomic table alteration operations.
     *
     * This property maintains the ordered sequence of modifications that will be
     * applied to the database table. The order is significant as certain operations
     * may have dependencies on previous alterations.
     *
     * Operations are executed in FIFO (First-In-First-Out) order, ensuring
     * predictable schema modification behavior.
     *
     * @var list<AlterOperation> $operations A strictly typed list of atomic table modifications
     *                                       where each operation represents a single schema change
     */
    private array $operations = [];

    /**
     * Initializes a new immutable table alteration specification.
     *
     * @param string $tableName The canonical name of the database table to be altered
     *                          Must be a valid identifier according to database naming conventions
     *
     * @throws InvalidArgumentException If the table name is empty or contains invalid characters
     */
    private function __construct(private readonly string $tableName) {}

    /**
     * Creates a new table alteration specification following the named constructor pattern.
     * This factory method provides a more expressive and semantic way to initiate table alterations.
     *
     * @param string $tableName The identifier of the table to alter
     *
     * @return self A new immutable instance of TableAlteration
     *
     * @throws InvalidArgumentException If table name validation fails
     *
     * @api
     */
    public static function for(string $tableName) : self
    {
        return new self(tableName: $tableName);
    }

    /**
     * Adds a new column to the table with specified characteristics.
     *
     * @param string               $name   The identifier for the new column
     * @param string               $type   The SQL data type for the column
     * @param array<string, mixed> $params Additional column attributes
     *
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function addColumn(string $name, string $type, array $params = []) : self
    {
        $definition = $this->createColumnDefinition(
            method   : 'create',
            arguments: [$name, ...$params]
        );

        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Factory method for creating column definitions with specific configurations.
     *
     * @param string $method    The method name representing the column operation
     * @param array  $arguments Configuration parameters for the column
     *
     * @throws ReflectionException
     */
    private function createColumnDefinition(string $method, array $arguments) : ColumnDefinition
    {
        return (new Column())->create(method: $method, arguments: $arguments);
    }

    /**
     * Modifies an existing column's definition using a callback.
     *
     * @param string                            $name                     The identifier of the column to modify
     * @param Closure(Column): ColumnDefinition $columnDefinitionCallback Configuration callback
     *
     * @throws RuntimeException When callback returns an invalid definition
     */
    public function modifyColumn(string $name, Closure $columnDefinitionCallback) : self
    {
        $column     = new Column();
        $definition = $columnDefinitionCallback($column);

        if (! $definition instanceof ColumnDefinition) {
            throw new RuntimeException(
                message: 'Column definition callback must return a ColumnDefinition instance'
            );
        }

        $this->operations[] = new AlterOperation(
            type      : AlterType::MODIFY_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Renames an existing column in the table.
     *
     * This method creates a rename operation for an existing column while maintaining
     * referential integrity and schema consistency.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     *
     * @return self Fluent interface for method chaining
     *
     */
    public function renameColumn(string $from, string $to) : self
    {
        $this->operations[] = new AlterOperation(
            type      : AlterType::RENAME_COLUMN,
            target    : $from,
            definition: new RenameColumnDefinition(from: $from, to: $to)
        );

        return $this;
    }


    /**
     * Removes a column from the table structure.
     *
     * This operation permanently removes the specified column and its data.
     * It Should be used with caution as it's irreversible in production.
     *
     * @param string $column The name of the column to be dropped
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When column definition cannot be created
     */
    public function dropColumn(string $column) : self
    {
        // Create a column definition for the drop operation
        $definition = $this->createColumnDefinition(method: 'drop', arguments: [$column]);

        // Register the drop column operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_COLUMN,
            target    : $column,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes an index from the table.
     *
     * Handles the removal of an existing index while ensuring
     * database performance implications are considered.
     *
     * @param string $indexName The name of the index to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When index definition cannot be created
     */
    public function dropIndex(string $indexName) : self
    {
        // Create a column definition for the drop index operation
        $definition = $this->createColumnDefinition(method: 'dropIndex', arguments: [$indexName]);

        // Register the drop index operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_INDEX,
            target    : $indexName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes a foreign key constraint from the table.
     *
     * This operation removes the referential integrity constraint while
     * maintaining the underlying column and its data.
     *
     * @param string $foreignKeyName The name of the foreign key constraint to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When a foreign key definition cannot be created
     */
    public function dropForeign(string $foreignKeyName) : self
    {
        // Create a column definition for the drop foreign key operation
        $definition = $this->createColumnDefinition(method: 'dropForeign', arguments: [$foreignKeyName]);

        // Register the drop foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_FOREIGN,
            target    : $foreignKeyName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Adds a new index definition to the table alteration operations queue.
     *
     * This method follows Domain-Driven Design principles by encapsulating index
     * creation logic within the aggregate root's context. It ensures type safety
     * through strict parameter typing and immutable operation queuing.
     *
     * @param string                    $name    The unique identifier for the index within the table's scope
     * @param array<int|string, string> $columns List of column names to be included in the index
     * @param string                    $type    The index type specification (defaults to 'INDEX')
     *                                           Supported values: 'INDEX', 'UNIQUE', 'FULLTEXT', 'SPATIAL'
     *
     * @return self Returns the current instance for method chaining (fluent interface)
     *
     * @throws InvalidArgumentException When invalid index type is provided
     */
    public function addIndex(
        string $name,
        array  $columns,
        string $type = 'INDEX'
    ) : self {
        // Append new alter operation to the operations collection using constructor promotion
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_INDEX,        // Specifies the operation type as index addition
            target    : $name,                     // Sets the index name as the operation target
            definition: new AddIndexDefinition( // Creates immutable index definition
                            name   : $name,                   // Index identifier
                            columns: $columns,             // Columns to be indexed
                            type   : $type                    // Index type specification
                        )
        );

        // Return self for method chaining capability
        return $this;
    }

    /**
     * Retrieves the immutable table identifier from the migration context.
     *
     * This method provides access to the protected table name property, maintaining
     * encapsulation while exposing the necessary information for SQL generation.
     * Following Domain-Driven Design principles, it represents a crucial part of
     * the domain model's identity.
     *
     * @return string The fully qualified, immutable table identifier
     *
     * @throws never This method guarantees no exceptions will be thrown
     *
     * @api       This method is part of the public API contract
     * @since     1.0.0
     * @immutable This method always returns the same value for the same instance
     */
    public function getTable() : string
    {
        // Return the immutable table identifier stored during object construction
        return $this->tableName;
    }

    /**
     * Retrieves the collection of pending alter operations.
     *
     * @return list<AlterOperation> Ordered a sequence of table modifications
     */
    public function getOperations() : array
    {
        return $this->operations;
    }

    /**
     * Adds a foreign key constraint to establish referential integrity between tables.
     *
     * This domain operation ensures data consistency by creating a relationship between
     * the current table and a referenced table. It supports customizable referential
     * actions for maintaining data integrity during updates and deletions.
     *
     * @param string      $name       The identifier for the foreign key constraint
     * @param array       $columns    Local columns participating in the relationship
     * @param string      $refTable   The referenced table name
     * @param array       $refColumns Referenced columns in the target table
     * @param string|null $onDelete   Action to take when a referenced record is deleted
     * @param string|null $onUpdate   Action to take when a referenced record is updated
     *
     * @return self Fluent interface for method chaining
     *
     * @throws InvalidArgumentException When constraint parameters are invalid
     */
    public function addForeignKey(
        string      $name,       // Constraint identifier
        array       $columns,    // Source columns in the current table
        string      $refTable,   // Referenced table name
        array       $refColumns, // Target columns in the referenced table
        string|null $onDelete = null, // Optional deletion behavior
        string|null $onUpdate = null  // Optional update behavior
    ) : self
    {
        // Register a new foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_FOREIGN,      // Specify an operation type as a foreign key addition
            target    : $name,                       // Set the constraint name as the target
            definition: new AddForeignKeyDefinition( // Define the foreign key specifics
                            name             : $name,
                            columns          : $columns,
                            referencedTable  : $refTable,
                            referencedColumns: $refColumns,
                            onDelete         : $onDelete,
                            onUpdate         : $onUpdate
                        )
        );

        return $this; // Enable method chaining
    }
}
=== Design/Table/Alter/AlterTableRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use RuntimeException;

/**
 * Class AlterTableRenderer
 *
 * Renders valid SQL ALTER TABLE statements from structured DSL operations.
 * Encapsulates the rendering logic for each supported operation, delegating
 * to the proper rendering strategies or SQL renderers depending on a definition type.
 *
 * @final
 */
final class AlterTableRenderer
{
    /**
     * Renders an ALTER TABLE SQL statement from a structured table alteration specification.
     *
     * This service method transforms a domain-specific AlterTable object into a valid SQL ALTER TABLE
     * statement. It ensures proper SQL syntax and escaping while maintaining database schema integrity.
     *
     * @param AlterTable $alter The domain model representing table alterations
     *
     * @return string The fully formed SQL ALTER TABLE statement
     * @throws RuntimeException When attempting to render an empty alteration set
     *
     * @example
     * $SQL = SQLRenderer::render(
     *     AlterTable::for('users')->addColumn('email', 'VARCHAR(255)')
     * );
     */
    public static function render(AlterTable $alter) : string
    {
        // Retrieve the collection of atomic table operations from the alteration specification
        $operations = $alter->getOperations();

        // Validate that at least one operation has been defined
        if (empty($operations)) {
            throw new RuntimeException(
                message: "No ALTER TABLE operations defined for table '{$alter->getTable()}'."
            );
        }

        // Transform each operation into its corresponding SQL representation
        $segments = [];
        foreach ($operations as $operation) {
            $segments[] = self::renderOperation(operation: $operation);
        }

        // Compose the final ALTER TABLE statement with a proper table name escaping
        return sprintf(
            'ALTER TABLE `%s` %s;',
            $alter->getTable(),
            implode(', ', $segments)
        );
    }

    /**
     * Renders a single database alteration operation into its SQL representation.
     *
     * This method implements the Strategy pattern by mapping AlterType enum values
     * to their corresponding SQL syntax. It ensures type-safety through PHP 8.3's
     * enhanced type system and match expressions.
     *
     * @param AlterOperation $operation The alteration operation value object
     *
     * @return string                  The SQL fragment representing the operation
     * @throws RuntimeException        When encountering unsupported operation types
     */
    private static function renderOperation(AlterOperation $operation) : string
    {
        // Use match expression for type-safe operation mapping
        return match ($operation->type) {
            // Handle column addition with proper SQL syntax
            AlterType::ADD_COLUMN    => sprintf(
                'ADD COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column modification maintaining schema consistency
            AlterType::MODIFY_COLUMN => sprintf(
                'MODIFY COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column renaming with a proper identifier escaping
            AlterType::RENAME_COLUMN => sprintf(
                'RENAME COLUMN `%s` TO `%s`',
                $operation->target,
                self::assertColumnRenameTarget(operation: $operation)
            ),

            // Handle column removal with a proper identifier escaping
            AlterType::DROP_COLUMN   => sprintf(
                'DROP COLUMN `%s`',
                $operation->target
            ),

            // Handle index removal with a proper identifier escaping
            AlterType::DROP_INDEX    => sprintf(
                'DROP INDEX `%s`',
                $operation->target
            ),

            // Handle foreign key constraint removal
            AlterType::DROP_FOREIGN  => sprintf(
                'DROP FOREIGN KEY `%s`',
                $operation->target
            ),

            // Handle index and foreign key additions through definition renderer
            AlterType::ADD_INDEX,
            AlterType::ADD_FOREIGN   => self::renderDefinition(operation: $operation),

            // Handle unsupported operations with a descriptive exception
            default                  => throw new RuntimeException(
                message: "Unsupported ALTER operation type: {$operation->type->value}"
            ),
        };
    }

    /**
     * Renders an SQL definition from an AlterOperation using polymorphic behavior.
     *
     * This method implements the Strategy pattern by dynamically selecting the appropriate
     * rendering approach based on the definition type. It handles both direct column
     * definitions and SQL-renderable objects through a uniform interface.
     *
     * @param AlterOperation $operation The operation containing the definition to render
     *
     * @return string                   The SQL-safe string representation
     * @throws RuntimeException         When definition is missing or unsupported
     */
    private static function renderDefinition(AlterOperation $operation) : string
    {
        // Extract definition from operation for validation and processing
        $definition = $operation->definition;

        // Ensure definition exists before attempting to render
        if ($definition === null) {
            throw new RuntimeException(
                message: "Definition missing for operation type: {$operation->type->value}"
            );
        }

        // Handle ColumnDefinition using a dedicated renderer for complex column structures
        if ($definition instanceof ColumnDefinition) {
            return ColumnSQLRenderer::render(column: $definition->getBuilder());
        }

        // Process objects implementing SQL rendering capabilities through toSql() method
        if (method_exists($definition, 'toSql')) {
            return $definition->toSql();
        }

        // Throw exception for unsupported definition types
        throw new RuntimeException(
            message: sprintf(
                         'Cannot render alter operation [%s]: definition is not renderable.',
                         $operation->type->value
                     )
        );
    }

    /**
     * Validates and extracts the target column name for a rename operation.
     *
     * This method ensures type safety and semantic correctness of column rename operations
     * by validating that the provided operation contains a valid ColumnDefinition.
     * Following Domain-Driven Design principles, it enforces invariants at the domain boundary.
     *
     * @param AlterOperation $operation The alter operation containing the rename definition
     *
     * @return string The validated target column name
     * @throws RuntimeException When the operation definition is not a valid ColumnDefinition
     */
    private static function assertColumnRenameTarget(AlterOperation $operation) : string
    {
        // Extract the definition from the operation for validation
        $definition = $operation->definition;

        // Ensure type safety through runtime assertion of the definition type
        if (! ($definition instanceof ColumnDefinition)) {
            throw new RuntimeException(
                message: "Invalid rename operation definition – expected ColumnDefinition."
            );
        }

        // Extract and return the validated target column name
        return $definition->columnName();
    }
}

=== Design/Table/Alter/Definitions/AddForeignKeyDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a foreign key creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create foreign key constraints. It follows immutable design principles
 * to ensure consistency during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddForeignKeyDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the AddForeignKeyDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name              The name of the foreign key constraint
     * @param array<string> $columns           The local columns participating in the foreign key
     * @param string        $referencedTable   The referenced table name
     * @param array<string> $referencedColumns The columns in the referenced table
     * @param string|null   $onDelete          The ON DELETE behavior (CASCADE, SET NULL, etc.)
     * @param string|null   $onUpdate          The ON UPDATE behavior (CASCADE, SET NULL, etc.)
     */
    public function __construct(
        public string      $name,
        public array       $columns,
        public string      $referencedTable,
        public array       $referencedColumns,
        public string|null $onDelete = null,
        public string|null $onUpdate = null
    ) {}

    /**
     * Generates the SQL statement for the foreign key creation operation.
     *
     * Produces a standardized SQL ADD CONSTRAINT statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in table and column names.
     *
     * @return string The complete SQL statement for creating the foreign key constraint
     */
    public function toSql() : string
    {
        // Transform column names arrays into properly escaped column identifiers
        $columns = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->columns));
        $refs    = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->referencedColumns));

        // Construct the base foreign key constraint SQL
        $sql = "ADD CONSTRAINT `{$this->name}` FOREIGN KEY ({$columns}) REFERENCES `{$this->referencedTable}` ({$refs})";

        // Append ON DELETE clause if specified
        if ($this->onDelete) {
            $sql .= " ON DELETE {$this->onDelete}";
        }

        // Append ON UPDATE clause if specified
        if ($this->onUpdate) {
            $sql .= " ON UPDATE {$this->onUpdate}";
        }

        return $sql;
    }
}
=== Design/Table/Alter/Definitions/AddIndexDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents an index creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create various types of database indexes (standard, unique, fulltext).
 * It follows immutable design principles to ensure consistency during
 * the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddIndexDefinition extends AlterColumnDefinition
{
    /**
     * Valid index types supported by this definition.
     *
     * @var array<string>
     */
    private const array VALID_INDEX_TYPES = ['INDEX', 'UNIQUE', 'FULLTEXT'];

    /**
     * Initializes a new instance of the AddIndexDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name    The name of the index to be created
     * @param array<string> $columns The columns to be included in the index
     * @param string        $type    The type of index (INDEX, UNIQUE, FULLTEXT)
     */
    public function __construct(
        public string $name,
        public array  $columns,
        public string $type = 'INDEX'
    ) {
        assert(
            in_array($type, self::VALID_INDEX_TYPES, true),
            sprintf('Invalid index type. Must be one of: %s', implode(', ', self::VALID_INDEX_TYPES))
        );
    }

    /**
     * Generates the SQL statement for the index creation operation.
     *
     * Produces a standardized SQL CREATE INDEX statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column and index names.
     *
     * @return string The complete SQL statement for creating the index
     */
    public function toSql() : string
    {
        // Transform column names array into properly escaped column identifiers
        $columns = implode(
            ', ',
            array_map(
                static fn(string $col) : string => "`{$col}`",
                $this->columns
            )
        );

        // Construct the final SQL statement using the defined format
        return sprintf(
            '%s `%s` (%s)',
            strtoupper($this->type),
            $this->name,
            $columns
        );
    }
}
=== Design/Table/Alter/Definitions/Base/AlterColumnDefinition.php ===
<?php

/**
 * Provides base functionality for SQL column alteration definitions.
 *
 * This abstract class serves as a foundation for implementing various column
 * alteration strategies in database migrations, following the Domain-Driven Design
 * pattern and Single Responsibility Principle.
 *
 * @category Database
 * @package  Gemini\Database\Migration\Design\Table\Alter\Definitions\Base
 * @author   Development Team
 * @version  1.0.0
 * @since    1.0.0
 */
declare(strict_types=1);

/**
 * Base abstract class representing a column alteration definition.
 *
 * This class serves as a blueprint for defining SQL representation of
 * a column alteration in a database migration. It provides an abstract
 * method that subclasses must implement to define specific
 * SQL generation logic for altering database table columns.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions\Base;

abstract readonly class AlterColumnDefinition
{
    /**
     * Converts the column alteration definition to its SQL representation.
     *
     * This method must be implemented by concrete classes to provide specific SQL
     * generation logic for different types of column alterations.
     *
     * @return string The SQL statement representing the column alteration
     *
     * @throws \RuntimeException When SQL generation fails
     */
    abstract public function toSql() : string;
}
=== Design/Table/Alter/Definitions/RenameColumnDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a column renaming operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to rename database columns. It's immutable by design to ensure data integrity
 * during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class RenameColumnDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the RenameColumnDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     */
    public function __construct(
        public string $from,
        public string $to
    ) {}

    /**
     * Generates the SQL statement for the column renaming operation.
     *
     * Produces a standardized SQL RENAME COLUMN statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column names.
     *
     * @return string The complete SQL statement for renaming the column
     */
    public function toSql() : string
    {
        return sprintf('RENAME COLUMN `%s` TO `%s`', $this->from, $this->to);
    }
}
=== Design/Table/Alter/DTO/AlterOperation.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\DTO;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;

/**
 * Represents an immutable value object for table alteration operations.
 *
 * This DTO encapsulates the essential information needed to perform
 * structural modifications to database tables, ensuring type safety
 * and immutability in the domain model.
 *
 * @final    Prevents extension to maintain invariants
 * @readonly Ensures immutability of the value object
 */
final readonly class AlterOperation
{
    /**
     * Constructs a new AlterOperation instance using constructor promotion.
     *
     * Encapsulates the complete state required for a table alteration
     * operation through immutable properties, following DDD value object patterns.
     *
     * @param AlterType                                   $type                                                                                                       The
     *                                                                                                                                                                perform
     * @param string                                      $target                                                                                                     The
     *                                                                                                                                                                identifier
     * @param ColumnDefinition|AlterColumnDefinition|null $definition                                                                                                 The
     *                                                                                                                                                                specification
     */
    public function __construct(
        public AlterType                                   $type,
        public string                                      $target,
        public ColumnDefinition|AlterColumnDefinition|null $definition = null
    ) {}
}
=== Design/Table/Alter/Enums/AlterType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\Enums;

/**
 * Enum AlterType
 *
 * Defines all supported ALTER TABLE operation types.
 * Used in conjunction with AlterOperation to describe mutations to a table schema.
 *
 * @immutable
 * @psalm-immutable
 */
enum AlterType: string
{
    /**
     * Adds a new column to a table.
     *
     * Example: ALTER TABLE users ADD COLUMN age INT;
     */
    case ADD_COLUMN = 'ADD_COLUMN';

    /**
     * Modifies an existing column.
     *
     * Example: ALTER TABLE users MODIFY COLUMN name VARCHAR(255) NOT NULL;
     */
    case MODIFY_COLUMN = 'MODIFY_COLUMN';

    /**
     * Renames a column.
     *
     * Example: ALTER TABLE users RENAME COLUMN old_name TO new_name;
     */
    case RENAME_COLUMN = 'RENAME_COLUMN';

    /**
     * Drops a column.
     *
     * Example: ALTER TABLE users DROP COLUMN deprecated_field;
     */
    case DROP_COLUMN = 'DROP_COLUMN';

    /**
     * Drops an index.
     *
     * Example: ALTER TABLE users DROP INDEX idx_email;
     */
    case DROP_INDEX = 'DROP_INDEX';

    /**
     * Drops a foreign key constraint.
     *
     * Example: ALTER TABLE orders DROP FOREIGN KEY fk_user_id;
     */
    case DROP_FOREIGN = 'DROP_FOREIGN';

    /**
     * Represents an operation to add a new index to a table.
     *
     * This operation allows the creation of different types of indexes (regular INDEX,
     * UNIQUE, FULLTEXT, SPATIAL) to optimize query performance and enforce data integrity.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE users ADD INDEX idx_email (email);
     *     ALTER TABLE users ADD UNIQUE INDEX idx_username (username);
     */
    case ADD_INDEX = 'ADD_INDEX';

    /**
     * Represents an operation to add a new foreign key constraint to a table.
     *
     * This operation establishes referential integrity between tables by creating
     * a foreign key relationship with configurable ON DELETE and ON UPDATE behaviors.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE orders
     *     ADD CONSTRAINT fk_user_id
     *     FOREIGN KEY (user_id)
     *     REFERENCES users(id)
     *     ON DELETE CASCADE
     *     ON UPDATE CASCADE;
     */
    case ADD_FOREIGN = 'ADD_FOREIGN';
}

=== Design/Table/Enum/FieldModifierEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enumeration: FieldModifierEnum
 *
 * This enum provides a type-safe way to define and manage field modifiers
 * used in database migrations for the Gemini system.
 * Each enumerated case represents a specific modifier,
 * ensuring maintainability and reducing duplication across the codebase.
 *
 * Following Domain-Driven Design (DDD), it encapsulates behavior related
 * to its enumeration, ensuring that valid operations are directly associated
 * with the definition itself.
 */
enum FieldModifierEnum: string
{
    /**
     * Represents the "nullable" field modifier.
     *
     * This modifier allows the associated database column to accept NULL values.
     *
     * @var string
     */
    case NULLABLE = 'nullable';

    /**
     * Represents the "unique" field modifier.
     *
     * This modifier ensures that all values in the associated database column
     * are unique and no duplicates are allowed.
     *
     * @var string
     */
    case UNIQUE = 'unique';

    /**
     * Represents the "primary" field modifier.
     *
     * This modifier signifies that the database column serves as a primary key,
     * which uniquely identifies each row in the table.
     *
     * @var string
     */
    case PRIMARY = 'primary';

    /**
     * Represents the "index" field modifier.
     *
     * This modifier designates the creation of an index for the associated column
     * to improve query performance.
     *
     * @var string
     */
    case INDEX = 'index';

    /**
     * Check if the provided value is a valid case for this enum.
     *
     * This method ensures that the given value matches one of the enum's predefined
     * cases, improving type safety and reducing unexpected errors during runtime.
     *
     * @param string $value The value to validate against the enum cases.
     *
     * @return bool Returns `true` if the value exists in the enum, otherwise `false`.
     */
    public static function isValid(string $value) : bool
    {
        // Validate if the provided value exists within the enum's list of values using strict comparison.
        return in_array($value, self::values(), true);
    }

    /**
     * Retrieve all string values of the enum cases.
     *
     * This method provides a centralized way to access the raw underlying values
     * of the defined enum cases. This is particularly useful when the raw values
     * need to be passed to external systems or stored in a database.
     *
     * @return array<int, string> An indexed array of the string values of all cases.
     */
    public static function values() : array
    {
        // Use PHP 8.1+ `cases()` method to get all enum cases and extract their `value` property.
        return array_column(self::cases(), 'value');
    }

    /**
     * Safely attempts to retrieve an enum instance from a given value. If the value is null
     * or invalid, it returns null instead of throwing an error.
     *
     * This method wraps around PHP's built-in `tryFrom()` to provide a safe and null-tolerant
     * implementation that prevents exceptions when handling dynamic inputs.
     *
     * @param string|null $value The value to convert to an enum instance, or `null`.
     *
     * @return self|null Returns the enum instance for the corresponding value, or `null` if the value is invalid.
     */
    public static function fromOrNull(string|null $value) : self|null
    {
        // Ensure type-safety by checking if the input is a string before attempting conversion.
        return is_string($value) ? self::tryFrom($value) : null;
    }
}
=== Design/Table/Enum/FieldTypeEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum FieldTypeEnum
 *
 * This enum serves as a representation of valid Gemini-compatible column types.
 * It ensures type safety and provides a centralized definition for managing
 * the various database field types used in migrations in a Domain-Driven Design (DDD) context.
 */
enum FieldTypeEnum: string // Enum declaration with an underlying string type, ensuring type-safety for the enum values.
{
    /**
     * Represents a variable-length string column in the database.
     * Suitable for shorter text or character data, defined by Gemini's `string` type.
     *
     * @var string
     */
    case STRING = 'string';

    /**
     * Represents an integer column in the database.
     * Suitable for whole numbers, defined as `integer` in Gemini migrations.
     *
     * @var string
     */
    case INTEGER = 'integer';

    /**
     * Represents a big integer column in the database.
     * Useful for storing larger whole numbers, as defined by Gemini's `bigInteger` type.
     *
     * @var string
     */
    case BIGINT = 'bigInteger';

    /**
     * Represents a boolean column in the database.
     * Used to store true/false values, as defined by Gemini's `boolean` type.
     *
     * @var string
     */
    case BOOLEAN = 'boolean';

    /**
     * Represents a decimal column in the database.
     * Suitable for storing precise numeric values with defined precision and scale.
     *
     * @var string
     */
    case DECIMAL = 'decimal';

    /**
     * Represents a float column in the database.
     * Useful for storing approximate numeric values with floating-point precision.
     *
     * @var string
     */
    case FLOAT = 'float';

    /**
     * Represents an enum column in the database.
     * Allows for a fixed set of predefined string values, common for constrained fields.
     *
     * @var string
     */
    case ENUM = 'enum';

    /**
     * Represents a text column in the database.
     * Suitable for storing large textual content, as defined by Gemini's `text` type.
     *
     * @var string
     */
    case TEXT = 'text';

    /**
     * Represents a timestamp column in the database.
     * Typically used for storing date and time information with precision.
     *
     * @var string
     */
    case TIMESTAMP = 'timestamp';

    /**
     * Represents a universally unique identifier (UUID) column in the database.
     * Useful for storing UUIDs for globally unique identification purposes.
     *
     * @var string
     */
    case UUID = 'uuid';

    /**
     * Represents a foreign key column in the database.
     * Primarily used for establishing relationships between tables in a relational database.
     *
     * @var string
     */
    case FOREIGN = 'foreign';

    /**
     * Returns a list of all enum values.
     *
     * This method provides a centralized way to retrieve the values of all the cases defined in the enum.
     * It utilizes PHP 8.1+ `cases()` enumeration feature to dynamically return the `value` property
     * of each case, ensuring type-safety and simplicity when needing the raw string representations of the cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Uses array_column to extract the 'value' property of each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Design/Table/Enum/ForeignActionEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum ForeignActionEnum
 *
 * This enum represents possible actions to be taken on foreign key constraints
 * when certain events occur in the referenced table, such as row deletions or updates.
 *
 * In the context of database migrations, this enum simplifies handling of foreign key behaviors
 * by providing a strongly typed definition for actions like cascade, restrict, or no action.
 * It enhances type-safety, readability, and ensures centralized management of foreign key options.
 *
 * Designed using PHP 8.1+ enums, this class leverages modern features for expressive and reliable
 * definition of constants.
 */
enum ForeignActionEnum: string // Enum declaration with 'string' type to ensure type safety for the defined cases.
{
    /**
     * Indicates cascading behavior for foreign keys.
     * When the referenced row is updated or deleted, the change cascades to the dependent rows.
     *
     * Example: If a parent record is removed, all associated child records are also removed.
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Indicates behavior to set foreign key columns to NULL.
     * When the referenced row is deleted, dependent foreign key columns in related rows are set to NULL.
     *
     * Example: If a parent record is deleted, the foreign key in child records will be nullified.
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Restricts changes to the referenced row.
     * Prevents any changes (such as deletion) to a parent row when there are dependencies on it.
     *
     * Example: Trying to delete a parent record with dependent child records will raise an error.
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Indicates no action should be taken on foreign key constraints.
     * It simply allows the database to raise an error if the integrity rules are violated.
     *
     * Example: If a parent record is targeted for deletion but a child record exists, the operation fails.
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Retrieves an array of all values defined by the enum cases.
     *
     * This method provides a centralized, type-safe way to access the raw string values
     * of all enum cases. It is useful when generating lists of possible options for migrations
     * or when working with foreign key actions dynamically.
     *
     * Uses PHP's built-in `cases()` method, introduced in PHP 8.1+, to retrieve the values of all cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Leverages `array_column` to extract the 'value' property from each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Design/Table/Table.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table;

use BadMethodCallException;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Traits\FieldMappingTrait;
use Gemini\Database\Migration\Design\Table\Traits\IndexDefinitionsTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderDslTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderSqlTrait;
use RuntimeException;

/**
 * @internal Auto-generated from ColumnType enum
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final class Table
{
    /**
     * Import the IndexDefinitionsTrait which provides robust database index management capabilities.
     *
     * This trait encapsulates the domain logic for defining and managing various types of database indexes:
     * - Standard indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     * - Composite indexes (COMPOSITE)
     *
     * @see   \IndexDefinitionsTrait For complete index management functionality
     * @since 8.3.0
     */
    use IndexDefinitionsTrait;

    /**
     * Imports TableRenderSqlTrait, which provides SQL generation capabilities for table definitions.
     *
     * This trait is responsible for converting table definitions into valid SQL CREATE TABLE statements.
     * It works in conjunction with column definitions and rendering logic to produce
     * properly formatted SQL strings.
     *
     * @see TableRenderSqlTrait::toSql() For the main SQL generation method
     * @see ColumnSQLRenderer For the column-specific SQL rendering
     *
     * @api
     */
    use TableRenderSqlTrait;

    /**
     * Incorporates table rendering capabilities via Domain-Specific Language (DSL).
     *
     * This trait provides DSL generation functionality for database table definitions,
     * enabling fluent and declarative table schema specifications. It transforms
     * column definitions into a standardized DSL format suitable for database migrations.
     *
     * @see     ColumnDSLRenderer For the underlying DSL formatting logic
     * @see     ColumnAttributes For the column attribute specifications
     *
     * @author  Your Name <your.email@domain.com>
     * @package Database\Schema
     * @version 1.0.0
     */
    use TableRenderDslTrait;

    /**
     * Imports the FieldMappingTrait which provides essential field mapping capabilities for database schema
     * definitions.
     *
     * This trait encapsulates domain logic for mapping FieldDTO objects to table schema DSL,
     * implementing a flexible and extensible field mapping strategy pattern.
     *
     * Key responsibilities:
     * - Manages field-to-DSL mapper injection
     * - Provides fluent interface for field application
     * - Handles both single and batch field mapping operations
     *
     * @see   FieldToDslMapperInterface For the mapping strategy contract
     * @see   FieldDTO For the field data transfer object structure
     *
     * @since 8.3.0
     * @api
     */
    use FieldMappingTrait;

    /**
     * Collection of column definitions indexed by column name.
     *
     * Maintains the ordered set of columns that define the table structure,
     * ensuring column name uniqueness through associative array keys.
     *
     * @var array<string, ColumnDefinition>
     */
    private array $columns = [];

    /**
     * Constructs a new Table instance with the specified name.
     *
     * Uses constructor promotion for lean initialization of the immutable name property.
     */
    private function __construct(private readonly string $name) {}

    /**
     * Dynamic column type handler implementing the Schema DSL.
     *
     * Provides a fluent interface for column definition by delegating to the Column factory.
     * Method name becomes the column type, the first argument is expected to be the column name.
     *
     * @param string            $method    The column types to create
     * @param array<int, mixed> $arguments The column definition arguments
     *
     * @return ColumnDefinition              The created column definition
     * @throws BadMethodCallException        When a column type is invalid
     * @throws RuntimeException|\ReflectionException             When column creation fails
     */
    public function __call(string $method, array $arguments) : ColumnDefinition
    {
        $column = (new Column())->create(
            method   : $method,
            arguments: $arguments
        );

        return $this->addColumn(column: $column);
    }

    /**
     * Named constructor implementing the factory pattern for Table creation.
     *
     * Provides a semantic way to instantiate new Table objects while encapsulating
     * construction details.
     *
     * @param string $name The logical name of the table
     *
     * @return self       The constructed Table instance
     */
    public static function create(string $name) : self
    {
        return new self(name: $name);
    }

    /**
     * Adds a column definition to the table schema.
     *
     * Maintains the column collection while supporting method chaining for the fluent interface.
     *
     * @param ColumnDefinition $column The column definition to add
     *
     * @return ColumnDefinition        The added column definition
     */
    public function addColumn(ColumnDefinition $column) : ColumnDefinition
    {
        $this->columns[$column->columnName()] = $column;

        return $column;
    }

    /**
     * Replaces or adds a column definition in the schema.
     *
     * This method ensures atomic column replacement within the schema definition,
     * maintaining schema consistency and integrity. It follows the Single
     * Responsibility Principle by focusing solely on column replacement logic.
     *
     * @param ColumnDefinition $column The column definition to replace or add
     *
     * @return void
     * @throws RuntimeException When attempting to replace with an invalid column
     */
    public function replaceColumn(ColumnDefinition $column) : void
    {
        // Extract the column name from the definition for validation and indexing
        $name = $column->columnName();

        // Ensure column name validity to maintain schema integrity
        if (! $name) {
            throw new RuntimeException(
                message: "Column name must not be empty for replacement."
            );
        }

        // Perform atomic column replacement in the schema definition
        $this->columns[$name] = $column;
    }

    /**
     * Retrieves the table name.
     *
     * Value object accessor for the immutable table name property.
     *
     * @return string The logical table name
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * Retrieves all column definitions.
     *
     * Provides read-only access to the complete collection of column definitions.
     *
     * @return array<string, ColumnDefinition> Column definitions indexed by name
     */
    public function getColumns() : array
    {
        return $this->columns;
    }

    /**
     * Retrieves all defined table indexes.
     *
     * This method provides access to the collection of indexes that have been
     * defined for the current table schema.
     * The indexes can include various types such as:
     * - Regular indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     *
     * @return array<string, ColumnDefinition> Array of index definitions keyed by index name
     *
     * @since 1.0.0
     * @api
     */
    public function getIndexes() : array
    {
        // Return the protected collection of index definitions
        return $this->indexes;
    }
}
=== Design/Table/Traits/FieldMappingTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;

/**
 * Provides field mapping capabilities for database schema definitions.
 *
 * This trait implements the Strategy pattern to enable dynamic field-to-DSL mapping
 * in database table definitions. It serves as a bridge between FieldDTO objects
 * and the table's DSL methods.
 *
 * Key Features:
 * - Implements a Strategy pattern for flexible field mapping
 * - Supports both single and batch field operations
 * - Provides fluent interface for method chaining
 * - Maintains loose coupling through dependency injection
 *
 * @template T of object
 * @author YourName <your@email.com>
 * @since  8.3.0
 */
trait FieldMappingTrait
{
    /**
     * Field-to-DSL mapper implementation.
     *
     * Responsible for transforming FieldDTO objects into table column definitions
     * using the fluent DSL. Implements the Strategy pattern to allow runtime
     * mapping behavior modification.
     *
     * @var FieldToDslMapperInterface|null
     */
    private FieldToDslMapperInterface|null $mapper = null;

    /**
     * Configures the field mapping strategy.
     *
     * Injects the mapper implementation that will be used for converting FieldDTO
     * objects into table column definitions via the fluent DSL.
     *
     * @param FieldToDslMapperInterface $mapper The field mapping strategy to use
     *
     * @return T The trait using instance for method chaining
     */
    public function useMapper(FieldToDslMapperInterface $mapper) : self
    {
        $this->mapper = $mapper;

        return $this;
    }

    /**
     * Applies multiple field definitions to the table schema.
     *
     * Batch processes an array of FieldDTO objects, applying each one to the table
     * schema using the configured mapper.
     *
     * @param array<int, FieldDTO> $fields Collection of field definitions to apply
     *
     * @return T The trait using instance for method chaining
     */
    public function applyMany(array $fields) : self
    {
        foreach ($fields as $field) {
            $this->apply(field: $field);
        }

        return $this;
    }

    /**
     * Applies a single field definition to the table schema.
     *
     * Delegates the field-to-column mapping to the injected mapper strategy,
     * enforcing the requirement for a configured mapper.
     *
     * @param FieldDTO $field The field definition to apply
     *
     * @return T The trait using instance for method chaining
     * @throws RuntimeException When no mapper has been configured
     */
    public function apply(FieldDTO $field) : self
    {
        if (! $this->mapper) {
            throw new RuntimeException(message: 'No FieldToDslMapperInterface injected into Table.');
        }

        $this->mapper->apply(table: $this, field: $field);

        return $this;
    }
}
=== Design/Table/Traits/IndexDefinitionsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Trait IndexDefinitionsTrait
 *
 * Provides fluent DSL methods for defining table-level indexes.
 */
trait IndexDefinitionsTrait
{
    /**
     * @var array<string, ColumnDefinition> Indexes keyed by index name
     */
    protected array $indexes = [];

    /**
     * Adds a general-purpose INDEX.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::INDEX, columns: $columns, indexName: $indexName);
    }

    /**
     * Internal helper to create and register an index ColumnDefinition.
     *
     * @param ColumnType                $type
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    private function addIndex(ColumnType $type, string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        $cols = (array) $columns;
        $name = $indexName ?? strtolower($type->value) . '_' . implode('_', $cols);

        $definition = ColumnDefinition::make(name: $name, type: $type)
            ->columns($cols);

        $this->indexes[$name] = $definition;

        return $definition;
    }

    /**
     * Adds a FULLTEXT index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::FULLTEXT, columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a SPATIAL index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatialIndex(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::SPATIAL, columns: $columns, indexName: $indexName);
    }

    /**
     * Alias for unique composite keys.
     *
     * @param array<int, string> $columns
     * @param string|null        $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function uniqueComposite(array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->unique(columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a UNIQUE index with optional composite support.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::UNIQUE, columns: $columns, indexName: $indexName);
    }
}

=== Design/Table/Traits/SpatialColumnsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\ColumnBuilder;

trait SpatialColumnsTrait
{
    public function geometry(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRY', name: $name);
    }

    public function point(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POINT', name: $name);
    }

    public function lineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'LINESTRING', name: $name);
    }

    public function polygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POLYGON', name: $name);
    }

    public function multiPoint(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOINT', name: $name);
    }

    public function multiLineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTILINESTRING', name: $name);
    }

    public function multiPolygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOLYGON', name: $name);
    }

    public function geometryCollection(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRYCOLLECTION', name: $name);
    }
}
=== Design/Table/Traits/TablePropertiesTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

/**
 * Trait TablePropertiesTrait
 *
 * Provides methods for defining table-level properties such as storage engine, character set, collation, and comments.
 * These properties allow for fine-grained control over database table configurations, ensuring optimal performance and
 * compatibility.
 *
 * Supported properties:
 * - Storage engine (e.g., InnoDB, MyISAM)
 * - Character set (e.g., utf8, utf8mb4)
 * - Collation (e.g., utf8_general_ci, utf8mb4_unicode_ci)
 * - Table-level comments for documentation and indexing purposes
 *
 * Usage Example:
 * ```
 * $blueprint->engine('InnoDB');
 * $blueprint->charset('utf8mb4');
 * $blueprint->collation('utf8mb4_unicode_ci');
 * $blueprint->comment('User table storing authentication details');
 * ```
 *
 * @package Gemini\Database\Migration\Table\Traits
 */
trait TablePropertiesTrait
{
    /**
     * Sets the storage engine for the table.
     *
     * @param string $engine The storage engine (e.g., 'InnoDB', 'MyISAM').
     *
     * @return \Gemini\Database\Migration\Design\Table\Table|\Gemini\Database\Migration\Design\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->engine('InnoDB');
     * ```
     */
    public function engine(string $engine) : self
    {
        $this->tableEngine = $engine;

        return $this;
    }

    /**
     * Sets the character set for the table.
     *
     * @param string $charset The character set (e.g., 'utf8mb4', 'utf8').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->charset('utf8mb4');
     * ```
     */
    public function charset(string $charset) : self
    {
        $this->charset = $charset;

        return $this;
    }

    /**
     * Sets the collation for the table.
     *
     * @param string $collation The collation (e.g., 'utf8mb4_unicode_ci', 'utf8_general_ci').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->collation('utf8mb4_unicode_ci');
     * ```
     */
    public function collation(string $collation) : self
    {
        $this->collation = $collation;

        return $this;
    }

    /**
     * Sets a comment for the table.
     *
     * @param string $text The comment text.
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->comment('Stores user authentication data');
     * ```
     */
    public function comment(string $text) : self
    {
        $this->tableComment = addslashes($text);

        return $this;
    }
}

=== Design/Table/Traits/TableRenderDslTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnDSLRenderer;

/**
 * Trait TableRenderDslTrait
 *
 * Provides Domain-Specific Language (DSL) rendering capabilities for database table definitions.
 * Implement the Single Responsibility Principle by focusing solely on DSL generation logic.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 *
 * @since   1.0.0
 */
trait TableRenderDslTrait
{
    /**
     * Converts the table definition into a DSL representation.
     *
     * Transforms the internal column collection into a formatted DSL string using
     * the ColumnDSLRenderer. Follows the Command Query Separation principle by
     * performing a pure transformation operation.
     *
     * @return string The generated DSL representation of the table structure
     */
    public function toDsl() : string
    {
        // Initialize collection for DSL line storage
        $lines = [];

        // Transform each column definition into its DSL representation
        foreach ($this->getColumns() as $column) {
            // Delegate rendering responsibility to a specialized renderer
            $lines[] = (new ColumnDSLRenderer())->format(column: $column->getBuilder());
        }

        // Join DSL lines with proper indentation
        return implode(
            separator: PHP_EOL . '            ',
            array    : $lines
        );
    }
}
=== Design/Table/Traits/TableRenderSqlTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use RuntimeException;

/**
 * Trait TableRenderSqlTrait
 *
 * Provides SQL rendering capabilities for table definitions in the database migration context.
 * Implements Domain-Driven Design principles for table schema representation.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 */
trait TableRenderSqlTrait
{
    /**
     * Generates the SQL CREATE TABLE statement for the current table definition.
     *
     * Transforms the abstract table representation into a valid SQL statement,
     * handling both simple and nested column definitions. Ensures proper SQL
     * formatting with indentation and newlines for improved readability.
     *
     * @return string Complete SQL CREATE TABLE statement
     * @throws RuntimeException When no columns are defined for the table
     */
    public function toSql() : string
    {
        // Retrieve all column definitions from the table schema
        $columns = $this->getColumns();

        // Validate that the table has at least one column defined
        if (empty($columns)) {
            throw new RuntimeException(
                message: sprintf('No columns defined for table [%s]', $this->getName())
            );
        }

        // Initialize collection for SQL column definitions
        $lines = [];

        // Process each column definition, handling both single and nested columns
        foreach ($columns as $col) {
            if (is_array($col)) {
                // Handle nested column definitions (e.g., for compound indexes)
                foreach ($col as $nested) {
                    $lines[] = ColumnSQLRenderer::render(column: $nested->getBuilder());
                }
            } else {
                // Process single column definition
                $lines[] = ColumnSQLRenderer::render(column: $col->getBuilder());
            }
        }

        // Construct the complete CREATE TABLE statement with proper formatting
        $sql = sprintf(
            "CREATE TABLE `%s` (\n    %s\n)",
            $this->getName(),
            implode(",\n    ", $lines)
        );

        // Append semicolon to complete the SQL statement
        return $sql . ';';
    }
}
=== Runner/CliInput.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

class CliInput
{
    public function __construct(private readonly array $rawArguments) {}

    /**
     * Check if a specific key exists in the arguments.
     */
    public function has(string $key) : bool
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get the value of a specific key.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                [$k, $value] = explode('=', (string) $rawArgument, 2) + [1 => $default];

                return $value;
            }
        }

        return $default;
    }

    /**
     * Retrieve a raw argument by index.
     */
    public function getRawArgument(int $index) : string|null
    {
        return $this->rawArguments[$index] ?? null;
    }

    /**
     * Get all remaining arguments (after the command).
     */
    public function getRemainingArguments() : array
    {
        return array_slice($this->rawArguments, 2);
    }
}

=== Runner/Commands/Commands.php ===
<?php

declare(strict_types=1);

/**
 * Represents a container for database migration commands.
 */

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The Commands class is responsible for managing and organizing available commands
 * within the application.
 *
 * It initializes and retrieves a collection of commands during instantiation.
 */
class Commands
{
    private Arrhae $commands;

    public function __construct()
    {
        $this->commands = $this->getCommands();
    }

    private function getCommands() : Arrhae
    {
        return Arrhae::make(
            items: [
                       //'install'          => new InstallCommand(),
                       'create:migration' => new MigrationGenerator(),
                   ]
        );
    }
}
=== Runner/Commands/Defined/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Defined;

/**
 * Class Migration
 *
 * This class defines a set of migration commands and their corresponding aliases.
 * It helps in standardizing the command names for various migration operations.
 */
class Migration
{
    /**
     * Get the list of migration commands and their aliases.
     *
     * This method returns an associative array mapping custom command names to
     * their actual migration command counterparts. The intent is to provide a
     * simpler and more standardized way to refer to common migration operations.
     *
     * @return array<string, string> Returns an associative array of command aliases.
     */
    public static function definedCommandAliases() : array
    {
        return [
            'migrate:up'       => 'migrate',
            'migrate:down'     => 'migrate:rollback',
            'migrate:reapply'  => 'migrate:refresh',
            'migrate:clean'    => 'migrate:fresh',
            'create:migration' => 'make:migration',
        ];
    }
}
=== Runner/Commands/InstallCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\MigrationException;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\SchemaBuilder;
use Psr\Log\LoggerInterface;
use RuntimeException;
use Throwable;

use function readline;
use function strtolower;
use function trim;

/**
 * InstallCommand handles the initial application setup.
 *
 * This final class is made readonly to ensure immutability after instantiation,
 * which enhances reliability and predictability in its behavior.
 */
final readonly class InstallCommand implements CommandInterface
{
    /**
     * The name of the migrations table used to track migrations.
     */
    private const string MIGRATIONS_TABLE = 'migrations';

    /**
     * Constructor for InstallCommand.
     *
     * @param SchemaBuilder                $schemaBuilder       Builder for database schemas.
     * @param LoggerInterface              $logger              Logger instance for logging events.
     * @param MigrationRepositoryInterface $migrationRepository Repository for handling migration records.
     */
    public function __construct(
        private SchemaBuilder                $schemaBuilder,
        private LoggerInterface              $logger,
        private MigrationRepositoryInterface $migrationRepository
    ) {}

    /**
     * Executes the command to set up the initial database and migrations.
     *
     * @param array $arguments Key-value array of arguments for the command.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in the process fails.
     */
    public function execute(array $arguments = []) : void
    {
        $database = $this->getDatabaseName(arguments: $arguments);
        $this->prepareDatabase(database: $database);
        $this->ensureMigrationsTableSetup();
        $this->recordSelfAsFirstMigration();
    }

    /**
     * Retrieves the database name from arguments or environment variables.
     *
     * Throws an exception if the database name is not found.
     *
     * @param array $arguments The command-line arguments passed to the script.
     *
     * @return string The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database name is not provided.
     */
    private function getDatabaseName(array $arguments) : string
    {
        $database = $arguments['database'] ?? env(key: 'DB_NAME') ?? null;
        if (! $database) {
            $this->logAndThrowMigrationException(message: 'Database name is required but was not provided.');
        }

        $this->logger->info(message: 'Preparing installation for database: ' . $database);

        return $database;
    }

    /**
     * Logs an error message and throws a MigrationException.
     *
     * This ensures that each failure point provides a consistent error handling strategy.
     *
     * @param string          $message  The error message to log and throw.
     * @param \Throwable|null $previous The previous exception for chaining, if any.
     *
     * @throws MigrationException Always thrown after logging the error.
     */
    private function logAndThrowMigrationException(string $message, Throwable|null $previous = null) : never
    {
        $this->logger->error(message: $message);
        throw new MigrationException(message: $message, previous: $previous);
    }

    /**
     * Prepares the database for the installation.
     *
     * Checks the database connection and ensures the existence of the database.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in preparation fails.
     */
    private function prepareDatabase(string $database) : void
    {
        $this->checkDatabaseConnection(database: $database);
        $this->ensureDatabaseExists(database: $database);
    }

    /**
     * Checks if the connection to the database is healthy.
     *
     * Throws an exception if the connection is not healthy, to ensure database operations are safe to proceed.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database connection is unhealthy.
     */
    private function checkDatabaseConnection(string $database) : void
    {
        if (! $this->schemaBuilder->isConnectionHealthy(database: $database)) {
            $this->logAndThrowMigrationException(
                message: sprintf("Failed to establish a healthy connection to the database '%s'.", $database)
            );
        }
    }

    /**
     * Ensures that the database exists, creating it if it does not.
     *
     * Logs and provides feedback to the user accordingly.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the database fails.
     */
    private function ensureDatabaseExists(string $database) : void
    {
        if (! $this->schemaBuilder->databaseExists(database: $database)) {
            $this->logger->info(message: sprintf("Database '%s' does not exist. Creating database...", $database));
            $this->schemaBuilder->createDatabase(database: $database);
            echo "Database '" . $database . "' created successfully.\n";
        } else {
            echo "Database '" . $database . "' already exists.\n";
        }
    }

    /**
     * Ensures the migrations table is set up correctly.
     *
     * This method handles the creation or recreation of the migrations table, providing feedback and
     * handling exceptions to maintain consistency in the setup process.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if setting up the migrations table fails.
     */
    private function ensureMigrationsTableSetup() : void
    {
        try {
            if (! $this->schemaBuilder->tableExists(table: self::MIGRATIONS_TABLE)) {
                $this->createMigrationsTable();
            } else {
                $this->promptRecreateMigrationsTable();
            }

            echo "Migration install completed.\n";
        } catch (RuntimeException $runtimeException) {
            $this->logAndThrowMigrationException(
                message : "Failed to set up migrations table: " . $runtimeException->getMessage(),
                previous: $runtimeException
            );
        }
    }

    /**
     * Creates the migrations table with the necessary columns.
     *
     * The table structure is defined within a callback to ensure consistent setup.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the migrations table fails.
     */
    private function createMigrationsTable() : void
    {
        try {
            $this->schemaBuilder->create(table: self::MIGRATIONS_TABLE, callback: static function ($table) : void {
                $table->id();
                $table->string('migration');
                $table->string('executable');
                $table->integer('batch');
                $table->timestamp('executed_at')->useCurrent();
            });
            $this->logger->info(message: 'Migrations table created successfully.');
            echo "Migrations table created successfully.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to create migrations table: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Prompts the user to recreate the migration table if it already exists.
     *
     * Provides options to drop and recreate the table or to skip this step.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if user opts to recreate and the operation
     *                                                                  fails.
     */
    private function promptRecreateMigrationsTable() : void
    {
        $choice = strtolower(
            trim(readline("The 'migrations' table already exists. Do you want to recreate it? [yes/no]: "))
        );
        if (in_array($choice, ['yes', 'y'], true)) {
            $this->schemaBuilder->drop(table: self::MIGRATIONS_TABLE);
            $this->logger->info(message: 'Old migrations table dropped.');
            echo "Old 'migrations' table dropped.\n";
            $this->createMigrationsTable();
        } else {
            echo "Skipped creating the 'migrations' table.\n";
        }
    }

    /**
     * Records this InstallCommand as the first migration in the migrations table.
     *
     * This method ensures that InstallCommand is logged as the first entry,
     * establishing the provenance of the migration system installation.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if saving the record fails.
     */
    private function recordSelfAsFirstMigration() : void
    {
        try {
            $this->migrationRepository->save(
                migration : 'CreateMigrationsTable',
                executable: self::class,
                batch     : 1
            );
            $this->logger->info(message: 'Recorded InstallCommand as the first migration.');
            echo "Recorded InstallCommand as the first migration.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to record the InstallCommand migration: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}
=== Runner/Commands/MakeMigrationCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\{Repository\RepositoryGenerator};
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\DTO\DtoGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityQueryBuilderGenerator;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MakeMigrationCommand
 *
 * This class manages the creation of migrations and optionally generates
 * related components like Entity, DTO, Repository, etc.
 */
final readonly class MakeMigrationCommand implements CommandInterface
{
    private const string        ERROR_MISSING_ARGUMENTS = "Migration name and table name are required.";

    private const        string ERROR_INVALID_FIELDS    = "Invalid fields format. Expected format: 'name:type:attr1,attr2'.";

    public function __construct(
        private MigrationGenerator          $migrationGenerator,
        private EntityGenerator             $entityGenerator,
        private EntityQueryBuilderGenerator $entityQueryBuilderGenerator,
        private DtoGenerator                $dtoGenerator,
        private RepositoryGenerator         $repositoryGenerator,
        private ServiceGenerator            $serviceGenerator,
        private MigrationStateManager       $migrationStateManager,
        private LoggerInterface             $logger
    ) {}

    /**
     * Executes the MakeMigration command.
     *
     * @param array $arguments Command-line arguments.
     */
    public function execute(array $arguments) : void
    {
        try {
            $input = new Arrhae($arguments);

            // Check for presence
            if (! $input->has(key: 'name') || ! $input->has(key: 'table')) {
                $this->reportError(message: self::ERROR_MISSING_ARGUMENTS);

                return;
            }

            $name  = $input->get(key: 'name');
            $table = $input->get(key: 'table');

            $fieldsInput = $input->get(key: 'fields', default: '');
            $fields      = $this->extractFields(fieldsInput: $fieldsInput);

            $this->generateMigration(name: $name, table: $table, fields: $fields);

            if ($input->get(key: 'entity', default: false)) {
                $this->generateEntity(name: $table, fields: $fields);
            }
            if ($input->get(key: 'entity-qb', default: false)) {
                $this->generateQueryBuilder(name: $table, table: $table, fields: $fields);
            }
            if ($input->get(key: 'dto', default: false)) {
                $this->generateDto(name: $table, fields: $fields);
            }
            if ($input->get(key: 'repository', default: false)) {
                $this->generateRepository(name: $table, fields: $fields);
            }
            if ($input->get(key: 'service', default: false)) {
                $this->generateService(name: $table);
            }
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    /**
     * Reports an error to the logger and echoes it.
     *
     * @param string $message The error message.
     */
    private function reportError(string $message) : void
    {
        $this->logger->error(message: $message);
        echo "Error: " . $message . "\n";
    }

    private function extractFields(string $fieldsInput) : array
    {
        // Wrap the fields into an Arrhae instance
        return (new Arrhae(items: explode(',', $fieldsInput)))
            ->filter(callback: fn($field) => ! empty($field)) // Filter out empty fields
            ->map(callback: function ($field) {
                $parts = explode(':', $field);
                if (count($parts) < 2) {
                    throw new InvalidArgumentException(message: self::ERROR_INVALID_FIELDS);
                }

                $name       = $parts[0];
                $type       = $parts[1];
                $attributes = array_slice($parts, 2);

                return $this->parseField(name: $name, type: $type, attributes: $attributes);
            })
            ->toArray(); // Convert back to a standard array
    }

    private function parseField(string $name, string $type, array $attributes) : array
    {
        // Wrap attributes in Arrhae for simplified handling
        return (new Arrhae(items: $attributes))
            ->reduce(
                callback: fn($fieldData, $attribute) => match (true) {
                    str_contains($attribute, 'default:') => array_merge(
                        $fieldData,
                        [
                            'default' => str_replace(
                                'default:',
                                '',
                                $attribute
                            ),
                        ]
                    ),
                    $attribute === 'unique'              => array_merge($fieldData, ['unique' => true]),
                    $attribute === 'nullable'            => array_merge($fieldData, ['nullable' => true]),
                    default                              => $fieldData
                },
                initial : ['name' => $name, 'type' => $type]
            );
    }

    private function generateMigration(string $name, string $table, array $fields) : void
    {
        try {
            $this->migrationGenerator->writeMigrationFile(name: $name, table: $table, fields: $fields);
            $this->migrationStateManager->migrate(availableMigrations: [$name]);
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    private function handleException(Throwable $e) : void
    {
        $errorMessage = sprintf(
            'Error: %s in %s on line %d',
            $e->getMessage(),
            $e->getFile(),
            $e->getLine()
        );
        $this->logger->error(message: $errorMessage);
        echo $errorMessage . "\n";
    }

    private function generateEntity(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('Entity %s created successfully.', $name)
        );
    }

    private function executeSafely(callable $operation, string $successMessage) : void
    {
        try {
            $operation();
            $this->logger->info(message: $successMessage);
            echo $successMessage . "\n";
        } catch (Throwable $throwable) {
            $this->handleException(e: $throwable);
        }
    }

    private function generateQueryBuilder(string $name, string $table, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityQueryBuilderGenerator->create(
                name  : $name,
                table : $table,
                fields: $fields
            ),
            successMessage: sprintf('Entity QueryBuilder %s created successfully.', $name)
        );
    }

    private function generateDto(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->dtoGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('DTO %s created successfully.', $name)
        );
    }

    private function generateRepository(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->repositoryGenerator->create(
                tableName: $name,
                entity   : $name,
                fields   : $fields
            ),
            successMessage: sprintf('Repository %s created successfully.', $name)
        );
    }

    private function generateService(string $name) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->serviceGenerator->create(name: $name),
            successMessage: sprintf('Service %s created successfully.', $name)
        );
    }
}

=== Runner/Commands/Middlewares/LoggingMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;

/**
 * Middleware for logging command execution.
 *
 * This middleware logs the execution of migration commands, both at the start and at the
 * completion of the command's execution. It helps to track command activities, useful for
 * debugging and auditing purposes.
 */
class LoggingMiddleware
{
    /**
     * Handles the command execution with logging.
     *
     * Logs the start and end of command execution, providing insights into command activities.
     *
     * @param array    $input                                               The input parameters for the command.
     * @param callable $next                                                The next middleware or the actual command
     *                                                                      execution.
     *
     */
    public function handle(CommandInterface $command, array $input, callable $next) : void
    {
        // Log the start of the command execution.
        logger(message: 'Executing command: ' . $command::class, context: $input, level: 'debug');

        // Proceed to the next middleware or actual command execution.
        $next();

        // Log the end of the command execution.
        logger(message: 'Command execution finished: ' . $command::class, context: [], level: 'debug');
    }
}
=== Runner/Commands/Middlewares/MiddlewareStack.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * A stack of middleware functions to be executed as a pipeline.
 *
 * - Extends Arrhae to manage the internal collection of middleware functions.
 * - Allows pushing middleware functions onto the stack.
 * - Executes the middleware functions in sequence, passing control to the `next` middleware.
 */
class MiddlewareStack extends Arrhae
{
    /**
     * Adds a middleware callable to the stack.
     *
     * This method allows chaining by returning the instance.
     *
     * @param callable $middleware The middleware to add.
     *
     * @return self The instance itself for method chaining.
     */
    public function push(callable $middleware) : self
    {
        $this->add($middleware);

        return $this;
    }

    /**
     * Executes the command by passing it through the middleware stack.
     *
     * - The method applies each middleware function to the command.
     * - Ensures that the `next` callable is eventually called.
     *
     * @param CommandInterface $command   The command to execute.
     * @param array            $arguments The arguments for the command.
     * @param callable         $next      The next middleware callable.
     */
    public function execute(
        CommandInterface $command,
        array            $arguments,
        callable         $next
    ) : void {
        // Middleware logic here, last middleware will eventually call $next()
        $next();
    }
}
=== Runner/Commands/MigrateCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MigrateCommand
 *
 * A final immutable class responsible for executing the migration process.
 * Implements CommandInterface to standardize command execution.
 *
 * The class is marked as readonly to enforce immutability ensuring
 * that its state cannot be altered after instantiation, adding robustness
 * and thread-safety.
 */
final readonly class MigrateCommand implements CommandInterface
{
    /**
     * MigrateCommand constructor.
     *
     * @param MigrationStateManager        $migrationStateManager Service to manage the state of migrations.
     * @param MigrationRepositoryInterface $migrationRepository   Repository to fetch available migrations.
     * @param LoggerInterface              $logger                Logger for recording operational events.
     */
    public function __construct(
        private MigrationStateManager        $migrationStateManager,
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface              $logger
    ) {}

    /**
     * Executes the migration process.
     *
     * This method orchestrates the entire migration process, logging important steps
     * and handling exceptions to ensure smooth operation.
     *
     * @param array $arguments CLI arguments or configuration parameters.
     *
     * @throws MigrationException If the migration process encounters an error.
     */
    public function execute(array $arguments = []) : void
    {
        try {
            $this->logger->info(message: 'Starting migration process.');
            echo "Starting migration process...\n";

            $availableMigrations = $this->fetchAvailableMigrations();
            $this->migrationStateManager->migrate(availableMigrations: $availableMigrations);

            $this->logger->info(message: 'Migration process completed successfully.');
            echo "Migration process completed successfully.\n";
        } catch (MigrationException $migrationException) {
            // Handle known migration-specific errors.
            $this->handleError(migrationException: $migrationException);
        } catch (Throwable $throwable) {
            // Handle unexpected errors that do not fall under MigrationException.
            $this->handleUnexpectedError(throwable: $throwable);
        }
    }

    /**
     * Fetches available migrations directly from the database.
     *
     * This encapsulates the retrieval logic from the repository, ensuring a single responsibility
     * and making it easy to modify data fetching strategy if required.
     *
     * @return array List of fully qualified migration class names.
     */
    private function fetchAvailableMigrations() : array
    {
        $migrations          = $this->migrationRepository->getAll();
        $availableMigrations = array_column($migrations, 'executable');

        $this->logger->info(message: 'Fetched available migrations.', context: ['migrations' => $availableMigrations]);

        return $availableMigrations;
    }

    /**
     * Handles migration-specific errors gracefully.
     *
     * This function centralizes error handling for migration exceptions, ensuring consistent
     * logging and error reporting which makes debugging easier.
     *
     * @param MigrationException $migrationException Exception to handle.
     */
    private function handleError(MigrationException $migrationException) : void
    {
        $this->logger->error(
            message: 'Migration process failed.',
            context: ['error' => $migrationException->getMessage()]
        );

        echo sprintf('Migration process failed: %s%s', $migrationException->getMessage(), PHP_EOL);
    }

    /**
     * Handles unexpected errors gracefully.
     *
     * Centralizes the handling of unknown or unexpected errors, ensuring that critical failures
     * are logged and reported consistently, making it easier to track issues.
     *
     * @param Throwable $throwable Exception to handle.
     */
    private function handleUnexpectedError(Throwable $throwable) : void
    {
        $this->logger->critical(
            message: 'An unexpected error occurred during the migration process.',
            context: ['error' => $throwable->getMessage()]
        );

        echo sprintf('Unexpected error: %s%s', $throwable->getMessage(), PHP_EOL);
    }
}
=== Runner/Commands/MigrateFreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateFreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Running fresh migrations...\n";
            $this->logger->info("Fresh migrations executed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error running fresh migrations: ' . $throwable->getMessage());
        }
    }
}
=== Runner/Commands/MigrateRefreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRefreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Refreshing migrations...\n";
            $this->logger->info("Migrations refreshed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error refreshing migrations: ' . $throwable->getMessage());
        }
    }
}
=== Runner/Commands/MigrateRollbackCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRollbackCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Rolling back migrations...\n";
            $this->logger->info("Migrations rolled back successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error rolling back migrations: ' . $throwable->getMessage());
        }
    }
}
=== Runner/Commands/MigrateStatusCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;

final readonly class MigrateStatusCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        echo "Migration status:\n";
        echo "[✓] Migration_001\n";
        echo "[✓] Migration_002\n";
        $this->logger->info("Migration status retrieved successfully.");
    }
}
=== Runner/Commands/ValidateStubsCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\StubResolver;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * ValidateStubsCommand Class
 *
 * Validates the existence and readability of stub files in the specified directory.
 */
readonly class ValidateStubsCommand implements CommandInterface
{
    public function __construct(
        private StubResolver    $stubResolver,
        private LoggerInterface $logger
    ) {}

    /**
     * Executes the stub validation command.
     *
     * @param array $arguments List of stub file names to validate.
     */
    public function execute(array $arguments) : void
    {
        if ($arguments === []) {
            $this->logger->error(message: "No stub files provided for validation.");
            echo "Error: No stub files provided for validation.\n";

            return;
        }

        foreach ($arguments as $argument) {
            try {
                // Attempt to read the stub file
                $this->stubResolver->read(stubName: $argument);

                // Log and output success message
                $this->logger->info(message: sprintf('Stub "%s" is valid.', $argument));
                echo sprintf("Stub \"%s\" is valid.\n", $argument);
            } catch (Throwable $e) {
                // Log and output error message
                $this->logger->error(
                    message: sprintf(
                                 'Stub "%s" validation failed: %s',
                                 $argument,
                                 $e->getMessage()
                             )
                );
                echo sprintf(
                    "Error: Stub \"%s\" validation failed: %s\n",
                    $argument,
                    $e->getMessage()
                );
            }
        }
    }
}

=== Runner/Console/CLI.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Console;

use Exception;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The CLI class handles command-line interactions for database migrations.
 * It utilizes the Arrhae collection class for managing commands and arguments,
 * providing enhanced flexibility and powerful data manipulation capabilities.
 *
 * Example Usage:
 * php gemini create:migration --name=CreateUsersTable
 */
class CLI
{
    /**
     * @var Arrhae The collection of available commands.
     */
    private Arrhae $commands;

    /**
     * CLI constructor.
     *
     * Initializes the commands collection using the Arrhae::make() factory method.
     */
    public function __construct()
    {
        // Initialize the command collection with Arrhae
        $this->commands = Arrhae::make(
            items: [
                       'make:migration' => new MigrationGenerator(),
                   ]
        );
    }

    /**
     * Executes the CLI command based on provided arguments.
     *
     * @param array $argv Command-line arguments.
     *
     * @return void
     */
    public function run(array $argv) : void
    {
        // Wrap the $argv array into an Arrhae collection for enhanced manipulation
        $args = Arrhae::make(items: $argv);

        // Check if at least one command is provided
        if ($args->count() < 2) {
            $this->displayUsage();
            exit(1);
        }

        // Retrieve the command name (second argument)
        $commandName = $args->get(key: 1);

        // Format the arguments using the Arrhae-based method
        $arguments = $this->formatArguments(args: $args->slice(offset: 2));

        // Check if the command exists in the collection
        if (! $this->commands->has(key: $commandName)) {
            echo "Command not found: {$commandName}\n";
            $this->suggestSimilarCommands(commandName: $commandName);
            exit(1);
        }

        // Retrieve the command instance
        $command = $this->commands->get(key: $commandName);

        // Ensure the command is executable
        if (! method_exists($command, 'execute')) {
            echo "Command '{$commandName}' is not executable.\n";
            exit(1);
        }

        // Execute the command with the formatted arguments
        try {
            $command->execute($arguments->toArray());
        } catch (Exception $e) {
            echo "Error executing command '{$commandName}': " . $e->getMessage() . "\n";
            exit(1);
        }
    }

    /**
     * Displays the usage instructions for the CLI.
     *
     * @return void
     */
    private function displayUsage() : void
    {
        echo "Usage: php gemini <command> [options]\n";
        echo "Available Commands:\n";
        echo $this->commands->keys()->map(static fn($command) => "  - {$command}")->implode("\n") . "\n";
    }

    /**
     * Formats command-line arguments into a structured Arrhae collection.
     *
     * This method parses arguments to handle both flag-style (e.g., --key=value)
     * and positional arguments, assigning the first positional argument to 'name'.
     *
     * @param Arrhae $args Raw command-line arguments (excluding script name and command name).
     *
     * @return Arrhae Formatted arguments as an Arrhae collection.
     */
    private function formatArguments(Arrhae $args) : Arrhae
    {
        // Use Arrhae's filtering and mapping capabilities to parse arguments
        return $args
            ->filter(callback: static fn($arg, $key) => is_string($arg) && $key !== 0) // Exclude script name
            ->mapWithKeys(callback: static function ($arg) {
                if (str_starts_with($arg, '--')) {
                    // Parse --key=value arguments
                    $keyValue = substr($arg, 2);
                    $parts    = explode('=', $keyValue, 2);

                    $key = $parts[0];
                    $value = $parts[1] ?? true; // Assign true if no value is provided

                    return [$key => $value];
                } elseif (! str_starts_with($arg, '--') && ! isset($arg)) {
                    // Assign the first positional argument to 'name'
                    return ['name' => $arg];
                }

                return [];
            })
            // Ensure 'name' is set if a positional argument exists
            ->when(
                condition: $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'))->count() > 0,
                callback : function ($collection) use ($args) {
                    $positionalArgs = $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'));

                    return $collection->set('name', $positionalArgs->first());
                }
            );
    }

    /**
     * Suggests similar commands if the provided command is not found.
     *
     * @param string $commandName The command name that was not found.
     *
     * @return void
     */
    private function suggestSimilarCommands(string $commandName) : void
    {
        // Wrap the keys into an Arrhae instance to use fuzzyMatch
        $similarCommands = Arrhae::make(items: $this->commands->keys())
            ->fuzzyMatch(query: $commandName, threshold: 60)
            ->toArray();

        if (! empty($similarCommands)) {
            echo "Did you mean:\n";
            echo Arrhae::make(items: $similarCommands)
                     ->map(callback: fn($cmd) => "  - {$cmd}")
                     ->implode("\n") . "\n";
        }
    }
}

=== Runner/DTO/FieldDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Gemini\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationArrayRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldAttributesRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldTypeRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationForeignActionRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationIntegerRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationStringRule;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;
use InvalidArgumentException;

final class FieldDTO extends AbstractDTO
{
    #[Required]
    #[Trimmed]
    #[StringType]
    public string                 $name;

    #[MigrationFieldTypeRule]
    public FieldTypeEnum|null     $type       = null;

    #[MigrationIntegerRule]
    public int|null               $length     = null;

    #[MigrationIntegerRule]
    public int|null               $total      = null;

    #[MigrationIntegerRule]
    public int|null               $places     = null;

    #[MigrationArrayRule]
    public array|null             $values     = null;

    public mixed                  $default    = null;

    #[MigrationFieldAttributesRule]
    public array|null             $attributes = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $comment    = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $references = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $on         = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onDelete   = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onUpdate   = null;

    public function __construct(array|object $data)
    {
        $data = (array) $data;

        if (isset($data['name'], $data['type'])) {
            parent::__construct(data: $data);

            return;
        }

        $fieldName  = array_key_first($data);
        $definition = (array) ($data[$fieldName] ?? []);

        if (! isset($definition['type'])) {
            throw new InvalidArgumentException("Missing required 'type' key for field '{$fieldName}'");
        }

        $definition['name'] = $fieldName;
        parent::__construct(data: $definition);
    }
}

=== Runner/DTO/MigrationDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\DTOObjectOf;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;

/**
 * Data Transfer Object (DTO) for handling migration creation requests.
 *
 * This class acts as an intermediate structure for carrying data between
 * different layers/domain boundaries. It validates input data and ensures all
 * necessary properties conform to their expected types or constraints.
 *
 * Each property of the DTO is initialized and validated through the parent
 * `AbstractDTO` class's constructor.
 *
 * @package Application\DTO
 */
class MigrationDTO extends AbstractDTO
{
    /**
     * The name of the migration class (in PascalCase format).
     *
     * - This represents the high-level name of the migration and is expected to follow coding standards.
     * - This property is subject to trimming and validation rules for string-based input.
     *
     * Example:
     * ```
     * $migrationDTO->name = 'CreateUsersTable';
     * ```
     *
     * @var string Represents the name of the migration class.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be of type string.
    #[Required]
    public string $name;

    /**
     * The name of the database table being targeted or created by the migration.
     *
     * - This represents the physical table name in the database schema.
     * - It undergoes trimming and validation (must be a non-empty string).
     *
     * Example:
     * ```
     * $migrationDTO->table = 'users';
     * ```
     *
     * @var string Represents the target database table for the migration.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be a non-empty string.
    #[Required]
    public string $table;

    /**
     * The schema property representing a complex structure for validation.
     *
     * @var SchemaDTO A data transfer object containing structured schema information.
     */
    #[Required]
    #[DTOObjectOf(SchemaDTO::class)]
    public SchemaDTO $schema;

    public function __construct(array $data = [])
    {
        parent::__construct($data);
//        dd($this, '📦 DTO NAKON HYDRACIJE');
    }
}
=== Runner/DTO/MigrationRecordDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Integer;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * DTO representing a single migration record.
 *
 * Used to transfer structured migration metadata (name, SQL, batch, time).
 */
final class MigrationRecordDTO extends AbstractDTO
{
    #[Required(message: 'Migration name is required.')]
    #[StringType(message: 'Migration must be a string.')]
    public string $migration;

    #[Required(message: 'Executable is required.')]
    #[StringType(message: 'Executable must be a string.')]
    public string $executable;

    #[Required(message: 'Batch ID is required.')]
    #[Integer(message: 'Batch must be an integer.')]
    public int    $batch;

    #[Required(message: 'Execution time is required.')]
    #[StringType(message: 'Execution time must be a valid datetime string.')]
    public string $executed_at;
}

=== Runner/DTO/SchemaDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object (DTO) representing a database schema.
 *
 * Primary purpose:
 * - Facilitates the consistent and strongly typed representation of schema-related data throughout the system.
 * - Encapsulates and validates an array of fields, where each field is defined by an instance of `FieldDTO`.
 *
 * Leveraging DDD Practices:
 * - Serves as a Boundary Data Design for interaction between application layers.
 * - Ensures domain consistency by enforcing attribute-based validations (e.g., `#[Required]`, `#[ArrayType]`).
 *
 * @package Application\DTO
 */
class SchemaDTO extends AbstractDTO
{
    /**
     * A list of field definitions forming a database schema.
     *
     * - Represents the core building blocks of a database schema (e.g., columns, field attributes).
     * - Each field within the array is strongly typed as `FieldDTO`, ensuring schema integrity.
     *
     * Validation Requirements:
     * - **Required:** `fields` must be present and cannot be `null`.
     * - **ArrayType:** It must be an array of well-formed `FieldDTO` instances.
     *
     * @var \Gemini\Database\Migration\Runner\DTO\FieldDTO[] $fields
     *
     */
    #[Required]
    #[ArrayType]
    public array $fields;
}
=== Runner/Entity/Migration.php ===
<?php

declare(strict_types=1);

/**
 * Class Migration
 *
 * This class represents a Migration entity in the domain layer. It encapsulates:
 * - The name of the migration.
 * - The date and time when the migration was executed.
 *
 * Responsibilities:
 * - Store and provide access to migration-related data.
 * - Offer additional utilities for validation and serialization.
 *
 * Adheres to:
 * - Single Responsibility Principle (SRP): Only holds migration-specific data and logic.
 * - Immutability: The properties are set at construction and cannot be changed afterward.
 */

namespace Gemini\Database\Migration\Runner\Entity;

use DateTimeImmutable;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use JsonSerializable;

/**
 * The Migration class represents a database migration.
 * It stores the migration's name and the date/time of its execution.
 *
 * Features:
 * - Provides methods to retrieve migration details.
 * - Implements validation for robust handling of migration data.
 * - Supports JSON serialization for external APIs or storage.
 */
class Migration implements JsonSerializable
{
    /**
     * Constructor for the Migration class.
     *
     * @param string            $migrationName The name of the migration (must be non-empty).
     * @param DateTimeImmutable $executedAt    The date and time the migration was executed.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    public function __construct(
        protected string            $migrationName,
        protected DateTimeImmutable $executedAt,
        protected QueryBuilder      $queryBuilder
    ) {
        $this->validateMigrationName(migrationName: $migrationName);
    }

    /**
     * Validates the migration name.
     *
     * @param string $migrationName The name of the migration.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    private function validateMigrationName(string $migrationName) : void
    {
        if (trim($migrationName) === '') {
            throw new InvalidArgumentException(message: 'Migration name cannot be empty.');
        }

        if (strlen($migrationName) > 255) {
            throw new InvalidArgumentException(message: 'Migration name cannot exceed 255 characters.');
        }
    }

    /**
     * Creates a Migration instance from an array of data.
     *
     * @param array $data An associative array containing 'migration_name' and 'executed_at' keys.
     *
     * @return static A new Migration instance created from the provided data.
     * @throws \InvalidArgumentException If required, data is missing or invalid.
     */
    public static function fromArray(array $data) : self
    {
        if (! isset($data['migration_name'], $data['executed_at'])) {
            throw new InvalidArgumentException(message: 'Missing required keys: "migration_name" and "executed_at".');
        }

        $executedAt = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', $data['executed_at']);
        if ($executedAt === false) {
            throw new InvalidArgumentException(
                message: 'Invalid date format for "executed_at". Expected "Y-m-d H:i:s".'
            );
        }

//        return new self(
//            migrationName: $data['migration_name'],
//            executedAt   : $executedAt,
//            queryBuilder : $this->queryBuilder
//        );
    }

    /**
     * Alias for `getMigrationName`, used for compatibility with other systems.
     *
     * @return string The name of the migration.
     */
    public function getName() : string
    {
        return $this->getMigrationName();
    }

    /**
     * Retrieves the name of the migration.
     *
     * @return string The name of the migration.
     */
    public function getMigrationName() : string
    {
        return $this->migrationName;
    }

    /**
     * Gets the date and time when the migration was executed.
     *
     * @return DateTimeImmutable The datetime representing when the migration was executed.
     */
    public function getExecutedAt() : DateTimeImmutable
    {
        return $this->executedAt;
    }

    /**
     * Prepares the migration instance for JSON serialization.
     *
     * @return array The migration data ready for JSON encoding.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Converts the migration instance to an associative array.
     *
     * @return array The migration data as an associative array.
     */
    public function toArray() : array
    {
        return [
            'migration_name' => $this->migrationName,
            'executed_at'    => $this->executedAt->format(format: 'Y-m-d H:i:s'),
        ];
    }
}

=== Runner/Enum/MigrationStatus.php ===
<?php

/**
 * Migration Status Value Object
 *
 * This file is part of the Gemini Database Migration System.
 *
 * @copyright Gemini Team 2024
 */

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Enum;

/**
 * MigrationStatus Value Object represents the lifecycle states of a database migration.
 *
 * This immutable enum encapsulates all possible states a migration can transition through
 * during its lifecycle, ensuring type safety and domain integrity. Each state represents
 * a distinct phase in the migration process, making the domain model explicit and enforcing
 * business rules through type constraints.
 *
 * @api
 * @final
 * @since   1.0.0
 * @package Gemini\Database\Migration
 */
enum MigrationStatus: string
{
    /**
     * Represents a migration that is scheduled but not yet executed.
     * This is the initial state of any new migration.
     */
    case Pending = 'pending';

    /**
     * Represents a migration that has been successfully applied to the database.
     * Transitions from Pending state after successful execution.
     */
    case Executed = 'executed';

    /**
     * Represents a migration that has been reversed to its previous state.
     * Only migrations in Executed state can transition to RolledBack.
     */
    case RolledBack = 'rolled_back';

    /**
     * Represents a migration that encountered an error during execution or rollback.
     * Can transition from any state when an operation fails.
     */
    case Failed = 'failed';

    /**
     * Determines if the migration can be executed.
     *
     * @return bool True if the migration is in a state where it can be executed
     */
    public function canBeExecuted() : bool
    {
        return $this === self::Pending || $this === self::RolledBack;
    }

    /**
     * Determines if the migration can be rolled back.
     *
     * @return bool True if the migration is in a state where it can be rolled back
     */
    public function canBeRolledBack() : bool
    {
        return $this === self::Executed;
    }
}
=== Runner/Exception/MigrationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Exception;

use RuntimeException;
use Throwable;

/**
 * MigrationException
 *
 * Represents errors that occur during the migration process.
 * Extends RuntimeException to provide context-specific information for migration failures.
 */
class MigrationException extends RuntimeException
{
    /**
     * Constructor for the MigrationException.
     *
     * @param string         $message  The error message describing the issue.
     * @param int            $code     An optional error code for categorizing the error.
     * @param Throwable|null $previous Optional previous exception for chained exceptions.
     */
    public function __construct(string $message, int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Provides a string representation of the exception for debugging purposes.
     *
     * @return string A detailed message including the exception class and message.
     */
    public function __toString() : string
    {
        return sprintf(
            "[%s]: %s in %s on line %d\nStack trace:\n%s",
            static::class,
            $this->getMessage(),
            $this->getFile(),
            $this->getLine(),
            $this->getTraceAsString()
        );
    }
}

=== Runner/Execution/MigrationExecutionServiceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

/**
 * Interface MigrationExecutionServiceInterface
 *
 * Defines high-level operations for applying, rolling back,
 * and previewing schema migrations in a transactional and declarative manner.
 */
interface MigrationExecutionServiceInterface
{
    /**
     * Executes all pending migrations in order.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function executeUp() : void;

    /**
     * Rolls back the most recent batch of migrations.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function rollbackBatch() : void;

    /**
     * Simulates execution and returns SQL preview.
     *
     * @return array<string>
     */
    public function pretend() : array;
}

=== Runner/Execution/MigrationExecutionService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

use Gemini\Database\Migration\Runner\Migration;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Concrete implementation for executing migration logic.
 */
final readonly class MigrationExecutionService implements MigrationExecutionServiceInterface
{
    public function __construct(private LoggerInterface $logger) {}

    /**
     * @throws \Throwable
     */
    public function runUp(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration UP: " . $migration::class);
            $migration->executeUp();
            $this->logger->info(message: "Migration UP completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration UP failed: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * @throws \Throwable
     */
    public function runDown(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration DOWN: " . $migration::class);
            $migration->executeDown();
            $this->logger->info(message: "Migration DOWN completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration DOWN failed: " . $e->getMessage());
            throw $e;
        }
    }
}

=== Runner/Generators/AbstractGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Facade\Facades\Storage;
use RuntimeException;

/**
 * AbstractGenerator
 *
 * Provides reusable foundational logic for migration file generation.
 * Adheres to Clean Architecture and modern DSL philosophy.
 */
abstract class AbstractGenerator
{
    /**
     * Retrieves the contents of a stub file used as a template.
     *
     * @param string $stubName The name of the stub file to retrieve (e.g., 'create.stub').
     *
     * @return string The contents of the stub.
     * @throws RuntimeException If the stub file is missing.
     */
    protected function getStub(string $stubName) : string
    {
        $stubPath = $this->resolveStubPath(stubName: $stubName);

        if (! Storage::exists($stubPath)) {
            throw new RuntimeException(message: sprintf('Stub "%s" not found at path: %s', $stubName, $stubPath));
        }

        return Storage::read($stubPath);
    }

    /**
     * Resolves the absolute path to the specified stub file.
     *
     * @param string $stubName The filename of the stub.
     *
     * @return string The resolved absolute path.
     */
    private function resolveStubPath(string $stubName) : string
    {
        return AppPath::STUBS_PATH->get() . $stubName;
    }

    /**
     * Replaces all placeholders in a stub string with provided values.
     *
     * @param string                $stub         The original stub content.
     * @param array<string, string> $placeholders Array of placeholders and replacement values.
     *
     * @return string The updated stub content.
     */
    protected function replacePlaceholders(string $stub, array $placeholders) : string
    {
        foreach ($placeholders as $placeholder => $value) {
            $stub = str_replace(sprintf('{{%s}}', $placeholder), $value, $stub);
        }

        return $stub;
    }

    /**
     * Writes content to a file and applies secure permissions.
     *
     * @param string $path    The absolute file path.
     * @param string $content The content to write to disk.
     *
     * @throws RuntimeException On write or permission failure.
     */
    protected function writeToFile(string $path, string $content) : void
    {
        $directory = dirname($path);

        // Create a directory if it doesn't exist
        if (! Storage::exists($directory)) {
            Storage::createDirectory($directory);
        }

        // Throws if writing to a file fails
        if (! Storage::write($path, $content)) {
            throw new RuntimeException(message: 'Failed to write file at path: ' . $path);
        }

        $permissions = config(key: 'app.filePermissions', default: 0666);

        if (! Storage::setPermissions($path, $permissions)) {
            throw new RuntimeException(message: 'Failed to set permissions for file: ' . $path);
        }

        $this->setFileOwnership($path);
    }

    /**
     * Ensures the file has appropriate ownership metadata for local development.
     *
     * @param string $path Absolute path of the file.
     */
    private function setFileOwnership(string $path) : void
    {
        if (PHP_OS_FAMILY === 'Linux' || PHP_OS_FAMILY === 'Darwin') {
            $uid = getmyuid() ?: getenv('UID') ?: 1000;
            $gid = getmygid() ?: getenv('GID') ?: 1000;

            shell_exec(sprintf('chown %d:%d %s', $uid, $gid, escapeshellarg($path)));
        }
    }

    /**
     * Resolves the appropriate filesystem path for a given namespace.
     *
     * @param string $namespace The target namespace.
     * @param string $name      The base class name (without extension).
     *
     * @return string Fully qualified file path.
     * @throws RuntimeException If no config path is found for the namespace.
     */
    protected function resolvePath(string $namespace, string $name) : string
    {
        $type = array_keys(config(key: 'app.namespaces'), $namespace, true)[0] ?? null;
        $path = config(key: 'app.paths.' . $type);

        if (! $path) {
            throw new RuntimeException(
                message: sprintf('Path for %s is not defined in app.php configuration.', $namespace)
            );
        }

        return rtrim(base_path(), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . rtrim((string) $path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . ($name . '.php');
    }
}
=== Runner/Generators/Code/BlueprintCodeGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Code;

use Gemini\Database\Migration\Design\Table\Table;
use RuntimeException;

/**
 * Class BlueprintCodeGenerator
 *
 * Responsible for converting an instance of the Table class into
 * syntactically valid PHP schema definition statements (e.g. `$table->string('name')...`).
 *
 * This class is used during migration stub rendering to inject generated code
 * for table schema directly from the domain blueprint object.
 *
 * @package Gemini\Database\Migration\Generators\Code
 */
final readonly class BlueprintCodeGenerator
{
    /**
     * Indentation used for formatting output.
     *
     * @var string
     */
    private const string INDENT = '            ';

    /**
     * Generates formatted PHP code lines from the given Table object.
     *
     * @param Table $blueprint The domain object containing table column definitions.
     *
     * @return string Fully formatted PHP schema definition lines suitable for migration stub.
     *
     * @throws RuntimeException If blueprint contains invalid structures or unsupported definitions.
     */
    public function generate(Table $blueprint) : string
    {
        // Retrieve all raw column definitions from the Table instance.
        $columns = $blueprint->getRawColumnDefinitions();

        // Check for an empty schema and return a placeholder comment if needed.
        if (empty($columns)) {
            return self::INDENT . '// No schema defined in Table.';
        }

        // Map each raw SQL/DSL definition into a properly indented PHP statement.
        $lines = array_map(
            static fn(string $line) : string => self::INDENT . '$table->addColumn(' . var_export($line, true) . ');',
            $columns
        );

        // Join all formatted lines into a single block.
        return implode(PHP_EOL, $lines);
    }
}

=== Runner/Generators/CommandInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

/**
 * Interface CommandInterface
 *
 * Describes a blueprint for CLI commands in the Gemini framework.
 * Any CLI command in the Gemini system should implement this interface to ensure consistency.
 */
interface CommandInterface
{
    /**
     * Executes the command with provided arguments.
     *
     * The method signature enforces strict typing by using `array` for arguments and
     * `void` for the return type, which aligns with the goals of type safety and clarity.
     *
     * @param array $arguments Arguments passed to the command.
     *
     * Important to note:
     * - The method does not return anything (`void`), reflecting that CLI commands typically
     *   produce their outcome directly via output or side effects (like writing to a file).
     * - This interface ensures any implementing class will provide its own specific logic
     *   for executing commands, maintaining a standard method signature for execution.
     */
    public function execute(array $arguments) : void;
}
=== Runner/Generators/Controller/ControllerGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Controller;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * ControllerGenerator Class
 *
 * This final class is responsible for generating RESTful controllers based on a given name.
 * It inherits from AbstractGenerator, ensuring reusable code for common generator functionalities.
 */
final class ControllerGenerator extends AbstractGenerator
{
    /**
     * Creates a RESTful controller class file.
     *
     * @param string $name The name of the controller to be generated.
     *
     * This method constructs a namespace and path for controller files using
     * configuration variables. If these configurations are missing, it throws an exception.
     * The class name is generated, and a stub file is loaded and customized with placeholders.
     * Finally, the customized stub is written to the appropriate file path.
     *
     * @throws RuntimeException If the namespace or path configuration is missing, or if file operations fail.
     */
    public function create(string $name) : void
    {
        // Retrieve the namespace and path for controllers from the configuration
        $namespace = config(key: 'app.namespaces.Controllers');
        $path      = config(key: 'app.paths.Controllers');

        // Ensure both namespace and path are configured
        if ($namespace === null || $path === null) {
            throw new RuntimeException(message: 'Controllers namespace or path is not configured.');
        }

        // Generate the class name for the controller
        $className = $this->generateMigrationClassName(tableName: $name, type: 'controller');

        // Load the controller stub and replace placeholders
        $stub = $this->getStub(stubName: 'controller.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'ControllerName' => $className,
            'namespace'      => $namespace,
        ]);

        // Resolve the file path for the new controller and write the customized stub content
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Runner/Generators/DTO/DtoGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\DTO;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Class DtoGenerator
 *
 * A final class responsible for generating DTO (Data Transfer Object)
 * classes based on a given table name and its fields.
 *
 * @package Gemini\Database\Migration\Generators
 */
final class DtoGenerator extends AbstractGenerator
{
    /**
     * Generate and create a DTO class file based on provided table name and fields.
     *
     * @param string $tableName The name of the table to generate the DTO for.
     * @param array  $fields    An associative array of fields where 'type' and 'name' are defined.
     *
     * @throws RuntimeException If DTO paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Retrieve DTO namespace and path from configuration
        $namespace = config(key: 'app.namespaces.DTO');
        $path      = config(key: 'app.paths.DTO');

        // Ensure namespace and path are configured
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'DTO paths or namespaces are not configured correctly.');
        }

        // Generate the class name using the AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'dto');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'dto.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'DTOName'    => $className,
            'Namespace'  => $namespace,
            'Properties' => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate formatted properties for the DTO class.
     *
     * @param array $fields An array of fields with 'type' and 'name'.
     *
     * @return string Formatted properties as strings.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    public %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types.
     *
     * @param string $type The database type (e.g., 'string', 'int').
     *
     * @return string The corresponding PHP type (e.g., 'string', 'int') or 'mixed' if not mapped.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Runner/Generators/Entity/EntityGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Final class for generating entity classes based on table schema.
 * Extends the AbstractGenerator for reusing the generator logic.
 */
final class EntityGenerator extends AbstractGenerator
{
    /**
     * Create an entity class file for the given table and fields.
     *
     * @param string $tableName The name of the table.
     * @param array  $fields    The fields' definitions of the table.
     *
     * @throws RuntimeException If paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Load namespace and path from configuration.
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');

        // If a namespace or path is not configured, throw an exception.
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method.
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'  => $className,
            'Namespace'   => $namespace,
            'Properties'  => $this->generateProperties(fields: $fields),
            'Constructor' => $this->generateConstructor(fields: $fields),
            'Methods'     => $this->generateMethods(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate class properties for the given fields.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Convert database field types to corresponding PHP types.
     *
     * @param string $type The database field type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }

    /**
     * Generate constructor method for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated constructor.
     */
    private function generateConstructor(array $fields) : string
    {
        // Arguments for the constructor.
        $args = implode(
            ', ',
            array_map(
                fn($field) : string => sprintf(
                    '%s|null $%s = null',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );

        // Property assignments in the constructor.
        $assignments = implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf('        $this->%s = $%s;', $field['name'], $field['name']),
                $fields
            )
        );

        return <<<PHP
            public function __construct({$args})
            {
                {$assignments}
            }
            PHP;
    }

    /**
     * Generate getter and setter methods for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated methods.
     */
    private function generateMethods(array $fields) : string
    {
        $methods = array_map(function (array $field) : string {
            // Generating getter method.
            $getter = <<<PHP
                public function get{$this->camelCase(name: $field['name'])}(): ?{$this->mapType(type: $field['type'])}
                {
                    return \$this->{$field['name']};
                }
                PHP;

            // Generating setter method.
            $setter = <<<PHP
                                                            public function set{$this->camelCase(
                    name: $field['name']
                )}({$this->mapType(
                    type: $field['type']
                )} \${$field['name']}): self
                                                            {
                                                                \$this->{$field['name']} = \${$field['name']};
                                                                return \$this;
                                                            }
                PHP;

            return "{$getter}\n\n{$setter}";
        }, $fields);

        return implode(PHP_EOL, $methods);
    }

    /**
     * Convert snake_case to CamelCase.
     *
     * @param string $name The string in snake_case.
     *
     * @return string The string converted to CamelCase.
     */
    private function camelCase(string $name) : string
    {
        return ucfirst(
            str_replace(
                ' ',
                '',
                ucwords(
                    str_replace('_', ' ', $name)
                )
            )
        );
    }
}
=== Runner/Generators/Entity/EntityQueryBuilderGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * EntityQueryBuilderGenerator Class
 *
 * Generates PHP entity classes with integrated query builder functionality.
 * Designed to automate generation of entity classes with standard CRUD operations.
 */
final class EntityQueryBuilderGenerator extends AbstractGenerator
{
    /**
     * Create a new entity class with integrated query builder methods.
     *
     * @param string $name   The name of the entity class to create.
     * @param string $table  The name of the database table associated with the entity.
     * @param array  $fields The fields to include in the entity class.
     *
     * @throws RuntimeException if necessary configuration is missing.
     */
    public function create(string $name, string $table, array $fields) : void
    {
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name based on the table and entity type.
        $className = $this->generateMigrationClassName(tableName: $table, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity-querybuilder.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'   => $className,
            'TableName'    => $table,
            'Namespace'    => $namespace,
            'QueryMethods' => $this->generateQueryMethods(),
            'Properties'   => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate standard query methods for the entity.
     *
     * @return string The PHP code for query methods.
     *
     * Methods include common CRUD operations to make entity management straightforward.
     */
    private function generateQueryMethods() : string
    {
        return <<<PHP
            public function find(int \$id): ?self
            {
                \$result = \$this->where('id', '=', \$id)->first();
                return \$result ? (new static())->fillFromArray(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->get();
                return array_map(fn(array \$data) => (new static())->fillFromArray(\$data), \$results);
            }
            
            public function save(): bool
            {
                \$data = get_object_vars(\$this);
                if (!empty(\$data['id'])) {
                    return \$this->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->insertGetId(\$data);
                if (\$id) {
                    \$this->id = \$id;
                    return true;
                }
            
                return false;
            }
            
            public function delete(): bool
            {
                if (empty(\$this->id)) {
                    throw new \RuntimeException('Cannot delete an unsaved entity.');
                }
                return \$this->where('id', '=', \$this->id)->delete();
            }
            
            public function fillFromArray(array \$data): self
            {
                foreach (\$data as \$key => \$value) {
                    if (property_exists(\$this, \$key)) {
                        \$this->{\$key} = \$value;
                    }
                }
                return \$this;
            }
            PHP;
    }

    /**
     * Generate properties for the entity class based on given fields.
     *
     * @param array $fields The fields to include in the entity class.
     *
     * @return string The PHP code for entity properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn(array $field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types for entity properties.
     *
     * @param string $type The database type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Runner/Generators/Migration/MigrationGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Migration;

use DateTimeImmutable;
use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use Gemini\Database\Migration\Runner\DTO\MigrationDTO;
use Gemini\Database\Migration\Runner\Enum\MigrationStatus;
use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;
use Gemini\Database\Migration\Runner\Manifest\ManifestStoreInterface;
use RuntimeException;

/**
 * Generates migration classes using Gemini's Domain-Specific Language (DSL).
 *
 * This generator is responsible for transforming structured migration metadata (DTOs)
 * into concrete PHP migration classes. It implements a robust templating system
 * to ensure consistent and maintainable migration file generation.
 *
 * @final    This class is final to prevent inheritance and maintain encapsulation
 * @package  Gemini\Database\Migration\Runner\Generators\Migration
 * @since    8.3.0
 */
final class MigrationGenerator extends AbstractGenerator
{
    /**
     * Template file name used for generating migration classes.
     *
     * This constant defines the stub file that serves as a template for all
     * generated migration classes.
     *
     * @var string
     */
    private const string MIGRATION_STUB = 'anonymous-migration.stub';

    /**
     * Constructs a new instance of the migration generator.
     *
     * This constructor implements the Constructor Promotion pattern (PHP 8.0+) for a cleaner,
     * more maintainable dependency injection. It follows Domain-Driven Design principles
     * by accepting a mapper strategy that encapsulates the field-to-DSL mapping logic.
     *
     * @param FieldToDslMapperInterface $mapper Strategy pattern implementation responsible for
     *                                          mapping field definitions to DSL representations
     *
     * @throws \InvalidArgumentException If the mapper implementation is invalid
     *
     * @since 8.3.0
     */
    public function __construct(
        private readonly FieldToDslMapperInterface $mapper,
        private readonly ManifestStoreInterface    $manifestStore,
    ) {}

    /**
     * Orchestrates the creation of a new database migration file.
     *
     * This method serves as the primary entry point for migration generation,
     * implementing the Command pattern through DTO-based input. It delegates the
     * actual file writing to specialized private methods, maintaining separation
     * of concerns.
     *
     * @param MigrationDTO $dto Data Transfer Object containing migration specifications
     *                          including name, table, and schema information
     *
     * @return void
     * @throws \ReflectionException
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */

    public function generateMigration(MigrationDTO $dto) : void
    {
        // Step 1: Generate migration file and obtain its full path
        $filePath = $this->writeMigrationFile(
            fileName: $dto->name,
            table   : $dto->table,
            fields  : $dto->schema->fields
        );

        // Step 2: Build Manifest Entry DTO
        $manifestEntryDTO = new CreateManifestEntryDTO(
            [
                'migration'      => $dto->name,
                'file'           => basename($filePath),
                'status'         => MigrationStatus::Pending->value,
                'hash'           => hash_file('sha256', $filePath),
                'batch'          => null,
                'executed_at'    => null,
                'rolled_back_at' => null,
                'tenant_id'      => null,
                'tags'           => [],
                'logs'           => [],
                'created_at'     => new DateTimeImmutable(),
            ]
        );

        // Step 3: Store manifest entry
        $this->manifestStore->createEntry($manifestEntryDTO);

        // Step 4: Provide user feedback
        echo "🛠️ Migration '{$dto->name}' and manifest entry created successfully.\n";
    }


    /**
     * Handles the core migration file generation process.
     *
     * This method orchestrates the complete workflow of creating a new database migration file:
     * 1. Validates and retrieves configuration settings
     * 2. Generates the necessary file naming parts
     * 3. Prepares content placeholders
     * 4. Generates and writes the final migration file
     *
     * @param string     $fileName The base name for the migration class (PascalCase)
     * @param string     $table    The target database table name
     * @param FieldDTO[] $fields   Collection of field specifications for table schema
     *
     */
    private function writeMigrationFile(
        string $fileName,
        string $table,
        array  $fields
    ) : string {
        // Retrieve critical configuration settings for migration generation
        $namespace = config(key: 'app.namespaces.Migrations');
        $path      = config(key: 'app.paths.Migrations');

        // Validate configuration presence to ensure proper setup
        if (! ($namespace && $path)) {
            throw new RuntimeException(
                message: "Migration paths or namespaces are misconfigured."
            );
        }

        // Generate timestamp for unique migration file naming
        $timestamp = $this->generateTimestamp();

        // Transform file name into appropriate formats for different uses
        $className = ucfirst($fileName);
        $snakeName = $this->toSnakeCase(string: $fileName);

        // Prepare template placeholders with migration-specific values
        $placeholders = [
            'MigrationName' => $className,
            'Namespace'     => $namespace,
            'TableName'     => $table,
            'Fields'        => $this->generateMigrationTableFields(fields: $fields),
        ];

        // Generate migration content by applying placeholders to the template
        $stubContent = $this->replacePlaceholders(
            stub        : $this->getStub(stubName: self::MIGRATION_STUB),
            placeholders: $placeholders
        );

        // Construct the final file path for the migration
        $finalPath = $this->resolvePath(
            namespace: $namespace,
            name     : "{$timestamp}_{$snakeName}"
        );

        // Write the migration file to the filesystem
        $this->writeToFile(
            path   : $finalPath,
            content: $stubContent
        );

        // Store the generated file name important for manifest entry
        return $finalPath;
    }

    /**
     * Generates a UTC-based timestamp for migration naming.
     *
     * Creates a standardized timestamp format used in migration file names
     * to ensure proper ordering and uniqueness.
     *
     * @return string Formatted timestamp (YmdHis)
     */
    private function generateTimestamp() : string
    {
        return (new DateTimeImmutable())->format(format: 'YmdHis');
    }

    /**
     * Converts PascalCase/camelCase strings to snake_case.
     *
     * Implements a robust string transformation algorithm that handles:
     * - PascalCase to snake_case
     * - camelCase to snake_case
     * - Special character replacement
     *
     * @param string $string The input string to convert
     *
     * @return string The snake_case representation
     */
    private function toSnakeCase(string $string) : string
    {
        $string = preg_replace('/([a-z])([A-Z])/', '$1_$2', $string);
        $string = preg_replace('/[^a-zA-Z0-9]/', '_', $string);

        return strtolower(trim((string) $string, '_'));
    }

    /**
     * Generates the migration table DSL lines using the Table DSL Renderer.
     *
     * Uses a temporary Table blueprint to apply FieldDTO definitions via the fieldMapper,
     * and renders them as `$table->...` PHP migration code lines suitable for stub injection.
     *
     * @param array<int, FieldDTO> $fields Validated list of field DTOs
     *
     * @return string DSL-compatible PHP migration body
     *
     * @throws RuntimeException When the field collection is empty or rendering fails
     */
    private function generateMigrationTableFields(array $fields) : string
    {
        // Create blueprint with injected mapper (injected earlier in MigrationGenerator)
        $table = Table::create(name: 'temporary')
            ->useMapper($this->mapper)
            ->applyMany($fields);

        // Render DSL output
        return $table->toDsl();
    }

}
=== Runner/Generators/Repository/RepositoryGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Repository;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * RepositoryGenerator Class
 *
 * This class is responsible for generating repository classes with predefined methods for database operations.
 * It extends from AbstractGenerator and leverages its methods to handle stubs and file writing.
 */
final class RepositoryGenerator extends AbstractGenerator
{
    /**
     * Create a repository class for a given table and entity.
     *
     * @param string $tableName The name of the database table.
     * @param string $entity    The name of the entity class.
     * @param array  $fields    Additional fields used in repository methods. (Default: empty array).
     *
     * @throws RuntimeException If repository paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, string $entity, array $fields = []) : void
    {
        $namespace = config(key: 'app.namespaces.Repositories');
        $path      = config(key: 'app.paths.Repositories');

        // Ensure namespace and path configuration exists
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Repository paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'repository');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'repository.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'RepositoryName' => $className,
            'Namespace'      => $namespace,
            'EntityName'     => $entity,
            'Methods'        => $this->generateMethods(entity: $entity),
        ]);

        // Determine the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate method stubs for the repository class.
     *
     * @param string $entity The name of the entity class.
     *
     * @return string The generated methods as a string.
     */
    private function generateMethods(string $entity) : string
    {
        return <<<PHP
            public function find(int \$id): ?{$entity}
            {
                \$result = \$this->queryBuilder()->where('id', '=', \$id)->first();
                return \$result ? new {$entity}(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->queryBuilder()->get();
                return array_map(fn(\$data) => new {$entity}(\$data), \$results);
            }
            
            public function save({$entity} \$entity): bool
            {
                \$data = get_object_vars(\$entity);
            
                if (!empty(\$data['id'])) {
                    return \$this->queryBuilder()->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->queryBuilder()->insertGetId(\$data);
                if (\$id) {
                    \$entity->setId(\$id);
                    return true;
                }
            
                return false;
            }
            
            public function delete(int \$id): bool
            {
                return \$this->queryBuilder()->where('id', '=', \$id)->delete();
            }
            PHP;
    }
}
=== Runner/Generators/Service/ServiceGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Service;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Service Generator
 *
 * This generator creates service classes with basic scaffolding.
 * It extends AbstractGenerator to leverage shared utilities for file generation.
 */
final class ServiceGenerator extends AbstractGenerator
{
    /**
     * Creates a new service class.
     *
     * This method uses a stub file as a template, replaces placeholders
     * with actual values, and writes the generated content to a destination path.
     *
     * @param string $name The name of the service class to be generated.
     */
    public function create(string $name) : void
    {
        // Load the namespace and path from configuration
        // Rationale: Allow configuration to dictate the location and structure of generated files
        $namespace = config(key: 'app.namespaces.Services');
        $path      = config(key: 'app.paths.Services');

        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Service namespace or path is not configured correctly.');
        }

        // Generate the class name using AbstractGenerator's method
        // Intent: Create standardized class names based on provided table name
        $className = $this->generateMigrationClassName(tableName: $name, type: 'service');

        // Load the service stub file
        // Rationale: Use a template to maintain consistent structure across generated service classes
        $stub = $this->getStub(stubName: 'service.stub');

        // Replace placeholders in the stub
        // Intent: Dynamically insert the class name and namespace into the template
        $stub = $this->replacePlaceholders(
            stub:         $stub,
            placeholders: [
                              'ServiceName' => $className,
                              'Namespace'   => $namespace,
                          ]
        );

        // Resolve the file path
        // Rationale: Ensure the new class is placed in the correct directory based on namespace
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);

        // Write the generated content to the file
        // Rationale: Finalize the service class creation by writing the populated template to the file system
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Runner/Generators/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Exception;
use Psr\Log\LoggerInterface;

/**
 * StubResolver Class
 *
 * This class is responsible for handling the location, validation, and reading of stub files
 * used in code generation. It ensures that the directory containing stub files exists and is readable,
 * and it supports reading specific stub files for use in other applications.
 */
readonly class StubResolver
{
    /**
     * @param string          $stubDirectory The directory where stub files are stored.
     * @param LoggerInterface $logger        The logger instance for logging errors and information.
     *
     * @throws Exception If the stub directory is invalid upon instantiation.
     */
    public function __construct(
        private string          $stubDirectory,
        private LoggerInterface $logger
    ) {
        $this->validateStubDirectory();
    }

    /**
     * Validates that the stub directory exists and is readable.
     *
     * Throws an exception if the directory does not exist or is not readable, and logs a critical error.
     * This check is crucial for ensuring that later file operations do not fail due to
     * an invalid directory path.
     *
     * @throws Exception If the stub directory is invalid.
     */
    private function validateStubDirectory() : void
    {
        if (! is_dir($this->stubDirectory) || ! is_readable($this->stubDirectory)) {
            // Log the critical issue that the directory is invalid.
            $this->logger->critical(
                sprintf('Invalid stub directory: "%s".', $this->stubDirectory)
            );

            throw new Exception(
                sprintf(
                    'Stub directory "%s" does not exist or is not readable.',
                    $this->stubDirectory
                )
            );
        }
    }

    /**
     * Reads the contents of a stub file.
     *
     * This method resolves the full path of the stub file and attempts to read its contents.
     * If reading fails, it logs an error and throws an exception.
     * Successfully read content is logged for auditing purposes.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The content of the stub file.
     * @throws Exception If the stub file cannot be read.
     */
    public function read(string $stubName) : string
    {
        // Resolve a full path for the specified stub file.
        $stubPath = $this->resolve($stubName);

        $content = file_get_contents($stubPath);
        if ($content === false) {
            // Log the error if reading the file fails.
            $this->logger->error(
                sprintf('Failed to read content of stub file: "%s" at "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Failed to read stub file: "%s".', $stubName));
        }

        // Log successful read for future reference.
        $this->logger->info(
            sprintf('Successfully read stub file: "%s" from path: "%s".', $stubName, $stubPath)
        );

        return $content;
    }

    /**
     * Resolves the full path of a stub file.
     *
     * This method constructs the full path to the stub file within the stub directory.
     * It checks for the file's existence and readability, logging warnings and throwing exceptions as necessary.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The resolved path of the stub file.
     * @throws Exception If the stub file does not exist or is unreadable.
     */
    public function resolve(string $stubName) : string
    {
        $stubPath = rtrim($this->stubDirectory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $stubName;

        // Check that the file exists and is readable before progressing.
        if (! file_exists($stubPath) || ! is_readable($stubPath)) {
            // Log a warning if the file is missing or not accessible.
            $this->logger->warning(
                sprintf('Stub file "%s" not found or unreadable at path: "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Stub file "%s" not found or unreadable.', $stubName));
        }

        return $stubPath;
    }
}
=== Runner/Manifest/DTO/CreateManifestEntryDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest\DTO;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object for creating a Manifest Entry.
 *
 * Provides validated, casted, and serializable structure for manifest metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest\DTO
 *
 * @final
 */
final class CreateManifestEntryDTO extends AbstractDTO
{
    /**
     * Logical migration name (e.g., CreateProductsTable).
     */
    #[Required]
    public string $migration;

    /**
     * Physical file name (e.g., 20250428120300_create_products_table.php).
     */
    #[Required]
    public string $file;

    /**
     * Migration execution status (pending, executed, rolled_back, failed).
     */
    #[Required]
    public string $status;

    /**
     * SHA-256 hash of the migration file.
     */
    #[Required]
    public string $hash;

    /**
     * Optional batch ID assigned during migration execution.
     */
    public string|null $batch = null;

    /**
     * UTC ISO8601 timestamp of execution completion.
     */
    public string|null $executed_at = null;

    /**
     * UTC ISO8601 timestamp if migration was rolled back.
     */
    public string|null $rolled_back_at = null;

    /**
     * Optional tenant identifier for multi-tenant schemas.
     */
    public string|null $tenant_id = null;

    /**
     * Categorization tags for grouping migrations.
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs attached to the migration.
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Manifest creation timestamp.
     */
    #[Required]
    public DateTimeImmutable $created_at;
}

=== Runner/Manifest/ManifestDBInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

/**
 * Represents the persistence contract for migration manifest entries.
 *
 * This interface defines the repository contract for managing migration manifest records
 * in a persistence store. It follows the Repository Pattern from DDD and ensures
 * a consistent way to handle migration metadata across different storage implementations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestDBInterface
{
    /**
     * Persists a new migration manifest entry to the storage.
     *
     * This method is responsible for creating a new record in the persistence layer.
     * It encapsulates the storage-specific implementation details while maintaining
     * a consistent interface for manifest entry creation.
     *
     * @param array<string, mixed> $data The manifest entry data to persist
     *
     * @return array<string, mixed> The persisted manifest entry with any storage-generated metadata
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When provided data is invalid
     * @throws \SleekDB\Exceptions\JsonException When JSON serialization fails
     * @throws \SleekDB\Exceptions\IdNotAllowedException When ID field conflicts occur
     */
    public function insert(array $data) : array;

    /**
     * Retrieves manifest entries matching specified criteria.
     *
     * Implements specification pattern for flexible querying of manifest entries.
     * Supports complex query conditions while abstracting storage-specific query syntax.
     *
     * @param array<int, array<string|array>> $conditions Query specifications for filtering entries
     *
     * @return array<int, array<string, mixed>> Collection of manifest entries matching the conditions
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When query conditions are invalid
     */
    public function find(array $conditions) : array;

    /**
     * Retrieves all manifest entries from the storage.
     *
     * Provides a way to access the complete migration history. Use with caution
     * in large datasets as it may impact performance.
     *
     * @return array<int, array<string, mixed>> Complete collection of manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When internal query fails
     */
    public function findAll() : array;

    /**
     * Updates existing manifest entries matching the specified criteria.
     *
     * Supports atomic updates of manifest entries based on matching conditions.
     * Implements bulk update capability for efficient batch processing.
     *
     * @param array<int, array<string|array>> $conditions Specifications for identifying entries to update
     * @param array<string, mixed>            $newData    Updated data to apply to matching entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When conditions or data are invalid
     */
    public function update(array $conditions, array $newData) : void;
}
=== Runner/Manifest/ManifestDB.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Concrete implementation of ManifestDBInterface using SleekDB.
 *
 * @final
 */
final class ManifestDB implements ManifestDBInterface
{
    /**
     * The underlying SleekDB store instance.
     *
     * @var Store
     */
    private Store $store;

    /**
     * ManifestDB constructor.
     *
     * @param string $storagePath Path where a manifest database is located.
     *
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function __construct(string $storagePath)
    {
        $this->store = new Store(
            storeName   : 'manifest',
            databasePath: $storagePath
        );
    }

    /**
     * Insert a new manifest record.
     *
     * @param array<string, mixed> $data
     *
     * @return array<string, mixed>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function insert(array $data) : array
    {
        return $this->store->insert($data);
    }

    /**
     * Find manifest records matching given conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function find(array $conditions) : array
    {
        return $this->store->findBy($conditions);
    }

    /**
     * Retrieve all manifest records.
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function findAll() : array
    {
        return $this->store->findAll();
    }

    /**
     * Update manifest records matching conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     * @param array<string, mixed>             $newData
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function update(array $conditions, array $newData) : void
    {
        $this->store
            ->createQueryBuilder()
            ->where($conditions)
            ->getQuery()
            ->update($newData);
    }
}

=== Runner/Manifest/ManifestStoreInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Defines the contract for managing migration manifest entries in the application.
 *
 * This service interface abstracts the business operations for migration manifest management,
 * providing a clean boundary between the domain logic and persistence layer. It follows
 * the Service Pattern from DDD to encapsulate complex migration tracking operations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestStoreInterface
{
    /**
     * Creates a new migration manifest entry in the store.
     *
     * Processes and validates the migration entry data through a DTO before persistence.
     * Ensures data integrity and consistent state transitions for new migrations.
     *
     * @param CreateManifestEntryDTO $dto Value object containing validated migration entry data
     *
     * @throws \SleekDB\Exceptions\IOException When a storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When entry data is invalid
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void;

    /**
     * Retrieves all migration manifest entries from the store.
     *
     * Provides a complete view of the migration history for audit and management purposes.
     * Results are ordered by creation timestamp to maintain execution sequence.
     *
     * @return array<int, array<string, mixed>> Collection of all migration manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When retrieval operation fails
     */
    public function fetchAll() : array;

    /**
     * Retrieves all pending migrations that haven't been executed.
     *
     * Identifies migrations that need to be processed in the next migration run.
     * Filters entries based on execution status and ordering constraints.
     *
     * @return array<int, array<string, mixed>> Collection of pending migration entries
     *
     * @throws \SleekDB\Exceptions\IOException When the query operation fails
     */
    public function findPending() : array;

    /**
     * Performs rollback operations for migrations in a specific batch.
     *
     * Manages the state transition of migrations during a rollback process.
     * Updates manifest entries to reflect rollback status and timing.
     *
     * @param string $batch Identifier for the batch of migrations to rollback
     *
     * @throws \SleekDB\Exceptions\IOException When the rollback operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When batch identifier is invalid
     */
    public function rollbackBatch(string $batch) : void;

    /**
     * Locates a specific migration entry by its unique name.
     *
     * Provides direct access to individual migration metadata for verification
     * and state management purposes.
     *
     * @param string $migrationName Unique identifier/name of the migration
     *
     * @return array<string, mixed>|null Migration entry if found, null otherwise
     *
     * @throws \SleekDB\Exceptions\IOException When lookup operation fails
     */
    public function findByMigrationName(string $migrationName) : array|null;
}
=== Runner/Manifest/ManifestStore.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Service that manages manifest operations.
 */
final readonly class ManifestStore implements ManifestStoreInterface
{
    public function __construct(private ManifestDBInterface $db) {}

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\JsonException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void
    {
        $this->db->insert($dto->toArray());
    }

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function fetchAll() : array
    {
        return $this->db->findAll();
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findPending() : array
    {
        return $this->db->find(
            [
                ['status', '=', 'pending'],
            ]
        );
    }

    public function rollbackBatch(string $batch) : void
    {
        $this->db->update(
            [['batch', '=', $batch]],
            ['status' => 'rolled_back', 'rolled_back_at' => (new DateTimeImmutable())->format(DATE_ATOM)]
        );
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findByMigrationName(string $migrationName) : array|null
    {
        $found = $this->db->find(
            [
                ['migration', '=', $migrationName],
            ]
        );

        return $found[0] ?? null;
    }
}
=== Runner/Manifest/MigrationManifestEntry.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\DateFormat;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * Represents an immutable manifest entry for database migrations within the system.
 *
 * This Value Object encapsulates all metadata related to a single database migration,
 * including its execution status, timing information, and associated metadata. It follows
 * the immutability principle to ensure data consistency throughout the migration process.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 * @final   This class is immutable and must not be extended to maintain invariants
 */
final class MigrationManifestEntry extends AbstractDTO
{
    /**
     * The unique identifier/name of the migration.
     *
     * @var string Represents the unique name used to identify this migration
     */
    #[Required]
    #[StringType]
    public string $migrationName;

    /**
     * The physical file name containing the migration code.
     *
     * @var string The actual filename on the filesystem containing migration logic
     */
    #[Required]
    #[StringType]
    public string $fileName;

    /**
     * Current status of the migration (e.g., 'pending', 'executed', 'failed').
     *
     * @var string Indicates the current state of migration execution
     */
    #[Required]
    #[StringType]
    public string $status;

    /**
     * Cryptographic hash of the migration content for integrity verification.
     *
     * @var string SHA-256 hash (or similar) of the migration file content
     */
    #[Required]
    #[StringType]
    public string $hash;

    /**
     * Optional batch identifier grouping related migrations.
     *
     * @var string|null Identifier for grouping migrations in execution batches
     */
    public string|null $batch = null;

    /**
     * Timestamp when the migration was successfully executed.
     *
     * @var string|null ISO-8601 formatted datetime string of execution
     */
    public string|null $executedAt = null;

    /**
     * Timestamp when the migration was rolled back.
     *
     * @var string|null ISO-8601 formatted datetime string of rollback
     */
    public string|null $rolledBackAt = null;

    /**
     * Optional tenant identifier for multi-tenant environments.
     *
     * @var string|null Unique identifier of the tenant this migration applies to
     */
    public string|null $tenantId = null;

    /**
     * Collection of tags for migration categorization and filtering.
     *
     * @var array<string> List of tags associated with this migration
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs and debug information.
     *
     * @var array<string, mixed> Collection of log entries related to migration execution
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Timestamp when this manifest entry was created.
     *
     * @var DateTimeImmutable Immutable datetime representing creation timestamp
     */
    #[Required]
    #[DateFormat('Y-m-d H:i:s')]
    public DateTimeImmutable $createdAt;
}
=== Runner/Manifest/MigrationManifestService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Service for managing the Migration Manifest entries.
 *
 * Handles creation, retrieval, updating, and validation of migration metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 *
 * @final   This class is immutable and must not be extended.
 */
final class MigrationManifestService
{
    /**
     * SleekDB Store instance for Manifest storage.
     *
     * @var Store
     */
    private Store $store;

    /**
     * Constructor.
     *
     * Initializes the SleekDB Store directly.
     *
     * @param string $manifestPath Absolute path to the manifest storage directory.
     *
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     */
    public function __construct(string $manifestPath)
    {
        $this->store = new Store(
            storeName    : 'manifest',
            databasePath : $manifestPath,
            configuration: ['auto_cache' => true]
        );
    }

    /**
     * Creates a new Manifest entry.
     *
     * @param MigrationManifestEntry $entry Data Transfer Object representing the migration manifest.
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function createEntry(MigrationManifestEntry $entry) : void
    {
        $this->store->insert(
            [
                'migration'      => $entry->migrationName,
                'file'           => $entry->fileName,
                'status'         => $entry->status,
                'hash'           => $entry->hash,
                'batch'          => $entry->batch,
                'executed_at'    => $entry->executedAt,
                'rolled_back_at' => $entry->rolledBackAt,
                'tenant_id'      => $entry->tenantId,
                'tags'           => $entry->tags,
                'logs'           => $entry->logs,
                'created_at'     => $entry->createdAt->format(DATE_ATOM),
            ]
        );
    }

    /**
     * Retrieves all Manifest entries.
     *
     * @return array<int, array<string, mixed>> List of all migration manifest entries.
     */
    public function all() : array
    {
        return $this->store->fetch();
    }

    /**
     * Finds a specific migration entry by its migration name.
     *
     * @param string $migrationName Logical name of the migration.
     *
     * @return array<string, mixed>|null The matching manifest entry or null if not found.
     */
    public function find(string $migrationName) : array|null
    {
        $result = $this->store
            ->where('migration', '=', $migrationName)
            ->fetch();

        return $result[0] ?? null;
    }
}

=== Runner/MigrationException.php ===
<?php

declare(strict_types=1);

/**
 * Class MigrationException
 *
 * Exceptions class to handle migration-specific errors within the Gemini database migration context.
 *
 * This class extends the base Exceptions class to provide custom error handling for
 * database migrations, encapsulating the message, error code, and the previous exception.
 *
 * Example usage:
 * <code>
 * throw new MigrationException("Migration failed due to XYZ reason");
 * </code>
 *
 * @package Gemini\Database\Migration
 */

namespace Gemini\Database\Migration\Runner;

use Exception;
use Throwable;

/**
 * MigrationException is a custom exception that is thrown during migration operations.
 *
 * The MigrationException class extends the base Exceptions class and provides additional contextual
 * information specifically related to database migration errors. This exception should be used
 * to indicate issues encountered during the process of migrating database schemas or related data.
 *
 * Usage example:
 * throw new MigrationException("Migration failed due to XYZ reason.");
 *
 * @package Gemini\Database\Migration
 */
class MigrationException extends Exception
{
    /**
     * Constructs a new MigrationException.
     *
     * @param string          $message  The Exceptions message to throw.
     * @param int             $code     The Exceptions code.
     * @param \Throwable|null $previous The previous throwable used for the exception chaining.
     */
    public function __construct(
        string         $message = '',
        int            $code = 0,
        Throwable|null $previous = null,
    ) {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== Runner/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Service\MigrationExecution;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Abstract Migration Base Class
 *
 * Provides the foundation for creating database migrations in the Gemini framework.
 * Supports transactional, auditable, API-driven migration execution with up/down lifecycle.
 */
abstract readonly class Migration
{
    /**
     * Message template for successful operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_SUCCESS = 'Successfully executed: %s';

    /**
     * Message template for failed operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_FAILURE = 'Failed to execute: %s. Error: %s';

    /**
     * Message template for exception escalation during migration.
     *
     * @var string
     */
    protected const string MIGRATION_ERROR = 'Migration error during: %s. Details: %s';

    /**
     * Dependency for schema creation and modification.
     *
     * @var SchemaBuilder
     */
    protected SchemaBuilder $schemaBuilder;

    /**
     * Action for managing migration registration and persistence.
     *
     * @var MigrationExecution
     */
    protected MigrationExecution $migrationService;

    /**
     * Optional logger for structured output.
     *
     * @var LoggerInterface|null
     */
    protected LoggerInterface|null $logger;

    /**
     * Constructs the Migration base.
     *
     * @param SchemaBuilder        $schemaBuilder    DSL engine for table/column mutation.
     * @param MigrationExecution   $migrationService Action to persist execution records.
     * @param LoggerInterface|null $logger           Optional logger.
     */
    public function __construct(
        SchemaBuilder        $schemaBuilder,
        MigrationExecution   $migrationService,
        LoggerInterface|null $logger = null
    ) {
        $this->schemaBuilder    = $schemaBuilder;
        $this->migrationService = $migrationService;
        $this->logger           = $logger;
    }

    /**
     * Executes the "up" migration lifecycle.
     *
     * @throws MigrationException
     * @throws \Throwable
     */
    final public function executeUp() : void
    {
        $name  = $this->getMigrationName();
        $batch = $this->migrationService->getLatestBatch() + 1;

        $this->logInfo(message: sprintf("🔼 Starting migration '%s' (up)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->up(),
                description: sprintf("Applying migration '%s'", $name)
            );

            $this->migrationService->save(
                migration : $name,
                executable: 'up()',
                batch     : $batch
            );

            $this->logInfo(message: sprintf("🧱 Migration '%s' completed successfully (up).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Migration '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Resolves the class-based migration name.
     *
     * @return string
     */
    private function getMigrationName() : string
    {
        return static::class;
    }

    /**
     * Logs a message if logger is available.
     *
     * @param string $message
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Wraps any logic in try/catch, logs success/failure, escalates errors.
     *
     * @param callable $operation
     * @param string   $description
     *
     * @throws MigrationException
     */
    private function executeSafely(callable $operation, string $description) : void
    {
        // Begin a try block to handle potential errors during operation execution.
        try {
            // Execute the passed operation.
            // Any exception thrown here will be caught by the catch block below.
            $operation();

            $this->logInfo(message: sprintf(self::LOG_OPERATION_SUCCESS, $description));
        } catch (Throwable $e) {
            $this->logError(message: sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Log the failure of the operation with the error message for debugging or auditing purposes.
            $this->logError(sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Throw a MigrationException to escalate the issue while providing context for the failure.
            throw new MigrationException(
                message : sprintf(self::MIGRATION_ERROR, $description, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Logs an error if logger is available.
     *
     * @param string $message
     */
    private function logError(string $message) : void
    {
        $this->logger?->error(message: $message);
    }

    /**
     * Abstract method to be implemented by concrete migrations.
     *
     * @return void
     */
    abstract protected function up() : void;

    /**
     * Executes the "down" rollback lifecycle.
     *
     * @throws MigrationException
     */
    final public function executeDown() : void
    {
        $name = $this->getMigrationName();

        $this->logInfo(message: sprintf("🔽 Starting migration '%s' (down)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->down(),
                description: sprintf("Reverting migration '%s'", $name)
            );

            $this->migrationService->delete(migration: $name);

            $this->logInfo(message: sprintf("🗑️ Migration '%s' completed successfully (down).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Rollback for '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Abstract method for rollback.
     *
     * @return void
     */
    abstract protected function down() : void;
}

=== Runner/Repository/MigrationRepositoryInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Repository;

/**
 * Interface MigrationRepositoryInterface
 *
 * Defines a contract for managing database migrations.
 * This interface abstracts migration management to ensure consistent migration operations across different
 * implementations.
 */
interface MigrationRepositoryInterface
{
    /**
     * Registers a migration with specified details into the database.
     *
     * @param string $migration  The name or identifier of the migration.
     * @param string $executable The class- or identifier-responsible for executing the migration.
     * @param int    $batch      The batch number that groups this migration with others.
     *
     * The `save` method is crucial for keeping a record of applied migrations
     * along with their batch number to allow rollback or re-execution of specific batches.
     */
    public function save(string $migration, string $executable, int $batch) : void;

    /**
     * Removes a specific migration entry from the database.
     *
     * @param string $migration The name or identifier of the migration to be deleted.
     *
     * Use `delete` to remove the record of a migration, especially if it was applied
     * erroneously or if it needs to be reapplied from scratch.
     */
    public function delete(string $migration) : void;

    /**
     * Checks if a certain migration is recorded in the database.
     *
     * @param string $migration The name or identifier of the migration.
     *
     * @return bool Returns true if the migration exists, otherwise false.
     *
     * The `has` method helps to verify if a migration has already been applied
     * to avoid duplicate application of the same migration.
     */
    public function has(string $migration) : bool;

    /**
     * Retrieves all migration records that have been executed.
     *
     * @return array An array containing details of all executed migrations.
     *
     * The `getAll` method provides a comprehensive list of all migrations that
     * have been executed, useful for audits and tracking the history of migrations.
     */
    public function getAll() : array;

    /**
     * Fetches migrations belonging to a specific batch.
     *
     * @param int $batch The batch number to filter migrations by.
     *
     * @return array An array of migrations under the given batch.
     *
     * The `getMigrationsByBatch` method is useful for operations that need to
     * target specific groups of migrations, such as rolling back a single batch.
     */
    public function getMigrationsByBatch(int $batch) : array;

    /**
     * Gets the highest batch number currently in use.
     *
     * @return int The highest batch number.
     *
     * The `getLatestBatch` method is essential for determining the most recent
     * group of migrations that were applied, often used to target the latest set
     * of migrations for rollbacks.
     */
    public function getLatestBatch() : int;

    /**
     * Removes all migration records, effectively resetting the migration state.
     *
     * Using `dropAllMigrations` prepares the system for a fresh start of migrations,
     * useful in scenarios where the entire migration history needs to be cleared.
     */
    public function dropAllMigrations() : void;

    /**
     * Returns all unexpected (pending) migrations from the database.
     *
     * @return array<int, array<string, mixed>>
     */
    public function allPending() : array;

    /**
     * Deletes all migrations associated with a given batch ID.
     *
     * @param int $batch The batch number to delete.
     */
    public function removeByBatch(int $batch) : void;

    /**
     * Retrieves all migrations for a specific batch in reverse order.
     *
     * @param int $batch The batch to search.
     *
     * @return array<int, array<string, mixed>>
     */
    public function findByBatch(int $batch) : array;

}
=== Runner/SchemaBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Closure;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * SchemaBuilder
 *
 * Infrastructure facade for declaratively managing database schema via Domain-Specific Language (DSL).
 *
 * This class is responsible for all Data Definition Language (DDL) operations related to schema evolution,
 * such as table creation, deletion, renaming, and connectivity checks. It wraps these operations in
 * transaction-safe boundaries and provides centralized logging, exception normalization, and
 * semantic mapping from domain-oriented blueprints to raw SQL statements.
 *
 * It uses:
 * - QueryBuilder for driver-agnostic query execution
 * - Table DSL for semantic schema construction
 * - LoggerInterface for audit logging and observability
 *
 * It provides:
 * - Transactional safety for destructive operations
 * - Health check APIs for deployment probes
 * - Domain-safe exception boundaries for orchestration code
 *
 * This class belongs to the Infrastructure Layer of a Clean Architecture system,
 * and is intentionally readonly and immutable for safety in concurrent and async environments.
 *
 * @package Gemini\Database\Migration\Runner
 * @readonly
 * @final
 */
final readonly class SchemaBuilder
{
    /**
     * Constructor for initializing the QueryBuilder and LoggerInterface dependencies.
     *
     * @param QueryBuilder    $queryBuilder An instance of QueryBuilder to handle database queries.
     * @param LoggerInterface $logger       An instance of LoggerInterface for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private QueryBuilder    $queryBuilder,
        private LoggerInterface $logger
    ) {}

    /**
     * Determines whether a physical table exists in the active database schema.
     *
     * This check queries the `information_schema.tables` system view using the current
     * database context. It ensures compatibility with multi-tenant schemas and provides
     * fault-tolerant behavior on driver-level errors.
     *
     * @param non-empty-string $table The fully qualified table name to inspect
     *
     * @return bool True if the table exists, false otherwise
     * @throws \Random\RandomException
     */
    public function tableExists(string $table) : bool
    {
        // ✅ Guard against empty table names (domain invariant)
        if (trim($table) === '') {
            return false;
        }

        try {
            return $this->queryBuilder
                ->table(tableName: 'information_schema.tables')
                ->where(column: 'table_schema', value: $this->queryBuilder->raw(sql: 'DATABASE()'))
                ->where(column: 'table_name', value: $table)
                ->exists();
        } catch (QueryBuilderException $e) {
            // ❌ Defensive: driver-level failures shouldn't propagate upward
            $this->logger->error(
                message: 'Failed to verify table existence.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: $e->getMessage(), type: 'warning');

            return false;
        }
    }

    /**
     * Handles message output formatting based on the execution context (CLI or API/HTTP).
     *
     * This method implements the Single Responsibility Principle by managing output
     * formatting and delivery based on the application's runtime environment.
     *
     * @param string $message The message content to be output
     * @param string $type    The message type for color coding (success|warning|error|info)
     *
     * @return string|null Returns null for CLI context (direct output) or string for HTTP context
     */
    public function output(string $message, string $type = 'info') : string|null
    {
        // Determine if we're running in a CLI environment
        if (php_sapi_name() === 'cli') {
            // Define ANSI color codes for different message types in CLI
            $color = match ($type) {
                'success' => "\033[32m", // Green signifies successful operations
                'warning' => "\033[33m", // Yellow indicates warnings or cautions
                'error'   => "\033[31m", // Red represents errors or failures
                default   => "\033[0m",  // Default color for informational messages
            };

            // Output the colored message with reset code and line ending
            echo $color . $message . "\033[0m" . PHP_EOL;

            // CLI context doesn't need return value as output is immediate
            return '';
        }

        // For HTTP/API context, return the raw message
        return $message;
    }

    /**
     * Creates a new database table using a fluent Domain-Specific Language (DSL) schema definition.
     *
     * This method allows declarative schema construction by accepting a user-defined DSL callback.
     * Internally, it ensures atomic DDL execution via transactional encapsulation and logs all operations.
     *
     * @param non-empty-string $table    The name of the table to be created
     * @param Closure          $callback Closure defining the table schema using the fluent DSL
     *
     */
    public function create(string $table, Closure $callback) : bool
    {
        // ✅ Defensive: enforce a table name contract
        if (trim($table) === '') {
            $this->logger->warning(
                message: 'Table name is empty.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table name is empty.', type: 'warning');

            return false;
        }

        try {
            // ✅ Construct new Table schema blueprint using domain factory
            $blueprint = Table::create(name: $table);

            // ✅ Delegate table schema definition to user via DSL callback
            $callback($blueprint);

            // ✅ Generate SQL from blueprint (idempotent)
            $sql = $blueprint->toSql();

            // ✅ Execute SQL within transactional boundary (atomic DDL)
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->raw(sql: $sql)->execute()
            );

            // ✅ Structured operation logging for auditability
            $this->logger->info(
                message: 'Table successfully created.',
                context: ['table' => $table, 'query' => $sql]
            );

            return true;
        } catch (Throwable $e) {
            // ❌ Translate all low-level driver/query exceptions into a domain exception
            $this->logger->error(
                message: 'Failed to create table.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Failed to create table.', type: 'error');

            return false;
        }
    }

    /**
     * Drops the specified table if it exists, using transactional guarantees.
     *
     * This operation is destructive and irreversible. It wraps the `DROP TABLE`
     * execution in a transactional context to ensure rollback capability on failure.
     * Logging is performed for observability, and domain-specific exception wrapping
     * ensures consistent error boundaries.
     *
     * @param non-empty-string $table The name of the table to drop
     *
     * @throws MigrationException On failure to drop the table
     */
    public function drop(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Drop failed: empty table name.', context: ['table' => $table]);

            $this->output(message: 'Drop failed: empty table name.', type: 'warning');

            return false;
        }

        try {
            // 💥 Atomic drop with rollback support
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder
                    ->table(tableName: $table)
                    ->drop()
            );

            // 📘 Successful audit trail
            $this->logger->info(
                message: 'Table dropped successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table dropped successfully.');

            return true;
        } catch (Throwable $e) {
            // 🚨 Surface clean domain-level failure
            $this->logger->error(
                message: 'Failed to drop table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to drop table.', type: 'error');

            return false;
        }
    }

    /**
     * Renames a table within the database schema using transactional guarantees.
     *
     * This method encapsulates the renaming of a table from its current name to a new name.
     * The operation is executed within a transaction, ensuring rollback on failure.
     * Logs are emitted to track structural changes for audit purposes.
     *
     * @param non-empty-string $oldName The current name of the table
     * @param non-empty-string $newName The desired new name for the table
     *
     * @throws MigrationException When renaming fails due to invalid names or query execution errors
     */
    public function rename(string $oldName, string $newName) : bool
    {
        if (trim($oldName) === '' || trim($newName) === '') {
            $this->logger->warning(
                message: 'Cannot rename table: source or destination name is empty.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Cannot rename table: source or destination name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🛡 Perform rename in transaction for rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->renameTable(
                    oldName: $oldName,
                    newName: $newName
                )
            );

            // 📋 Log structural schema change
            $this->logger->info(
                message: 'Table renamed successfully.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Table renamed successfully.');

            return true;
        } catch (Throwable $e) {
            // 🧱 Wrap lower-level failure in domain-safe exception
            $this->logger->warning(
                message: "Failed to rename table '{$oldName}' to '{$newName}'",
                context: [
                             'old_name'  => $oldName,
                             'new_name'  => $newName,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to rename table.', type: 'warning');

            return false;
        }
    }

    /**
     * Truncates a table, removing all data while retaining schema structure.
     *
     * This operation deletes all records from the given table without logging individual row deletions.
     * It is faster than a DELETE operation and suitable for resetting state in non-production contexts.
     * The operation is performed transactionally and wrapped in domain-safe exception boundaries.
     *
     * @param non-empty-string $table The name of the table to truncate
     *
     * @throws MigrationException If truncation fails due to SQL or driver issues
     */
    public function truncate(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Cannot truncate table: table name is empty.');
            $this->output(message: 'Cannot truncate table: table name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🚨 Run inside a transaction to ensure rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->table(tableName: $table)->truncate()
            );

            // 📢 Log action for observability and audit trail
            $this->logger->info(
                message: 'Table truncated successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table truncated successfully.');

            return true;
        } catch (Throwable $e) {
            // 🧱 Encapsulate and elevate to domain-level failure
            $this->logger->error(
                message: 'Failed to truncate table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to truncate table.', type: 'error');

            return false;
        }
    }

    /**
     * Checks whether a given database exists in the current RDBMS instance.
     *
     * Queries the `information_schema.SCHEMATA` view to determine if the specified
     * database schema is present. This method is essential for conditional migrations,
     * onboarding flows, or database provisioning orchestration.
     *
     * @param non-empty-string $database The name of the database schema to check
     *
     * @return bool True if the schema exists, false otherwise
     * @throws \Random\RandomException
     */
    public function databaseExists(string $database) : bool
    {
        // 🧱 Defensive contract enforcement
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to check database existence with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database existence: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // 📦 Query the information schema for the presence of the schema name
            return $this->queryBuilder
                ->table(tableName: 'information_schema.SCHEMATA')
                ->where(column: 'SCHEMA_NAME', value: $database)
                ->exists();
        } catch (QueryBuilderException $e) {
            // 🪵 Log error for observability and diagnostics
            $this->logger->error(
                message: 'Failed to check database existence.',
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to check database existence.', type: 'error');

            return false;
        }
    }

    /**
     * Creates a new database schema if it does not already exist.
     *
     * This method is typically used during bootstrap, provisioning, or deployment flows.
     * It ensures explicit schema creation with high observability and proper fault isolation.
     *
     * @param non-empty-string $database The name of the schema to be created
     *
     * @throws MigrationException If database creation fails
     */
    public function createDatabase(string $database) : bool
    {
        // 🧱 Domain precondition: avoid invalid names
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to create database with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot create database: database name is empty.');

            return false;
        }

        try {
            // 🛠 Execute database creation command via query builder abstraction
            $this->queryBuilder->createDatabase(database: $database);

            // 🧾 Log the successful creation event for observability
            $this->logger->info(
                message: 'Database schema successfully created.',
                context: ['database' => $database]
            );

            $this->output(message: 'Database schema successfully created.');

            return true;
        } catch (Throwable $e) {
            // 🔥 Wrap infrastructure failure in domain-specific exception
            $this->logger->warning(
                message: "Failed to create database '{$database}'",
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to create database.', type: 'error');

            return false;
        }
    }

    /**
     * Verifies database connectivity by attempting to select the given schema.
     *
     * This check is used for liveness/readiness probes, orchestration health checks,
     * and resilience features that depend on connection status with minimal overhead.
     *
     * @param non-empty-string $database The name of the database schema to check connectivity for
     *
     * @return bool True if the connection is healthy, false otherwise
     * @throws \Random\RandomException
     */
    public function isConnectionHealthy(string $database) : bool
    {
        // 🧱 Guard clause: avoid checking unnamed schemas
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Health check failed — database name was empty.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database connectivity: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // 🧪 Attempt to switch to target schema
            $this->queryBuilder->useDatabase(database: $database);

            // ✅ If successful, consider the connection healthy
            $this->output(message: 'Database connectivity check successful.');

            return true;
        } catch (QueryBuilderException $e) {
            // ❌ Connection or database switch failed — log failure
            $this->logger->error(
                message: 'Database connectivity check failed.',
                context: ['database' => $database, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Database connectivity check failed.', type: 'error');

            return false;
        }
    }
}

=== Runner/Service/MigrationExecution.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class MigrationExecution
 *
 * Provides CRUD operations for database migrations with transactional safety and structured logging.
 * Uses a QueryBuilder abstraction to manage migration records efficiently.
 */
class MigrationExecution implements MigrationRepositoryInterface
{
    /**
     * The default table name used for storing migration data.
     */
    private const string TABLE_MIGRATIONS = 'migrations';

    /**
     * The default date and time format used for formatting and parsing dates.
     */
    private const string DATE_FORMAT = 'Y-m-d H:i:s';

    /**
     * Constructor to initialize the class with required dependencies.
     *
     * @param QueryBuilder         $queryBuilder The query builder instance for database interactions.
     * @param LoggerInterface|null $logger       Optional logger instance for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private readonly QueryBuilder    $queryBuilder,
        private readonly LoggerInterface $logger
    ) {}

    /**
     * Persists a new migration record into the database.
     *
     * @param string $migration  Name of the migration file or class.
     * @param string $executable Raw SQL or migration command executed.
     * @param int    $batch      Batch number that this migration belongs to.
     *
     * @throws InvalidArgumentException When the input is invalid.
     * @throws Throwable When the insert operation fails.
     */
    public function save(string $migration, string $executable, int $batch) : void
    {
        // Validate that both the migration name and executable are not empty.
        if (empty($migration) || empty($executable)) {
            throw new InvalidArgumentException(message: "Migration name and executable cannot be empty.");
        }

        // Validate that the batch ID is greater than 0.
        if ($batch < 1) {
            throw new InvalidArgumentException(message: "Batch ID must be greater than 0.");
        }

        // Generate the current timestamp in the defined DATE_FORMAT ('Y-m-d H:i:s').
        $timestamp = (new DateTimeImmutable())->format(format: self::DATE_FORMAT);

        // Save the migration record using a database transaction to ensure atomicity.
        $this->queryBuilder->transaction(operations: function () use ($migration, $executable, $batch, $timestamp) {
            // Specify the target database table and insert the migration data.
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS) // Set the target table to 'migrations'.
                ->insert(
                    parameters: [
                                    'migration'   => $migration,    // Name of the migration file or class.
                                    'executable'  => $executable,  // The executed SQL or migration command.
                                    'batch'       => $batch,       // Grouping number for the migration (batch).
                                    'executed_at' => $timestamp,   // Timestamp of when the migration was saved.
                                ]
                )
                ->flush(); // Commit the database operation immediately.
        });

        // Log an informational message about the saved migration if a logger is available.
        $this->logger->info(message: "Saved migration '{$migration}' in batch {$batch}.");
    }

    /**
     * Checks whether a given migration exists in the database.
     *
     * @param string $migration Name of the migration to check.
     *
     * @return bool True if migration exists, false otherwise.
     *
     * @throws Throwable If the query fails.
     */
    public function has(string $migration) : bool
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'migration', value: $migration)
            ->exists();
    }

    /**
     * Retrieves all migration records.
     *
     * @return array List of all migrations in associative array format.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getAll() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select('migration', 'executable', 'batch', 'executed_at')
            ->get()
            ->toArray();
    }

    /**
     * Retrieves all migrations associated with a specific batch.
     *
     * @param int $batch The batch number to filter migrations.
     *
     * @return array Migrations belonging to the given batch.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getMigrationsByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->get()
            ->toArray();
    }

    /**
     * Fetches the most recent batch number from the migrations table.
     *
     * @return int Latest batch number, or 0 if no migrations exist.
     *
     * @throws Throwable If the query fails.
     */
    public function getLatestBatch() : int
    {
        $result = $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select(columns: 'MAX(batch) AS batch')
            ->get()
            ->first(key: 'batch');

        return $result !== null ? (int) $result : 0;
    }

    /**
     * Removes all migration records using the built-in truncate method.
     *
     * @throws Throwable If the truncate operation fails.
     */
    public function dropAllMigrations() : void
    {
        $this->queryBuilder->transaction(operations: function () {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->truncate()
                ->flush();
        });

        $this->logger->info(message: "Dropped all migration records.");
    }

    /**
     * Returns all pending migrations (executed_at is NULL).
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function allPending() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->whereNull(column: 'executed_at')
            ->orderBy(column: 'id', direction: 'asc')
            ->get()
            ->toArray();
    }

    /**
     * Deletes all migrations in the given batch.
     *
     * @param int $batch
     *
     * @throws \Exception
     */
    public function removeByBatch(int $batch) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($batch) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'batch', value: $batch)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "🗑 Removed all migrations in batch {$batch}.");
    }

    /**
     * Removes a specific migration record from the database.
     *
     * @param string $migration Name of the migration to delete.
     *
     * @throws Throwable If deletion fails.
     */
    public function delete(string $migration) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($migration) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'migration', value: $migration)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "Deleted migration '{$migration}'.");
    }

    /**
     * Finds all migrations for a specific batch in reverse order (for rollback).
     *
     * @param int $batch
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Random\RandomException
     */
    public function findByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->orderBy(column: 'id', direction: 'desc')
            ->get()
            ->toArray();
    }

}

=== Runner/Service/MigrationStateManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Manages the lifecycle of migrations, including execution, rollback, refresh, and fresh operations.
 */
final readonly class MigrationStateManager
{
    public function __construct(
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface|null         $logger = null
    ) {}

    /**
     * Refresh migrations by rolling back all and reapplying them.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If the refresh process fails.
     */
    public function refresh(array $availableMigrations) : void
    {
        try {
            $this->rollbackAll();
            $this->migrate(availableMigrations: $availableMigrations);
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to refresh migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback all migrations batch by batch.
     *
     * @throws MigrationException If rolling back migrations fails.
     */
    public function rollbackAll() : void
    {
        try {
            while ($batch = $this->migrationRepository->getLatestBatch()) {
                $this->rollbackBatch(batch: $batch);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : 'Failed to rollback all migrations: ' . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a specific batch of migrations.
     *
     * @param int $batch Batch ID to rollback.
     *
     * @throws MigrationException If rolling back the batch fails.
     */
    public function rollbackBatch(int $batch) : void
    {
        try {
            foreach ($this->migrationRepository->getMigrationsByBatch(batch: $batch) as $migration) {
                $this->rollbackMigration(migration: $migration['migration']);
                $this->migrationRepository->delete(migration: $migration['migration']);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to rollback batch " . $batch . ": " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If rolling back the migration fails.
     */
    private function rollbackMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: sprintf("Migration class '%s' not found.", $fullNamespace));
            }

            $instance = app($fullNamespace);
            if (! $instance instanceof Migration) {
                throw new MigrationException(
                    message: sprintf("Migration '%s' must extend the base Migration class.", $fullNamespace)
                );
            }

            $instance->executeDown();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : sprintf("Failed to rollback migration '%s': %s", $migration, $throwable->getMessage()),
                previous: $throwable
            );
        }
    }

    /**
     * Resolves the full namespace of the migration class.
     *
     * @param string $className The migration class name.
     *
     * @return string Fully qualified namespace of the class.
     */
    private function resolveFullNamespace(string $className) : string
    {
        $availableNamespaces = config(key: 'app.namespaces.Migrations', default: []);

        $fullNamespace = rtrim((string) $availableNamespaces, '\\') . '\\' . ltrim($className, '\\');
        if (class_exists($fullNamespace)) {
            $this->logInfo('Resolved migration namespace: ' . $fullNamespace);

            return $fullNamespace;
        }

        throw new MigrationException(message: sprintf("Unable to resolve namespace for class: '%s'.", $className));
    }

    /**
     * Log an informational message.
     *
     * @param string $message The message to log.
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Migrate all pending migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If applying migrations fails.
     */
    public function migrate(array $availableMigrations) : void
    {
        try {
            $pending = $this->getPendingMigrations(availableMigrations: $availableMigrations);

            if ($pending === []) {
                $this->logInfo(message: "No migrations to execute.");

                return;
            }

            $batchId = $this->migrationRepository->getLatestBatch() + 1;

            foreach ($pending as $migration) {
                $this->runMigration(migration: $migration);
                $this->migrationRepository->save(
                    migration : $migration,
                    executable: $this->resolveFullNamespace($migration),
                    batch     : $batchId
                );
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to execute migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Get pending migrations by comparing available with executed migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @return array List of pending migrations.
     */
    private function getPendingMigrations(array $availableMigrations) : array
    {
        $executed = array_column($this->migrationRepository->getAll(), 'migration');

        return array_diff($availableMigrations, $executed);
    }

    /**
     * Run a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If applying the migration fails.
     */
    private function runMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: "Migration class '" . $fullNamespace . "' not found.");
            }

            $instance = app($fullNamespace);

            if (! $instance instanceof Migration) {
                $this->logInfo(message: "Skipping non-migration class '" . $fullNamespace . "'.");

                return;
            }

            $instance->executeUp();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to run migration '" . $migration . "': " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}

=== Runner/Stubs/anonymous-migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Anonymous database migration.
 *
 * This migration is responsible for applying and rolling back schema changes
 * within the database context, using an immutable, declarative approach.
 *
 * @package {{Namespace}}
 * @readonly Guarantees immutability of the migration object
 * @version 1.0.0
 * @since PHP 8.3
 */
return new readonly class extends Migration
{
    /**
     * Perform the forward (up) migration.
     *
     * This method creates the database structure using the SchemaBuilder DSL,
     * applying all field definitions provided during migration generation.
     *
     * @return void
     *
     * @throws MigrationException If the schema creation process encounters an error
     */
    protected function up(): void
    {
        // Create a new database table dynamically defined during migration generation
        $this->schemaBuilder->create(
            table: '{{TableName}}',
            callback: function (Table $table): void {
                // Apply dynamically generated field definitions
                {{Fields}}

                // Add default created_at and updated_at timestamp columns
                $table->timestamps();
            }
        );

        // Output success message after schema creation
        $this->schemaBuilder->output(message: "🏗️ Migration executed: Table '{{TableName}}' created successfully.");
    }

    /**
     * Perform the rollback (down) migration.
     *
     * This method drops the previously created database table, reverting
     * the schema to its prior state before this migration execution.
     *
     * @return void
     *
     * @throws MigrationException If the schema rollback process encounters an error
     */
    protected function down(): void
    {
        // Drop the database table associated with this migration
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Output success message after table deletion
        $this->schemaBuilder->output(message: "🗑️ Migration rollback executed: Table '{{TableName}}' dropped successfully.");
    }
};

=== Runner/Stubs/controller.stub ===
<?php

declare(strict_types=1);

namespace {{namespace}};

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * {{ControllerName}} Controller
 *
 * RESTful Controller for managing resources.
 */
class {{ControllerName}}
{
    /**
     * Display a listing of the resource.
     *
     * @return ResponseInterface
     */
    public function index(): ResponseInterface
    {
        // Fetch all resources (dummy example data)
        $data = [
            ['id' => 1, 'name' => 'Resource 1'],
            ['id' => 2, 'name' => 'Resource 2'],
        ];

        // Return Blade view with data
        return view('resources.index', compact('data'));
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return ResponseInterface
     */
    public function create(): ResponseInterface
    {
        // Return Blade view for the create form
        return view('resources.create');
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param ServerRequestInterface $request
     * @return ResponseInterface
     */
    public function store(ServerRequestInterface $request): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Store the resource (dummy logic)
        // Example: Save to database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource created successfully.');
    }

    /**
     * Display the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function show(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view with resource data
        return view('resources.show', compact('resource'));
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function edit(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view for the edit form
        return view('resources.edit', compact('resource'));
    }

    /**
     * Update the specified resource in storage.
     *
     * @param ServerRequestInterface $request
     * @param int $id
     * @return ResponseInterface
     */
    public function update(ServerRequestInterface $request, int $id): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Update the resource (dummy logic)
        // Example: Update in database

        // Redirect to show page with success message
        return response(302, ['Location' => route('resources.show', ['id' => $id])])
            ->withHeader('X-Message', 'Resource updated successfully.');
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function destroy(int $id): ResponseInterface
    {
        // Delete the resource (dummy logic)
        // Example: Remove from database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource deleted successfully.');
    }
}

=== Runner/Stubs/dto.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Data Transfer Object for {{DTOName}}.
 */
final class {{DTOName}} extends AbstractDTO
{
{{Properties}}

}

=== Runner/Stubs/entity-querybuilder.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;

/**
 * Entity class with QueryBuilder integration for {{EntityName}}.
 */
class {{EntityName}} extends QueryBuilder
{
    /**
     * Table name associated with the entity.
     */
    protected string $tableName = '{{TableName}}';

{{QueryMethods}}
}

=== Runner/Stubs/entity.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

/**
 * Entity class for {{EntityName}}.
 */
class {{EntityName}}
{
{{Properties}}

    {{Constructor}}

{{Methods}}
}

=== Runner/Stubs/migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Database Migration Implementation for {{TableName}} Entity.
 *
 * This class represents a concrete database migration strategy implementing the schema
 * modifications for the {{TableName}} bounded context. It follows immutable design
 * principles and provides declarative schema definitions.
 *
 * @package {{Namespace}}
 * @final This class is not designed for inheritance
 * @readonly Ensures immutability of the migration definition
 * @version 1.0.0
 * @since PHP 8.3
 *
 * @template-implements Migration
 */
final readonly class {{MigrationName}} extends Migration
{
    /**
     * Executes the forward migration operation.
     *
     * Implements the schema creation logic using a fluent DSL pattern.
     * Creates the {{TableName}} table with defined columns and constraints.
     *
     * @return void
     * @throws MigrationException When schema creation fails
     *
     * @api
     */
    protected function up(): void
    {
        // Instantiate schema creation using fluent builder pattern
        $this->schemaBuilder->create(
            table: '{{TableName}}', // Named argument for better code clarity
            callback: function (Table $table): void {
                {{Fields}}

                // Adds standardized timestamp columns for entity lifecycle tracking
                $table->timestamps();
            }
        );

        // Provide feedback for migration execution monitoring
        $this->schemaBuilder->output("🏗️ Table '{{TableName}}' created successfully.");
    }

    /**
     * Executes the rollback migration operation.
     *
     * Implements the schema rollback logic by removing the {{TableName}} table
     * and all its associated constraints and indexes.
     *
     * @return void
     * @throws MigrationException When schema rollback fails
     *
     * @api
     */
    protected function down(): void
    {
        // Execute table removal using schema builder
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Provide feedback for rollback execution monitoring
       $this->schemaBuilder->output("🗑️ Table '{{TableName}}' dropped successfully.");
    }
}

=== Runner/Stubs/repository.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;
use {{EntityNamespace}}\{{EntityName}};

/**
 * Repository for {{RepositoryName}}.
 */
final class {{RepositoryName}}
{
    public function __construct(private QueryBuilder $queryBuilder) {}

    public function find(int $id): ?{{EntityName}}
    {
        $result = $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->first();

        return $result ? $this->mapToEntity($result) : null;
    }

    public function save({{EntityName}} $entity): int
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->insertGetId($entity->toArray());
    }

    public function update(int $id, {{EntityName}} $entity): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->update($entity->toArray());
    }

    public function delete(int $id): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->delete();
    }

    private function mapToEntity(array $data): {{EntityName}}
    {
        return new {{EntityName}}($data);
    }
}

=== Runner/Stubs/service.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Psr\Log\LoggerInterface;

/**
 * Service for {{ServiceName}}.
 */
final class {{ServiceName}}
{
    public function __construct(private LoggerInterface $logger) {}

    public function execute(array $input): array
    {
        $this->logger->info("Executing service logic for {{ServiceName}}.", ['input' => $input]);

        try {
            return $this->processLogic($input);
        } catch (\Throwable $exception) {
            $this->logger->error("Execution failed for {{ServiceName}}.", ['error' => $exception->getMessage()]);
            throw new \RuntimeException("Failed to execute service logic.", 0, $exception);
        }
    }

    private function processLogic(array $input): array
    {
        return ['status' => 'success', 'processed_data' => $input];
    }
}

=== Runner/Stubs/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Stubs;

use Gemini\Gemini;
use RuntimeException;

/**
 * Resolves and loads stub files for generators.
 */
final readonly class StubResolver
{
    /**
     * Path to stub files in the framework for migrations.
     */
    private string $defaultStubPath;

    public function __construct()
    {
        // Use the Gemini enum to dynamically resolve the default stub path.
        $this->defaultStubPath = Gemini::MIGRATIONS->resolve() . 'stubs/';
    }

    /**
     * Resolves a stub file by its name.
     *
     * @param string $stubName Name of the stub file.
     *
     * @return string Content of the stub file.
     */
    public function resolve(string $stubName) : string
    {
        $filePath = $this->defaultStubPath . $stubName;

        if (! file_exists($filePath)) {
            throw new RuntimeException(message: 'Stub file not found: ' . $filePath);
        }

        return file_get_contents($filePath);
    }
}

