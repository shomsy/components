=== Attributes/AbstractRule.php ===
<?php

namespace Gemini\DataHandling\Validation\Attributes;

use Gemini\DataHandling\Validation\Attributes\Contracts\RuleValidator;

abstract class AbstractRule implements RuleValidator
{
    use RuleHelpers;

    /**
     * Common error thrower.
     */
    protected function fail(string $message, string $property) : never
    {
        throw new ValidationException("Validation failed on '{$property}': {$message}");
    }
}

=== Attributes/Contracts/RuleValidator.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Contracts;

use Gemini\Exception\ValidationException;

/**
 * Interface RuleValidator
 *
 * A contract for implementing custom validation rules for a Data Transfer Object (DTO).
 * This interface enforces a consistent structure and ensures flexibility
 * when implementing reusable and testable validation logic.
 */
interface RuleValidator
{
    /**
     * Validates the input value for a specific property of a Data Transfer Object (DTO).
     *
     * @param mixed  $value    The value to be validated.
     *                         It can be of any responseData type and represents the value assigned to the DTO property.
     * @param array  $responseData     The complete responseData array representing the DTO.
     *                         This allows access to other properties of the DTO during validation, enabling
     *                         advanced validation logic that involves relationships between properties.
     * @param string $property The name of the DTO property being validated.
     *                         This parameter identifies which specific property the $value represents.
     *
     * @throws ValidationException If the validation fails.
     *                             The exception provides details of the validation failure, enabling the caller
     *                             to handle validation errors appropriately, such as returning user-friendly error
     *                             messages or logging the failure for debugging purposes.
     */
    public function validate(mixed $value, array $responseData, string $property) : void;
}
=== Attributes/Hidden.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes;

use Attribute;

/**
 * Attribute Hidden
 *
 * Marks a DTO property as hidden from serialization (toArray, toJson).
 *
 * Pure marker – contains no logic. Interpreted by Serialization trait.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
final class Hidden
{
    //
}

=== Attributes/Rules/AcceptedIf.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate if a property value is "accepted" conditionally based on another field's value.
 *
 * The 'AcceptedIf' attribute ensures the given property is validated as accepted (with specific valid values)
 * if a condition on a another field's value is met. This allows for conditional validation logic to be applied
 * on responseData transfer objects.
 *
 * The class is marked readonly to indicate that instances should have immutable properties. This ensures
 * consistency and reliability of the validation logic once an instance is created with a specific condition.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates that a property is "accepted" if a certain condition in the responseData is met.
 *
 * The "acceptance" means that the value should be one of 'yes', 'on', 1, or true. If the condition specified
 * by conditionField and conditionValue is met and the value is not one of these acceptable values,
 * a ValidationException is thrown.
 *
 * @throws \Gemini\Exception\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AcceptedIf
{
    public function __construct(private string $conditionField, private mixed $conditionValue) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        if (($responseData[$this->conditionField] ?? null) === $this->conditionValue
            && ! in_array(
                $value,
                ['yes', 'on', 1, true],
                true,
            )) {
            throw new ValidationException(message: $property . " must be accepted.");
        }
    }
}

=== Attributes/Rules/Accepted.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class representing an "Accepted" validation rule.
 *
 * This class can be used as an attribute to ensure that a property
 * has an acceptable value such as 'yes', 'on', 1, or true.
 *
 * - Flags Attribute::TARGET_PROPERTY restricts usage to class properties.
 * - Throws ValidationException if the value does not meet acceptable criteria.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * This attribute class enforces that a property must be explicitly accepted.
 * It's used for properties where a confirmation or acknowledgment is required.
 * The acceptable values are 'yes', 'on', 1, or true.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Accepted
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array($value, ['yes', 'on', 1, true], true)) {
            throw new ValidationException(message: $property . ' must be accepted.');
        }
    }
}

=== Attributes/Rules/ActiveURL.php ===
<?php

declare(strict_types=1);

/**
 * ActiveURL Attribute class to enforce the validation of URLs.
 * This attribute can be applied to properties to ensure they are active URLs.
 * The requirement for the URL to be active involves both validation of URL format and DNS resolution.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates if the provided value is an active URL.
 *
 * This method checks if the given value is a valid URL format and also verifies
 * whether the host of the URL has a DNS A record. This dual-check ensures that
 * the URL is both syntactically correct and points to an existing domain.
 *
 * @param mixed  $value    The value to be validated as an active URL.
 * @param string $property The name of the property being validated, used in the exception message.
 *
 * @throws \Gemini\Exception\ValidationException if the value is not a valid or active URL.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ActiveURL
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_URL) || ! checkdnsrr(parse_url((string) $value, PHP_URL_HOST), 'A')) {
            throw new ValidationException(message: $property . ' must be an active URL.');
        }
    }
}

=== Attributes/Rules/AfterOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a property to be a date after or equal to a specified date.
 *
 * This attribute is applied at the property level within a Data Transfer Object (DTO).
 * It ensures that the validated date is not earlier than the provided comparison date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * Attribute class designed to enforce the rule that a given date must be
 * either after or equal to a specified date. This validation is used
 * in scenarios where certain business rules require dates to respect
 * a minimum threshold.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AfterOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate < $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be a date after or equal to %s.',
                             $property,
                             $this->date,
                         ),
            );
        }
    }
}

=== Attributes/Rules/After.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a date property must be after a specified date.
 *
 * The After attribute can be applied to properties to ensure the date value
 * assigned to the property is after a predefined date. This is particularly
 * useful in scenarios where certain events must occur after a specific date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * Validates that the provided date is after the date specified during instantiation.
 *
 * @throws \Gemini\Exception\ValidationException if the input date is not after the comparison date.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class After
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate <= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date after %s.', $property, $this->date));
        }
    }
}

=== Attributes/Rules/AlphaDash.php ===
<?php

declare(strict_types=1);

/**
 * This class represents a validation rule to ensure that a given property
 * contains only letters, numbers, dashes, and underscores.
 *
 * The class is marked as an attribute and is intended to be used on class properties.
 * The Attribute::TARGET_PROPERTY flag restricts its use to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates that the given value adheres to the AlphaDash rule.
 *
 * Ensures the value only contains letters, numbers, dashes, and underscores.
 *
 * @throws \Gemini\Exception\ValidationException if the value does not match the allowed pattern.
 *
 * Rationale: This validation is necessary for sanitizing inputs where only alphanumeric characters,
 * dashes, and underscores are allowed. It helps prevent potential security risks
 * and ensures consistency in the values stored or processed.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaDash
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^[\pL\pM\pN_-]+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(
                message: $property . ' may only contain letters, numbers, dashes, and underscores.',
            );
        }
    }
}

=== Attributes/Rules/AlphaNumOrEmail.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute to validate that a value is either alphanumeric or in a valid email format.
 *
 * This rule can be applied to properties of a class to ensure their value adheres to
 * the specified format. It supports usernames (alphanumeric) or valid email addresses.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AlphaNumOrEmail
{
    /**
     * Default error message template for validating either an alphanumeric username or a valid email.
     */
    private const string DEFAULT_ERROR_MESSAGE = 'The "%s" must be either an alphanumeric username or a valid email.';

    /**
     * Constructor for the AlphaNumOrEmail attribute.
     *
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private string|null $message = null) {}

    /**
     * Validates that the provided value is either alphanumeric or a valid email.
     *
     * @param mixed  $value The value to validate.
     * @param string $name  The property name being validated.
     *
     * @throws ValidationException If the value is not a valid alphanumeric string or email.
     */
    public function validate(mixed $value, string $name) : void
    {
        if (! $this->isValidValue($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $name),
                metadata: [
                              'property' => $name,
                              'value'    => $value,
                              'expected' => 'alphanumeric or valid email',
                          ]
            );
        }
    }

    /**
     * Checks if the value is a valid alphanumeric string or email.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is valid; false otherwise.
     */
    private function isValidValue(mixed $value) : bool
    {
        return is_string($value) && ($this->isAlphanumeric($value) || $this->isEmail($value));
    }

    /**
     * Determines if the string is alphanumeric.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is alphanumeric; false otherwise.
     */
    private function isAlphanumeric(string $value) : bool
    {
        return (bool) preg_match('/^[a-zA-Z0-9]+$/', $value);
    }

    /**
     * Determines if the string is a valid email.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is a valid email; false otherwise.
     */
    private function isEmail(string $value) : bool
    {
        return filter_var($value, FILTER_VALIDATE_EMAIL) !== false;
    }
}

=== Attributes/Rules/AlphaNum.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce alphanumeric validation on properties.
 *
 * This class can be used to annotate class properties to indicate that
 * they must only contain letters and numbers. This is particularly useful
 * for ensuring responseData integrity in DTOs (Data Transfer Objects) by validating
 * their properties against the alphanumeric constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * An attribute class to enforce that a property value consists solely of letters and numbers.
 *
 * This attribute can be applied to class properties to ensure responseData validation for alphanumeric characters.
 *
 * Note: This class relies on Unicode property escapes (\pL, \pM, \pN) to cover all letters, marks, and numbers,
 * allowing for internationalization support.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaNum
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^[\pL\pM\pN]+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' may only contain letters and numbers.');
        }
    }
}

=== Attributes/Rules/Alpha.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to ensure a property contains only alphabetic characters.
 *
 * This class uses the #[Attribute] annotation to indicate that it can be used as an attribute,
 * specifically targeting properties. The validation logic enforces that the value assigned to the
 * annotated property consists solely of letters (alpha characters).
 *
 * Using this class helps in maintaining responseData integrity by validating properties directly at the attribute definition
 * level.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class used to validate that a property contains only letters.
 * Targets properties, indicating this rule applies at the property level.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Alpha
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^\pL+$/u', (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' must only contain letters.');
        }
    }
}

=== Attributes/Rules/ArrayRule.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property value must be an array.
 *
 * Annotated properties treated with this attribute will have
 * their values validated to ensure they are arrays. If not,
 * an exception is thrown to signal a validation failure.
 *
 * To be used specifically on property level.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class intended to enforce array type validation for properties.
 *
 * This class is designed to ensure that certain properties, when decorated with
 * this attribute, must hold array values. It integrates with the validation
 * mechanism throwing exceptions when validation fails.
 *
 * Decorate properties in DTOs with this class to enforce type constraints and
 * keep responseData integrity.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ArrayRule
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_array($value)) {
            throw new ValidationException(message: $property . ' must be an array.');
        }
    }
}

=== Attributes/Rules/BeforeOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class that ensures a property is a date before or equal to a specified date.
 *
 * This attribute can be applied to properties and ensures that their value is a date
 * formatted as 'Y-m-d' that is before or equal to the date specified during instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * This attribute class enforces that a given date must be before or equal to a specified date.
 *
 * The readonly modifier ensures immutability, providing a safeguard against accidental changes to the date property.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class BeforeOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate > $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be a date before or equal to %s.',
                             $property,
                             $this->date,
                         ),
            );
        }
    }
}

=== Attributes/Rules/Before.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce date validation rules.
 *
 * This Attribute can only be applied to properties.
 * It checks if a given date value is before a specified date.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * Attribute to validate if a given date is before a specified date.
 *
 * The "Before" class is a read-only attribute designed to enforce a date validation rule.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Before
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate >= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date before %s.', $property, $this->date));
        }
    }
}

=== Attributes/Rules/Between.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to impose a "between" validation rule on a property.
 *
 * This attribute is intended to be used on properties that need to ensure
 * their values lie between a specified minimum and maximum range.
 *
 * The class is marked as read-only to prevent changes to the min and max
 * values after instantiation, ensuring the integrity of the validation rule.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class for enforcing that a property's value is within a specified range.
 *
 * Modifiers:
 * - This class is read-only to ensure immutability once it is constructed.
 * - It is intended to be used as a property attribute.
 *
 * Use this class to validate that a given property falls within a specific minimum and maximum range.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Between
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value < $this->min || $value > $this->max) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be between %d and %d.',
                             $property,
                             $this->min,
                             $this->max,
                         ),
            );
        }
    }
}

=== Attributes/Rules/Boolean.php ===
<?php

declare(strict_types=1);

/**
 * A custom attribute to validate boolean values.
 *
 * This attribute is applied to properties within Data Transfer Objects (DTOs). The validation ensures that the
 * property
 * value adheres to a boolean format. The attribute itself helps enforce responseData consistency and integrity, typically in
 * responseData handling and transfer scenarios.
 *
 * Note: The #[Attribute(flags: Attribute::TARGET_PROPERTY)] syntax ensures this attribute can only be applied to
 * properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates that the provided value is a boolean.
 * Throws a ValidationException if the value is not a boolean.
 *
 * The use of filter_var with FILTER_VALIDATE_BOOLEAN and FILTER_NULL_ON_FAILURE
 * ensures that we are only accepting true or false values. This is important
 * as some values (e.g., "yes", "no") might incorrectly pass simple boolean checks.
 *
 * The rationale here is to provide strict validation for a boolean context,
 * ensuring responseData consistency and avoiding potential bugs arising from loosely
 * validated values.
 *
 * @throws \Gemini\Exception\ValidationException if the value is not a boolean.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Boolean
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_bool(filter_var($value, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE))) {
            throw new ValidationException(message: $property . ' field must be true or false.');
        }
    }
}

=== Attributes/Rules/Custom.php ===
<?php

declare(strict_types=1);

/**
 * The Custom attribute class allows for custom validation logic to be applied
 * to object properties. This is particularly useful for defining property-specific
 * validation rules that don't fit standard validation patterns.
 *
 * - `Attribute::TARGET_PROPERTY` ensures this attribute is applied to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Closure;
use Gemini\Exception\ValidationException;

/**
 * Indicates that this attribute is targeting a property and is immutable.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Custom
{
    public function __construct(private Closure $callback) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $isValid = ($this->callback)($value);
        if (! $isValid) {
            throw new ValidationException(message: $property . ' is invalid according to custom rule.');
        }
    }
}

=== Attributes/Rules/DateEquals.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a date equality rule on a DTO property.
 *
 * This attribute ensures that a property's date value matches a specified date.
 * Useful for scenarios where a particular date needs to be strictly validated,
 * such as ensuring a creation date matches a record date.
 *
 * - Declared readonly to emphasize immutability once initialized.
 * - Can only be applied to class properties (TARGET_PROPERTY).
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * Validates that the given value matches the specified date.
 *
 * The validation checks for strict equality between the input date
 * and the configured date. The date format used is 'Y-m-d'.
 *
 * @throws \Gemini\Exception\ValidationException if the dates do not match or if either date is invalid.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateEquals
{
    public function __construct(private string $date) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate != $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date equal to %s.', $property, $this->date));
        }
    }
}

=== Attributes/Rules/DateFormat.php ===
<?php

declare(strict_types=1);

/**
 * This class is an attribute that enforces a specific date format on a property.
 *
 * The 'readonly' keyword ensures immutability, making sure that once the attribute
 * is instantiated, its properties cannot be modified.
 *
 * Applied for property-level validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * The DateFormat class is a read-only attribute used to enforce a specific date format on a property.
 *
 * It leverages PHP's native DateTime class to attempt parsing the string into a date
 * according to the specified format. If the parsing fails, or if the parsed date does not match
 * the original string, a ValidationException is thrown. This is crucial for ensuring date fields
 * consistently conform to expected formats, which can help prevent errors related to date handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateFormat
{
    public function __construct(private string $format) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $date = DateTime::createFromFormat(format: $this->format, datetime: $value);
        if (! $date || $date->format(format: $this->format) !== $value) {
            throw new ValidationException(
                message: sprintf('%s does not match the format %s.', $property, $this->format),
            );
        }
    }
}

=== Attributes/Rules/Date.php ===
<?php

declare(strict_types=1);


/**
 * Includes a date validation attribute which targets properties.
 * Ensures that property values conform to date formats 'Y-m-d' or 'Y-m-d H:i:s'.
 *
 * This attribute can be instantiated and used to provide a clear validation rule
 * for date properties, simplifying validation logic in the broader application.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTime;
use Gemini\Exception\ValidationException;

/**
 * This class is an attribute used to validate date properties.
 *
 * It ensures that the value assigned to a property is a valid date
 * in the standard formats 'Y-m-d' or 'Y-m-d H:i:s'. If the value
 * does not conform to these formats, a ValidationException is thrown.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Date
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! DateTime::createFromFormat(format: 'Y-m-d', datetime: $value) && ! DateTime::createFromFormat(
                format  : 'Y-m-d H:i:s',
                datetime: $value,
            )) {
            throw new ValidationException(message: $property . " is not a valid date.");
        }
    }
}

=== Attributes/Rules/Different.php ===
<?php

declare(strict_types=1);

/**
 * The Different validation attribute is used to enforce that a property must have a different value
 * from another specified property within the same responseData context.
 *
 * This is a read-only attribute applied to a class property, ensuring immutability after instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * The Different class is an immutable validator to ensure that a given property in a dataset
 * differs from another specified property. It is intended to be used as an attribute for responseData validation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Different
{
    public function __construct(private string $field) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        if ($value === ($responseData[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be different from %s.', $property, $this->field));
        }
    }
}

=== Attributes/Rules/DigitsBetween.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a digit-based range constraint on a property.
 *
 * This Attribute is declared as read-only and targets properties.
 * It ensures that the value of the property contains only digits and
 * that the number of digits falls within the specified minimum and maximum range.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Class DigitsBetween
 *
 * This class contains validation logic to ensure that a given value is a string
 * composed only of digits and that its length falls within a specified minimum
 * and maximum range.
 *
 * Marked as readonly to indicate immutability: once instantiated, the properties
 * $min and $max should not be altered.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DigitsBetween
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match('/^\d+$/', (string) $value), [0, false], true) || strlen(
                                                                                      (string) $value,
                                                                                  ) < $this->min || strlen(
                                                                                                        (string) $value,
                                                                                                    ) > $this->max) {
            throw new ValidationException(
                message: sprintf(
                             '%s must be between %d and %d digits.',
                             $property,
                             $this->min,
                             $this->max,
                         ),
            );
        }
    }
}

=== Attributes/Rules/Digits.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a property to contain exactly a specified number of digits.
 *
 * - This class can only be used as a property attribute (TARGET_PROPERTY).
 * - The 'readonly' keyword denotes that the property values cannot be changed after instantiation.
 * - Instantiated with a single parameter 'digits' to determine the number of digits required.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Readonly class to validate that a property consists of a specific number of digits.
 *
 * @Attribute aims to use this class as a property attribute in another class.
 * This is useful for validating property values against a specific constraint.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Digits
{
    public function __construct(private int $digits) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match(sprintf('/^\d{%d}$/', $this->digits), (string) $value), [0, false], true)) {
            throw new ValidationException(message: sprintf('%s must be %d digits.', $property, $this->digits));
        }
    }
}

=== Attributes/Rules/Distinct.php ===
<?php

declare(strict_types=1);

/**
 * The Distinct attribute is used to ensure that all elements in a property array are unique.
 * It is applied to a property using the PHP attribute syntax.
 *
 * @Attribute(flags: Attribute::TARGET_PROPERTY)
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class to enforce uniqueness constraint on property values.
 * This class uses the Attribute flag TARGET_PROPERTY to specify that it
 * should be used on class properties. Ensures that an array property
 * contains unique elements only.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Distinct
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (count($value) !== count(array_unique($value))) {
            throw new ValidationException(message: $property . ' field has a duplicate value.');
        }
    }
}

=== Attributes/Rules/DTOArrayOf.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Attribute to automatically transform an array into an array of DTOs.
 *
 * Used for fields like: array<int, FieldDTO>
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class DTOArrayOf
{
    /**
     * @param class-string<AbstractDTO> $class Fully-qualified DTO class name
     */
    public function __construct(public string $class) {}

    /**
     * Transforms the input array into DTO instances
     *
     * @param array|null $value
     *
     * @return array<int, AbstractDTO>
     */
    public function apply(array|null $value) : array
    {
        return array_map(
            fn(array $item) => new ($this->class)($item),
            $value ?? []
        );
    }
}

=== Attributes/Rules/DTOObjectOf.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class DTOObjectOf
{
    public function __construct(public string $class) {}

    public function apply(array|object|null $value) : AbstractDTO|null
    {
        if (is_null($value)) {
            return null;
        }

        return new ($this->class)((array) $value);
    }
}

=== Attributes/Rules/Email.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to mark a property as needing email validation.
 *
 * This custom attribute can be used on property declarations to enforce
 * email validation rules, encapsulating the validation logic in a reusable manner.
 *
 * Example:
 *
 * #[Email]
 * private string $email;
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates whether the provided value is a valid email address.
 *
 * @throws \Gemini\Exception\ValidationException if the value is not a valid email address.
 *
 * The rationale for this approach is to ensure that only valid email addresses are accepted and
 * stored within the system. By enforcing this validation at the point where the attribute is used,
 * it provides a centralized validation mechanism that ensures consistency across different parts
 * of the application where the Email attribute is applied.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Email
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_EMAIL)) {
            throw new ValidationException(message: $property . ' must be a valid email address.');
        }
    }
}

=== Attributes/Rules/EndsWith.php ===
<?php

declare(strict_types=1);

/**
 * Represents a validation rule that asserts a property must end with one of the specified suffixes.
 *
 * This attribute is exclusively designed to be used on class properties, ensuring that the designated
 * property ends with one of the provided suffixes during validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * The EndsWith class is used to validate that a given value ends with one of the specified suffixes.
 *
 * This is particularly useful for ensuring values like file extensions, URLs, or other string properties
 * meet specific criteria. Instead of marking individual properties with multiple attributes, this class
 * allows for a centralized validation logic.
 *
 * ## Why Readonly:
 * The readonly class modifier is used here to ensure immutability of class instances. Once instantiated,
 * the suffixes cannot be altered, providing consistent behaviour throughout the lifetime of the object.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EndsWith
{
    public function __construct(private array $suffixes) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->suffixes as $suffix) {
            if (str_ends_with((string) $value, (string) $suffix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must end with one of the following: ' . implode(', ', $this->suffixes),
        );
    }
}

=== Attributes/Rules/EnumAreValuesAllowed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * EnumAreValuesAllowed Attribute
 *
 * This validation attribute ensures that a property is an array containing only
 * valid values of a specified Enum class. It applies validation rules during runtime and
 * supports declarative validation of Data Transfer Objects (DTOs) in a clean and DDD-friendly way.
 *
 * Example usage:
 * ```
 * #[EnumAreValuesAllowed(MyEnum::class)]
 * private array $myProperty;
 * ```
 *
 * - The `readonly` modifier ensures immutability after instantiation.
 * - The attribute works only on class properties (`TARGET_PROPERTY`).
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EnumAreValuesAllowed
{
    /**
     * Fully qualified class name of the Enum to validate against.
     *
     * @var string $enumClass The expected Enum class, which must implement `BackedEnum` to support `tryFrom`.
     */
    public function __construct(
        private string $enumClass,
        private bool   $strict = false // disallow null if strict = true
    ) {}

    /**
     * Validates whether the given value is an array of valid Enum instances or Enum-backed values.
     *
     * @param mixed  $value    The property value to validate.
     * @param string $property The name of the property (used for exception messages).
     *
     * @throws ValidationException If the validation fails due to:
     *                              - The value not being an array.
     *                              - The array containing invalid Enum values.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; // ⬅️ Null is valid — ignore further validation
        }

        // Ensure the value is an array
        if (! is_array($value)) {
            throw new ValidationException(
                message: "{$property} must be an array of {$this->enumClass}"
            );
        }

        // Iterate through the array to validate each element
        foreach ($value as $v) {
            if ($v === null) {
                throw new ValidationException(message: "{$property} must not contain null values");
            }

            $resolved = is_object($v) ? $v : ($this->enumClass)::tryFrom($v);

            if (! $resolved instanceof $this->enumClass) {
                throw new ValidationException(
                    message: "{$property} contains invalid enum value: " . var_export($v, true)
                );
            }
        }
    }

    /**
     * Applies the Enum resolution to each element of the value if valid.
     *
     * This method accepts an array of Enum-backed values or Enum instances and ensures
     * that all elements are converted into instances of the specified Enum class.
     *
     * @param mixed $value The property value to process.
     *
     * @return array|null Returns an array of Enum instances if the input is valid, null otherwise.
     */
    public function apply(mixed $value) : array|null
    {
        // Resolve each array element to its respective Enum instance, or return null if not an array
        return is_array($value)
            ? array_map(
                fn($v) => is_object($v) ? $v : ($this->enumClass)::tryFrom($v),
                $value
            )
            : null;
    }
}
=== Attributes/Rules/EnumIsValueAllowed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use BackedEnum;
use Gemini\Exception\ValidationException;

/**
 * Attribute: EnumIsValueAllowed
 *
 * A declarative validation rule that ensures a property adheres to a specified enum constraint.
 * This attribute enforces that the annotated property either:
 * - Is already an instance of the specified Enum class.
 * - Resolves from a scalar value (if the Enum class is backed).
 *
 * If the value cannot be resolved to a valid Enum instance or scalar value, a ValidationException
 * is thrown with an appropriate error describing the issue.
 *
 * **Key Usage:**
 * - This Attribute ensures cleaner and more maintainable DTO properties within DDD contexts.
 * - Limited to `#[Attribute::TARGET_PROPERTY]` for enforcement at the property level.
 *
 * This validator relies on the PHP 8.1+ `BackedEnum` interface for backed enums.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class EnumIsValueAllowed
{
    /**
     * Constructor for the EnumIsValueAllowed Attribute.
     *
     * Leverages Constructor Promotion for concise and expressive class definition.
     *
     * @param class-string<BackedEnum> $enumClass Fully qualified Enum class name.
     *                                            This must be a valid class implementing PHP's `BackedEnum` interface.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates the value against the specified Enum class.
     *
     * This method ensures the following:
     * - If the value is already an instance of the predefined Enum class, no further action is required.
     * - For scalar values (e.g., strings, integers), the method attempts to resolve the value into a backed Enum case.
     * - Throws a `ValidationException` if:
     *   1. The resolution fails (e.g., the provided scalar does not map to any Enum case).
     *   2. The provided value is not an Enum instance or a valid scalar convertible to a case.
     *
     * @param mixed  $value    The value to validate. This can refer to any mixed-type responseData.
     *                         Passed as a reference (`&`) to apply inline transformations (e.g., scalar -> Enum
     *                         conversion).
     * @param string $property The name of the property being validated.
     *                         Used to provide meaningful error messages for exceptions.
     *
     * @throws ValidationException If the value cannot be validated or resolved to the specified Enum.
     */
    public function validate(mixed &$value, string $property) : void
    {
        // Retrieve the Enum class provided in the attribute.
        $enumClass = $this->enumClass;

        // Step 1: If the value is already an instance of the given Enum class, validation succeeds.
        if ($value instanceof $enumClass) {
            return;
        }

        // Step 2: If the value is a scalar (e.g., string, int), check for compatibility with backed Enums.
        if (is_scalar($value) && is_subclass_of($enumClass, BackedEnum::class)) {
            // Attempt to resolve the scalar value into a backed Enum case using 'tryFrom'.
            $resolved = $enumClass::tryFrom($value);

            // If the value was successfully resolved, update the reference and exit.
            if ($resolved !== null) {
                $value = $resolved;

                return;
            }

            // Step 3: If resolution failed, enumerate all possible backed values for error clarity.
            $allowed = implode(
                ', ',
                array_map(
                    static fn(BackedEnum $e) => $e->value, // Extract each Enum's value.
                    $enumClass::cases() // Retrieve all cases for the Enum.
                )
            );

            // Throw an exception with the allowed values for better debugging and usage feedback.
            throw new ValidationException(
                message: "{$property} must be one of enum {$enumClass}: {$allowed}"
            );
        }

        // Step 4: If the value is neither a valid Enum instance nor a valid scalar convertible to an Enum, throw an exception.
        throw new ValidationException(
            message: "{$property} must be an instance or value of {$enumClass}"
        );
    }
}
=== Attributes/Rules/Enum.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use BackedEnum;
use Gemini\Exception\ValidationException;
use UnitEnum;

/**
 * Enum Validator Attribute
 *
 * Ensures that the provided value matches the specified enum type.
 * Supports both:
 * - Standard enum instances.
 * - Scalar values mapping to `BackedEnum` values.
 * Throws a validation exception when the value violates the constraint.
 *
 * Use attribute declaration to enable declarative validations for Data Objects.
 * Complies with strict type safety and clean code principles.
 *
 * @template T of UnitEnum
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class Enum
{
    /**
     * Initializes the Enum Validator Attribute.
     *
     * @param class-string<T> $enumClass The fully qualified class name of the target enum.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates whether the provided value is a valid enum instance or a scalar value
     * that can be mapped to a `BackedEnum`.
     *
     * @param mixed  $value    The value being validated; expected to be an enum instance or backed value.
     * @param string $property The name of the property being validated (for meaningful exception messages).
     *
     * @throws ValidationException When the value does not match the expected enum or backed enum type.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the provided class exists and is a valid enum.
        if (! enum_exists($this->enumClass)) {
            // Throws an exception when the class does not exist or is not declared as an enum.
            throw new ValidationException(
                message: "Enum class '{$this->enumClass}' does not exist."
            );
        }

        // If the value is already an instance of the specified enum, accept it as valid.
        if ($value instanceof $this->enumClass) {
            return; // Validation passes with no further checks needed.
        }

        // If the value is scalar, validate its compatibility with BackedEnum.
        if (is_scalar($value) && is_subclass_of($this->enumClass, BackedEnum::class)) {
            // Extract all scalar values (backed values) from the enum cases.
            $values = array_column($this->enumClass::cases(), 'value');

            // If the scalar value matches one of the allowed enum backed values, validation passes.
            if (in_array($value, $values, true)) {
                return; // Validation passes; exit early.
            }

            // Throw an exception if the scalar value does not match any of the allowed backed values.
            throw new ValidationException(
                message: "{$property} must be one of: " . implode(', ', $values)
            );
        }

        // Fallback: Reject any other types (e.g., arrays, objects without compatibility).
        throw new ValidationException(message: "{$property} must be a valid enum of type {$this->enumClass}");
    }
}
=== Attributes/Rules/FileException.php ===
<?php

declare(strict_types=1);

/**
 * FileException ensures that a given property's value is a valid file.
 *
 * This attribute is applied to properties of a Data Transfer Object (DTO)
 * to enforce file validation rules. The class uses PHP's Attribute feature,
 * which allows adding metadata to classes, methods, properties, and more.
 *
 * The class operates under the assumption that file validation is critical
 * for the correctness and security of the business logic in the application
 * where it's used.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Custom exception for file validation errors.
 *
 * This class is used as an attribute to indicate that the associated property
 * should be validated to ensure it is a file. The rationale behind this custom
 * exception is to provide a more specific and meaningful error when validation fails.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FileException
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_file($value)) {
            throw new ValidationException(message: $property . ' must be a file.');
        }
    }
}

=== Attributes/Rules/Filled.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce that a property must have a value.
 * Applied as a property validator using attributes.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class used to enforce that a property must have a value.
 *
 * This Attribute is intended to be used on properties to ensure they are not empty.
 * The rationale behind this class is to provide a simple way to perform validation
 * through attribute-based validation mechanism which enhances readability and maintains
 * validation logic closer to the responseData definition.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Filled
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (empty($value)) {
            throw new ValidationException(message: $property . ' must have a value.');
        }
    }
}

=== Attributes/Rules/FloatRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute to enforce that a property value must be a float.
 *
 * This attribute validates that the value of a property is a float. It is
 * primarily used in DTOs to ensure responseData integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FloatRule
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a valid float.';

    /**
     * Constructor for the FloatRule attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a float or numeric.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a float or numeric.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_float($value) && ! is_numeric($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'expected' => 'float',
                              'actual'   => gettype($value),
                          ]
            );
        }
    }
}

=== Attributes/Rules/ImageDimension.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate image dimensions for a property in a DTO.
 *
 * This class checks various constraints like specific width, height,
 * minimum and maximum dimensions, and aspect ratio. It is designed to
 * be used as an attribute on properties within responseData transfer objects (DTOs).
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Exception;
use Gemini\Exception\ValidationException;

/**
 * This readonly class is used to encapsulate the dimensions of an image and ensure they adhere to specified validation
 * rules. The readonly modifier ensures immutability, which is crucial for maintaining consistency in image validation
 * parameters.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class ImageDimension
{
    public function __construct(
        private int|null   $width = null,
        private int|null   $height = null,
        private int|null   $min_width = null,
        private int|null   $min_height = null,
        private int|null   $max_width = null,
        private int|null   $max_height = null,
        private float|null $ratio = null,
    ) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        try {
            $dimensions = getimagesize($value);

            $width  = $dimensions[0];
            $height = $dimensions[1];

            if ($this->width !== null && $width !== $this->width) {
                throw new ValidationException(message: sprintf('%s must be %d pixels wide.', $property, $this->width));
            }

            if ($this->height !== null && $height !== $this->height) {
                throw new ValidationException(message: sprintf('%s must be %d pixels tall.', $property, $this->height));
            }

            if ($this->min_width !== null && $width < $this->min_width) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s must be at least %d pixels wide.',
                                 $property,
                                 $this->min_width,
                             ),
                );
            }

            if ($this->min_height !== null && $height < $this->min_height) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s must be at least %d pixels tall.',
                                 $property,
                                 $this->min_height,
                             ),
                );
            }

            if ($this->max_width !== null && $width > $this->max_width) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels wide.', $property, $this->max_width),
                );
            }

            if ($this->max_height !== null && $height > $this->max_height) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels tall.', $property, $this->max_height),
                );
            }

            if ($this->ratio !== null && abs($width / $height - $this->ratio) > 0.0001) {
                throw new ValidationException(message: sprintf('%s aspect ratio must be %s.', $property, $this->ratio));
            }
        } catch (Exception) {
            throw new ValidationException(message: $property . ' has invalid image dimensions.');
        }
    }
}

=== Attributes/Rules/Image.php ===
<?php

declare(strict_types=1);

/**
 * Defines an attribute to validate that a property is an image.
 *
 * This attribute should be used to annotate properties that are expected to
 * hold image file names or paths. The validation logic checks the file
 * extension against a pre-defined list of allowed image formats.
 *
 * Usage:
 * #[Image]
 * private $imageProperty;
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validate that the provided file's extension is among the allowed image types.
 *
 * INTENT: Ensure that the input value is a valid image format to prevent
 * invalid responseData from entering the system, which could cause errors downstream.
 * This method throws an exception if validation fails to enforce strict conformity.
 *
 * @throws \Gemini\Exception\ValidationException If the file extension is not permitted.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Image
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $allowedMimes = ['jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'];
        $extension    = strtolower(pathinfo((string) $value, PATHINFO_EXTENSION));
        if (! in_array($extension, $allowedMimes, true)) {
            throw new ValidationException(message: $property . ' must be an image.');
        }
    }
}

=== Attributes/Rules/In.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute that validates a property's value is one of a predefined set.
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class In
{
    /**
     * @param array<int|string> $values List of accepted values for the field.
     */
    public function __construct(private array $values) {}

    /**
     * Validates whether a given value is in the allowed set.
     *
     * @param mixed  $value    Value to validate.
     * @param string $property Property name (for exception context).
     *
     * @throws ValidationException If the value is not in the list of allowed values.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Unwrap enum to scalar value if needed
        if (is_object($value) && method_exists($value, 'value')) {
            $value = $value->value;
        }

        // Perform strict comparison against an allowed set
        if (! in_array($value, $this->values, true)) {
            $allowed = implode(', ', array_map('strval', $this->values));

            throw new ValidationException(
                message: "{$property} must be one of: {$allowed}"
            );
        }
    }
}

=== Attributes/Rules/Integer.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Class Integer
 *
 * This class is an attribute used for validating that the targeted property is an integer.
 * It is designed to enforce validation rules declaratively using PHP's Attribute syntax
 * and ensures that incorrect responseData types are rejected with clear exception handling.
 *
 * Domain-Driven Design (DDD) implications:
 * - Acts as a declarative rule for property validation within domain entities or value objects.
 * - Short-circuits invalid input before further operations, preserving domain integrity.
 *
 * @package Gemini\DataHandling\Validation\Attributes\Rules
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)] // Restricts this attribute to properties.
class Integer
{
    /**
     * The default error message used when the validation fails.
     *
     * This constant defines a generic error message indicating that the value must be an integer.
     * It uses a placeholder to include the property name dynamically.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be an integer.';

    /**
     * Custom error message for validation failures.
     *
     * @var string|null $message A custom message provided at instantiation to override the default.
     *                           If null, the default error message will be used.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the given value is an integer.
     *
     * A property is validated against this rule. If the value does not satisfy the constraint,
     * a `ValidationException` is thrown, containing detailed metadata about the failure.
     *
     * @param mixed  $value    The value to be validated. Can be any type, as mixed is used.
     * @param string $property The name of the property being validated, for error context.
     *
     * @return void
     *
     * @throws ValidationException If the value is not an integer.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the value is not an integer.
        if (! is_int($value)) {
            // Throw a detailed validation exception if the value is invalid.
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                // Use a custom or default error message.
                metadata: [
                              'property' => $property, // The name of the property being validated.
                              'value'    => $value,    // The actual value that failed validation.
                              'expected' => 'int',     // The expected type of the value (integer).
                              'actual'   => gettype($value), // The actual type of the provided value.
                          ]
            );
        }
    }
}
=== Attributes/Rules/IPAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to indicate that a property must be a valid IP address.
 *
 * This class is designed to be used as an attribute on properties within
 * Data Transfer Objects (DTOs). It validates that the given property value is a
 * valid IP address, ensuring responseData integrity and consistency.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * This class is designed to validate IP addresses for properties marked with the TARGET_PROPERTY attribute.
 *
 * The primary behavior of this class is to ensure that values assigned to certain properties are valid IP addresses,
 * throwing a ValidationException otherwise. This ensures responseData integrity and consistency across the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPAddress
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== Attributes/Rules/IP.php ===
<?php

declare(strict_types=1);

/**
 * IP Attribute class used to validate that a property holds a valid IP address.
 *
 * This class is designed to be instantiated as an attribute to enforce that a property
 * within a Data Transfer Object (DTO) is a valid IP address. Utilizing PHP's Attribute
 * syntax makes the validation declarative and more maintainable.
 *
 * - The `TARGET_PROPERTY` flag ensures that this attribute can only be applied to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validate if the given value is a valid IP address.
 * Throws an exception if validation fails.
 *
 * @throws \Gemini\Exception\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IP
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== Attributes/Rules/IPv4.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce IPv4 validation on properties.
 *
 * This class will be used to annotate properties and ensure they contain valid IPv4 addresses.
 * The main decision here is to leverage PHP's filter_var function with the FILTER_VALIDATE_IP flag.
 * This is a better approach than regular expressions due to its efficiency and robustness.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * An attribute class to validate if a given value is a valid IPv4 address.
 *
 * The validation is essential for ensuring that the property this attribute
 * is applied to adheres to the IPv4 format, which can be critical for
 * network configurations and communication protocols.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv4
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            throw new ValidationException(message: $property . ' must be a valid IPv4 address.');
        }
    }
}

=== Attributes/Rules/IPv6.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to designate a property that must be a valid IPv6 address.
 * The use of this attribute triggers validation against the IPv6 format.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates that the given value is a proper IPv6 address. If not, it throws a ValidationException.
 *
 * @param mixed  $value    The value to be validated as an IPv6 address.
 * @param string $property The name of the property being validated.
 *
 * @throws \Gemini\Exception\ValidationException If the value is not a valid IPv6 address.
 *
 * The use of filter_var function with FILTER_VALIDATE_IP and FILTER_FLAG_IPV6 ensures that only valid IPv6 formats are
 * accepted, reinforcing responseData integrity especially where IP addresses are critical.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv6
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            throw new ValidationException(message: $property . ' must be a valid IPv6 address.');
        }
    }
}

=== Attributes/Rules/JSON.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for marking properties that should be validated as JSON.
 * Using #[Attribute(flags: Attribute::TARGET_PROPERTY)] to limit usage to properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates if the provided value is a valid JSON string.
 *
 * @throws \Gemini\Exception\ValidationException If the value is not a valid JSON string.
 *
 * The rationale for this function is to ensure that properties using this attribute
 * always contain valid JSON responseData. This helps maintain responseData integrity within the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class JSON
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        json_decode((string) $value);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new ValidationException(message: $property . ' must be a valid JSON string.');
        }
    }
}

=== Attributes/Rules/MACAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for defining a MAC address validation rule to be used on DTO properties.
 *
 * This class leverages PHP's Attribute feature introduced in PHP 8. It is intended to be
 * used as an attribute on properties in Data Transfer Objects (DTOs) to enforce that the
 * value of the property is a valid MAC address.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validate the given MAC address.
 *
 * This method uses PHP's built-in `filter_var` function to check if the input value
 * is a valid MAC address. If it's not, a `ValidationException` is thrown.
 *
 * @throws \Gemini\Exception\ValidationException If the given value is not a valid MAC address.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class MACAddress
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_MAC)) {
            throw new ValidationException(message: $property . ' must be a valid MAC address.');
        }
    }
}

=== Attributes/Rules/Max.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Countable;
use Gemini\Exception\ValidationException;
use InvalidArgumentException;

/**
 * Attribute to enforce a maximum value or length constraint on a property.
 *
 * Supports validation for strings, numerics, arrays, and countable objects.
 **/
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Max
{
    /** Error messages for different validation types. */
    private const string ERROR_NUMERIC   = 'The value of "%s" must not exceed %d.';

    private const string ERROR_STRING    = 'The length of "%s" must not exceed %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must not exceed %d.';

    private const string ERROR_INVALID   = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';

    /**
     * Constructor for the Max attribute.
     *
     * @param int         $max     The maximum value or size.
     * @param string|null $message Optional custom error message.
     *
     * @throws InvalidArgumentException If the max value provided is negative.
     */
    public function __construct(private readonly int $max, private readonly string|null $message = null)
    {
        // Ensure the maximum value is a non-negative integer.
        if ($max < 0) {
            throw new InvalidArgumentException(message: 'The maximum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the maximum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     **/
    public function validate(mixed $value, string $property) : void
    {
        // Allow null values (no validation required for null).
        if ($value === null) {
            return;
        }

        // Match the type of value to the appropriate validation method.
        match (true) {
            is_numeric($value)                              => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string($value)                               => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable($value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                                         => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    /**
     * Validates numeric values against the maximum constraint.
     *
     * @param float  $value    The numeric value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value exceeds the maximum.
     */
    private function validateNumeric(float $value, string $property) : void
    {
        if ($value > $this->max) {
            // The Numeric value exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    /**
     * Throws a ValidationException with relevant error details.
     *
     * @param string $errorKey The error key identifying the type of validation error.
     * @param string $property The name of the property being validated.
     * @param mixed  $value    The value that caused the validation failure.
     *
     * @throws ValidationException Always triggered when called.
     */
    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        // Constructs and throws a detailed ValidationException.
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at most %d.', ucfirst($property), $this->max),
            metadata: [
                          'property' => $property,
                          'value'    => $value,
                          'max'      => $this->max,
                          'errorKey' => $errorKey,
                      ]
        );
    }

    /**
     * Validates string values against the maximum length constraint.
     *
     * @param string $value    The string value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the string length exceeds the maximum.
     */
    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen($value) > $this->max) {
            // String length exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    /**
     * Validates array or countable values against the maximum count constraint.
     *
     * @param array|Countable $value    The array or countable value to validate.
     * @param string          $property The name of the property being validated.
     *
     * @throws ValidationException If the count exceeds the maximum.
     */
    private function validateCountable(array|Countable $value, string $property) : void
    {
        // Determine the count of elements.
        $count = is_array($value) ? count($value) : iterator_count($value);

        if ($count > $this->max) {
            // Element count exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}
=== Attributes/Rules/MigrationArrayRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates and casts to array from native array or JSON stringified array.
 *
 * Accepts:
 * - native PHP array
 * - JSON-encoded array string
 * - null
 *
 * Rejects:
 * - all other types (objects, ints, resources, strings that are not valid JSON arrays)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationArrayRule
{
    /**
     * Validates that the value is either a PHP array or a valid JSON string representing an array.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_array($value)) {
            return;
        }

        if (is_string($value) && json_validate(json: $value)) {
            $decoded = json_decode($value, true);

            if (is_array($decoded)) {
                return;
            }
        }

        throw new ValidationException(
            message: "{$property} must be a valid array or JSON array string. Got: " . get_debug_type($value)
        );
    }

    /**
     * Converts value to PHP array if valid. Returns null if value is null.
     *
     * @param mixed $value
     *
     * @return array|null
     */
    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Attributes/Rules/MigrationFieldAttributesRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\FieldModifierEnum;
use Gemini\Exception\ValidationException;

/**
 * Validates and casts an array of migration field modifiers.
 *
 * Accepts:
 * - FieldModifierEnum[]
 * - string[] matching FieldModifierEnum values
 *
 * Rejects:
 * - any non-array input
 * - values not resolvable via FieldModifierEnum::tryFrom()
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldAttributesRule
{
    /**
     * Validates an array of enum-compatible modifiers.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! is_array($value)) {
            throw new ValidationException(
                message: "{$property} must be an array of FieldModifierEnum values or string equivalents."
            );
        }

        foreach ($value as $item) {
            if ($item === null) {
                continue;
            }

            if ($item instanceof FieldModifierEnum) {
                continue;
            }

            if (! is_string($item)) {
                throw new ValidationException(
                    message: "{$property} contains non-string value: " . var_export($item, true)
                );
            }

            if (! FieldModifierEnum::tryFrom($item)) {
                throw new ValidationException(
                    message: "{$property} contains invalid field modifier: " . var_export($item, true)
                );
            }
        }
    }

    public function apply(mixed $value) : array|null
    {
        return is_array($value) ? $value : null;
    }

}

=== Attributes/Rules/MigrationFieldTypeRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Gemini\Exception\ValidationException;

/**
 * Validation rule for the 'type' field in FieldDTO.
 *
 * Ensures the field is either:
 * - an instance of FieldTypeEnum (hydrated previously), or
 * - null (optional field)
 *
 * No casting is done here – hydration must have resolved the correct type.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldTypeRule
{
    /**
     * Validates the 'type' field value without casting.
     *
     * @param mixed  $value    The raw or hydrated value of the property
     * @param string $property The property name being validated
     *
     * @throws ValidationException If the value is not null or a FieldTypeEnum instance
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! $value instanceof FieldTypeEnum) {
            throw new ValidationException(
                message: "{$property} must be an instance of FieldTypeEnum or null. Got: " . get_debug_type($value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}
=== Attributes/Rules/MigrationForeignActionRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Gemini\Exception\ValidationException;

/**
 * Validates the 'onDelete' and 'onUpdate' fields as valid ForeignActionEnum values.
 *
 * Accepts:
 * - null (no validation error)
 * - ForeignActionEnum instance (direct assignment)
 * - string (cast to enum via tryFrom)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationForeignActionRule
{
    /**
     * Validates that the input is either null or a valid ForeignActionEnum (or castable string).
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException If an invalid type or unknown enum case is given.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || $value instanceof ForeignActionEnum) {
            return;
        }

        if (! is_string($value)) {
            throw new ValidationException(message: "{$property} must be a string or ForeignActionEnum instance.");
        }

        if (ForeignActionEnum::tryFrom(value: $value) === null) {
            throw new ValidationException(
                message: "{$property} is not a valid ForeignActionEnum. Got: " . var_export($value, true)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Attributes/Rules/MigrationIntegerRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates and casts integer-compatible inputs.
 *
 * Accepts:
 * - Native integer (e.g. 42)
 * - Numeric strings representing non-negative integers (e.g. "42")
 *
 * Rejects:
 * - Floats (e.g. 3.14)
 * - Negative numeric strings with non-digit chars (e.g. "-42", "42a")
 * - Booleans, arrays, objects, null (except null is accepted)
 *
 * Example:
 *   "42" => 42
 *   42 => 42
 *   null => null
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
readonly class MigrationIntegerRule
{
    /**
     * Validates the value against integer or digit-only string formats.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || is_int($value)) {
            return;
        }

        if (is_string($value) && preg_match('/^\d+$/', $value)) {
            return;
        }

        throw new ValidationException(
            message: "{$property} must be an integer or numeric string. Got: " . get_debug_type($value)
        );
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Attributes/Rules/MigrationStringRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Validates and casts a value to string if allowed.
 *
 * Accepts:
 * - native string
 * - int, float, bool (castable scalars)
 * - objects implementing __toString()
 * Rejects:
 * - arrays, resources, objects without __toString
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationStringRule
{
    /**
     * Validates the string-compatibility of a value.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_bool($value)) {
            throw new ValidationException(message: "{$property} cannot be a boolean when casting to string.");
        }

        if (! is_scalar($value) && ! (is_object($value) && method_exists($value, '__toString'))) {
            throw new ValidationException(
                message: "{$property} must be a string or string-castable object. Got: " . get_debug_type($value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Attributes/Rules/Mimes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class Mimes to enforce file type restrictions on a given property.
 *
 * This class is marked as `readonly` to indicate that once instantiated, the `$mimes` array should not be modified,
 * maintaining the integrity of the type rules it enforces.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * ########################################################################
 * Represents a validation rule for file mime types.
 *
 * `readonly` keyword ensures the $mimes array cannot be modified after
 * the object is constructed, which guarantees immutability and consistency.
 * This is crucial for validation logic as allowed mime types must remain constant.
 * ########################################################################
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimes
{
    public function __construct(private array $mimes) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $extension = strtolower(pathinfo((string) $value, PATHINFO_EXTENSION));
        if (! in_array($extension, $this->mimes)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(', ', $this->mimes),
            );
        }
    }
}

=== Attributes/Rules/Mimetypes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define permissible MIME types for a file property.
 *
 * The class is marked as readonly to ensure immutability after initialization.
 * It is targeted specifically for class properties using the `Attribute::TARGET_PROPERTY` flag.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use finfo;
use Gemini\Exception\ValidationException;

/**
 * This class is designed to enforce validation of file MIME types.
 * Declared as `readonly` to ensure immutability of `mimetypes` after instantiation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimetypes
{
    public function __construct(private array $mimetypes) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $finfo    = new finfo(flags: FILEINFO_MIME_TYPE);
        $mimeType = $finfo->file(filename: $value);

        if (! in_array($mimeType, $this->mimetypes, true)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(
                           ', ',
                           $this->mimetypes,
                       ),
            );
        }
    }
}

=== Attributes/Rules/Min.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Countable;
use Gemini\Exception\ValidationException;
use InvalidArgumentException;

/**
 * Attribute to enforce a minimum value or length constraint on a property.
 *
 * Supports numeric values, strings, and countable objects/arrays.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Min
{
    private const string ERROR_NUMERIC   = 'The value of "%s" must be at least %d.';

    private const string ERROR_STRING    = 'The length of "%s" must be at least %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must be at least %d.';

    private const string ERROR_INVALID   = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';


    /**
     * Constructor for the Min attribute.
     *
     * @param int         $min     The minimum value or size.
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private readonly int $min, private readonly string|null $message = null)
    {
        if ($min < 0) {
            throw new InvalidArgumentException(message: 'The minimum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the minimum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; // Allow nulls; other validators handle required constraints.
        }

        match (true) {
            is_numeric($value)                              => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string($value)                               => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable($value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                                         => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    private function validateNumeric(float $value, string $property) : void
    {
        if ($value < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at least %d.', ucfirst($property), $this->min),
            metadata: [
                          'property' => $property,
                          'value'    => $value,
                          'min'      => $this->min,
                          'errorKey' => $errorKey,
                      ]
        );
    }

    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen($value) < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    private function validateCountable(array|Countable $value, string $property) : void
    {
        $count = is_array($value) ? count($value) : iterator_count($value);

        if ($count < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}

=== Attributes/Rules/NotIn.php ===
<?php

declare(strict_types=1);

/**
 * An attribute class applied to a property to ensure the property value is not
 * within a specified set of values. This uses a 'NotIn' validation rule.
 *
 * This class is marked as 'readonly' to signify that it should not be modified
 * after instantiation, enhancing its immutability and ensuring integrity.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class used to enforce that a property value is not within a specified array of values.
 *
 * The readonly modifier ensures that instances of this class are immutable once constructed.
 * This design choice prevents accidental changes to the array of invalid values after instantiation,
 * which is critical for maintaining consistent validation rules.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotIn
{
    public function __construct(private array $values) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array($value, $this->values, true)) {
            throw new ValidationException(message: $property . ' must not be one of: ' . implode(', ', $this->values));
        }
    }
}

=== Attributes/Rules/NotRegex.php ===
<?php

declare(strict_types=1);

/**
 * The NotRegex class is an attribute used to validate that a property does not match a given regex pattern.
 *
 * This attribute is applied at the property level (TARGET_PROPERTY) and enforces validation rules at runtime.
 * The primary use case is to ensure that certain input properties do not conform to particular patterns,
 * which is critical for enforcing business rules and avoiding invalid responseData submissions.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * This attribute class ensures that a value does not match a specific regex pattern.
 *
 * Using the #[Attribute(flags: Attribute::TARGET_PROPERTY)] directive to target properties only,
 * it integrates with validation mechanisms seamlessly.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotRegex
{
    public function __construct(private string $pattern) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (preg_match($this->pattern, (string) $value)) {
            throw new ValidationException(message: $property . ' format is invalid.');
        }
    }
}

=== Attributes/Rules/Nullable.php ===
<?php

declare(strict_types=1);

/**
 * This class represents an attribute that can be used to mark a property as nullable.
 *
 * By using the #[Nullable] attribute, it indicates that a property on a responseData transfer object (DTO)
 * can accept a null value, which is relevant in many scenarios like optional fields or partial updates.
 *
 * The use of #[Attribute(flags: Attribute::TARGET_PROPERTY)] specifies that this attribute can only
 * be applied to properties, ensuring it isn't misapplied to methods or classes.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * This class is used as an attribute to indicate that a property can be null.
 * The lack of validation signifies that null values are permissible, simplifying the handling of such properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Nullable
{
    public function validate(mixed $value, string $property) : void
    {
        // No validation needed; the property being null is acceptable.
    }
}

=== Attributes/Rules/Numeric.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce numeric validation on a property.
 *
 * This attribute is applied to properties that must contain numeric values.
 * The `validate` method will be called to ensure the property value adheres to the numeric constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class used to enforce that a property must be numeric.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Numeric
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_numeric($value)) {
            throw new ValidationException(message: $property . ' must be a number.');
        }
    }
}

=== Attributes/Rules/Present.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class intended to mark properties that are required to be 'present'.
 * While commonly attributes enforce validation rules, this class only ensures
 * that the marked property is flagged as existing within the responseData set.
 *
 * This can be used in situations where simply the presence (even null or empty)
 * signifies a valid state. The property carrying this attribute thus should be checked
 * for its existence, but no further validation on its value is performed.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * Attribute class that enforces the presence of a property.
 * This is typically used in situations where merely setting the property is enough to confirm its presence.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Present
{
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        // No validation needed; the property being set means it is present.
    }
}

=== Attributes/Rules/RegexException.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;
use InvalidArgumentException;

/**
 * Attribute for enforcing regular expression validation on class properties.
 *
 * Validates that a property value matches a specified regular expression.
 * Includes optional custom error messages for flexible validation error handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RegexException
{
    private const string DEFAULT_ERROR_MESSAGE = '%s format is invalid.';

    /**
     * Constructor for the RegexException attribute.
     *
     * @param string      $pattern The regular expression pattern to validate against.
     * @param string|null $message Optional custom error message for validation failures.
     *
     * @throws InvalidArgumentException If the provided regex pattern is invalid.
     */
    public function __construct(
        private string      $pattern,
        private string|null $message = null
    ) {
        $this->validatePattern($pattern);
    }

    /**
     * Ensures the regex pattern is valid.
     *
     * @param string $pattern The regex pattern to validate.
     *
     * @throws InvalidArgumentException If the regex pattern is invalid.
     */
    private function validatePattern(string $pattern) : void
    {
        if (preg_match($pattern, '') === false) {
            throw new InvalidArgumentException(sprintf('Invalid regex pattern: %s', $pattern));
        }
    }

    /**
     * Validates a value against the regex pattern.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value does not match the regex pattern.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($this->isInvalidValue($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'pattern'  => $this->pattern,
                          ]
            );
        }
    }

    /**
     * Checks if a value is invalid based on the regex pattern.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is invalid; false otherwise.
     */
    private function isInvalidValue(mixed $value) : bool
    {
        if (! is_string($value) && ! is_numeric($value)) {
            return true; // Only strings and numeric values are valid
        }

        return preg_match($this->pattern, (string) $value) !== 1;
    }
}

=== Attributes/Rules/Required.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute to enforce that a property (or a nested path) must be provided and not null.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY | Attribute::IS_REPEATABLE)]
class Required
{
    /**
     * Path within the object to validate (e.g., 'schema.fields')
     *
     * @var string|null
     */
    private string|null $path;

    /**
     * Custom validation error message.
     *
     * @var string|null
     */
    private string|null $message;

    /**
     * Constructor
     *
     * @param string|null $path    Optional deep path to validate (e.g., 'schema.fields')
     * @param string|null $message Optional custom error message
     */
    public function __construct(string|null $path = null, string|null $message = null)
    {
        $this->path    = $path;
        $this->message = $message;
    }

    /**
     * Validates a required value, supporting deep paths like 'schema.fields'.
     *
     * @param mixed  $value    The full object or field to validate.
     * @param string $property The property name being validated.
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $target = $value;

        if ($this->path !== null) {
            // Traverse nested properties (e.g., schema.fields)
            foreach (explode('.', $this->path) as $segment) {
                if (is_array($target) && array_key_exists($segment, $target)) {
                    $target = $target[$segment];
                } elseif (is_object($target) && isset($target->$segment)) {
                    $target = $target->$segment;
                } else {
                    $target = null;
                    break;
                }
            }
        }

        if ($target === null) {
            throw new ValidationException(
                message : $this->message ?? sprintf(
                'The "%s" field is required and cannot be null.',
                $this->path ?? $property
            ),
                metadata: ['property' => $this->path ?? $property]
            );
        }
    }
}

=== Attributes/Rules/RequiredWithout.php ===
<?php

declare(strict_types=1);

/**
 * The RequiredWithout attribute marks a property as required only if certain other fields are not present.
 * This is useful for conditional validation scenarios where the presence of a property is dependent on the absence of
 * other properties.
 *
 * This attribute is intended to be applied to class properties (Target: PROPERTY).
 * It leverages PHP 8's attribute syntax to integrate seamlessly with the language's validation infrastructure.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Class RequiredWithout
 *
 * Attribute class to enforce the requirement of a property being non-empty unless certain other properties are present
 * in responseData.
 *
 * - The use of readonly ensures immutability, making fields immutable after instantiation.
 * - The __construct function takes an array of fields to check against, ensuring robustness and flexibility.
 * - The validate method includes complex business logic following a specific validation rule, demanding an explanation
 * for future maintainability.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWithout
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (! isset($responseData[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf(
                                 '%s is required when %s is not present.',
                                 $property,
                                 $field,
                             ),
                );
            }
        }
    }
}

=== Attributes/Rules/RequiredWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class enforcing a "required with" validation rule.
 *
 * This attribute ensures that a given property must have a value if the specified fields are present in the provided
 * responseData array. The class and its methods help enforce specific business rules where responseData interdependencies require
 * conditional validations.
 *
 * Attribute is set to TARGET_PROPERTY for use with class properties.
 * The class is marked as readonly as it doesn't require modification after instantiation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class for validating that a property is required if specified sibling properties are present.
 *
 * The readonly modifier ensures that the $fields property is immutable, providing safety by preventing accidental
 * changes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWith
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (isset($responseData[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf('%s is required when %s is present.', $property, $field),
                );
            }
        }
    }
}

=== Attributes/Rules/Same.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce that the value of the decorated property
 * must match the value of another specified property within the same responseData context.
 *
 * This attribute should be applied to properties within a DTO to ensure
 * that certain fields have equal values, which is helpful for tasks such as
 * confirming password or email fields.
 *
 * Using the readonly class guarantees immutability once instantiated, ensuring responseData consistency.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * This class defines a validation rule that ensures a given property value is the same as another specified property
 * value. It is an immutable class, signified by the 'readonly' keyword, meaning its state cannot be altered after
 * instantiation.
 *
 * The primary use case is validation scenarios where fields need to have matching values, such as password
 * confirmation fields.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Same
{
    public function __construct(private string $field) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, array $responseData, string $property) : void
    {
        if ($value !== ($responseData[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be the same as %s.', $property, $this->field));
        }
    }
}

=== Attributes/Rules/Size.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define a validation rule for the exact size of a property's value.
 *
 * This class is marked readonly to enforce immutability after instantiation, ensuring
 * the consistency of the size constraint.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class for enforcing fixed-size length constraints on properties.
 * Applied at the property level to validate that a property's length matches the specified size.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Size
{
    public function __construct(private int $size) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (strlen((string) $value) !== $this->size) {
            throw new ValidationException(
                message: sprintf('%s must be exactly %d characters.', $property, $this->size),
            );
        }
    }
}

=== Attributes/Rules/StartsWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property's value starts with one of the specified prefixes.
 * Using this attribute helps ensure consistent responseData formatting and validation across the application.
 *
 * The Attribute is restricted to be used on properties by the TARGET_PROPERTY flag.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class for validating that a given value starts with one of the specified prefixes.
 *
 * The class uses PHP 8.0's Attributes feature to provide declarative validation rules on class properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class StartsWith
{
    public function __construct(private array $prefixes) {}

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->prefixes as $prefix) {
            if (str_starts_with((string) $value, (string) $prefix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must start with one of the following: ' . implode(', ', $this->prefixes),
        );
    }
}

=== Attributes/Rules/StringRule.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute to enforce that a property value must be a string.
 *
 * This attribute validates that the value of a property is a string. It is
 * primarily used in DTOs to ensure responseData integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class StringRule
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a string.';

    /**
     * Constructor for the StringRule attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a string.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a string.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_string($value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                              'property' => $property,
                              'value'    => $value,
                              'expected' => 'string',
                              'actual'   => gettype($value),
                          ]
            );
        }
    }
}

=== Attributes/Rules/Timezone.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to specify a property should hold a valid timezone.
 *
 * - Set the target to property to enforce the attribute can only be used on class properties.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use DateTimeZone;
use Gemini\Exception\ValidationException;

/**
 * Validates whether the provided value is a valid timezone identifier.
 *
 * @throws \Gemini\Exception\ValidationException If the value is not a valid timezone identifier.
 *
 * The method leverages the DateTimeZone::listIdentifiers() method to ensure
 * the value conforms to one of the recognized timezone identifiers. This is
 * crucial for maintaining consistency and avoiding errors related to time
 * calculations throughout the application. Any deviation triggers a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Timezone
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array($value, DateTimeZone::listIdentifiers(), true)) {
            throw new ValidationException(message: $property . ' must be a valid timezone.');
        }
    }
}

=== Attributes/Rules/Trimmed.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;

#[Attribute(Attribute::TARGET_PROPERTY)]
class Trimmed
{
    /**
     * Trims the given value if it is a string.
     *
     * @param mixed $value The value to trim.
     *
     * @return mixed The trimmed value.
     */
    public function apply(mixed $value) : mixed
    {
        return is_string($value) ? trim($value) : $value;
    }
}


=== Attributes/Rules/Url.php ===
<?php

declare(strict_types=1);

/**
 * Class URL
 *
 * Defines a custom attribute for validating if a property is a valid URL.
 * Meant to be used on class properties to enforce URL format validation.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute class to represent URL validation.
 *
 * Applied at TARGET_PROPERTY level to ensure properties are valid URLs.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class URL
{
    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var($value, FILTER_VALIDATE_URL)) {
            throw new ValidationException(message: $property . ' must be a valid URL.');
        }
    }
}

=== Attributes/Rules/UUID.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for enforcing UUID validation on properties.
 *
 * This class is defined as an attribute which can be used to annotate properties within responseData transfer objects (DTOs).
 * The validation logic ensures that any property marked with this attribute contains a valid UUID string.
 */

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * This class defines a UUID attribute to be used for property validation.
 *
 * The class ensures that UUIDs conform to the standard format, making it useful for
 * database or API validations where UUIDs are commonly used as unique identifiers.
 *
 * The UUID class is marked as an attribute with the TARGET_PROPERTY flag, meaning
 * it can be assigned to class properties for validation purposes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class UUID
{
    private const string UUID_REGEX =
        '/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i';

    /**
     * @throws \Gemini\Exception\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(preg_match(self::UUID_REGEX, (string) $value), [0, false], true)) {
            throw new ValidationException(message: $property . ' must be a valid UUID.');
        }
    }
}

=== Attributes/Rules/ValidDTOArray.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Gemini\Exception\ValidationException;

/**
 * Attribute for validating an array of responseData transfer objects (DTOs).
 *
 * This attribute ensures that a property adheres to an array structure where all items
 * are valid DTOs inheriting from the specified target class (via `$dtoClass`).
 *
 * The validation process assumes that the target DTO class's constructor validates
 * its input automatically. Invalid responseData within the array will trigger a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
final readonly class ValidDTOArray
{
    /**
     * The fully-qualified class name of the Data Transfer Object (DTO) we expect.
     *
     * @param string $dtoClass The DTO class name to validate instantiated items.
     */
    public function __construct(private string $dtoClass) {}

    /**
     * Validates the given value to ensure it is an array of valid DTOs.
     *
     * Checks the following conditions:
     * - The value must be an array.
     * - Each item in the array must be either an array or an object.
     * - An instance of the specified `$dtoClass` must be successfully created for each item.
     *
     * If any of the above conditions are violated, a ValidationException is thrown.
     *
     * @param mixed  $value    The value of the property to be validated.
     * @param string $property The name of the property being validated, used in exception messages.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Ensure the provided value is of type array.
        if (! is_array($value)) {
            throw new ValidationException(
                message: "Expected array of DTOs for {$property}"
            );
        }

        // Iterate through the array to validate each item.
        foreach ($value as $item) {
            // Ensure each item is either an array or an object.
            if (! is_array($item) && ! is_object($item)) {
                throw new ValidationException(
                    message: "Invalid item in {$property}, must be an array or object"
                );
            }

            // Attempt to instantiate the target DTO class with the item.
            // This assumes the DTO constructor validates its input.
            new $this->dtoClass($item);
        }
    }

    /**
     * Converts all elements of the array into instances of the specified DTO class.
     *
     * This method applies a transformation where each element of the input array
     * is passed to the constructor of the defined `$dtoClass`, returning a new array
     * of fully instantiated DTO objects.
     *
     * @param mixed $value The input array to transform.
     *
     * @return array<int, object> An array of DTO objects.
     *
     * @throws ValidationException If construction of any DTO fails.
     */
    public function apply(mixed $value) : array
    {
        return array_map(
            fn($v) => new $this->dtoClass($v), // Instantiate DTO for each item
            $value // Input array
        );
    }
}
=== messages.php ===
<?php

declare(strict_types=1);

return [
    'validation.max.invalid_type' => 'Invalid type for {property}. Expected {expected}, got {actual}.',
    'validation.max.string'       => '{property} may not be longer than {max} characters.',
    'validation.max.numeric'      => '{property} may not be greater than {max}.',
    'validation.max.countable'    => '{property} may not contain more than {max} items.',
];
