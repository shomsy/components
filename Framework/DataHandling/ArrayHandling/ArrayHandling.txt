=== Arrhae.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling;

use ArrayAccess;
use ArrayIterator;
use Closure;
use Countable;
use Gemini\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Gemini\DataHandling\ArrayHandling\Traits\AdvancedStringSearchTrait;
use Gemini\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\DebugTrait;
use Gemini\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\LockableTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Gemini\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Gemini\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Gemini\DataHandling\ArrayHandling\Traits\StringManipulationTrait;
use Gemini\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Gemini\DataHandling\ArrayHandling\Traits\TransformationTrait;
use InvalidArgumentException;
use IteratorAggregate;
use Traversable;


/**
 * Class Arrhae
 *
 * The `Arrhae` class is a comprehensive utility for working with arrays. It offers a variety of methods
 * for transforming, querying, and manipulating complex arrays. It supports features like dot notation for nested
 * arrays, lazy evaluation, optimized array access, conditional operations, and more.
 *
 * This class implements the `ArrayAccess`, `IteratorAggregate`, and `Countable` interfaces, allowing it to work
 * seamlessly with array operations, iteration, and counting.
 *
 * Additionally, it leverages several traits to modularize functionality:
 * - `AbstractDependenciesTrait`: Manages dependencies required by the class.
 * - `AggregationTrait`: Provides methods for aggregating data (e.g., sum, average).
 * - `ArrayAccessTrait`: Implements array access methods.
 * - `ArrayConversionTrait`: Offers methods to convert arrays to different formats.
 * - `CollectionWalkthroughTrait`: Facilitates iteration and traversal of collections.
 * - `ConditionalsTrait`: Provides conditional operations on arrays.
 * - `DebugTrait`: Contains debugging utilities.
 * - `LazyEvaluationTrait`: Enables lazy evaluation of array operations.
 * - `MacrosTrait`: Allows adding custom macros to the class.
 * - `ManageItemsTrait`: Manages items within the array.
 * - `MetaInfoTrait`: Provides metadata information about the array.
 * - `OrderManipulationTrait`: Handles ordering and sorting of array items.
 * - `PartitioningTrait`: Facilitates partitioning of the array into subsets.
 * - `SetOperationsTrait`: Implements set operations like union and intersection.
 * - `SortOperationsTrait`: Offers advanced sorting capabilities.
 * - `StructureConversionTrait`: Converts the array structure as needed.
 * - `TransformationTrait`: Provides methods to transform array data.
 *
 * @method float|int sum(string|callable $key) Sums all numeric values in the array.
 * @method float|null average() Calculates the average of all numeric values in the array.
 * @method Arrhae fromJson(string $json) Creates an Arrhae instance from a JSON string.
 * @method string toJson() Converts the array to a JSON string.
 *
 * @package Gemini\DataHandling\ArrayHandling
 */
class Arrhae implements ArrayAccess, IteratorAggregate, Countable
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;
    use AdvancedStringSearchTrait;
    use StringManipulationTrait;
    use LockableTrait;

    /**
     * @var array The underlying items of the collection.
     */
    protected array $items = [];

    /**
     * Arrhae constructor.
     *
     * Initializes the `Arrhae` instance with an optional array of items. This constructor is called when a new
     * instance of `Arrhae` is created, and it optionally accepts an array of items that will be stored internally.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Converts an iterable to an array.
     *
     * This helper method ensures that the provided items are converted to an array,
     * regardless of whether they are initially an array or a Traversable object.
     *
     * @param iterable $items The items to convert.
     *
     * @return array The converted array of items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    protected function convertToArray(iterable $items) : array
    {
        if (is_array($items)) {
            return $items;
        }

        return iterator_to_array($items, false);
    }

    /**
     * Creates a new locked collection instance from the given items.
     *
     * This named constructor enforces immutability by creating a locked collection,
     * preventing any modifications after instantiation - adhering to DDD value object principles.
     *
     * @template TKey of array-key
     * @template TValue
     * @param iterable<TKey, TValue> $items The source items to populate the collection
     *
     * @return static<TKey, TValue> A new locked collection instance
     * @throws \RuntimeException If the collection cannot be locked
     * @immutable
     */
    public static function lockedFrom(iterable $items) : self
    {
        // First create a new collection instance from the provided items
        // Then immediately lock it to ensure immutability
        return self::make($items)->lock();
    }

    /**
     * Static factory method to create a new Arrhae instance.
     *
     * This method provides a convenient way to instantiate the Arrhae collection
     * with an initial set of items. It accepts any iterable data type, including
     * arrays and objects implementing the Traversable interface.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @return self A new instance of Arrhae initialized with the provided items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     *
     * @example
     * use Gemini\DataHandling\Arrhae;
     *
     * // Creating a collection from an array
     * $collection = Arrhae::make(['apple', 'banana', 'cherry']);
     *
     * // Creating a collection from a Traversable object
     * $iterator = new ArrayIterator(['apple', 'banana', 'cherry']);
     * $collection = Arrhae::make($iterator);
     */
    public static function make(iterable $items = []) : self
    {
        return new self(items: $items);
    }

    /**
     * Creates an immutable copy of the current instance.
     *
     * This method ensures thread-safety and immutability by creating a deep clone
     * of the current instance and applying a lock mechanism to prevent further modifications.
     * Implement the Immutable Object Pattern for defensive programming.
     *
     * @return self Returns a new locked instance
     * @throws \RuntimeException If the locking mechanism fails
     * @since 8.3.0
     * @immutable
     * @final
     */
    public function toImmutable() : self
    {
        // Create a defensive copy and apply immutability lock
        return clone $this->lock();
    }

    /**
     * Retrieves all items in the `Arrhae` instance.
     *
     * This method returns all items currently stored in the instance as a plain array. It is helpful for getting
     * access to the full dataset.
     *
     * @return array All items in the instance as a standard array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * print_r($arrh->all()); // Output: [1, 2, 3]
     * ```
     */
    public function all() : array
    {
        return $this->items;
    }

    /**
     * Sets a value at the specified key using dot notation for nested arrays.
     *
     * This method allows setting a value at a specific key, even within nested arrays, by using dot notation.
     * If a nested array doesn't exist, it will be created automatically.
     *
     * @param string|int $key   The key to set, which may include dot notation for nested arrays.
     * @param mixed      $value The value to set at the specified key.
     *
     * @return $this Returns the current instance for method chaining.
     *
     * @throws InvalidArgumentException If the key is not a string or integer.
     *
     * ```
     * $arrh = new Arrhae();
     * $arrh->set('user.name', 'Alice');
     * print_r($arrh->all()); // Output: ['user' => ['name' => 'Alice']]
     * ```
     */
    public function set(string|int $key, mixed $value) : self
    {
        if (! is_string($key) && ! is_int($key)) {
            throw new InvalidArgumentException(message: "Key must be a string or an integer.");
        }

        $this->assertNotLocked();

        if (is_string($key) && str_contains($key, '.')) {
            $array = &$this->items;
            foreach (explode('.', $key) as $segment) {
                if (! isset($array[$segment]) || ! is_array($array[$segment])) {
                    $array[$segment] = [];
                }

                $array = &$array[$segment];
            }

            $array = $value;
        } else {
            $this->items[$key] = $value;
        }

        return $this;
    }

    /**
     * Checks if a specific key exists using dot notation for nested keys.
     *
     * This method checks if a key exists in the array. If the key contains dot notation, it checks recursively
     * through the nested arrays.
     *
     * @param string|int $key The key to check for existence.
     *
     * @return bool True if the key exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->has('user.name'); // Output: true
     * ```
     */
    public function has(string|int $key) : bool
    {
        return $this->get(key: $key) !== null;
    }

    /**
     * Gets a value by key using dot notation for nested arrays.
     *
     * This method retrieves a value for a specific key, supporting dot notation for nested keys.
     * If the key doesn't exist, it returns the provided default value.
     *
     * @param string|int $key     The key to retrieve, supports dot notation for nested arrays.
     * @param mixed      $default The default value to return if the key does not exist. Default is `null`.
     *
     * @return mixed The value associated with the key or the default if the key does not exist.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->get('user.name'); // Output: 'Alice'
     * ```
     */
    public function get(string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists($key, $this->items)) {
            return $this->items[$key];
        }

        if (is_string($key) && str_contains($key, '.')) {
            $array = $this->items;
            foreach (explode('.', $key) as $segment) {
                if (is_array($array) && array_key_exists($segment, $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Removes an item by key, supporting dot notation for nested keys.
     *
     * This method removes a specific key and its associated value from the array. If the key is nested, dot notation
     * will be used to traverse through the levels and remove the item.
     *
     * @param string|int $key The key to remove.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * $arrh->forget('user.name');
     * print_r($arrh->all()); // Output: ['user' => []]
     * ```
     */
    public function forget(string|int $key) : self
    {
        $this->assertNotLocked();

        if (array_key_exists($key, $this->items)) {
            unset($this->items[$key]);
        } elseif (is_string($key) && str_contains($key, '.')) {
            $array = &$this->items;
            $keys  = explode('.', $key);
            while (count($keys) > 1) {
                $segment = array_shift($keys);
                if (! isset($array[$segment]) || ! is_array($array[$segment])) {
                    return $this;
                }

                $array = &$array[$segment];
            }

            unset($array[array_shift($keys)]);
        }

        return $this;
    }

    /**
     * Appends a value to the end of the array.
     *
     * This method adds a new value to the end of the current array, allowing dynamic expansion of the items.
     *
     * @param mixed $value The value to append to the array.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $arrh->add(4);
     * print_r($arrh->all()); // Output: [1, 2, 3, 4]
     * ```
     */
    public function add(mixed $value) : self
    {
        $this->assertNotLocked();

        $this->items[] = $value;

        return $this;
    }

    /**
     * Returns an iterator for the array.
     *
     * This method returns an iterator that can be used to loop through the items in the array using a `foreach`
     * loop or other iteration methods.
     *
     * @return Traversable An iterator for the items in the collection.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * foreach ($arrh as $item) {
     *     echo $item; // Outputs: 1 2 3
     * }
     * ```
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->items);
    }

    /**
     * Counts the number of items in the array.
     *
     * This method returns the total number of items in the array, equivalent to the result of the `count()` function.
     *
     * @return int The number of items in the array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->count(); // Output: 3
     * ```
     */
    public function count() : int
    {
        return count($this->items);
    }

    /**
     * Extracts a list of values from the array using the specified key or applies a Closure.
     *
     * This method maps through the items and extracts the values associated with the specified key from each item.
     * If a Closure is provided instead of a key, it applies the Closure to each item and returns the results.
     * If a value doesn't exist or isn't an array when using a key, `null` is returned for that item.
     *
     * @param string|\Closure $key The key to pluck from each item or a Closure to apply to each item.
     *
     * @return array An array containing the plucked values or the results of the Closure for each item.
     *
     * ```
     * // Using a key
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'John'],
     *     ['id' => 2, 'name' => 'Jane'],
     *     ['id' => 3, 'name' => 'Bob']
     * ]);
     * $names = $arrh->pluck('name');
     * print_r($names); // Output: ['John', 'Jane', 'Bob']
     *
     * // Using a Closure
     * $ages = $arrh->pluck(function($item) {
     *     return $item['id'] * 10;
     * });
     * print_r($ages); // Output: [10, 20, 30]
     * ```
     */
    public function pluck(string|Closure $key) : array
    {
        return match (true) {
            $key instanceof Closure => array_map($key, $this->items),
            default                 => array_map(
                fn($item) => is_array($item) && array_key_exists($key, $item) ? $item[$key] : null,
                $this->items
            ),
        };
    }

    /**
     * Retrieves a value from the items array using the specified key.
     *
     * This method retrieves the value associated with a specific key if it exists in the array, or returns
     * the provided default value if the key is absent.
     *
     * @param string $key     The key to retrieve from the items array.
     * @param mixed  $default The default value to return if the key doesn't exist. Default is `null`.
     *
     * @return mixed The value associated with the key, or the default value if the key doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['id' => 1, 'name' => 'Alice']);
     * echo $arrh->arrGet('name'); // Output: 'Alice'
     * echo $arrh->arrGet('age', 30); // Output: 30
     * ```
     */
    public function arrGet(string $key, mixed $default = null) : mixed
    {
        if (is_array($this->items) && array_key_exists($key, $this->items)) {
            return $this->items[$key];
        }

        return $default;
    }

    /**
     * Retrieves a nested value from an array using a dot-notated key.
     *
     * This method allows retrieving values from a nested array using a dot notation key. If the value is
     * not found at any level, it returns the provided default value.
     *
     * @param string $key     The dot-notated key to retrieve the value.
     * @param mixed  $default The default value to return if the key is not found.
     *
     * @return mixed The nested value associated with the key or the default value if not found.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->getValue('user.name'); // Output: 'Alice'
     * ```
     */
    public function getValue(string $key, mixed $default = null) : mixed
    {
        $firstItem = $this->first();
        if (! $firstItem || ! is_array($firstItem)) {
            return $default;
        }

        foreach (explode('.', $key) as $segment) {
            if (is_array($firstItem) && array_key_exists($segment, $firstItem)) {
                $firstItem = $firstItem[$segment];
            } else {
                return $default;
            }
        }

        return $firstItem;
    }

    /**
     * Retrieves the first item in the array, optionally extracting a specific key using dot notation or applying a
     * Closure.
     *
     * This method returns the first item in the array. If a `$key` is provided, it retrieves the value associated
     * with that key using dot notation, similar to the `get()` method. If `$key` is a Closure, it applies the Closure
     * to the first item and returns the result. If the array is empty or the key does not exist, it returns `null` or
     * the provided default value.
     *
     * @param string|int|Closure|null $key      Optional key to retrieve from the first item, supports dot notation or
     *                                          a Closure.
     * @param mixed                   $default  The default value to return if the key is not found. Default is `null`.
     *
     * @return mixed The first item, the value of the specified key in the first item, the result of the Closure, or
     *               the default value.
     *
     * ```
     * // Without key
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->first(); // Output: 1
     *
     * // With key
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->first('user.name'); // Output: 'Alice'
     *
     * // With Closure
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice', 'age' => 25]],
     *     ['user' => ['name' => 'Bob', 'age' => 30]],
     * ]);
     * $firstUserAge = $arrh->first(function($item) {
     *     return $item['user']['age'];
     * });
     * echo $firstUserAge; // Output: 25
     *
     * // With key that does not exist
     * echo $arrh->first('user.gender', 'unknown'); // Output: 'unknown'
     * ```
     * @noinspection PhpParameterNameChangedDuringInheritanceInspection
     */
    public function first(string|int|Closure|null $key = null, mixed $default = null) : mixed
    {
        if ($this->items === []) {
            return $default;
        }

        $firstItem = reset($this->items);
        if ($key === null) {
            return $firstItem;
        }

        if ($key instanceof Closure) {
            return $key($firstItem);
        }

        return $this->getFromItem(item: $firstItem, key: $key, default: $default);
    }

    /**
     * Retrieves a value from a single array item using a key with dot notation or applies a Closure.
     *
     * This helper method is used internally to extract a value from a single array item using a dot-notated key
     * or apply a Closure to it.
     *
     * @param mixed               $item    The array item to extract the value from.
     * @param string|int|\Closure $key     The key to retrieve, supports dot notation or a Closure.
     * @param mixed               $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key, the result of the Closure, or the default value if the key does
     *               not exist.
     */
    protected function getFromItem(mixed $item, string|int|Closure $key, mixed $default = null) : mixed
    {
        if ($key instanceof Closure) {
            return $key($item);
        }

        if (is_array($item)) {
            return $this->getValueFromArray(array: $item, key: $key, default: $default);
        }

        return $default;
    }

    /**
     * Retrieves a value from an array using a key with dot notation.
     *
     * This helper method is used internally to extract a value from an array using a dot-notated key.
     *
     * @param array      $array   The array to extract the value from.
     * @param string|int $key     The key to retrieve, supports dot notation.
     * @param mixed      $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key or the default value if the key does not exist.
     */
    protected function getValueFromArray(array $array, string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists($key, $array)) {
            return $array[$key];
        }

        if (is_string($key) && str_contains($key, '.')) {
            $segments = explode('.', $key);
            foreach ($segments as $segment) {
                if (is_array($array) && array_key_exists($segment, $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Determines whether some items in the array match a given condition.
     *
     * This method iterates over the items and applies the callback function to each item. It returns `true`
     * if the callback returns `true` for any item, and `false` otherwise.
     *
     * @param callable $callback The callback to apply to each item.
     *
     * @return bool `true` if at least one item satisfies the condition, `false` otherwise.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->some(fn($item) => $item > 2); // Output: true
     * ```
     */
    public function some(callable $callback) : bool
    {
        foreach ($this->items as $item) {
            if ($callback($item)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Retrieves the items stored in the `Arrhae` instance.
     *
     * This is a protected method that returns the array of items, which is useful in internal operations.
     *
     * @return array The items in the collection.
     */
    protected function getItems() : array
    {
        return $this->items;
    }

    /**
     * Sets the array of items for the current instance.
     *
     * This method allows setting a new array of items for the `Arrhae` instance. It is useful when you want
     * to replace the current set of items with a different array.
     *
     * @param array|iterable $items The new items array to set.
     *
     * @return $this The current instance for method chaining.
     */
    protected function setItems(iterable $items) : static
    {
        $this->assertNotLocked();

        $this->items = $items;

        return $this;
    }
}

=== Traits/AbstractDependenciesTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

/**
 * This trait provides common query operations for collections.
 * It includes methods for filtering and checking the existence of items based on different conditions.
 */
trait AbstractDependenciesTrait
{
    /**
     * Retrieve the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @return array The items in the collection.
     */
    abstract protected function getItems() : array;

    /**
     * Sets the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @param array $items The items to set in the collection.
     */
    abstract protected function setItems(array $items) : static;
}

=== Traits/AdvancedStringSearchTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use FuzzyWuzzy\Fuzz;
use FuzzyWuzzy\Process;
use InvalidArgumentException;

/**
 * Trait AdvancedStringSearchTrait
 *
 * Provides advanced string search functionalities for collections, including fuzzy search and similarity-based search.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait AdvancedStringSearchTrait
{
    /**
     * Performs a fuzzy match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the query and each item using FuzzyWuzzy,
     * returning items that meet or exceed the specified similarity threshold.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->fuzzyMatch('aple', 80);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->fuzzyMatch('Alic', 70, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * //     ['name' => 'Alina'],
     * // ]
     */
    public function fuzzyMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower($query), s2: strtolower($target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Helper method to validate the threshold.
     *
     * @param float $threshold The threshold to validate.
     *
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     */
    protected function isProperThreshold(float $threshold) : void
    {
        if ($threshold < 0 || $threshold > 100) {
            throw new InvalidArgumentException(message: 'Threshold must be between 0 and 100.');
        }
    }

    /**
     * Searches for items with a similarity percentage above a specified threshold.
     *
     * This method uses the similarity percentage between the query and each item to determine matches.
     *
     * @param string      $query     The search query string.
     * @param float       $threshold The minimum similarity percentage (0 to 100).
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->similaritySearch('apple', 80);
     * // Returns ['apple', 'aple', 'apply']
     *
     * $arrhAssoc = new Arrhae([
     *     ['title' => 'Introduction to PHP'],
     *     ['title' => 'Advanced PHP Techniques'],
     *     ['title' => 'PHP for Beginners'],
     *     ['title' => 'JavaScript Essentials'],
     * ]);
     * $resultsAssoc = $arrhAssoc->similaritySearch('PHP Intro', 70, 'title');
     * // Returns [
     * //     ['title' => 'Introduction to PHP'],
     * //     ['title' => 'PHP for Beginners'],
     * // ]
     */
    public function similaritySearch(string $query, float $threshold = 70.0, string|null $key = null) : static
    {
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower($query), s2: strtolower($target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a Levenshtein-based search and sorts the results by similarity.
     *
     * This method finds items within a certain distance from the query and sorts them by their similarity to the query.
     *
     * @param string      $query       The search query string.
     * @param int         $maxDistance The maximum Levenshtein distance allowed.
     * @param string|null $key         The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items sorted by similarity.
     *
     * @throws InvalidArgumentException If the max distance is negative.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'apricot', 'banana', 'grape', 'pineapple']);
     * $results = $arrh->levenshteinSearch('appel', 2);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->levenshteinSearch('Alic', 2, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function levenshteinSearch(string $query, int|null $maxDistance = null, string|null $key = null) : static
    {
        $maxDistance ??= 2;
        if ($maxDistance < 0) {
            throw new InvalidArgumentException(message: 'Maximum distance cannot be negative.');
        }

        $matchedItems = [];

        foreach ($this->getItems() as $item) {
            $target = $key !== null ? ($item[$key] ?? '') : $item;

            if (! is_string($target)) {
                continue;
            }

            $distance = levenshtein(strtolower($query), strtolower($target));

            if ($distance <= $maxDistance) {
                $matchedItems[$distance][] = $item;
            }
        }

        ksort($matchedItems);

        // Flatten the array while preserving order
        $sortedMatchedItems = [];
        foreach ($matchedItems as $matchedItem) {
            foreach ($matchedItem as $item) {
                $sortedMatchedItems[] = $item;
            }
        }

        return new static(items: $sortedMatchedItems);
    }

    /**
     * Performs a partial match on the collection items based on a given query.
     *
     * This method checks if the query string is a substring of the target string.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->partialMatch('app');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->partialMatch('Ali', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function partialMatch(string $query, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $query) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Check if query is a substring of target
                return stripos($target, $query) !== false;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a token sort match on the collection items based on a given query.
     *
     * This method sorts the tokens in both the query and target strings and then calculates the similarity ratio.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSortMatch('banana apple', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSortMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Sort tokens in the query
        $sortedQuery = $this->sortTokens($query);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $sortedQuery, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Sort tokens in the target
                $sortedTarget = $this->sortTokens($target);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Helper method to sort tokens in a string.
     *
     * @param string $string The string to sort tokens for.
     *
     * @return string The string with sorted tokens.
     */
    protected function sortTokens(string $string) : string
    {
        $tokens = explode(' ', strtolower($string));
        sort($tokens); // Sort tokens in ascending order

        return implode(' ', $tokens);
    }

    /**
     * Performs a token set match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the unique tokens of the query and target strings.
     *
     * @param string      $query     The search query string.
     * @param float       $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSetMatch('apple banana', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSetMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold($threshold);

        // Initializing FuzzyWuzzy components
        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Get unique tokens in the query
        $uniqueQueryTokens = array_unique(explode(' ', strtolower($query)));
        sort($uniqueQueryTokens);
        $sortedQuery = implode(' ', $uniqueQueryTokens);

        $matchedItems = array_filter(
            $this->getItems(),
            function ($item) use ($key, $fuzz, $sortedQuery, $threshold, $process) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Get unique tokens in the target
                $uniqueTargetTokens = array_unique(explode(' ', strtolower($target)));
                sort($uniqueTargetTokens);
                $sortedTarget = implode(' ', $uniqueTargetTokens);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a phonetic match on the collection items based on a given query.
     *
     * This method uses the Metaphone algorithm to find phonetically similar strings.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['Smith', 'Smyth', 'Smithe', 'Johnson']);
     * $results = $arrh->phoneticMatch('Smyth');
     * // Returns ['Smith', 'Smyth', 'Smithe']
     */
    public function phoneticMatch(string $query, string|null $key = null) : static
    {
        $queryPhonetic = metaphone(strtolower($query));

        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $queryPhonetic) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                // Calculate phonetic code
                $targetPhonetic = metaphone(strtolower($target));

                return $queryPhonetic === $targetPhonetic;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a regular expression search on the collection items based on a given pattern.
     *
     * This method returns items that match the provided regular expression pattern.
     *
     * @param string      $pattern The regular expression pattern.
     * @param string|null $key     The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the provided pattern is invalid.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->regexSearch('/^ap/');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->regexSearch('/^Ali/', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function regexSearch(string $pattern, string|null $key = null) : static
    {
        if (@preg_match($pattern, '') === false) {
            throw new InvalidArgumentException(message: 'Invalid regular expression pattern.');
        }

        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $pattern) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string($target)) {
                    return false;
                }

                return preg_match($pattern, $target) === 1;
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Performs a custom match on the collection items using a user-defined callback.
     *
     * This method allows for highly flexible and customizable search criteria.
     *
     * @param callable    $callback The callback function to determine a match. Should return a boolean.
     * @param string|null $key      The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->customMatch(function($item) {
     *     return strpos($item, 'ap') === 0;
     * });
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30],
     *     ['name' => 'Alicia', 'age' => 25],
     *     ['name' => 'Alina', 'age' => 28],
     *     ['name' => 'Bob', 'age' => 35],
     * ]);
     * $resultsAssoc = $arrhAssoc->customMatch(function($value, $item) {
     *     return $item['age'] > 27;
     * }, 'age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 30],
     * //     ['name' => 'Alina', 'age' => 28],
     * // ]
     */
    public function customMatch(callable $callback, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            $this->getItems(),
            static function ($item) use ($key, $callback) {
                $target = $key !== null ? ($item[$key] ?? null) : $item;

                return $callback($target, $item);
            }
        );

        return new static(items: array_values($matchedItems));
    }

    /**
     * Sorts the matched items by similarity in descending order.
     *
     * This method is typically used after a search to rank the results based on how closely they match the query.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return array An array of matched items sorted by similarity.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->fuzzyMatch('apple', 60, 'name')->sortBySimilarity('apple', 'name');
     * // Returns items sorted by similarity to 'apple'
     */
    public function sortBySimilarity(string $query, string|null $key = null) : array
    {
        $queryLower = strtolower($query);

        $sortedItems = $this->getItems();
        usort($sortedItems, function ($a, $b) use ($key, $queryLower) : int {
            $fuzz   = new Fuzz();
            $aValue = $key !== null ? ($a[$key] ?? '') : $a;
            $bValue = $key !== null ? ($b[$key] ?? '') : $b;

            if (! is_string($aValue) || ! is_string($bValue)) {
                return 0;
            }

            $similarityA = $fuzz->ratio(s1: $queryLower, s2: strtolower($aValue));
            $similarityB = $fuzz->ratio(s1: $queryLower, s2: strtolower($bValue));

            return $similarityB <=> $similarityA;
        });

        return $sortedItems;
    }
}

=== Traits/AggregationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use LogicException;

/**
 * Trait AggregationTrait
 *
 * Provides robust aggregation methods for handling data collections.
 * Supports summation, averaging, min/max determination, and counting by keys or callbacks.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It offers flexible methods
 * that can operate on specific keys or use callbacks for dynamic value extraction.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait AggregationTrait
{
    /**
     * Calculate the average of values for a specified key or callback.
     *
     * This method computes the average (arithmetic mean) of all numeric values obtained
     * from the specified key or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float The resulting average or 0.0 if the collection is empty.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $averageScore = $arrh->average('score'); // Returns 80.0
     *
     * // Using a callback to calculate average age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $averageAge = $arrh->average(fn($item) => $item['age']); // Returns 30.0
     * ```
     */
    public function average(string|callable $key) : float
    {
        $count = count($this->getItems());

        return $count !== 0 ? $this->sum(key: $key) / $count : 0.0;
    }

    /**
     * Sum the values of a specified key or computed by a callback.
     *
     * This method calculates the total sum of all numeric values obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float|int The resulting sum of the values.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'amount' => 100.50],
     *     ['id' => 2, 'amount' => 200.75],
     *     ['id' => 3, 'amount' => 150.25],
     * ]);
     * $totalAmount = $arrh->sum('amount'); // Returns 451.5
     *
     * // Using a callback to sum ages
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $totalAge = $arrh->sum(fn($item) => $item['age']); // Returns 90
     * ```
     */
    public function sum(string|callable $key) : float|int
    {
        $this->validateData();

        return array_reduce(
            $this->getItems(),
            static function ($carry, $item) use ($key) : int|float {
                $value = is_callable($key) ? $key($item) : ($item[$key] ?? 0);

                if (! is_numeric($value)) {
                    throw new InvalidArgumentException('Non-numeric value encountered in sum calculation.');
                }

                return $carry + $value;
            },
            0
        );
    }

    /**
     * Validate the data structure before applying aggregation.
     *
     * Ensures that the collection is a valid array. This prevents unexpected errors
     * during aggregation operations.
     *
     * @throws LogicException If `getItems` does not return a valid array.
     */
    private function validateData() : void
    {
        $items = $this->getItems();

        if (! is_array($items)) {
            throw new LogicException('Expected data to be an array.');
        }
    }

    /**
     * Find the minimum value for a specified key or callback.
     *
     * This method identifies the smallest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The minimum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $minScore = $arrh->min('score'); // Returns 70
     *
     * // Using a callback to find minimum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $minAge = $arrh->min(fn($item) => $item['age']); // Returns 25
     * ```
     */
    public function min(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException('Cannot determine minimum value of an empty collection.');
        }

        return min($values);
    }

    /**
     * Map items to values based on a key or callback.
     *
     * Extracts values from each item in the collection based on the specified key or by applying a callback.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array The extracted values.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Mapping scores
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $scores = $arrh->mapValues('score'); // Returns [80, 90, 70]
     *
     * // Using a callback to extract names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $names = $arrh->mapValues(fn($item) => $item['name']); // Returns ['Alice', 'Bob', 'Charlie']
     * ```
     */
    private function mapValues(string|callable $key) : array
    {
        $this->validateData();

        return array_map(
            static fn($item) => is_callable($key) ? $key($item) : ($item[$key] ?? null),
            $this->getItems()
        );
    }

    /**
     * Find the maximum value for a specified key or callback.
     *
     * This method identifies the largest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The maximum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $maxScore = $arrh->max('score'); // Returns 90
     *
     * // Using a callback to find maximum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $maxAge = $arrh->max(fn($item) => $item['age']); // Returns 35
     * ```
     */
    public function max(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException('Cannot determine maximum value of an empty collection.');
        }

        return max($values);
    }

    /**
     * Count occurrences of unique values by a specified key or callback.
     *
     * This method tallies the number of times each unique value appears in the collection,
     * based on the specified key or by applying a callback to each item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array Associative array with counts for each unique value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $categoryCounts = $arrh->countBy('category');
     * // Returns ['A' => 2, 'B' => 2, 'C' => 1]
     *
     * // Using a callback to count based on a derived value
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 30],
     * ]);
     * $ageCounts = $arrh->countBy(fn($item) => $item['age']);
     * // Returns [25 => 1, 30 => 2, 35 => 1]
     * ```
     */
    public function countBy(string|callable $key) : array
    {
        $this->validateData();

        $result = [];
        foreach ($this->getItems() as $item) {
            $value          = is_callable($key) ? $key($item) : ($item[$key] ?? null);
            $result[$value] = ($result[$value] ?? 0) + 1;
        }

        return $result;
    }

    /**
     * Reduce the collection to a single value using a callback.
     *
     * This method applies a callback function cumulatively to the items of the collection,
     * from left to right, to reduce the collection to a single value.
     *
     * @param callable   $callback  Callback to apply to each item. It should accept two parameters:
     *                              the carry (accumulator) and the current item.
     * @param mixed|null $initial   Initial value to start the reduction. If not provided, the first item of the
     *                              collection is used.
     *
     * @return mixed The reduced value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $product = $arrh->reduce(fn($carry, $item) => $carry * $item, 1); // Returns 24
     *
     * // Using reduce to concatenate names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Bob'],
     *     ['name' => 'Charlie'],
     * ]);
     * $names = $arrh->reduce(fn($carry, $item) => $carry . ', ' . $item['name'], '');
     * // Returns ', Alice, Bob, Charlie'
     * ```
     */
    public function reduce(callable $callback, mixed $initial = null) : mixed
    {
        $this->validateData();

        return array_reduce($this->getItems(), $callback, $initial);
    }

    /**
     * Group items by a specified key or callback.
     *
     * This method organizes the collection into groups based on the specified key or by applying a callback to each
     * item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the grouping
     *                             value.
     *
     * @return array The grouped items.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Grouping by category
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $grouped = $arrh->aggregateGroupBy('category');
     *
     * Returns:
     * [
     *     'A' => [
     *         ['id' => 1, 'category' => 'A'],
     *         ['id' => 3, 'category' => 'A'],
     *     ],
     *     'B' => [
     *         ['id' => 2, 'category' => 'B'],
     *         ['id' => 5, 'category' => 'B'],
     *     ],
     *     'C' => [
     *         ['id' => 4, 'category' => 'C'],
     *     ],
     * ]
     *
     *
     * // Grouping by age range using a callback
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 40],
     * ]);
     * $groupedByAgeRange = $arrh->aggregateGroupBy(function($item) {
     *     if ($item['age'] < 30) {
     *         return 'Under 30';
     *     } elseif ($item['age'] < 40) {
     *         return '30-39';
     *     } else {
     *         return '40 and above';
     *     }
     * });
     *
     * Returns:
     * [
     *     'Under 30' => [
     *         ['name' => 'Alice', 'age' => 25],
     *     ],
     *     '30-39' => [
     *         ['name' => 'Bob', 'age' => 30],
     *         ['name' => 'Charlie', 'age' => 35],
     *     ],
     *     '40 and above' => [
     *         ['name' => 'David', 'age' => 40],
     *     ],
     * ]
     *
     */
    public function aggregateGroupBy(string|callable $key) : array
    {
        $this->validateData();

        $grouped = [];
        foreach ($this->getItems() as $item) {
            $groupKey             = is_callable($key) ? $key($item) : ($item[$key] ?? null);
            $grouped[$groupKey][] = $item;
        }

        return $grouped;
    }
}

=== Traits/ArrayAccessTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ArrayAccessTrait
 *
 * Provides array-like access to a collection of items, enabling operations such as
 * checking existence, retrieving, setting, unsetting, and manipulating multiple items.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ArrayAccessTrait
{
    use AbstractDependenciesTrait;

    /**
     * Check if an offset exists in the collection items.
     *
     * Determines whether a specific key or index exists within the collection.
     *
     * @param mixed $offset The offset to check.
     *
     * @return bool True if the offset exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $exists = $arrh->offsetExists(1); // Returns true
     * $exists = $arrh->offsetExists(5); // Returns false
     * ```
     */
    public function offsetExists(mixed $offset) : bool
    {
        return isset($this->getItems()[$offset]);
    }

    /**
     * Get the value at a specific offset in the collection.
     *
     * Retrieves the value associated with a given key or index. Returns null if the offset does not exist.
     *
     * @param mixed $offset The offset to retrieve.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->offsetGet(1); // Returns 'banana'
     * $fruit = $arrh->offsetGet(5); // Returns null
     * ```
     */
    public function offsetGet(mixed $offset) : mixed
    {
        return $this->getItems()[$offset] ?? null;
    }

    /**
     * Set a value at a specific offset in the collection.
     *
     * Assigns a value to a specified key or index. If the offset is null, the value is appended to the collection.
     *
     * @param mixed $offset The offset to assign the value to.
     * @param mixed $value  The value to set.
     *
     *
     * @throws InvalidArgumentException If the key is invalid or cannot be set.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->offsetSet(1, 'blueberry'); // Collection becomes ['apple', 'blueberry']
     * $arrh->offsetSet(null, 'cherry'); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        $items = $this->getItems();
        if (is_null($offset)) {
            $items[] = $value;
        } else {
            $items[$offset] = $value;
        }

        $this->setItems($items);
    }

    /**
     * Unset the value at a specific offset in the collection.
     *
     * Removes the value associated with a given key or index from the collection.
     *
     * @param mixed $offset The offset to unset.
     *
     *
     * @throws InvalidArgumentException If the offset cannot be unset.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->offsetUnset(1); // Collection becomes ['apple', 'cherry']
     * ```
     */
    public function offsetUnset(mixed $offset) : void
    {
        $items = $this->getItems();
        unset($items[$offset]);
        $this->setItems($items);
    }

    /**
     * Retrieve multiple values by an array of offsets.
     *
     * Fetches values corresponding to the provided array of keys or indexes.
     *
     * @param array $keys The offsets to retrieve.
     *
     * @return array An array of values corresponding to the given offsets.
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * $fruits = $arrh->getMultiple([0, 2]); // Returns ['apple', 'cherry']
     * ```
     */
    public function getMultiple(array $keys) : array
    {
        $items = $this->getItems();

        return array_intersect_key($items, array_flip($keys));
    }

    /**
     * Set multiple values at once.
     *
     * Assigns multiple values to the collection based on an associative array of offsets and values.
     *
     * @param array $values An associative array of offsets and their corresponding values.
     *
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->setMultiple([1 => 'blueberry', 2 => 'cherry']); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function setMultiple(array $values) : void
    {
        $items = $this->getItems();

        foreach ($values as $key => $value) {
            $items[$key] = $value;
        }

        $this->setItems($items);
    }

    /**
     * Retrieve and remove an item by its offset.
     *
     * Fetches the value at the specified offset and removes it from the collection.
     *
     * @param mixed $offset The offset to retrieve and remove.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * @throws InvalidArgumentException If the offset is invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->pull(1); // Returns 'banana' and collection becomes ['apple', 'cherry']
     * $fruit = $arrh->pull(5); // Returns null
     * ```
     */
    public function pull(mixed $offset) : mixed
    {
        $items = $this->getItems();
        $value = $items[$offset] ?? null;

        if (array_key_exists($offset, $items)) {
            unset($items[$offset]);
            $this->setItems($items);
        }

        return $value;
    }

    /**
     * Swap two items in the collection.
     *
     * Exchanges the values at the specified offsets within the collection.
     *
     * @param mixed $offset1 The first offset.
     * @param mixed $offset2 The second offset.
     *
     *
     * @throws OutOfBoundsException If either offset does not exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->swap(0, 2); // Collection becomes ['cherry', 'banana', 'apple']
     *
     * $arrh->swap(1, 3); // Throws OutOfBoundsException
     * ```
     */
    public function swap(mixed $offset1, mixed $offset2) : void
    {
        $items = $this->getItems();

        if (! isset($items[$offset1]) || ! isset($items[$offset2])) {
            throw new OutOfBoundsException(message: "One or both offsets do not exist.");
        }

        [$items[$offset1], $items[$offset2]] = [$items[$offset2], $items[$offset1]];

        $this->setItems($items);
    }

    /**
     * Retrieve all keys of the collection.
     *
     * Provides an array of all keys or indexes present in the collection.
     *
     * @return array An array of keys.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $keys = $arrh->keys(); // Returns [0, 1, 2]
     * ```
     */
    public function keys() : array
    {
        return array_keys($this->getItems());
    }

    /**
     * Retrieve all values of the collection.
     *
     * Provides an array of all values present in the collection.
     *
     * @return array An array of values.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $values = $arrh->values(); // Returns ['apple', 'banana', 'cherry']
     * ```
     */
    public function values() : array
    {
        return array_values($this->getItems());
    }
}

=== Traits/ArrayConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Exception;
use InvalidArgumentException;
use LogicException;
use SimpleXMLElement;

/**
 * Trait ArrayConversionTrait
 *
 * Provides methods to convert the collection to various formats such as JSON, XML, and arrays.
 * Also includes methods to filter the collection by including or excluding specific keys.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ArrayConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Convert the collection to a JSON string.
     *
     * This method serializes the collection into a JSON-formatted string. It accepts optional
     * JSON encoding options to customize the output.
     *
     * @param int $options Optional JSON encoding options. Default is 0.
     *
     * @return string JSON-encoded string representation of the collection.
     *
     * @throws InvalidArgumentException If the collection contains data that cannot be encoded to JSON.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $json = $arrh->toJson(); // Returns '["apple","banana","cherry"]'
     *
     * // With JSON_PRETTY_PRINT option
     * $jsonPretty = $arrh->toJson(JSON_PRETTY_PRINT);
     * /*
     * Returns:
     * [
     *     "apple",
     *     "banana",
     *     "cherry"
     * ]
     *
     */
    public function toJson(int $options = 0) : string
    {
        $json = json_encode($this->toArray(), $options);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new InvalidArgumentException(
                message: 'Failed to encode collection to JSON: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
     * Convert the collection and nested collections to an array.
     *
     * This method recursively converts each item in the collection to an array if it implements
     * the `toArray` method. Otherwise, it retains the item's original value.
     *
     * @return array Array representation of the collection.
     *
     * @throws LogicException If the collection contains non-escapable items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $array = $arrh->toArray();
     * // Returns [
     * //     ['id' => 1, 'score' => 80],
     * //     ['id' => 2, 'score' => 90],
     * //     ['id' => 3, 'score' => 70],
     * // ]
     * ```
     */
    public function toArray() : array
    {
        return array_map(function ($item) {
            if (is_object($item) && method_exists($item, 'toArray')) {
                return $item->toArray();
            }

            return $item;
        }, $this->getItems());
    }

    /**
     * Convert the collection to an XML string with a customizable root element.
     *
     * This method serializes the collection into an XML-formatted string. It allows specifying
     * a custom root element name. All values are escaped to ensure valid XML.
     *
     * @param string $rootElement The root element name for the XML. Default is 'root'.
     *
     * @return string XML representation of the collection.
     *
     * @throws Exception If the XML conversion fails.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $xml = $arrh->toXml('fruits');
     * /*
     * Returns:
     * <?xml version="1.0"?>
     * <fruits>
     *     <item>apple</item>
     *     <item>banana</item>
     *     <item>cherry</item>
     * </fruits>
     *
     */
    public function toXml(string $rootElement = 'root') : string
    {
        try {
            $xml = new SimpleXMLElement(data: sprintf('<%s/>', $rootElement));
            $this->arrayToXml(data: $this->toArray(), xml: $xml);

            return $xml->asXML();
        } catch (Exception $exception) {
            throw new Exception(
                message : 'Failed to convert collection to XML: ' . $exception->getMessage(),
                code    : $exception->getCode(),
                previous: $exception
            );
        }
    }

    /**
     * Helper method to recursively convert an array to XML.
     *
     * @param array            $data The data to convert.
     * @param SimpleXMLElement $xml  The XML element to append data to.
     */
    private function arrayToXml(array $data, SimpleXMLElement &$xml) : void
    {
        foreach ($data as $key => $value) {
            // Handle numeric keys by using 'item' as the tag name
            if (is_numeric($key)) {
                $key = 'item';
            }

            if (is_array($value)) {
                $child = $xml->addChild(qualifiedName: $key);
                $this->arrayToXml(data: $value, xml: $child);
            } else {
                $xml->addChild(qualifiedName: $key, value: htmlspecialchars((string) $value));
            }
        }
    }

    /**
     * Include only specified keys in the collection.
     *
     * This method filters the collection to retain only the specified keys. It returns a new
     * instance of the collection with the filtered items.
     *
     * @param array $keys Keys to retain in the collection.
     *
     * @return static Collection instance with specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->only(['name', 'city']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function only(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            $this->getItems(),
            static fn($item, $key) : bool => in_array($key, $keys, true),
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Exclude specified keys from the collection.
     *
     * This method filters the collection to remove the specified keys. It returns a new
     * instance of the collection without the excluded items.
     *
     * @param array $keys Keys to exclude from the collection.
     *
     * @return static Collection instance without specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->except(['age']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function except(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            $this->getItems(),
            static fn($item, $key) : bool => ! in_array($key, $keys, true),
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }
}

=== Traits/CollectionWalkthroughTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait CollectionWalkthroughTrait
 *
 * A comprehensive trait for traversing, querying, filtering, and searching collections.
 * This trait combines essential methods to enable structured and efficient collection handling.
 *
 * It is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait CollectionWalkthroughTrait
{
    use AbstractDependenciesTrait;

    /** ***Traversal and Filtering Methods*** */

    /**
     * Applies a callback to each item in the collection, transforming the items
     * and returning a new collection with the modified values.
     *
     * This method allows for the transformation of each item in the collection by
     * applying the provided callback function. The resulting collection contains
     * the transformed items.
     *
     * @param Closure $callback The callback to apply to each item. It should accept the item as a parameter and return
     *                          the transformed value.
     *
     * @return static A new instance with the mapped items.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $squared = $arrh->map(fn($item) => $item * $item); // Returns [1, 4, 9]
     * ```
     */
    public function map(Closure $callback) : static
    {
        $mappedItems = array_map($callback, $this->getItems());

        return new static(items: $mappedItems);
    }

    /**
     * Applies a callback to each item in the collection without modifying it.
     *
     * This method iterates over each item in the collection and applies the provided callback.
     * It is useful for performing operations that do not require modifying the collection,
     * such as logging or side effects.
     *
     * @param Closure $callback The callback to apply. It should accept the item and its key as parameters.
     *
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->each(fn($item) => echo $item . "\n");
     * // Outputs:
     * // apple
     * // banana
     * // cherry
     * ```
     */
    public function each(Closure $callback) : void
    {
        foreach ($this->getItems() as $key => $item) {
            $callback($item, $key);
        }
    }

    /**
     * Gets the first item passing a given truth test.
     *
     * This method retrieves the first item in the collection that satisfies the provided callback.
     * If no callback is provided, it returns the first item in the collection.
     *
     * @param Closure|null $callback The callback for the truth test. It should accept the item as a parameter and
     *                               return a boolean.
     *
     * @return mixed The first item passing the test, or null if none found.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $firstEven = $arrh->first(fn($item) => $item % 2 === 0); // Returns 2
     *
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $first = $arrh->first(); // Returns 'apple'
     * ```
     */
    public function first(Closure|null $callback = null) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (! $callback instanceof Closure || $callback($item)) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Zips items in the collection with additional arrays.
     *
     * This method combines the collection with one or more additional arrays. The resulting collection
     * contains arrays where each array contains elements from the corresponding positions of the input arrays.
     * If the input arrays have different lengths, the missing values are filled with `null`.
     *
     * @param array ...$items Arrays to zip with the collection.
     *
     * @return static A new collection with zipped items.
     *
     * @throws InvalidArgumentException If no additional arrays are provided.
     *
     * ```
     * $arrh1 = new Arrhae([1, 2, 3]);
     * $arrh2 = new Arrhae(['a', 'b', 'c']);
     * $zipped = $arrh1->zip($arrh2->getItems()); // Returns [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * $arrh3 = new Arrhae(['x', 'y']);
     * $zipped = $arrh1->zip($arrh2->getItems(), $arrh3->getItems());
     * // Returns [[1, 'a', 'x'], [2, 'b', 'y'], [3, 'c', null]]
     * ```
     */
    public function zip(array ...$items) : static
    {
        if ($items === []) {
            throw new InvalidArgumentException(message: 'At least one array must be provided to zip with.');
        }

        $zipped = array_map(null, $this->getItems(), ...$items);

        return new static(items: $zipped);
    }

    /**
     * Checks if the collection contains a specific value.
     *
     * This method determines whether a given value exists within the collection.
     * It uses strict comparison to ensure accurate matching.
     *
     * @param mixed $value The value to search for.
     *
     * @return bool True if found, false otherwise.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $hasBanana = $arrh->contains('banana'); // Returns true
     * $hasDate = $arrh->contains('date'); // Returns false
     * ```
     */
    public function contains(mixed $value) : bool
    {
        return in_array($value, $this->getItems(), true);
    }

    /** ***Query and Search Methods*** */

    /**
     * Alias for the search method.
     *
     * This method provides an alternative name for the `search` method for better readability.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $index = $arrh->indexOf('cherry'); // Returns 2
     * $index = $arrh->indexOf('date'); // Returns false
     * ```
     */
    public function indexOf(mixed $value) : int|false
    {
        return $this->search(value: $value);
    }

    /**
     * Finds the index of the first occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its first occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value  The value to search for.
     * @param bool  $strict Use strict comparison.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $index = $arrh->search('banana'); // Returns 1
     * $index = $arrh->search('date'); // Returns false
     * ```
     */
    public function search(mixed $value, bool $strict = false) : int|false
    {
        return array_search($value, $this->getItems(), $strict);
    }

    /**
     * Finds the last occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its last occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index of the last occurrence, or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $lastIndex = $arrh->lastIndexOf('banana'); // Returns 3
     * $lastIndex = $arrh->lastIndexOf('date'); // Returns false
     * ```
     */
    public function lastIndexOf(mixed $value) : int|false
    {
        $reversedItems = array_reverse($this->getItems(), true);

        return array_search($value, $reversedItems, true);
    }

    /**
     * Filters items where a specific key matches a given value.
     *
     * This method filters the collection to include only items where the specified key's value
     * is equal to the provided value.
     *
     * @param string $key   The key to filter by.
     * @param mixed  $value The value to match.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 25],
     * ]);
     * $filtered = $arrh->where('age', 25);
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 25],
     * //     ['name' => 'Charlie', 'age' => 25],
     * // ]
     * ```
     */
    public function where(string $key, mixed $value) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) === $value
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is between the provided minimum and maximum values, inclusive.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Alice', 'score' => 85],
     * //     ['name' => 'Bob', 'score' => 90],
     * // ]
     * ```
     */
    public function whereBetween(string $key, array $range) : static
    {
        if (count($range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) >= $min &&
                                       ($item[$key] ?? null) <= $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values are in an array.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of values.
     *
     * @param string $key    The key to filter by.
     * @param array  $values Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the values array is empty.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     * $filtered = $arrh->whereIn('role', ['admin', 'editor']);
     * // Returns [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Bob', 'role' => 'editor'],
     * // ]
     * ```
     */
    public function whereIn(string $key, array $values) : static
    {
        if ($values === []) {
            throw new InvalidArgumentException(message: 'Values array cannot be empty.');
        }

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => in_array($item[$key] ?? null, $values, true)
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is not within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is outside the provided minimum and maximum values.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereNotBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Charlie', 'score' => 75],
     * // ]
     * ```
     */
    public function whereNotBetween(string $key, array $range) : static
    {
        if (count($range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) < $min ||
                                       ($item[$key] ?? null) > $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNull('age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => null],
     * //     ['name' => 'Charlie', 'age' => null],
     * // ]
     * ```
     */
    public function whereNull(string $key) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) === null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is not null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is not `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNotNull('age');
     * // Returns [
     * //     ['name' => 'Bob', 'age' => 30],
     * // ]
     * ```
     */
    public function whereNotNull(string $key) : static
    {
        $filtered = array_filter(
            $this->getItems(),
            static fn($item) : bool => ($item[$key] ?? null) !== null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values belong to a group of acceptable values.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of groups. It allows for grouping-based filtering of collections.
     *
     * @param string $key    The key to filter by.
     * @param array  $groups Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $filtered = $arrh->whereInGroup('role', ['admin', 'subscriber']);
     *
     * // $filtered contains:
     * // [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Charlie', 'role' => 'subscriber'],
     * // ]
     * ```
     */
    public function whereInGroup(string $key, array $groups) : static
    {
        return $this->filter(callback: static fn($item) : bool => in_array($item[$key] ?? null, $groups, true));
    }

    /**
     * Filters items in the collection based on a callback.
     *
     * This method filters the collection by applying the provided callback to each item.
     * Only items for which the callback returns `true` are included in the resulting collection.
     *
     * @param Closure $callback The callback to filter items. It should accept the item and its key as parameters and
     *                          return a boolean.
     *
     * @return static A new instance containing only the filtered items.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $evens = $arrh->filter(fn($item) => $item % 2 === 0); // Returns [2, 4]
     * ```
     */
    public function filter(Closure $callback) : static
    {
        $filteredItems = array_filter(
            $this->getItems(),
            $callback,
            ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Updates items in the collection based on a condition.
     *
     * This method applies the provided update callback to items that satisfy the specified condition.
     * It returns a new instance with the updated items, ensuring immutability.
     *
     * @param Closure $condition The condition to check for each item. It should accept an item as a parameter and
     *                           return a boolean indicating whether the item should be updated.
     * @param Closure $updater   The callback to apply to items that satisfy the condition. It should accept an item
     *                           as a parameter and return the updated item.
     *
     * @return static A new instance with the updated items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     *     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     *     ['id' => 3, 'name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $updated = $arrh->updateWhere(
     *     fn($item) => $item['role'] === 'subscriber',
     *     fn($item) => array_merge($item, ['role' => 'member'])
     * );
     *
     * // $updated contains:
     * // [
     * //     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     * //     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     * //     ['id' => 3, 'name' => 'Charlie', 'role' => 'member'],
     * // ]
     * ```
     */
    public function updateWhere(Closure $condition, Closure $updater) : static
    {
        $updated = array_map(
            static fn($item) => $condition($item) ? $updater($item) : $item,
            $this->getItems()
        );

        return new static(items: $updated);
    }

    /**
     * Adds a whereIs clause to filter the array based on a condition.
     *
     * This method filters the items in the array based on the specified condition applied to a given column.
     * It supports a wide range of operators such as '=', '==', '===', '!=', '<>', '!==', '>', '<', '>=', '<=',
     * '<=>', 'contains', 'not contains', 'in', and 'not in'. The column can be specified using dot notation to access
     * nested values.
     *
     * @param string $column   The column name for the where clause.
     * @param string $operator The operator to be used in the where clause (e.g., '=', '==', '!=', '>', '<',
     *                         'contains', 'in', '<=>').
     * @param mixed  $value    The value to be compared with the column.
     */
    public function whereIs(string $column, string $operator, mixed $value) : self
    {
        // add more here if needed
        $supportedOperators = [
            '=',
            '==',
            '===',
            '!=',
            '<>',
            '!==',
            '>',
            '<',
            '>=',
            '<=',
            '<=>',
            'contains',
            'not contains',
            'in',
            'not in',
        ];

        if (! in_array($operator, $supportedOperators, true)) {
            throw new InvalidArgumentException(message: 'Unsupported operator: ' . $operator);
        }

        $filteredItems = array_filter(
            $this->items,
            function ($item) use ($column, $operator, $value) : bool {
                $itemValue = $this->getFromItem(item: $item, key: $column);

                return match ($operator) {
                    '=', '=='      => $itemValue == $value,
                    '==='          => $itemValue === $value,
                    '!=', '<>'     => $itemValue != $value,
                    '!=='          => $itemValue !== $value,
                    '>'            => $itemValue > $value,
                    '<'            => $itemValue < $value,
                    '>='           => $itemValue >= $value,
                    '<='           => $itemValue <= $value,
                    '<=>'          => $itemValue <=> $value,
                    'contains'     => match (true) {
                        is_string($itemValue) && is_string($value) => str_contains($itemValue, $value),
                        is_array($itemValue)                       => in_array($value, $itemValue, true),
                        default                                    => false,
                    },
                    'not contains' => match (true) {
                        is_string($itemValue) && is_string($value) => ! str_contains($itemValue, $value),
                        is_array($itemValue)                       => ! in_array($value, $itemValue, true),
                        default                                    => true,
                    },
                    'in'           => in_array($itemValue, (array) $value, true),
                    'not in'       => ! in_array($itemValue, (array) $value, true),
                    default        => false,
                };
            }
        );

        $this->items = array_values($filteredItems);

        return new static(items: $this->items);
    }

}

=== Traits/ConditionalsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait ConditionalsTrait
 *
 * Adds conditional behaviors to collections, enabling the application of callbacks
 * based on specific conditions. This promotes more expressive and readable code
 * when dealing with collections.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ConditionalsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Apply a callback if the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on a boolean condition. If the condition is true,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is true. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->when(true, fn($collection) => $collection->filter(fn($item) => $item > 2));
     * // $result contains [3, 4]
     * ```
     */
    public function when(bool $condition, Closure $callback) : static
    {
        if ($condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on the inverse of a boolean condition. If the condition is false,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is false. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->unless(false, fn($collection) => $collection->map(fn($item) => $item * 2));
     * // $result contains [2, 4, 6, 8]
     * ```
     */
    public function unless(bool $condition, Closure $callback) : static
    {
        if (! $condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the collection is empty.
     *
     * This method provides an inverse conditional application. It checks if the collection
     * is not empty, and if so, executes the provided callback with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->unlessEmpty(fn($collection) => $collection->remove(2));
     * // $result contains [1, 3]
     * ```
     */
    public function unlessEmpty(Closure $callback) : static
    {
        return $this->whenNotEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is not empty.
     *
     * This method checks if the collection has items. If it is not empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->whenNotEmpty(fn($collection) => $collection->map(fn($item) => $item + 1));
     * // $result contains [2, 3, 4]
     * ```
     */
    public function whenNotEmpty(Closure $callback) : static
    {
        if (! $this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Check if the collection is empty.
     *
     * This method determines whether the collection contains any items.
     *
     * @return bool True if the collection has no items, false otherwise.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $isEmpty = $arrh->isEmpty(); // Returns true
     *
     * $arrh = new Arrhae([1, 2, 3]);
     * $isEmpty = $arrh->isEmpty(); // Returns false
     * ```
     */
    public function isEmpty() : bool
    {
        return empty($this->getItems());
    }

    /**
     * Apply a callback unless the collection is not empty.
     *
     * This method checks if the collection is empty, and if so, executes the provided callback
     * with the current instance as its parameter. It serves as a semantic alternative to `whenEmpty`.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->unlessNotEmpty(fn($collection) => $collection->add('default'));
     * // $result contains ['default']
     * ```
     */
    public function unlessNotEmpty(Closure $callback) : static
    {
        return $this->whenEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is empty.
     *
     * This method checks if the collection has no items. If it is empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->whenEmpty(fn($collection) => $collection->setItems(['default']));
     * // $result contains ['default']
     * ```
     */
    public function whenEmpty(Closure $callback) : static
    {
        if ($this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }
}

=== Traits/DebugTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait DebugTrait
 *
 * Provides debugging capabilities for classes that implement the required methods.
 * This trait enforces the presence of `toArray` and `count` methods in the using class.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait DebugTrait
{
    /**
     * Dumps the array representation of the class and returns the instance.
     *
     * This method outputs the array representation using `var_dump` and returns
     * the current instance to allow method chaining.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dump();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * ```
     */
    public function dump() : static
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array($arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump($arrayRepresentation);

        return $this;
    }

    /**
     * Enforce the implementation of toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The array representation of the collection.
     */
    abstract public function toArray() : array;

    /**
     * Dumps the array representation of the class and terminates execution.
     *
     * This method outputs the array representation using `var_dump` and then
     * terminates the script execution.
     *
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dd();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * // Script execution terminated.
     * ```
     */
    public function dd() : void
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array($arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump($arrayRepresentation);
        die();
    }

    /**
     * Overrides the __debugInfo magic method to provide custom debugging information.
     *
     * This method is automatically called by `var_dump` and similar functions to retrieve
     * debugging information about the object.
     *
     * @return array The debugging information.
     */
    public function __debugInfo() : array
    {
        return $this->debugInfo();
    }

    /**
     * Provides debugging information including count and items.
     *
     * This method returns an associative array containing the count of items
     * and their array representation. It can be used to log or inspect the collection's state.
     *
     * @return array The debugging information for the current instance.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $debugInfo = $arrh->debugInfo();
     * // Returns:
     * // [
     * //     'count' => 3,
     * //     'items' => ['apple', 'banana', 'cherry']
     * // ]
     * ```
     */
    public function debugInfo() : array
    {
        $items = $this->toArray();

        if (! is_array($items)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        return [
            'count' => $this->count(),
            'items' => $items,
        ];
    }

    /**
     * Enforce the implementation of count method.
     *
     * Classes using this trait must implement this method.
     *
     * @return int The number of items in the collection.
     */
    abstract public function count() : int;
}

=== Traits/LazyEvaluationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait LazyEvaluationTrait
 *
 * Provides methods to enable lazy evaluation on collections.
 * It offers a set of functions to manipulate collections in a memory-efficient manner
 * using generator functions, enabling operations like taking or skipping elements
 * based on conditions, selecting every nth element, and sliding windows of elements.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait LazyEvaluationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Take items from the collection while the callback returns true.
     *
     * Creates a new collection taking elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to continue taking items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeWhile(fn($item) => $item < 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool($result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if (! $result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /** ***Traversal and Filtering Methods*** */


    /**
     * Skip items in the collection while the callback returns true.
     *
     * Creates a new collection that skips initial elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to skip items. It should accept the item and its key as parameters
     *                          and return a boolean.
     *
     * @return static A new lazy collection skipping items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipWhile(fn($item) => $item < 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool($result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if (! $result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Get every nth item in the collection.
     *
     * Useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved. Must be a positive integer.
     *
     * @return static A new lazy collection containing every nth item.
     *
     * @throws InvalidArgumentException If $step is not a positive integer.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5, 6]);
     * $result = $arrh->nth(2);
     * // $result yields 1, 3, 5
     * ```
     */
    public function nth(int $step) : static
    {
        if ($step <= 0) {
            throw new InvalidArgumentException(message: 'Step must be a positive integer.');
        }

        return new static(function () use ($step) {
            $index = 0;
            foreach ($this->getItems() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection until the callback returns true.
     *
     * Creates a new collection taking elements until the specified condition is met.
     *
     * @param Closure $callback The condition that stops the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeUntil(fn($item) => $item === 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool($result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if ($result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /**
     * Skip items in the collection until the callback returns true.
     *
     * Creates a new collection that starts taking elements once the specified
     * condition is met.
     *
     * @param Closure $callback The condition that starts the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection skipping items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipUntil(fn($item) => $item === 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool($result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if ($result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Creates a sliding window of items in the collection.
     *
     * Produces sub-arrays (chunks) of size specified, sliding by step count.
     * Useful for windowed computations or batch processing.
     *
     * @param int $size The size of each sliding window. Must be a positive integer.
     * @param int $step The step by which the window slides. Must be a positive integer. Defaults to 1.
     *
     * @return static A new lazy collection containing sliding windows of items.
     *
     * @throws InvalidArgumentException If $size or $step are not positive integers.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->sliding(3, 1);
     * // $result yields [1, 2, 3], [2, 3, 4], [3, 4, 5]
     * ```
     */
    public function sliding(int $size = 2, int $step = 1) : static
    {
        if ($size <= 0 || $step <= 0) {
            throw new InvalidArgumentException(message: 'Size and step must be positive integers.');
        }

        return new static(function () use ($size, $step) {
            $buffer = [];
            foreach ($this->getItems() as $item) {
                $buffer[] = $item;
                if (count($buffer) === $size) {
                    yield $buffer;
                    array_splice($buffer, 0, $step);
                }
            }

            // Yield remaining items if needed (optional)
            // if (count($buffer) > 0) {
            //     yield $buffer;
            // }
        });
    }

    /**
     * Returns a new instance with the first $limit items of the current collection.
     *
     * This method uses generator functions to yield only the specified number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $limit The number of items to take from the beginning of the collection. Must be a non-negative
     *                   integer.
     *
     * @return static A new lazy collection with the first $limit items.
     *
     * @throws InvalidArgumentException If $limit is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->take(3);
     * // $result yields 1, 2, 3
     * ```
     */
    public function take(int $limit) : static
    {
        if ($limit < 0) {
            throw new InvalidArgumentException(message: 'Limit must be a non-negative integer.');
        }

        return new static(
            iterator_to_array(
                (function () use ($limit) {
                    if ($limit === 0) {
                        return;
                    }

                    $count = 0;
                    foreach ($this->getItems() as $item) {
                        yield $item;
                        if (++$count >= $limit) {
                            break;
                        }
                    }
                })(),
                false
            )
        );
    }

    /**
     * Returns a new instance with the items starting from the $offset position of the current collection.
     *
     * This method utilizes generator functions to skip a certain number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $offset The number of items to skip from the beginning of the collection. Must be a non-negative
     *                    integer.
     *
     * @return static A new lazy collection with items starting from the $offset position.
     *
     * @throws InvalidArgumentException If $offset is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skip(2);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skip(int $offset) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset must be a non-negative integer.');
        }

        return new static(function () use ($offset) {
            if ($offset === 0) {
                foreach ($this->getItems() as $item) {
                    yield $item;
                }

                return;
            }

            $count = 0;
            foreach ($this->getItems() as $item) {
                if ($count++ < $offset) {
                    continue;
                }

                yield $item;
            }
        });
    }

    /**
     * Converts a lazy collection to an eagerly-loaded collection.
     *
     * This method resolves all deferred (lazy) items into an array, allowing for immediate
     * in-memory operations. It's useful for scenarios where further operations require
     * the collection to be fully loaded in memory.
     *
     * @return static A new instance containing the eagerly-loaded collection.
     *
     * ```
     * // Example: Processing a large dataset lazily, then converting to eager for final transformation.
     * $lazyCollection = new Arrhae((function () {
     *     // Simulate fetching a large dataset lazily.
     *     for ($i = 1; $i <= 10000; $i++) {
     *         yield [
     *             'id' => $i,
     *             'value' => $i * 2,
     *             'category' => $i % 2 === 0 ? 'even' : 'odd',
     *         ];
     *     }
     * })());
     *
     * // Step 1: Lazy filtering and mapping.
     * $filteredLazyCollection = $lazyCollection
     *     ->filter(fn($item) => $item['id'] > 5000)  // Keep items with IDs > 5000.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'value' => $item['value'] + 10,
     *         'is_even' => $item['category'] === 'even',
     *     ]);
     *
     * // Step 2: Convert to eager-loaded collection.
     * $eagerCollection = $filteredLazyCollection->toEager();
     *
     * // Step 3: Further eager operations.
     * $finalResult = $eagerCollection
     *     ->filter(fn($item) => $item['is_even'])     // Only keep even items.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'summary' => "Item ID: {$item['id']}, Value: {$item['value']}",
     *     ])
     *     ->toArray();
     *
     * // Output: $finalResult contains an eagerly-loaded array with transformed data.
     * [
     *     ['id' => 5002, 'summary' => 'Item ID: 5002, Value: 10014'],
     *     ['id' => 5004, 'summary' => 'Item ID: 5004, Value: 10018'],
     *     ...
     * ]
     * ```
     */
    public function toEager() : static
    {
        return new static(iterator_to_array($this->getItems()));
    }


}

=== Traits/LockableTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use LogicException;

/**
 * Trait LockableTrait
 *
 * Provides a locking mechanism to enforce immutability on collection-like objects.
 * Intended for use in data container classes (e.g., value object arrays) where mutation
 * should be explicitly prohibited after initialization or transformation.
 *
 * When locked, any attempt to mutate the object via methods like `set`, `forget`, `add`,
 * or internal `setItems` should result in a runtime exception.
 *
 * This trait enforces strict runtime safety in contexts such as:
 * - Domain-driven value object snapshots
 * - Immutable API response structures
 * - Secure, read-only configuration holders
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait LockableTrait
{
    /**
     * Indicates whether the current instance is locked and protected from mutation.
     */
    protected bool $locked = false;

    /**
     * Locks the current instance, making all mutating operations forbidden.
     *
     * This method should be called once the object reaches a stable state, typically
     * after construction, transformation, or hydration from a DTO.
     *
     * @return static Returns the same instance for fluent chaining.
     */
    public function lock() : static
    {
        // Enables the immutability flag
        $this->locked = true;

        // Return self to support fluent calls
        return $this;
    }

    /**
     * Indicates whether this instance has been locked.
     *
     * Useful for consumers to check immutability status.
     *
     * @return bool True if locked, false otherwise.
     */
    public function isLocked() : bool
    {
        return $this->locked;
    }

    /**
     * Checks whether mutation is allowed. Throws an exception if the instance is locked.
     *
     * Should be called at the top of any mutating method (e.g., set, forget, etc.)
     * to enforce write protection contract.
     *
     * @throws LogicException If mutation is attempted on a locked instance.
     */
    protected function assertNotLocked() : void
    {
        // Enforces immutability post-lock
        if ($this->locked === true) {
            throw new LogicException(message: 'Mutation is forbidden: this instance is locked and read-only.');
        }
    }
}

=== Traits/MacrosTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use BadMethodCallException;
use Closure;
use InvalidArgumentException;

/**
 * Trait MacrosTrait
 *
 * Provides the ability to register and handle macros (dynamic methods) within a class.
 * This trait allows for the registration of global macros and namespaced macros,
 * enabling flexible and organized method extensions.
 *
 * The trait enforces the implementation of the `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait MacrosTrait
{
    // Store macros and namespaced macros
    protected static array $macros          = [];

    protected static array $macroNamespaces = [];

    /**
     * Register a new global macro.
     *
     * This method allows you to define a macro (dynamic method) that can be called
     * on instances of the class using this trait.
     *
     * @param string  $name  The name of the macro.
     * @param Closure $macro The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macro('toUpperCase', function() {
     *     return array_map(fn($item) => strtoupper($item), $this->getItems());
     * });
     *
     * $instance->toUpperCase(); // Transforms all items to uppercase.
     * ```
     */
    public static function macro(string $name, Closure $macro) : void
    {
        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macros[$name])) {
            throw new InvalidArgumentException(message: sprintf("Macro '%s' is already registered.", $name));
        }

        self::$macros[$name] = $macro;
    }

    /**
     * Register a new namespaced macro.
     *
     * This method allows you to define a macro within a specific namespace, enabling
     * better organization and avoiding naming collisions.
     *
     * @param string  $namespace The namespace for organizing macros.
     * @param string  $name      The name of the macro within the namespace.
     * @param Closure $macro     The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the namespace or macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macroNamespace('string', 'toCamelCase', function() {
     *     return array_map(fn($item) => lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $item)))),
     *     $this->getItems());
     * });
     *
     * $instance->string::toCamelCase(); // Converts snake_case strings to camelCase.
     * ```
     */
    public static function macroNamespace(string $namespace, string $name, Closure $macro) : void
    {
        if ($namespace === '' || $namespace === '0') {
            throw new InvalidArgumentException(message: 'Namespace cannot be empty.');
        }

        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macroNamespaces[$namespace][$name])) {
            throw new InvalidArgumentException(
                message: sprintf("Macro '%s' is already registered in namespace '%s'.", $name, $namespace)
            );
        }

        self::$macroNamespaces[$namespace][$name] = $macro;
    }

    /**
     * Dynamically handle static method calls to macros.
     *
     * This magic method intercepts static calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     *
     * @param string $name      The name of the static method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Static global macro
     * MacrosTrait::macro('staticMethod', function() {
     *     return 'Static method called';
     * });
     *
     * Arrhae::staticMethod(); // Returns 'Static method called'
     * ```
     */
    public static function __callStatic(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains($name, '::')) {
            [$namespace, $macro] = explode('::', $name, 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo(null, static::class);

                return call_user_func_array($boundMacro, $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo(null, static::class);

            return call_user_func_array($boundMacro, $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Static method '%s' does not exist.", $name));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return iterable The collection of items.
     */
    abstract public function getItems() : iterable;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param iterable $items The collection of items to set.
     */
    abstract public function setItems(iterable $items) : static;

    /**
     * Handle dynamic method calls to macros.
     *
     * This magic method intercepts calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     * It supports both global macros and namespaced macros (using the '::' separator).
     *
     * @param string $name      The name of the method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Global macro
     * MacrosTrait::macro('sum', function() {
     *     return array_sum($this->getItems());
     * });
     *
     * $instance->sum(); // Returns the sum of all items.
     *
     * // Namespaced macro
     * MacrosTrait::macroNamespace('math', 'average', function() {
     *     return array_sum($this->getItems()) / count($this->getItems());
     * });
     *
     * $instance->math::average(); // Returns the average of all items.
     * ```
     */
    public function __call(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains($name, '::')) {
            [$namespace, $macro] = explode('::', $name, 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo($this, static::class);

                return call_user_func_array($boundMacro, $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo($this, static::class);

            return call_user_func_array($boundMacro, $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Method '%s' does not exist.", $name));
    }
}

=== Traits/ManageItemsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ManageItemsTrait
 *
 * Provides methods to manage items within a collection.
 * This trait offers functionalities to append, prepend, concatenate, remove,
 * replace, and slice items in a collection in an immutable and memory-efficient manner.
 *
 * The trait enforces the implementation of `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait ManageItemsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Append a value to the end of the collection.
     *
     * This method adds a new item to the end of the collection and returns a new instance
     * with the appended item, ensuring immutability.
     *
     * @param mixed $value The value to append.
     *
     * @return static A new instance with the appended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $newArrh = $arrh->append('cherry');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function append(mixed $value) : static
    {
        $items   = $this->getItems();
        $items[] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /** ***Item Management Methods*** */

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Prepend a value to the beginning of the collection.
     *
     * This method adds a new item to the beginning of the collection and returns a new instance
     * with the prepended item, ensuring immutability.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static A new instance with the prepended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['banana', 'cherry']);
     * $newArrh = $arrh->prepend('apple');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function prepend(mixed $value) : static
    {
        $items = $this->getItems();
        array_unshift($items, $value);

        return $this->setItems(items: $items);
    }

    /**
     * Concatenate the given iterable items to the current collection.
     *
     * This method merges the current collection with another iterable (array or instance of the using class)
     * and returns a new instance with the concatenated items, ensuring immutability.
     *
     * @param iterable $items The items to concatenate.
     *
     * @return static A new instance with concatenated items.
     *
     * @throws InvalidArgumentException If the provided items are not iterable.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $concatenated = $arrh1->concat($arrh2);
     * // $concatenated contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function concat(iterable $items) : static
    {
        $currentItems = $this->getItems();

        if ($items instanceof self) {
            $items = $items->getItems();
        } elseif (! is_array($items)) {
            throw new InvalidArgumentException(
                message: 'Concat method expects an array or an instance of the using class.'
            );
        }

        $newItems = array_merge($currentItems, $items);

        return $this->setItems(items: $newItems);
    }

    /**
     * Remove and return the first item of the collection.
     *
     * This method removes the first item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the first item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->shift();
     * // $newArrh contains ['banana', 'cherry']
     * ```
     */
    public function shift() : static|null
    {
        $items = $this->getItems();
        $value = array_shift($items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove and return the last item of the collection.
     *
     * This method removes the last item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the last item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->pop();
     * // $newArrh contains ['apple', 'banana']
     * ```
     */
    public function pop() : static|null
    {
        $items = $this->getItems();
        $value = array_pop($items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove an item at a specific index.
     *
     * This method removes the item at the specified index and returns a new instance
     * without that item. It throws an exception if the index is invalid.
     *
     * @param int $index The index of the item to remove.
     *
     * @return static A new instance without the specified item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->removeAt(1);
     * // $newArrh contains ['apple', 'cherry']
     * ```
     */
    public function removeAt(int $index) : static
    {
        $items = $this->getItems();

        if (! array_key_exists($index, $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        unset($items[$index]);

        // Reindex the array to maintain sequential keys
        $items = array_values($items);

        return $this->setItems(items: $items);
    }

    /**
     * Replace an item at a specific index.
     *
     * This method replaces the item at the specified index with a new value and returns a new instance
     * with the updated item. It throws an exception if the index is invalid.
     *
     * @param int   $index The index to replace.
     * @param mixed $value The new value.
     *
     * @return static A new instance with the replaced item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->replaceAt(1, 'blueberry');
     * // $newArrh contains ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function replaceAt(int $index, mixed $value) : static
    {
        $items = $this->getItems();

        if (! array_key_exists($index, $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        $items[$index] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Returns a sliced portion of the collection.
     *
     * This method returns a new instance containing a subset of the collection based on the provided offset and
     * length.
     *
     * @param int      $offset The starting index of the slice.
     * @param int|null $length The number of items to include in the slice. If null, slices to the end of the
     *                         collection.
     *
     * @return static A new instance containing the sliced portion.
     *
     * @throws InvalidArgumentException If the offset or length is negative.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $sliced = $arrh->slice(1, 3);
     * // $sliced contains ['banana', 'cherry', 'date']
     * ```
     */
    public function slice(int $offset, ?int $length = null) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset cannot be negative.');
        }

        if ($length !== null && $length < 0) {
            throw new InvalidArgumentException(message: 'Length cannot be negative.');
        }

        $slicedItems = array_slice($this->getItems(), $offset, $length, true);

        // If slicing preserves keys and you want sequential keys, reindex
        // $slicedItems = array_values($slicedItems);

        return new static(items: $slicedItems);
    }

    /**
     * Get all items in the collection.
     *
     * This method provides a complete array of all items in the collection.
     *
     * @return array The array of all items.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $allItems = $arrh->all();
     * // $allItems contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function all() : array
    {
        return $this->getItems();
    }
}

=== Traits/MetaInfoTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Carbon\Carbon;
use Closure;
use Exception;
use InvalidArgumentException;
use Ramsey\Uuid\Exception\UnsatisfiedDependencyException;
use Ramsey\Uuid\Uuid;

/**
 * Trait MetaInfoTrait
 *
 * Provides methods to enrich items within a collection with metadata such as GUIDs, timestamps, and version
 * information. It also offers functionality to clone the collection.
 *
 * This trait enforces the implementation of `getItems()`, `setItems()`, `map()`, and `toArray()` methods
 * in the using class to manage and transform the underlying data collection.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait MetaInfoTrait
{
    use AbstractDependenciesTrait;
    use TransformationTrait;

    /**
     * Add a unique GUID to each item in the collection.
     *
     * This method enriches each item with a universally unique identifier (UUID) under the 'id' key.
     *
     * @return static A new instance with GUIDs added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->guid();
     * // $newArrh contains:
     * // [
     * //     ['id' => 'uuid1', 'data' => 'apple'],
     * //     ['id' => 'uuid2', 'data' => 'banana'],
     * //     ['id' => 'uuid3', 'data' => 'cherry']
     * // ]
     * ```
     */
    public function guid() : static
    {
        return $this->map(static function ($item) : array {
            try {
                return [
                    'id'   => Uuid::uuid4()->toString(),
                    'data' => $item,
                ];
            } catch (Exception $e) {
                throw new InvalidArgumentException('Failed to generate UUID: ' . $e->getMessage(), $e->getCode(), $e);
            }
        });
    }

    /**
     * Enforce the implementation of the map method.
     *
     * Classes using this trait must implement this method.
     *
     * @param Closure $callback The callback to apply to each item.
     *
     * @return static A new instance with the transformed items.
     */
    abstract public function map(Closure $callback) : static;

    /**
     * Set or retrieve timestamps for items in the collection.
     *
     * When setting, this method adds a 'timestamp' key with the current time formatted as specified.
     * When retrieving, it extracts the 'timestamp' from each item.
     *
     * @param bool   $set    True to set the current timestamp, false to retrieve.
     * @param string $format Optional date format for timestamp. Defaults to Unix timestamp ('U').
     *
     * @return static A new instance with timestamps set or retrieved.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $timestamped = $arrh->timestamp();
     * // $timestamped contains:
     * // [
     * //     ['timestamp' => 'current_timestamp', 'data' => 'apple'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'banana'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'cherry']
     * // ]
     *
     * $timestamps = $arrh->timestamp(false);
     * // $timestamps contains: ['current_timestamp', 'current_timestamp', 'current_timestamp']
     * ```
     */
    public function timestamp(bool|null $set = null, string $format = 'U') : static
    {
        $set ??= true;
        try {
            $timestamp = Carbon::now()->format($format);
        } catch (Exception $exception) {
            throw new InvalidArgumentException(
                'Invalid date format: ' . $exception->getMessage(),
                $exception->getCode(),
                $exception
            );
        }

        return $this->map(
            static function ($item) use ($set, $timestamp) {
                if ($set) {
                    return [
                        'timestamp' => $timestamp,
                        'data'      => $item,
                    ];
                }

                return $item['timestamp'] ?? null;
            }
        );
    }

    /**
     * Add version information to each item in the collection.
     *
     * This method enriches each item with a 'version' key indicating the version number.
     *
     * @param int $version Version number to assign. Defaults to 1.
     *
     * @return static A new instance with version numbers added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $versioned = $arrh->version(2);
     * // $versioned contains:
     * // [
     * //     ['version' => 2, 'data' => 'apple'],
     * //     ['version' => 2, 'data' => 'banana'],
     * //     ['version' => 2, 'data' => 'cherry']
     * // ]
     * ```
     */
    public function version(int $version = 1) : static
    {
        return $this->map(static fn($item) : array => [
            'version' => $version,
            'data'    => $item,
        ]);
    }

    /**
     * Create a deep clone of the collection.
     *
     * This method creates a new instance of the collection with a deep copy of the current items.
     *
     * @return static Cloned collection.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $cloned = $arrh->clone();
     * // $cloned is a separate instance with the same items
     * ```
     */
    public function clone() : static
    {
        return new static($this->toArray());
    }

    /**
     * Enforce the implementation of the toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The collection represented as an array.
     */
    abstract public function toArray() : array;
}

=== Traits/OrderManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait OrderManipulationTrait
 *
 * Provides methods to manipulate the order of arrays.
 * This trait allows sorting arrays in ascending order
 * and shuffling array elements.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait OrderManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Sort items in ascending order based on a given key.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param string|callable $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new instance with sorted items.
     *
     * @throws InvalidArgumentException If the key is a string and does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortAsc('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAscending(string|callable $key) : static
    {
        $items = $this->getItems();

        // If sorting by a string key, ensure all items are arrays and contain the key
        if (is_string($key)) {
            foreach ($items as $item) {
                if (! is_array($item) || ! array_key_exists($key, $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            usort($items, static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable($key)) {
            usort($items, $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Shuffle the items.
     *
     * This method randomizes the order of items in the collection and returns a new instance
     * with the shuffled items, ensuring immutability.
     *
     * @return static A new instance with shuffled items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $shuffled = $arrh->shuffle();
     * // $shuffled might contain ['cherry', 'apple', 'banana']
     * ```
     */
    public function shuffle() : static
    {
        $items = $this->getItems();

        // Shuffle items to randomize their order
        shuffle($items);

        // Return a new instance to preserve immutability
        return new static(items: $items);
    }
}

=== Traits/PartitioningTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait PartitioningTrait
 *
 * Provides methods to partition and group items within a collection.
 * This trait allows splitting collections based on conditions, grouping by keys or callbacks,
 * and dividing collections into specified numbers of groups or chunks.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait PartitioningTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Splits the collection into two groups based on a callback.
     *
     * This method partitions the collection into two separate collections:
     * one where items satisfy the provided callback condition,
     * and another where items do not.
     *
     * @param Closure $callback The callback to determine the split condition.
     *
     * @return array Two collections: one matching the condition, one not.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * [$fruitsWithA, $fruitsWithoutA] = $arrh->partition(fn($item) => strpos($item, 'a') !== false);
     * // $fruitsWithA contains ['apple', 'banana', 'date']
     * // $fruitsWithoutA contains ['cherry']
     * ```
     */
    public function partition(Closure $callback) : array
    {
        $matches    = [];
        $nonMatches = [];

        foreach ($this->getItems() as $item) {
            if ($callback($item)) {
                $matches[] = $item;
            } else {
                $nonMatches[] = $item;
            }
        }

        return [new static(items: $matches), new static(items: $nonMatches)];
    }

    /** ***Partitioning Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Groups the collection items by a specific key or callback.
     *
     * This method organizes the collection into groups based on a specified key or a callback function.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param Closure|string $key The key to group by, or a callback function to determine the group key.
     *
     * @return static A collection containing grouped items.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * // Grouping by a string key
     * $arrh = new Arrhae([
     *     ['type' => 'fruit', 'name' => 'apple'],
     *     ['type' => 'fruit', 'name' => 'banana'],
     *     ['type' => 'vegetable', 'name' => 'carrot'],
     * ]);
     * $grouped = $arrh->groupBy('type');
     * // $grouped contains:
     * // [
     * //     'fruit' => new Arrhae([
     * //         ['type' => 'fruit', 'name' => 'apple'],
     * //         ['type' => 'fruit', 'name' => 'banana'],
     * //     ]),
     * //     'vegetable' => new Arrhae([
     * //         ['type' => 'vegetable', 'name' => 'carrot'],
     * //     ]),
     * // ]
     *
     * // Grouping by a callback
     * $groupedByLength = $arrh->groupBy(fn($item) => strlen($item['name']));
     * // $groupedByLength contains:
     * // [
     * //     5 => new Arrhae([['type' => 'fruit', 'name' => 'apple']]),
     * //     6 => new Arrhae([['type' => 'fruit', 'name' => 'banana'], ['type' => 'vegetable', 'name' => 'carrot']]),
     * // ]
     * ```
     */
    public function groupBy(Closure|string $key) : static
    {
        $grouped = [];

        foreach ($this->getItems() as $item) {
            if (is_callable($key)) {
                $groupKey = $key($item);
            } elseif (is_string($key)) {
                if (! is_array($item) || ! array_key_exists($key, $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }

                $groupKey = $item[$key];
            } else {
                throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
            }

            $grouped[$groupKey][] = $item;
        }

        return new static(items: array_map(fn($group) : static => new static(items: $group), $grouped));
    }

    /**
     * Splits the collection into a specified number of groups.
     *
     * This method divides the collection into the desired number of groups as evenly as possible.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param int $numberOfGroups The number of groups to split into.
     *
     * @return static A collection containing the specified number of groups.
     *
     * @throws InvalidArgumentException If the number of groups is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $groups = $arrh->split(2);
     * // $groups contains:
     * // [
     * //     new Arrhae(['apple', 'banana', 'cherry']),
     * //     new Arrhae(['date', 'elderberry']),
     * // ]
     * ```
     */
    public function split(int $numberOfGroups) : static
    {
        if ($numberOfGroups < 1) {
            throw new InvalidArgumentException(message: 'Number of groups must be at least 1.');
        }

        $totalItems = count($this->getItems());
        $groupSize  = (int) ceil($totalItems / $numberOfGroups);
        $groups     = array_chunk($this->getItems(), $groupSize);

        return new static(items: array_map(static fn($group) : static => new static(items: $group), $groups));
    }

    /**
     * Splits the collection into chunks of a given size.
     *
     * This method divides the collection into chunks, each containing a specified number of items.
     * Each chunk is represented as a sub-collection within the main collection.
     *
     * @param int $size The size of each chunk.
     *
     * @return static A collection containing the chunks.
     *
     * @throws InvalidArgumentException If the chunk size is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $chunks = $arrh->chunk(2);
     * // $chunks contains:
     * // [
     * //     new Arrhae(['apple', 'banana']),
     * //     new Arrhae(['cherry', 'date']),
     * //     new Arrhae(['elderberry']),
     * // ]
     * ```
     */
    public function chunk(int $size) : static
    {
        if ($size < 1) {
            throw new InvalidArgumentException(message: 'Chunk size must be at least 1.');
        }

        $chunks = array_chunk($this->getItems(), $size);

        return new static(items: array_map(static fn($chunk) : static => new static(items: $chunk), $chunks));
    }
}

=== Traits/SetOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait SetOperationsTrait
 *
 * Provides set operations methods to manipulate collections, including intersection, union, difference, and merging.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait SetOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Return the intersection of two collections.
     *
     * This method returns a new collection containing items that are present in both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to intersect with.
     *
     * @return static A new collection with intersected items.
     *
     * @throws InvalidArgumentException If the provided collection is empty.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'cherry', 'date']);
     * $intersection = $arrh1->intersect($arrh2);
     * // $intersection contains ['banana', 'cherry']
     * ```
     */
    public function intersect(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        if (empty($otherItems)) {
            throw new InvalidArgumentException('The provided collection for intersection is empty.');
        }

        $intersected = array_intersect($currentItems, $otherItems);

        return new static($intersected);
    }

    /** ***Set Operations Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Return the union of two collections.
     *
     * This method returns a new collection containing all unique items from both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to union with.
     *
     * @return static A new collection with unique combined items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['banana', 'cherry']);
     * $union = $arrh1->union($arrh2);
     * // $union contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function union(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);
        $unique = array_unique($merged, SORT_REGULAR); // SORT_REGULAR ensures proper uniqueness for arrays

        return new static($unique);
    }

    /**
     * Return the difference of two collections.
     *
     * This method returns a new collection containing items that are present in the current collection but not in the
     * provided collection.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with items in the original but not in the compared collection.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date']);
     * $difference = $arrh1->diff($arrh2);
     * // $difference contains ['apple', 'cherry']
     * ```
     */
    public function diff(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $diff = array_diff($currentItems, $otherItems);

        return new static($diff);
    }

    /**
     * Merge two collections together.
     *
     * This method merges the current collection with the provided collection and returns a new collection containing
     * all items.
     *
     * @param self $collection The collection to merge with.
     *
     * @return static A new collection with merged items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $merged = $arrh1->merge($arrh2);
     * // $merged contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function merge(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);

        return new static($merged);
    }

    /**
     * Returns the symmetric difference of two sets.
     *
     * This method returns a new collection containing elements that are present in either the current collection or
     * the
     * provided collection, but not in both. The symmetric difference is the combination of the differences in both
     * directions between the two sets.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with the symmetric difference of elements.
     *
     * @throws InvalidArgumentException If the provided collection is invalid or contains incompatible element types.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date', 'fig']);
     * $symDifference = $arrh1->symmetricDifference($arrh2);
     * print_r($symDifference->toArray());
     * // Outputs:
     * // ['apple', 'cherry', 'date', 'fig']
     * ```
     */
    public function symmetricDifference(self $collection) : static
    {
        $diff1         = array_diff($this->getItems(), $collection->toArray());
        $diff2         = array_diff($collection->toArray(), $this->getItems());
        $symDifference = array_merge($diff1, $diff2);

        return new static($symDifference);
    }
}

=== Traits/SortOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait SortOperationsTrait
 *
 * Provides methods to sort and manipulate the order of items within a collection.
 * This trait allows sorting in ascending or descending order based on a key or callback,
 * reversing the order of items, and sorting by keys.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait SortOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Sort the collection in descending order based on a given key or callback.
     *
     * This method sorts the collection in descending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $sortedDesc = $arrh->sortDesc('name');
     * // $sortedDesc contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function sortDesc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key)->reverse();
    }

    /** ***Sorting Methods*** */

    /**
     * Reverse the order of the items in the collection.
     *
     * This method returns a new instance with the items in reverse order, ensuring immutability.
     *
     * @return static A new instance with the items in reverse order.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $reversed = $arrh->reverse();
     * // $reversed contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function reverse() : static
    {
        return new static(items: array_reverse($this->getItems(), true));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Sort the collection based on a given key or callback.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortBy('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortBy(Closure|string $key) : static
    {
        $sortedItems = $this->getItems();

        if (is_string($key)) {
            foreach ($sortedItems as $sortedItem) {
                if (! is_array($sortedItem) || ! array_key_exists($key, $sortedItem)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            uasort($sortedItems, static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable($key)) {
            uasort($sortedItems, $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $sortedItems);
    }

    /**
     * Sort the collection by its keys in ascending order.
     *
     * This method sorts the collection by its keys in ascending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeys = $arrh->sortKeys();
     * // $sortedKeys contains ['a' => 'apple', 'b' => 'banana', 'c' => 'cherry']
     * ```
     */
    public function sortKeys() : static
    {
        $sorted = $this->getItems();
        ksort($sorted);

        return new static(items: $sorted);
    }

    /**
     * Sort the collection by its keys in descending order.
     *
     * This method sorts the collection by its keys in descending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeysDesc = $arrh->sortKeysDesc();
     * // $sortedKeysDesc contains ['c' => 'cherry', 'b' => 'banana', 'a' => 'apple']
     * ```
     */
    public function sortKeysDesc() : static
    {
        $sorted = $this->getItems();
        krsort($sorted);

        return new static(items: $sorted);
    }

    /**
     * Sorts the collection in ascending order based on a given key or callback.
     *
     * This method sorts the collection in ascending order using the specified key or a callback function for comparing
     * elements. If the key is a string, it is expected that the collection's elements are associative arrays
     * containing the specified key. If a callback function is provided, it is used to dynamically compare elements.
     *
     * @param Closure|string $key The key to sort by or a callable function for comparison.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more elements,
     *                                  or if the provided parameter is neither a Closure nor a string.
     *
     * ```
     * // Sorting by the 'price' key in ascending order
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sortedAsc = $arrh->sortAsc('price');
     * print_r($sortedAsc->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     *
     * // Sorting using a callback function
     * $sortedAscCallback = $arrh->sortAsc(function($a, $b) {
     *     return strlen($a['name']) <=> strlen($b['name']);
     * });
     * print_r($sortedAscCallback->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAsc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key);
    }

    /**
     * Sorts the collection by multiple criteria.
     *
     * This method allows sorting by multiple keys with specified orders (ascending or descending).
     * It accepts an associative array where keys represent the attributes to sort by,
     * and values specify the sorting order (`'asc'` for ascending, `'desc'` for descending).
     *
     * @param array $criteria Associative array of sorting criteria.
     *                        Keys are the item attributes, and values are sorting orders.
     *                        Example: `['name' => 'asc', 'age' => 'desc']`.
     *
     * @return static A new collection instance sorted by the given criteria.
     *
     * ```
     * $collection = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     *     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     *     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     *     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * ]);
     *
     * // Sort by name (ascending), then by age (ascending), and then by score (descending).
     * $sortedCollection = $collection->sortByMultiple([
     *     'name' => 'asc',
     *     'age' => 'asc',
     *     'score' => 'desc',
     * ]);
     *
     * // Result:
     * // [
     * //     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     * //     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     * //     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     * //     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * // ]
     * ```
     */
    public function sortByMultiple(array $criteria) : static
    {
        $items = $this->getItems();
        usort($items, static function (array $a, array $b) use ($criteria) : int {
            foreach ($criteria as $key => $order) {
                $result = $a[$key] <=> $b[$key];
                if ($result !== 0) {
                    return $order === 'desc' ? -$result : $result;
                }
            }

            return 0;
        });

        return new static(items: $items);
    }
}

=== Traits/StringManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StringManipulationTrait
 *
 * Provides advanced string manipulation capabilities to the Arrhae class, including
 * concatenation, case transformation, trimming, replacing, and more.
 */
trait StringManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Defines the default characters to be trimmed.
     */
    private const string DEFAULT_TRIM_CHARACTERS = " \t\n\r\0\x0B";

    /**
     * Concatenates the items of the collection into a string using a glue string.
     *
     * @param string $glue The string to use between items. Defaults to an empty string.
     *
     * @return string The concatenated string.
     *
     * @throws InvalidArgumentException If the collection contains non-string items.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana', 'cherry']);
     * echo $arrh->implode(', '); // Output: 'apple, banana, cherry'
     */
    public function implode(string $glue = '') : string
    {
        // Ensure all items are strings
        foreach ($this->getItems() as $item) {
            if (! is_string($item)) {
                throw new InvalidArgumentException(message: 'All items must be strings to perform implode.');
            }
        }

        return implode($glue, $this->getItems());
    }

    /**
     * Converts all string items in the collection to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to uppercase.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana']);
     * $uppercased = $arrh->uppercase();
     * // ['APPLE', 'BANANA']
     */
    public function uppercase(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => strtoupper($value), key: $key);
    }

    /**
     * A helper method to process items within the collection and apply string transformations.
     *
     * @param callable    $callback The transformation to apply to string items.
     * @param string|null $key      The key to target within associative arrays if applicable.
     *
     * @return static A new Arrhae instance with processed items.
     */
    private function processItems(callable $callback, ?string $key = null) : static
    {
        return $this->map(callback: function ($item) use ($callback, $key) {
            if ($key !== null && is_array($item) && isset($item[$key]) && is_string($item[$key])) {
                $item[$key] = $callback($item[$key]);

                return $item;
            }

            if (is_string($item)) {
                return $callback($item);
            }

            return $item;
        });
    }

    /**
     * Converts all string items in the collection to lowercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to lowercase.
     *
     * @example
     * $arrh = Arrhae::make(['APPLE', 'BANANA']);
     * $lowercased = $arrh->lowercase();
     * // ['apple', 'banana']
     */
    public function lowercase(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => strtolower($value), key: $key);
    }

    /**
     * Converts the first character of each word in the string items to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to the title case.
     *
     * @example
     * $arrh = Arrhae::make(['hello world', 'php is great']);
     * $titlecased = $arrh->title();
     * // ['Hello World', 'Php Is Great']
     */
    public function title(?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => ucwords(strtolower($value)), key: $key);
    }

    /**
     * Removes whitespace or other predefined characters from the beginning and end of string items.
     *
     * @param string      $characters The characters to trim. Defaults to trimming common whitespace characters.
     * @param string|null $key        The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items trimmed.
     *
     * @example
     * $arrh = Arrhae::make([' apple  ', "\tbanana\n", ' cherry ']);
     * $trimmed = $arrh->trim();
     * // ['apple', 'banana', 'cherry']
     */
    public function trim(string $characters = self::DEFAULT_TRIM_CHARACTERS, ?string $key = null) : static
    {
        return $this->processItems(callback: fn(string $value) : string => trim($value, $characters), key: $key);
    }

    /**
     * Converts string items in the collection to camelCase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to camelCase.
     *
     * @example
     * $arrh = Arrhae::make(['hello_world', 'php-is-great', 'convert this']);
     * $camelCased = $arrh->camelCase();
     * // ['helloWorld', 'phpIsGreat', 'convertThis']
     */
    public function camelCase(?string $key = null) : static
    {
        return $this->processItems(
            callback: fn(string $value) : string => lcfirst(
                str_replace(' ', '', ucwords(str_replace(['-', '_'], ' ', $value)))
            ),
            key     : $key
        );
    }
}
=== Traits/StructureConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StructureConversionTrait
 *
 * Provides methods to convert the structure of collections,
 * including flattening multidimensional arrays into dot-notated arrays
 * and converting collections to indexed lists.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait StructureConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multidimensional collection into a dot-notated array.
     *
     * Dot notation represents nested elements in a flat structure with keys such as "key.subkey".
     * This method returns a new instance with flattened keys and corresponding values.
     *
     * @return static A new instance with dot-notated keys and values.
     *
     * @throws InvalidArgumentException If the collection contains non-array nested items.
     *
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'address' => [
     *             'street' => '123 Main St',
     *             'city' => 'Anytown'
     *         ]
     *     ],
     *     'status' => 'active'
     * ]);
     * $flattened = $arrh->dot();
     * // $flattened contains:
     * // [
     * //     'user.name' => 'John Doe',
     * //     'user.address.street' => '123 Main St',
     * //     'user.address.city' => 'Anytown',
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function dot() : static
    {
        $results = [];
        $flatten = static function (array $items, string $prefix = '') use (&$flatten, &$results) : void {
            foreach ($items as $key => $value) {
                if (! is_scalar($key) && ! is_null($key)) {
                    throw new InvalidArgumentException(message: 'Keys must be scalar or null.');
                }

                $dotKey = $prefix . $key;
                if (is_array($value)) {
                    $flatten($value, $dotKey . '.');
                } else {
                    $results[$dotKey] = $value;
                }
            }
        };

        $items = $this->getItems();
        if (! is_array($items)) {
            throw new InvalidArgumentException(
                message: 'The collection must be an array to perform dot notation flattening.'
            );
        }

        $flatten(items: $items);

        return new static(items: $results);
    }

    /** ***Design Conversion Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Converts the collection to a list (indexed array).
     *
     * This method returns only the values, disregarding the keys.
     * It returns a new instance containing an indexed list of the original values.
     *
     * @return static A new instance with an indexed list of array values.
     *
     * ```
     * $arrh = new Arrhae(['first' => 'apple', 'second' => 'banana', 'third' => 'cherry']);
     * $list = $arrh->toList();
     * // $list contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function toList() : static
    {
        $list = array_values($this->getItems());

        return new static(items: $list);
    }

    /**
     * Reconstruct a dot-notated array back into a multidimensional array.
     *
     * This method reverses the flattening process, restoring the original multidimensional structure.
     *
     * @return static A new instance with the original multidimensional array structure.
     *
     * ```
     * $flattened = new Arrhae([
     *     'user.name' => 'John Doe',
     *     'user.address.street' => '123 Main St',
     *     'user.address.city' => 'Anytown',
     *     'status' => 'active'
     * ]);
     * $original = $flattened->unDot();
     * // $original contains:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'address' => [
     * //             'street' => '123 Main St',
     * //             'city' => 'Anytown'
     * //         ]
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function unDot() : static
    {
        $results = [];
        foreach ($this->getItems() as $dotKey => $item) {
            $keys = explode('.', (string) $dotKey);
            $temp = &$results;
            foreach ($keys as $key) {
                if (! isset($temp[$key]) || ! is_array($temp[$key])) {
                    $temp[$key] = [];
                }

                $temp = &$temp[$key];
            }

            $temp = $item;
            unset($temp);
        }

        return new static($results);
    }
}

=== Traits/TransformationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;
use RecursiveArrayIterator;
use RecursiveIteratorIterator;

/**
 * Trait TransformationTrait
 *
 * Provides methods to transform the structure of collections,
 * including flattening multidimensional arrays, applying callbacks,
 * and mapping with custom keys.
 *
 * @package Gemini\DataHandling\ArrayHandling\Traits
 */
trait TransformationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multi-dimensional array into a single-dimensional array.
     *
     * This method recursively flattens a multi-dimensional array into a single-dimensional
     * array, disregarding the original keys.
     *
     * @return static A new instance with the flattened array.
     *
     * @throws InvalidArgumentException If the collection is not an array.
     *
     * ```
     * $arrh = new Arrhae([
     *     'fruits' => ['apple', 'banana'],
     *     'vegetables' => ['carrot', 'lettuce'],
     *     'dairy' => 'milk'
     * ]);
     * $flattened = $arrh->flatten();
     * // $flattened contains:
     * // ['apple', 'banana', 'carrot', 'lettuce', 'milk']
     * ```
     */
    public function flatten() : static
    {
        $items = $this->getItems();
        if (! is_array($items)) {
            throw new InvalidArgumentException(message: 'The collection must be an array to perform flattening.');
        }

        $iterator  = new RecursiveIteratorIterator(iterator: new RecursiveArrayIterator(array: $items));
        $flattened = [];

        foreach ($iterator as $value) {
            $flattened[] = $value;
        }

        return new static(items: $flattened);
    }


    /** ***Transformation Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Apply a callback to each item and flatten the results into a single array.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an array, and the results are merged into a single, flattened array.
     *
     * @param Closure $callback The callback to apply. It should return an array for each item.
     *
     * @return static A new instance with the mapped and flattened array.
     *
     * @throws InvalidArgumentException If the callback does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $flatMapped = $arrh->flatMap(function($item) {
     *     return [$item, strtoupper($item)];
     * });
     * // $flatMapped contains ['apple', 'APPLE', 'banana', 'BANANA', 'cherry', 'CHERRY']
     * ```
     */
    public function flatMap(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $item) {
            $result = $callback($item);
            if (! is_array($result)) {
                throw new InvalidArgumentException(message: 'The callback for flatMap must return an array.');
            }

            $mapped = array_merge($mapped, $result);
        }

        return new static(items: $mapped);
    }

    /**
     * Apply a callback to each item, using returned keys as the new array keys.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an associative array with a single key-value pair, where the key becomes
     * the new key in the resulting collection.
     *
     * @param Closure $callback The callback to apply. It should return an associative array with one key-value pair.
     *
     * @return static A new instance with mapped keys and values.
     *
     * @throws InvalidArgumentException If the callback does not return an associative array with one key-value pair.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $mappedWithKeys = $arrh->mapWithKeys(function($item, $key) {
     *     return [$item => strlen($item)];
     * });
     * // $mappedWithKeys contains ['apple' => 5, 'banana' => 6, 'cherry' => 6]
     * ```
     */
    public function mapWithKeys(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $key => $item) {
            $result = $callback($item, $key);
            if (! is_array($result) || count($result) !== 1) {
                throw new InvalidArgumentException(
                    message: 'The callback for mapWithKeys must return an associative array with exactly one key-value pair.'
                );
            }

            $newKey   = key($result);
            $newValue = reset($result);
            if (array_key_exists($newKey, $mapped)) {
                throw new InvalidArgumentException(
                    message: sprintf("Duplicate key '%s' returned by mapWithKeys callback.", $newKey)
                );
            }

            $mapped[$newKey] = $newValue;
        }

        return new static(items: $mapped);
    }

    /**
     * Transform the current items using a callback.
     *
     * This method applies the provided callback to each item in the collection and returns
     * a new instance with the transformed items, ensuring immutability.
     *
     * @param Closure $callback The callback to apply.
     *
     * @return static A new instance with transformed items.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $transformed = $arrh->transform(function($item) {
     *     return $item * 2;
     * });
     * // $transformed contains [2, 4, 6]
     * ```
     */
    public function transform(Closure $callback) : static
    {
        $transformedItems = array_map($callback, $this->getItems());

        return new static(items: $transformedItems);
    }

    /**
     * Apply a complex transformation using SPL iterators.
     *
     * This method allows applying a callback to each element during iteration,
     * enabling complex transformations beyond simple mapping.
     *
     * @param Closure $callback The callback to apply to each element.
     *
     * @return static A new instance with the transformed collection.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * @example
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'age' => 30
     *     ],
     *     'status' => 'active'
     * ]);
     * $advancedTransformed = $arrh->advancedTransform(function($value, $key) {
     *     if ($key === 'age') {
     *         return $value + 1; // Increment age by 1
     *     }
     *     return $value;
     * });
     * print_r($advancedTransformed->toArray());
     * // Outputs:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'age' => 31
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function advancedTransform(Closure $callback) : static
    {
        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveArrayIterator(array: $this->getItems()),
            mode    : RecursiveIteratorIterator::CHILD_FIRST
        );

        $transformed = $this->getItems();

        foreach ($iterator as $key => $value) {
            if (! is_array($value)) {
                $transformed[$key] = $callback($value, $key);
            }
        }

        return new static(items: $transformed);
    }
}

