=== Attributes/AttributeInjector.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Gemini\Container\Containers\DependencyInjector;
use Gemini\Container\Exceptions\InvalidInjectionException;
use ReflectionClass;
use ReflectionProperty;

/**
 * AttributeInjector is responsible for resolving and injecting dependencies
 * marked with the #[Inject] attribute into the properties of an object at runtime.
 * This class leverages constructor promotion for clean and expressive instantiation.
 *
 * The class ensures:
 * - Only properties with #[Inject] are processed.
 * - Properties without a proper type or with builtin types are invalid for injection.
 * - Dependencies are fetched from the provided DependencyInjector container.
 */
final readonly class AttributeInjector
{
    /**
     * Constructor for AttributeInjector.
     *
     * @param DependencyInjector $container The dependency injection container responsible for
     *                                      resolving instances required by the object properties.
     */
    public function __construct(private DependencyInjector $container) {}

    /**
     * Traverses and injects dependencies into the properties of the given object
     * that are marked with the #[Inject] attribute.
     *
     * @template T of object
     *
     * @param object $object The target object whose injectable properties need to be processed.
     *
     * @return object The same object instance with dependencies injected into its properties.
     *
     * @throws InvalidInjectionException If the type of a property to be injected is missing or invalid.
     */
    public function inject(object $object) : object
    {
        // Create a reflection of the given object to analyze its properties and metadata.
        $reflection = new ReflectionClass(objectOrClass: $object);

        // Iterate over all properties of the object.
        foreach ($reflection->getProperties() as $property) {
            // Process and attempt to inject dependency for the current property.
            $this->processProperty(object: $object, property: $property);
        }

        // Return the object after injection processing.
        return $object;
    }

    /**
     * Inspects and injects a property of the given object if it is marked with #[Inject].
     *
     * This method ensures:
     * - Properties that are already initialized are skipped.
     * - Only properties with #[Inject] are processed.
     * - A valid dependency type is required for successful resolution.
     *
     * @param object             $object   The target object that owns the property to be injected.
     * @param ReflectionProperty $property The reflection instance of the property to analyze and inject.
     *
     * @throws InvalidInjectionException If the property lacks a valid type hint or its type is builtin.
     */
    private function processProperty(object $object, ReflectionProperty $property) : void
    {
        // Skip properties that are already initialized to avoid overriding existing values.
        if ($property->isInitialized(object: $object)) {
            return;
        }

        // Retrieve attributes of the property, specifically looking for #[Inject].
        $attributes = $property->getAttributes(name: Inject::class);

        // If the #[Inject] attribute isn't present, skip further processing for this property.
        if (empty($attributes)) {
            return;
        }

        // Retrieve the type of the property to validate its suitability for injection.
        $type = $property->getType();

        // Ensure the property has a valid type and is not a built-in PHP type.
        // Injection is only applicable for custom or class types.
        if (! $type || $type->isBuiltin()) {
            throw new InvalidInjectionException(
                property: $property,
                message : "Cannot inject property '{$property->getName()}': Missing or invalid type hint."
            );
        }

        // Resolve the dependency instance using the container based on the property’s type name.
        $dependency = $this->container->get(id: $type->getName());

        // Enable modification of the property value, even if it is private or protected.
        /** @noinspection PhpExpressionResultUnusedInspection */
        $property->setAccessible(accessible: true);

        // Inject the resolved dependency into the property's value.
        $property->setValue(objectOrValue: $object, value: $dependency);
    }
}
=== Attributes/Contextual.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Contextual
{
    public function __construct(
        public string      $target,
        public string|null $dependency = null
    ) {}
}
=== Attributes/Inject.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_PROPERTY)]
final class Inject {}
=== Attributes/Lazy.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_PROPERTY)]
final readonly class Lazy {}
=== Attributes/Scope.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Scope
{
    public function __construct(public string $name) {}
}
=== Attributes/ServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS)]
final class ServiceProvider {}
=== Attributes/Singleton.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS)]
final class Singleton {}
=== Attributes/Tag.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Attributes;

use Attribute;

#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final readonly class Tag
{
    public function __construct(public string $name) {}
}
=== Containers/Application.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Gemini\Logging\ErrorHandler;
use Throwable;

/**
 * Class Application
 *
 * Final class ensures that the Application cannot be inherited from,
 * promoting design integrity and stability.
 * This class orchestrates the application lifecycle, managing bootstrapping,
 * request handling, and error management.
 */
final readonly class Application
{
    /**
     * Run the application lifecycle.
     *
     * Bootstrap the container and register services.
     * Handle incoming requests. Any uncaught exceptions are passed to the error handler.
     * Using a Container instance to manage dependencies and configurations.
     *
     */
    public function run() : void
    {
        try {
            /* @var Kernel $kernel */
            $kernel = app()->get(id: Kernel::class);
            $kernel->handleHttpRequest(); // Initiates the main request-response lifecycle via the Kernel
        } catch (Throwable $throwable) {
            // Delegates error handling to the ErrorHandler
            // The app function should be an IoC container lookup to get the ErrorHandler instance
            app()->get(id: ErrorHandler::class)->handle($throwable);
        }
    }
}
=== Containers/Bootstrapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Exception;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\Facade\Facades\Storage;
use Spatie\Ignition\Ignition;

/**
 * The Bootstrapper class initializes the application's core settings and dependencies.
 * This includes loading environment variables, helper functions, routes, and setting up error handling.
 * It is the entry point for configuring the application during the bootstrap process.
 */
readonly class Bootstrapper
{
    /**
     * File permissions required for the view cache directory.
     */
    private const int REQUIRED_PERMISSIONS = 0755;

    /**
     * @param string $envFilePath     Path to the environment variables file.
     * @param string $helpersFilePath Path to the helper functions file.
     */
    public function __construct(
        private string $envFilePath,
        private string $helpersFilePath,
    ) {}

    /**
     * Initializes the core components of the application.
     *
     * This method performs all essential boot-time logic required for the framework to operate:
     *
     * - Applies hardened session cookie configuration for secure session lifecycle.
     * - Loads environment variables from the configured `.env.php` bootstrap file.
     * - Loads global helper functions required across application layers.
     * - Registers the core Dependency Injection container instance globally.
     * - Initializes Spatie Ignition for enhanced exception reporting and IDE integration.
     * - Ensures the view cache directory exists with proper permissions, and clears any residual cache.
     *
     * This method MUST be called before handling any HTTP requests, session startup, or rendering views.
     * It guarantees that the runtime environment, security context, and application state are properly initialized.
     *
     * @param ContainerInterface $container The dependency injection container instance.
     *
     * @throws Exception If any of the following fail:
     *                   - Environment or helper boot file is missing
     *                   - View cache directory cannot be created or cleared
     *                   - File system permission errors
     */
    public function bootstrap(ContainerInterface $container) : void
    {
        $this->initializeSessionSecurity();
        $this->loadConfiguration(container: $container);
        $this->initializeErrorHandling();
        $this->initializeViewCacheDirectory();
    }

    /**
     * Configures secure PHP session cookie parameters.
     *
     * Applies hardened security settings for session cookies,
     * including secure transport, HTTP-only access, and SameSite enforcement.
     * This method MUST be called before session_start().
     */
    private function initializeSessionSecurity() : void
    {
        session_set_cookie_params(
            [
                'secure'   => true,
                'httponly' => true,
                'samesite' => 'Strict',
            ]
        );
    }

    /**
     * Loads the configuration settings for the application.
     *
     * This includes environment variables and helper functions necessary for the application's operation.
     *
     * @throws \Exception
     */
    private function loadConfiguration(ContainerInterface $container) : void
    {
        $this->loadEnvironmentVariables();
        $this->loadHelperFunctions();
        appInstance(instance: $container);
    }

    /**
     * Loads environment variables from the specified file.
     */
    private function loadEnvironmentVariables() : void
    {
        require_once $this->envFilePath;
    }

    /**
     * Loads helper functions from the specified file.
     *
     * @throws \Exception
     */
    private function loadHelperFunctions() : void
    {
        if (! file_exists($this->helpersFilePath)) {
            throw new Exception(message: 'Helpers file not found: ' . $this->helpersFilePath);
        }

        require_once $this->helpersFilePath;
    }

    /**
     * Initializes error handling using the Spatie Ignition library.
     */
    private function initializeErrorHandling() : void
    {
        Ignition::make()
            ->shouldDisplayException(
                shouldDisplayException: env(key: 'APP_DEBUG') === 'true' || config(key: 'app.debug', default: false)
            ) // Display only in debug mode
            ->setTheme(theme: 'dark')
            ->register();
    }

    /**
     * Initializes the view cache directory.
     *
     * Ensures the view cache directory exists, has the correct permissions, and clears any existing cached files.
     * If the directory does not exist, it creates it with the necessary permissions.
     *
     * @throws Exception If the directory cannot be created, permissions cannot be set, or it cannot be cleared.
     */
    private function initializeViewCacheDirectory() : void
    {
        $viewCachePath = AppPath::getRoot() . 'storage/views';

        if (Storage::exists(path: $viewCachePath)) {
            $this->ensureDirectoryPermissions(path: $viewCachePath);
            $this->clearCacheDirectory(path: $viewCachePath);
        } else {
            $this->createViewCacheDirectory(path: $viewCachePath);
        }
    }

    /**
     * Ensures the specified directory has the required permissions.
     *
     * @param string $path The path to the directory.
     *
     * @throws Exception If permissions cannot be set.
     */
    private function ensureDirectoryPermissions(string $path) : void
    {
        if (! Storage::hasPermission(path: $path, permissions: self::REQUIRED_PERMISSIONS)
            && ! Storage::setPermissions(path: $path, permissions: self::REQUIRED_PERMISSIONS)) {
            throw new Exception(
                message: "Failed to set permissions for directory at " . $path . ". Check file system permissions."
            );
        }
    }

    /**
     * Clears the specified cache directory.
     *
     * @param string $path The path to the cache directory.
     *
     * @throws Exception If the directory cannot be cleared.
     */
    private function clearCacheDirectory(string $path) : void
    {
        if (! Storage::clear(directory: $path)) {
            throw new Exception(message: "Failed to clear cache in the view cache directory at " . $path . ".");
        }
    }

    /**
     * Creates the specified view cache directory with the necessary permissions.
     *
     * @param string $path The path to the view cache directory.
     *
     * @throws Exception If the directory cannot be created or permissions set.
     */
    private function createViewCacheDirectory(string $path) : void
    {
        if (! Storage::createDirectory(directory: $path)
            || ! Storage::setPermissions(path: $path, permissions: self::REQUIRED_PERMISSIONS)) {
            throw new Exception(message: "Failed to create directory at " . $path . " with the necessary permissions.");
        }
    }

}

=== Containers/DependencyInjector.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Closure;
use Gemini\Cache\InMemoryCache;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Containers\Proxy\LazyProxy;
use Gemini\Container\Containers\Registry\Bindings;
use Gemini\Container\Containers\Registry\Deferred;
use Gemini\Container\Containers\Registry\Instances;
use Gemini\Container\Containers\Registry\LifecycleHooks;
use Gemini\Container\Containers\Registry\ScopedInstances;
use Gemini\Container\Contracts\ContainerInterface;
use Gemini\Container\Exceptions\AutoResolveException;
use Gemini\Container\Exceptions\CircularDependencyException;
use Gemini\Container\Exceptions\ServiceNotFoundException;
use Gemini\Container\Exceptions\UnresolvableDependencyException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use InvalidArgumentException;
use League\Container\Exception\ContainerException;
use ReflectionClass;
use ReflectionException;
use ReflectionNamedType;
use ReflectionParameter;
use RuntimeException;
use Throwable;

/**
 * DependencyInjector
 *
 * A production-ready PSR-11 compatible service container.
 * Responsibilities:
 * - Dependency injection
 * - Singleton and scoped services
 * - Lifecycle hooks (INIT, SHUTDOWN, ERROR)
 * - In-memory caching
 *
 * This class adheres to SOLID principles and Clean Architecture guidelines.
 */
final class DependencyInjector implements ContainerInterface
{
    /**
     * Tracks the currently active scope context.
     * Used to isolate scoped service resolution per logical group (e.g. request, tenant).
     */
    private string $activeScope = 'default';

    /**
     * Indicates whether autowiring fallback is allowed.
     * When strict mode is enabled, only explicitly registered services can be resolved.
     */
    private bool $strictMode = false;


    private readonly Arrhae $contextualBindings;

    /**
     * Stores all registered bindings within the container.
     * This includes mappings of abstract types to concrete implementations.
     */
    private readonly Bindings $bindings;

    /**
     * Holds instances of singleton services that have been resolved.
     * Ensures only one instance of these services exists in the container.
     */
    private readonly Instances $instances;

    /**
     * Manages instances scoped to specific lifetimes or contexts.
     * Allows fine-grained control over the lifecycle of certain services.
     */
    private readonly ScopedInstances $scopedInstances;

    /**
     * Stores deferred bindings that will be resolved lazily.
     * Useful for optimizing performance by delaying the instantiation of services.
     */
    private readonly Deferred $deferred;

    /**
     * Tracks lifecycle hooks such as INIT, SHUTDOWN, and ERROR.
     * Enables executing custom logic during specific phases of the container's lifecycle.
     */
    private readonly LifecycleHooks $lifecycleHooks;

    /**
     * In-memory caching mechanism for storing resolved services or data.
     * Provides fast access to frequently used instances or configurations.
     */
    private readonly InMemoryCache $inMemoryCache;

    /**
     * Tracks the resolution stack during dependency resolution.
     * Used to detect and handle circular dependencies.
     */
    private array           $resolutionStack = [];

    private readonly Arrhae $scopedInstancesByScope;

    private readonly Arrhae $tagBindings;

    private readonly Arrhae $lazyBindings;

    /**
     * Constructor for the dependency injection container.
     *
     * @param int $cacheTTL Time-to-live (TTL) for the in-memory cache, in seconds.
     */
    public function __construct(private readonly int $cacheTTL = 3600)
    {
        $this->bindings               = new Bindings();
        $this->instances              = new Instances();
        $this->scopedInstances        = new ScopedInstances();
        $this->deferred               = new Deferred();
        $this->lifecycleHooks         = new LifecycleHooks();
        $this->inMemoryCache          = new InMemoryCache();
        $this->scopedInstancesByScope = new Arrhae();
        $this->contextualBindings     = new Arrhae();
        $this->tagBindings            = new Arrhae();
        $this->lazyBindings           = new Arrhae();
    }

    /**
     * Enables strict mode: disables fallback to autoResolve() for unknown services.
     *
     * This should be enabled in production for maximum control and security.
     */
    public function enableStrictMode() : void
    {
        $this->strictMode = true;
    }

    /**
     * Disables strict mode: allows fallback to reflection-based autowiring.
     */
    public function disableStrictMode() : void
    {
        $this->strictMode = false;
    }

    /**
     * Returns whether strict mode is currently active.
     *
     */
    public function isStrictMode() : bool
    {
        return $this->strictMode;
    }

    /**
     * Registers service providers specified in the configuration file.
     */
    public function registerProviders() : void
    {
        // Path to the configuration file containing the list of service providers.
        $providers = include AppPath::CONFIG->get() . '/services.php';

        foreach ($providers as $providerClass) {
            $provider = new $providerClass($this); // Pass DependencyInjector to the provider.
            $provider->register(); // Call register() to bind services.
            $provider->boot(); // Call boot() for additional setup.
        }
    }

    /**
     * Resolves a service from the container.
     */
    public function get(string $id) : mixed
    {
        if ($this->has(id: $id)) {
            return $this->resolve(abstract: $id);
        }

        // ✅ Strict mode blocks fallback resolution
        if ($this->strictMode) {
            $this->triggerHook(
                lifecycleHook: LifecycleHook::ERROR,
                args         : [new ServiceNotFoundException(serviceId: $id), $this]
            );
            throw new ServiceNotFoundException(serviceId: $id);
        }

        // ✅ Fallback to autowiring in dev/test
        if (class_exists($id)) {
            return $this->autoResolve(class: $id);
        }

        $this->triggerHook(
            lifecycleHook: LifecycleHook::ERROR,
            args         : [new ServiceNotFoundException(serviceId: $id), $this]
        );

        throw new ServiceNotFoundException(serviceId: $id);
    }

    /**
     * Checks if the container has a service registered.
     */
    public function has(string $id) : bool
    {
        if ($this->bindings->has(key: $id) || $this->instances->has(key: $id)) {
            return true;
        }

        return $this->deferred->has(key: $id);
    }

    /**
     * Resolves a service binding or auto-resolves a class.
     */
    private function resolve(string $abstract) : mixed
    {
        if (in_array($abstract, $this->resolutionStack, true)) {
            $circularDependencyException = new CircularDependencyException(
                serviceId      : $abstract,
                resolutionStack: $this->resolutionStack
            );

            $this->triggerHook(lifecycleHook: LifecycleHook::ERROR, args: [$circularDependencyException, $this]);
            throw $circularDependencyException;
        }

        $this->resolutionStack[] = $abstract;

        try {
            // ✅ Check for scoped instances first
            if ($this->scopedInstances->has(key: $abstract)) {
                $scoped = $this->scopedInstances->get(key: $abstract);

                if (! isset($scoped['instance'])) {
                    $instance           = $this->instantiate(concrete: $scoped['concrete']);
                    $scoped['instance'] = $instance;
                    $this->scopedInstances->set(key: $abstract, value: $scoped);
                }

                return $scoped['instance'];
            }

            // ✅ Check singleton cache
            if ($this->instances->has(key: $abstract)) {
                return $this->instances->get(key: $abstract);
            }

            // ✅ Check in-memory cache
            if ($cached = $this->inMemoryCache->get(key: $abstract)) {
                return $cached;
            }

            // ✅ Fallback to binding or autowiring
            $instance = $this->resolveBindingOrAutoResolve(abstract: $abstract);

            // ✅ Save singleton and cache if needed
            if ($this->bindings->get(key: $abstract)['singleton'] ?? false) {
                $this->instances->set(key: $abstract, value: $instance);
                $this->inMemoryCache->set(key: $abstract, value: $instance, ttl: $this->cacheTTL);
            }

            return $instance;
        } finally {
            array_pop($this->resolutionStack);
        }
    }

    /**
     * Triggers a lifecycle hook.
     */
    private function triggerHook(LifecycleHook $lifecycleHook, array $args = []) : void
    {
        $this->lifecycleHooks->trigger($lifecycleHook, $args);
    }

    /**
     * Instantiates a service using its concrete definition.
     */
    private function instantiate(Closure|string $concrete) : mixed
    {
        return $concrete instanceof Closure ? $concrete($this) : $this->autoResolve(class: $concrete);
    }

    /**
     * Automatically resolves a class using reflection.
     */
    private function autoResolve(string $class) : object
    {
        try {
            $reflectionClass = new ReflectionClass(objectOrClass: $class);

            if (! $reflectionClass->isInstantiable()) {
                throw new AutoResolveException(className: $class);
            }

            $constructor = $reflectionClass->getConstructor();

            if ($constructor === null) {
                return new $class();
            }

            $dependencies = array_map(
                fn(ReflectionParameter $reflectionParameter) : mixed => $this->resolveDependency(
                    reflectionParameter: $reflectionParameter
                ),
                $constructor->getParameters()
            );

            return $reflectionClass->newInstanceArgs(args: $dependencies);
        } catch (ReflectionException $reflectionException) {
            throw new AutoResolveException(className: $class, previous: $reflectionException);
        }
    }

    /**
     * Resolves a constructor dependency parameter.
     */
    private function resolveDependency(ReflectionParameter $reflectionParameter) : mixed
    {
        $type = $reflectionParameter->getType();

        // ✅ Must be a class type
        if ($type instanceof ReflectionNamedType && ! $type->isBuiltin()) {
            $dependency     = $type->getName();
            $declaringClass = $reflectionParameter->getDeclaringClass()?->getName();

            // ✅ Check for contextual binding override
            if (
                $declaringClass !== null &&
                isset($this->contextualBindings[$declaringClass][$dependency])
            ) {
                $contextual = $this->contextualBindings[$declaringClass][$dependency];

                return $this->instantiate(concrete: $contextual);
            }

            // ✅ Default resolve via container
            return $this->resolve(abstract: $dependency);
        }

        // ✅ Fallback to default value if available
        if ($reflectionParameter->isDefaultValueAvailable()) {
            return $reflectionParameter->getDefaultValue();
        }

        throw new UnresolvableDependencyException(reflectionParameter: $reflectionParameter);
    }

    /**
     * Resolves a service binding or auto-resolves a class.
     */
    private function resolveBindingOrAutoResolve(string $abstract) : mixed
    {
        if ($this->bindings->has(key: $abstract)) {
            return $this->instantiate(concrete: $this->bindings->get(key: $abstract)['concrete']);
        }

        return $this->autoResolve(class: $abstract);
    }

    /**
     * Registers any application services.
     */
    public function register() : void
    {
        $this->registerProviders();
    }

    /**
     * Boots the container after services are registered.
     */
    public function boot() : void
    {
        $this->triggerHook(lifecycleHook: LifecycleHook::INIT);
    }

    /**
     * Validates all registered bindings by resolving them.
     *
     * Useful in production to detect misconfigured services before runtime.
     *
     */
    public function validateBindings() : void
    {
        $errors = [];

        foreach ($this->allBindings() as $abstract => $_) {
            try {
                $this->get($abstract);
            } catch (Throwable $e) {
                $errors[] = "[{$abstract}] => " . $e::class . ': ' . $e->getMessage();
            }
        }

        if ($errors !== []) {
            throw new AutoResolveException(
                className: 'Container',
                previous : new RuntimeException(implode("\n", $errors))
            );
        }
    }

    /**
     * Retrieve all bindings registered in the container.
     *
     * @return array An associative array of all bindings.
     */
    public function allBindings() : array
    {
        return $this->bindings->all();
    }

    /**
     * Registers a singleton service in the container.
     */
    public function singleton(string $abstract, Closure|string $concrete) : void
    {
        $this->bind(abstract: $abstract, concrete: $concrete, singleton: true);
    }

    /**
     * Registers a service binding in the container.
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function bind(string $abstract, Closure|string|callable $concrete, bool $singleton = false) : void
    {
        if (! is_callable($concrete) && ! class_exists($concrete)) {
            throw new InvalidArgumentException(
                message: "Concrete for " . $abstract . " must be callable or a valid class."
            );
        }

        $this->bindings->set(key: $abstract, value: ['concrete' => $concrete, 'singleton' => $singleton]);
        $this->invalidateCache(id: $abstract);
        $this->rebuildDependencyGraph();
    }

    /**
     * Invalidates a specific service's cache.
     *
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    private function invalidateCache(string $id) : void
    {
        $this->inMemoryCache->delete(key: $id);
    }

    /**
     * Rebuilds the dependency graph.
     */
    private function rebuildDependencyGraph() : void {}

    /**
     * Shuts down the application lifecycle and triggers the SHUTDOWN hook.
     */
    public function shutdown() : void
    {
        $this->triggerHook(lifecycleHook: LifecycleHook::SHUTDOWN, args: [$this]);
    }

    /**
     * Combines and returns all bindings, instances, and scoped instances.
     *
     * @return array The combined array of all bindings, instances, and scoped instances.
     */
    public function everything() : array
    {
        return array_merge($this->allBindings(), $this->allInstances(), $this->allScopedInstances());
    }

    /**
     * Retrieve all resolved singleton instances.
     *
     * @return array An associative array of all resolved singleton instances.
     */
    public function allInstances() : array
    {
        return $this->instances->all();
    }

    /**
     * Retrieve all scoped instances.
     *
     * @return array An associative array of all scoped instances.
     */
    public function allScopedInstances() : array
    {
        return $this->scopedInstances->all();
    }

    /**
     * Registers a scoped binding in the container.
     *
     * This method establishes a scoped service registration within the Dependency Injection Container.
     * Scoped services are instantiated once per scope and reused within that scope boundary.
     *
     * @param string          $abstract The abstract type/interface to be bound
     * @param \Closure|string $concrete The concrete implementation or factory closure
     * @param string|null     $scope    The scope identifier (defaults to current active scope)
     *
     * @throws \RuntimeException When scope operations fail
     *
     * @throws \InvalidArgumentException When abstract or concrete are invalid
     */
    public function scoped(
        string         $abstract,
        Closure|string $concrete,
        string|null    $scope = null
    ) : void {
        // Determine the effective scope, fallback to active scope if none provided
        $scope = $scope ?? $this->activeScope;

        // Register the concrete implementation in the scoped instances collection
        // Using dot notation to create a unique scope-specific binding key
        $this->scopedInstancesByScope->set(
            key  : "$scope.$abstract",
            value: ['concrete' => $concrete]
        );
    }

    /**
     * Flushes all scoped instance bindings from the container.
     *
     * This method is crucial for maintaining a clean dependency injection container state
     * by removing all scoped instance registrations. It's particularly useful during:
     * - Testing scenarios where a fresh container state is needed
     * - Request lifecycle completion
     * - Manual container state management
     *
     * @throws ContainerException When clearing operation fails due to internal state corruption
     */
    public function flushScope(string|null $scope = null) : void
    {
        if ($scope === null) {
            $this->scopedInstancesByScope->clear();
        } else {
            $keysToForget = array_filter(
                $this->scopedInstancesByScope->keys(),
                static fn(string $key) => str_starts_with($key, "{$scope}.")
            );

            foreach ($keysToForget as $key) {
                $this->scopedInstancesByScope->forget($key);
            }
        }
    }


    public function beginScope(string $scope) : void
    {
        $this->activeScope = $scope;

        if (! $this->scopedInstancesByScope->has($scope)) {
            $this->scopedInstancesByScope->set($scope, []);
        }
    }

    /**
     * Begins contextual binding declaration using a fluent builder pattern.
     *
     * @param string $consumer The fully qualified class name of the consumer (e.g., Controller)
     *
     * @return object Anonymous context binder builder
     */
    public function when(string $consumer) : object
    {
        /**
         * Creates an anonymous readonly configuration class for contextual dependency binding.
         * Implements the Fluent Interface pattern for intuitive dependency configuration.
         *
         * @param DependencyInjector $di       The dependency injector instance
         * @param string             $consumer The consuming class identifier
         *
         * @return object                      Anonymous readonly configuration class
         */
        return new readonly class($this, $consumer) {
            /**
             * Initializes a new configuration context with dependency injection capabilities.
             * Uses constructor promotion for clean and maintainable property declaration.
             *
             * @param DependencyInjector $di       Core dependency injection service
             * @param string             $consumer Fully qualified name of the consuming class
             */
            public function __construct(
                private DependencyInjector $di,
                private string             $consumer
            ) {}

            /**
             * Initiates the dependency configuration chain for a specific dependency.
             * Creates a fluent interface for defining contextual bindings.
             *
             * @param string $dependency Fully qualified name of the required dependency
             *
             * @return object           Anonymous readonly configuration class for binding definition
             */
            public function needs(string $dependency) : object
            {
                /**
                 * Anonymous readonly class providing the final step in dependency configuration.
                 * Implements the Builder pattern for constructing contextual bindings.
                 */
                return new readonly class(
                    $this->di,
                    $this->consumer,
                    $dependency
                ) {
                    /**
                     * Initializes the binding configuration context.
                     * Uses constructor promotion for maintaining clean code principles.
                     *
                     * @param DependencyInjector $di         Core dependency injection service
                     * @param string             $consumer   Fully qualified name of the consuming class
                     * @param string             $dependency Fully qualified name of the dependency being bound
                     */
                    public function __construct(
                        private DependencyInjector $di,
                        private string             $consumer,
                        private string             $dependency
                    ) {}

                    /**
                     * Finalizes the contextual binding configuration.
                     * Registers the implementation for the specified dependency in the given context.
                     *
                     * @param Closure|string $implementation Concrete implementation or factory for the dependency
                     */
                    public function give(Closure|string $implementation) : void
                    {
                        $this->di->addContextualBinding(
                            consumer      : $this->consumer,
                            dependency    : $this->dependency,
                            implementation: $implementation
                        );
                    }
                };
            }
        };
    }

    /**
     * Adds a contextual binding to the container for dependency injection.
     *
     * Establishes a relationship between a consumer class and its dependencies,
     * allowing for specific implementation bindings in different contexts.
     * This enables flexible dependency resolution based on the consumer's context.
     *
     * @param string         $consumer       The fully qualified class name of the consuming service
     * @param string         $dependency     The abstract type or interface being bound
     * @param Closure|string $implementation The concrete implementation or factory closure
     *
     * @throws InvalidArgumentException When invalid binding parameters are provided
     */
    public function addContextualBinding(
        string         $consumer,
        string         $dependency,
        Closure|string $implementation
    ) : void {
        // Constructs a unique binding key using dot notation and registers the implementation
        $this->contextualBindings->set(
            key  : "{$consumer}.{$dependency}",
            value: $implementation
        );
    }

    /**
     * Registers a lazy-loading binding in the container.
     *
     * This method enables dependency injection with deferred resolution through a closure.
     * The binding will only be resolved when the abstract type is actually requested,
     * providing better performance through lazy initialization.
     *
     * @param string  $abstract The abstract type or interface to be resolved
     * @param Closure $resolver The closure that defines how to resolve the binding
     *
     * @throws InvalidArgumentException When the abstract parameter is invalid
     */
    public function lazy(
        string  $abstract,
        Closure $resolver
    ) : void {
        // Register the lazy binding resolver in the container's lazy bindings collection
        $this->lazyBindings->set($abstract, static fn() => new LazyProxy($resolver));
    }

    /**
     * Associates multiple services with a specific tag identifier
     *
     * This method establishes a many-to-one relationship between services and a tag,
     * enabling service discovery through tag-based lookup.
     *
     * @param string $tag      The tag identifier to associate services with
     * @param array  $services Array of service identifiers to be tagged
     *
     * @throws InvalidArgumentException If the tag name is invalid
     */
    public function tag(string $tag, array $services) : void
    {
        $this->tagBindings->set(key: $tag, value: $services);
    }

    /**
     * Retrieves all services associated with a specific tag
     *
     * Returns an array of service identifiers that were previously tagged
     * with the specified tag. Returns an empty array if no services are found.
     *
     * @param string $tag The tag identifier to look up
     *
     * @return array<int, string> Array of service identifiers associated with the tag
     */
    public function tagged(string $tag) : array
    {
        return $this->tagBindings->get(key: $tag, default: []);
    }

    /**
     * Resolves a lazy-loaded binding from the container.
     *
     * This method is part of the Dependency Injection Container's lazy loading mechanism,
     * implementing the Service Locator pattern for improved performance through deferred
     * instantiation of dependencies.
     *
     * @param string $abstract The abstract identifier to resolve from lazy bindings
     *
     * @return mixed The resolved instance or null if no lazy binding exists
     *
     * @throws \InvalidArgumentException When the abstract identifier is invalid
     * @throws \RuntimeException When the lazy binding closure fails to execute
     */
    private function resolveLazy(string $abstract) : mixed
    {
        // Check if a lazy binding exists for the given abstract and execute its closure if found
        return $this->lazyBindings->has(key: $abstract)
            // Execute the lazy binding closure to instantiate the dependency
            ? ($this->lazyBindings->get(key: $abstract))()
            // Return null if no lazy binding exists for the given abstract
            : null;
    }

    /**
     * Resolves a scoped instance from the container based on the current active scope.
     *
     * This method implements the Scope Pattern to manage instance lifecycles within defined boundaries.
     * It ensures proper isolation of instances between different scopes while maintaining
     * singleton-like behavior within the same scope.
     *
     * @param string $abstract The abstract identifier to resolve from the container
     *
     * @return mixed The resolved instance or null if not found in current scope
     *
     * @throws AutoResolveException When unable to instantiate the concrete implementation
     */
    private function resolveScoped(string $abstract) : mixed
    {
        // Construct the unique scope key by combining active scope and abstract identifier
        $scopeKey = $this->activeScope . '.' . $abstract;

        // Early return if no entry exists for the given scope key
        if (! $this->scopedInstancesByScope->has(key: $scopeKey)) {
            return null;
        }

        // Retrieve the scoped entry containing concrete implementation and optional instance
        $entry = $this->scopedInstancesByScope->get(key: $scopeKey);

        // Lazy instantiation of the concrete implementation if the instance doesn't exist
        if (! isset($entry['instance'])) {
            // Create a new instance using the stored concrete implementation
            $entry['instance'] = $this->instantiate(concrete: $entry['concrete']);
            // Update the scope registry with the newly created instance
            $this->scopedInstancesByScope->set(key: $scopeKey, value: $entry);
        }

        // Return the resolved scoped instance
        return $entry['instance'];
    }
}

=== Containers/Kernel.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

use Gemini\Exceptions\ValidationException;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Router\RouterInterface;
use Gemini\Logging\ErrorHandler;
use Psr\Http\Message\ResponseInterface;
use Throwable;

/**
 * Class Kernel
 *
 * Handles the HTTP request lifecycle, from middleware resolution to request dispatching
 * and error handling.
 * Encapsulates all logic required to process a web request.
 */
final class Kernel
{
    /**
     * @var array<callable> $middlewares
     */
    private array $middlewares = [];

    public function __construct(
        private readonly RouterInterface $router,
        private readonly ErrorHandler    $errorHandler,
    ) {}

    /**
     * Executes the complete HTTP lifecycle: request creation, middleware, routing and response.
     *
     * @throws \JsonException
     */
    public function handleHttpRequest() : void
    {
        $request = Request::createFromGlobals();

        try {
            $this->registerMiddlewares();
            $response = $this->generateResponse(request: $request);
            $this->sendResponse(response: $response);
        } catch (Throwable $throwable) {
            $this->handleException(throwable: $throwable);
        }
    }

    /**
     * Registers global middleware defined in configuration.
     */
    private function registerMiddlewares() : void
    {
        $this->middlewares = $this->resolveConfiguredMiddlewares();
    }

    /**
     * Resolves middleware from configuration and dependency container.
     *
     * @return array<callable> Resolved middleware handlers
     */
    private function resolveConfiguredMiddlewares() : array
    {
        $middlewareClasses = config(key: 'middleware.global');

        return array_map(
            static fn(string $middlewareClass) => app()->get($middlewareClass),
            $middlewareClasses
        );
    }

    /**
     * Builds the middleware stack and dispatches the request to the router.
     *
     * @param Request $request
     *
     * @return ResponseInterface
     */
    private function generateResponse(Request $request) : ResponseInterface
    {
        $handler = fn(Request $request) : ResponseInterface => $this->router->resolve($request);
        foreach (array_reverse($this->middlewares) as $middleware) {
            $currentHandler = $handler;
            $handler        = static fn(Request $request) : ResponseInterface => $middleware->handle(
                $request,
                $currentHandler
            );
        }

        return $handler($request);
    }

    /**
     * Sends a fully formed PSR-7 response to the client.
     *
     * @param ResponseInterface $response
     */
    private function sendResponse(ResponseInterface $response) : void
    {
        if (! headers_sent()) {
            http_response_code($response->getStatusCode());

            foreach ($response->getHeaders() as $name => $values) {
                foreach ($values as $value) {
                    header(header: "{$name}: {$value}", replace: false);
                }
            }
        } else {
            error_log(message: '⚠️ Headers already sent, unable to modify HTTP response headers.');
        }

        echo (string) $response->getBody();
    }

    /**
     * Handles any uncaught exceptions and renders a proper error response.
     *
     * @param Throwable $throwable
     *
     * @throws \JsonException
     */
    private function handleException(Throwable $throwable) : void
    {
        if ($throwable instanceof ValidationException) {
            $response = $this->errorHandler->render(throwable: $throwable);
            $this->sendResponse(response: $response->toResponse());

            return;
        }

        $this->errorHandler->handle(throwable: $throwable);
    }

    /**
     * Allows runtime appending of additional middleware.
     *
     * @param array<callable> $middlewares
     */
    public function addMiddlewares(array $middlewares) : void
    {
        $this->middlewares = array_merge($this->middlewares, $middlewares);
    }
}

=== Containers/LifecycleHook.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers;

enum LifecycleHook: string
{
    /**
     * Called when the container is initialized.
     */
    case INIT = 'init';

    /**
     * Called when the container is shutting down.
     */
    case SHUTDOWN = 'shutdown';

    /**
     * Called when an error occurs within the container.
     */
    case ERROR = 'error';

    /**
     * Get all available lifecycle hook types.
     *
     * @return array<string> List of lifecycle hook values.
     */
    public static function all() : array
    {
        return array_map(static fn(self $hook) : string => $hook->value, self::cases());
    }

    /**
     * Check if a given value is a valid lifecycle hook.
     *
     * @param string $value The value to check.
     *
     * @return bool True if the value is a valid lifecycle hook, false otherwise.
     */
    public static function isValid(string $value) : bool
    {
        return in_array($value, self::all(), true);
    }
}

=== Containers/Proxy/LazyProxy.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Proxy;

use Closure;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * Implements a lazy loading proxy pattern for deferred object initialization.
 * This proxy delays the creation of expensive objects until they are actually needed,
 * optimizing resource utilization and improving application performance.
 *
 * @template T of object
 * @final
 */
final readonly class LazyProxy
{
    /**
     * Metadata container for storing the proxied instance and related information.
     * Using Arrhae for type-safe key-value storage operations.
     */
    private Arrhae $meta;

    /**
     * Initializes a new lazy proxy instance with a resolver closure.
     * Implements constructor promotion for cleaner dependency injection.
     *
     * @param Closure(): T $resolver Factory closure that creates the actual instance when needed
     */
    public function __construct(private Closure $resolver)
    {
        $this->meta = new Arrhae();
    }

    /**
     * Dynamically forwards method calls to the proxied instance.
     * Ensures instance initialization before method invocation.
     *
     * @param string            $method The method name being called
     * @param array<int, mixed> $args   Arguments passed to the method
     *
     * @return mixed The result of the method call on the proxied instance
     */
    public function __call(string $method, array $args) : mixed
    {
        $this->init();

        return $this->meta->get(key: 'instance')->$method(...$args);
    }

    /**
     * Initializes the proxied instance if it hasn't been created yet.
     * Uses a lazy initialization pattern to defer object creation.
     */
    private function init() : void
    {
        if (! $this->meta->has(key: 'instance')) {
            $this->meta->set(key: 'instance', value: ($this->resolver)());
        }
    }

    /**
     * Dynamically forwards property access to the proxied instance.
     * Ensures instance initialization before property access.
     *
     * @param string $prop The property name being accessed
     *
     * @return mixed The value of the property from the proxied instance
     */
    public function __get(string $prop) : mixed
    {
        $this->init();

        return $this->meta->get(key: 'instance')->$prop;
    }

    /**
     * Resets the proxy by removing the cached instance.
     * Allows for re-initialization of the proxied object if needed.
     */
    public function reset() : void
    {
        $this->meta->forget(key: 'instance');
    }

    /**
     * Checks if the proxied instance has been initialized.
     *
     * @return bool True if the instance exists, false otherwise
     */
    public function hasInstance() : bool
    {
        return $this->meta->has(key: 'instance');
    }

    /**
     * Retrieves the proxied instance directly.
     * Note: This method doesn't ensure initialization.
     *
     * @return T|null The proxied instance if initialized, null otherwise
     */
    public function getInstance() : mixed
    {
        return $this->meta->get(key: 'instance');
    }
}
=== Containers/Registry/Bindings.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Bindings extends Arrhae {}
=== Containers/Registry/ChildContainers.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class ChildContainers extends Arrhae {}
=== Containers/Registry/DeferredContainerRegistry.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Deferred extends Arrhae {}
=== Containers/Registry/Deferred.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Deferred extends Arrhae {}
=== Containers/Registry/DependencyGraph.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class DependencyGraph extends Arrhae {}
=== Containers/Registry/Instances.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

class Instances extends Arrhae {}
=== Containers/Registry/LifecycleHooks.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\Container\Containers\LifecycleHook;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * LifecycleHooks
 *
 * A specialized registry for managing lifecycle hooks, leveraging Arrhae for array-like behavior.
 *
 * This class inherits from Arrhae to use its array-like operations and provides functionality
 * to register, trigger, and clear lifecycle hooks. Each lifecycle hook corresponds to a set
 * of callbacks that are executed when the hook is triggered.
 */
class LifecycleHooks extends Arrhae
{
    /**
     * Initialize the registry with keys for each lifecycle hook.
     *
     * The constructor ensures that every possible lifecycle hook is
     * initialized with an empty array to avoid key existence checks later.
     */
    public function __construct()
    {
        parent::__construct();
        // Ensure every LifecycleHook is initialized with an empty array
        foreach (LifecycleHook::cases() as $hook) {
            $this[$hook->value] = [];
        }
    }

    /**
     * Register a callback for a specific lifecycle hook.
     *
     * The registered callback will be executed when the corresponding
     * lifecycle hook is triggered.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to register the callback for.
     * @param callable      $callback The callback function to be executed.
     */
    public function register(LifecycleHook $lifecycleHook, callable $callback) : void
    {
        $this[$lifecycleHook->value][] = $callback;
    }

    /**
     * Trigger a lifecycle hook.
     *
     * Executes all registered callbacks for the specified hook. This method
     * passes any provided arguments to the callback functions.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to trigger.
     * @param mixed         ...$args Arguments passed to the callbacks.
     */
    public function trigger(LifecycleHook $lifecycleHook, mixed ...$args) : void
    {
        $callbacks = $this[$lifecycleHook->value] ?? [];
        foreach ($callbacks as $callback) {
            $callback(...$args);
        }
    }

    /**
     * Clear all callbacks for a specific lifecycle hook.
     *
     * This method removes all registered callbacks for the given lifecycle hook,
     * effectively resetting it.
     *
     * @param LifecycleHook $lifecycleHook The lifecycle hook to clear callbacks for.
     */
    public function clear(LifecycleHook $lifecycleHook) : void
    {
        $this[$lifecycleHook->value] = [];
    }
}
=== Containers/Registry/ScopedInstances.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Containers\Registry;

use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * Manages scoped instance registry within the dependency injection container.
 *
 * This registry maintains a collection of instances that are bound to a specific
 * container scope. It provides functionality to manage the lifecycle of these
 * instances, ensuring proper scope isolation and memory management.
 *
 * @template TKey of string
 * @template TValue of object
 * @extends Arrhae<TKey, TValue>
 *
 * @immutable
 * @final
 */
class ScopedInstances extends Arrhae
{
    /**
     * Clears all registered instances from the current scope.
     *
     * This operation ensures proper cleanup of scoped instances by iterating
     * through all registered entries and removing them individually. This
     * method is crucial for preventing memory leaks when a scope is terminated.
     *
     * @throws \RuntimeException If unable to clear instances due to internal state corruption
     *
     */
    public function clear() : void
    {
        // Iterate through all registered instances in the current scope
        foreach ($this->all() as $key => $value) {
            // Remove each instance individually to ensure proper cleanup
            $this->forget($key);
        }
    }
}
=== Contracts/ContainerInterface.php ===
<?php
declare(strict_types=1);

namespace Gemini\Container\Contracts;

/**
 * Interface defining the contract for a dependency injection container.
 *
 * Extends the PSR-11 ContainerInterface to provide additional methods for
 * registering, bootstrapping, and binding services. This interface is
 * essential for the application's dependency management and lifecycle.
 */
interface ContainerInterface extends \Psr\Container\ContainerInterface
{
    /**
     * Register any application services.
     *
     * This method is called once during the application's bootstrapping process.
     * Use this method to bind any essential services or classes to the container.
     */
    public function register() : void;

    /**
     * Bootstrap any application services.
     *
     * Called after service providers are registered. It is meant for initializing
     * middleware, event listeners, and deferred services before handling requests.
     */
    public function boot() : void;

    /**
     * Bind a service to the container.
     *
     * This method binds a concrete implementation or a closure to an abstract class
     * or interface. This allows the container to resolve it when requested,
     * facilitating dependency injection.
     *
     * @param string $abstract         The abstract name or interface.
     * @param callable|string $concrete The concrete implementation or closure.
     */
    public function bind(string $abstract, callable|string $concrete) : void;

    /**
     * Retrieve a service from the container.
     *
     * This method will fetch the service associated with the given identifier.
     *
     * @param string $id The identifier of the service.
     * @return mixed The instance of the service, or throws an exception if the id is not known to the container.
     */
    public function get(string $id): mixed;

    /**
     * Check if the container has a service for the given identifier.
     *
     * Returns true if the container can return an entry for the given identifier,
     * false otherwise.
     *
     * @param string $id The identifier of the service.
     * @return bool Whether the service exists in the container.
     */
    public function has(string $id): bool;
}
=== Exceptions/AutoResolveException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use Throwable;

/**
 * Thrown when automatic resolution of a class or dependency fails.
 */
class AutoResolveException extends \RuntimeException
{
    public function __construct(string $className, Throwable|null $previous = null)
    {
        $detailedMessage = $this->generateDetailedMessage($className, $previous);

        parent::__construct(
            message: $detailedMessage,
            code: 0,
            previous: $previous
        );
    }

    /**
     * Generates a detailed error message with file, line, stack trace, and previous exception details.
     *
     * @param string $className The name of the class that failed to resolve.
     * @param Throwable|null $previous The previous exception, if any.
     * @return string The detailed error message.
     */
    private function generateDetailedMessage(string $className, Throwable|null $previous): string
    {
        $message = sprintf("Failed to automatically resolve the class '%s'. Check the class dependencies.", $className);

        if ($previous instanceof \Throwable) {
            $file = $previous->getFile();
            $line = $previous->getLine();
            $prevMessage = $previous->getMessage();
            $stackTrace = $previous->getTraceAsString();

            $message .= PHP_EOL
                        . "Previous exception details:" . PHP_EOL
                        . ('  File: ' . $file) . PHP_EOL
                        . ('  Line: ' . $line) . PHP_EOL
                        . sprintf("  Message: '%s'", $prevMessage) . PHP_EOL
                        . "  Stack trace:" . PHP_EOL
                        . $stackTrace;
        }

        return $message;
    }
}

=== Exceptions/CircularDependencyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use ReflectionClass;
use ReflectionException;
use RuntimeException;
use Throwable;

/**
 * Thrown when a circular dependency is detected during resolution.
 */
class CircularDependencyException extends RuntimeException
{
    public function __construct(
        string         $serviceId,
        array          $resolutionStack,
        int            $code = 0,
        Throwable|null $previous = null
    ) {
        $formattedStack  = implode(' -> ', $resolutionStack);
        $reflectionHints = self::generateDebugHints($resolutionStack);
        $suggestions     = self::suggestFix($serviceId);

        $message = <<<TEXT
            ❌ Circular dependency detected while resolving service: '$serviceId'
            🌀 Resolution stack:
              $formattedStack
            
            🔍 Debug hints:
            $reflectionHints
            
            💡 Suggestions:
            $suggestions
            TEXT;

        parent::__construct(message: $message, code: $code, previous: $previous);
    }

    /**
     * Generate reflection-based debug output.
     *
     * @param string[] $resolutionStack
     *
     * @return string
     */
    private static function generateDebugHints(array $resolutionStack) : string
    {
        $lines = [];

        foreach ($resolutionStack as $class) {
            try {
                $r    = new ReflectionClass($class);
                $file = $r->getFileName();
                $line = $r->getStartLine();

                $lines[] = "• {$class}  (defined in {$file}:{$line})";
            } catch (ReflectionException) {
                $lines[] = "• {$class}  (could not locate source)";
            }
        }

        return implode("\n", $lines);
    }

    /**
     * Suggest common ways to break circular dependency.
     */
    private static function suggestFix(string $serviceId) : string
    {
        return <<<SUGGEST
            - Use constructor injection only for stable leaf services.
            - Break cycle by:
                • Introducing a factory/service locator for one of the deps.
                • Using an interface or abstract class with deferred resolution.
                • Lazy loading with Closure or `fn() => app()->get(...)`.
            
            - Check if $serviceId is indirectly requiring itself.
            SUGGEST;
    }
}

=== Exceptions/ClassNotInstantiableException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

/**
 * Thrown when attempting to instantiate a class that is not instantiable.
 */
class ClassNotInstantiableException extends \RuntimeException
{
    public function __construct(string $className, int $code = 0, \Throwable|null $previous = null)
    {
        parent::__construct(
            message: sprintf("Class '%s' is not instantiable. Ensure it is not abstract or an interface.", $className),
            code: $code,
            previous: $previous
        );
    }
}
=== Exceptions/FrameworkContainerException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use Exception;

/**
 * This exception class represents errors specific to the framework's dependency injection container.
 * Extending from the base Exception class provides a standardized way to handle these errors.
 */
class FrameworkContainerException extends Exception
{
    /**
     * Default error message given when no specific message is provided.
     */
    private const string DEFAULT_MESSAGE = 'A container exception has occurred.';

    /**
     * Constructs the FrameworkContainerException.
     *
     * @param string         $message  Custom error message that describes the exception.
     * @param int            $code     Optional error code for the exception.
     * @param Exception|null $previous Optional previous exception for chaining exceptions.
     */
    public function __construct(string $message = self::DEFAULT_MESSAGE, int $code = 0, Exception|null $previous = null)
    {
        // Calling the parent constructor to ensure proper exception handling.
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== Exceptions/InvalidInjectionException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use ReflectionProperty;
use RuntimeException;

/**
 * Exception thrown when an invalid property injection is detected.
 *
 * This exception is designed to communicate issues related to injecting dependencies into
 * a class property. It provides additional context about the problematic property for
 * debugging and resolution purposes.
 *
 * @package Gemini\Container\Exception
 */
class InvalidInjectionException extends RuntimeException
{
    /**
     * The name of the property where injection failed.
     *
     * This property stores the exact name of the class property that caused the injection
     * error, aiding in debugging and resolution.
     *
     * @var string
     */
    private string $propertyName;

    /**
     * Constructs a new InvalidInjectionException instance.
     *
     * This constructor accepts a `ReflectionProperty` representing the property
     * where the injection failed and a custom error message.
     *
     * @param ReflectionProperty $property The reflection of the property where injection failed.
     * @param string             $message  A detailed descriptive error message explaining the cause.
     */
    public function __construct(ReflectionProperty $property, string $message)
    {
        // Assigns the problematic property's name to the private property for future reference.
        $this->propertyName = $property->getName();

        // Calls the parent RuntimeException constructor with a named argument for the error message.
        parent::__construct(message: $message);
    }

    /**
     * Retrieves the name of the property causing the injection error.
     *
     * This method provides clients with access to the name of the property that caused
     * the exception, allowing for targeted debugging or error reporting.
     *
     * @return string The name of the problematic property.
     */
    public function getPropertyName() : string
    {
        return $this->propertyName;
    }
}
=== Exceptions/ServiceNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

use RuntimeException;
use Throwable;

/**
 * Thrown when a requested service cannot be found in the container.
 */
class ServiceNotFoundException extends RuntimeException
{
    public function __construct(string $serviceId, int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct(
            message : sprintf("Action '%s' not found in the container.", $serviceId),
            code    : $code,
            previous: $previous
        );
    }
}
=== Exceptions/UnresolvableDependencyException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\Exceptions;

/**
 * Thrown when a dependency cannot be resolved due to missing type hints or invalid configuration.
 */
class UnresolvableDependencyException extends \RuntimeException
{
    public function __construct(\ReflectionParameter $reflectionParameter, int $code = 0, \Throwable|null $previous = null)
    {
        $message = sprintf(
            "Cannot resolve dependency '%s' in parameter '%s' of function/method '%s'.",
            $reflectionParameter->getType()?->getName() ?? 'unknown type',
            $reflectionParameter->getName(),
            $reflectionParameter->getDeclaringFunction()->getName() ?? 'unknown function'
        );

        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}
=== ServiceProviders/Contracts/ServiceProviderInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Contracts;

/**
 * ServiceProviderInterface
 *
 * Defines the basic contract for service providers, including
 * methods for registering and booting services in the application container.
 */
interface ServiceProviderInterface
{
    /**
     * Registers services into the container.
     *
     * This is where bindings and singleton instances should be added
     * to make them available for dependency injection.
     */
    public function register() : void;

    /**
     * Boots registered services.
     *
     * Called after all services have been registered. Used to perform any
     * additional setup or configuration for services.
     */
    public function boot() : void;
}

=== ServiceProviders/Providers/AuthenticationServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;


use Gemini\Auth\Application\Action\LoginAction;
use Gemini\Auth\Application\Action\LogoutAction;
use Gemini\Auth\Application\Action\RegisterUserAction;
use Gemini\Auth\Application\Service\AuthenticationService;
use Gemini\Auth\Application\UseCase\API\ApiLoginUseCase;
use Gemini\Auth\Application\UseCase\API\ApiLogoutUseCase;
use Gemini\Auth\Application\UseCase\API\ApiRegisterUseCase;
use Gemini\Auth\Application\UseCase\Web\LoginUseCase;
use Gemini\Auth\Application\UseCase\Web\RetrieveCurrentUserUseCase;
use Gemini\Auth\Application\UseCases\Web\LogoutUseCase;
use Gemini\Auth\Application\UseCases\Web\RegisterUseCase;
use Gemini\Auth\Contracts\AuthenticationServiceInterface;
use Gemini\Auth\Contracts\CredentialsInterface;
use Gemini\Auth\Contracts\Identity\IdentityInterface;
use Gemini\Auth\Contracts\Identity\UserSourceInterface;
use Gemini\Auth\Domain\ValueObject\Credentials;
use Gemini\Auth\Infrastructure\Identity\Session\SessionIdentity;
use Gemini\Auth\Infrastructure\Security\PasswordHasher;
use Gemini\Auth\Infrastructure\User\DB\User;
use Gemini\Auth\Interface\HTTP\Middleware\AuthenticationMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\PermissionMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\RoleMiddleware;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Gemini\HTTP\Security\CsrfTokenManager;

/**
 * Action provider for authentication services.
 *
 * This class handles the registration of dependencies related to the authentication
 * system within the service container. Each dependency is registered as a singleton,
 * meaning the same instance will be reused throughout the application lifecycle.
 */
class AuthenticationServiceProvider extends ServiceProvider
{

    /**
     * Register authentication-related services and their dependencies.
     *
     * This method binds various authentication-related classes and interfaces to the service container,
     * ensuring that they are instantiated properly and are available for dependency injection.
     *
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(abstract: PasswordHasher::class, concrete: PasswordHasher::class);
        $this->dependencyInjector->singleton(abstract: CredentialsInterface::class, concrete: Credentials::class);

        // Register the UserRegistrationService
        $this->dependencyInjector->singleton(
            abstract: RegisterUserAction::class,
            concrete: fn() => new RegisterUserAction(
                userProvider: $this->dependencyInjector->get(UserSourceInterface::class)
            )
        );

        // Register the RegisterUseCase
        $this->dependencyInjector->singleton(
            abstract: RegisterUseCase::class,
            concrete: fn() => new RegisterUseCase(
                registerService: $this->dependencyInjector->get(RegisterUserAction::class)
            )
        );


        $this->dependencyInjector->singleton(
            abstract: AuthenticationServiceInterface::class,
            concrete: fn() => new AuthenticationService(
                identity: $this->dependencyInjector->get(SessionIdentity::class)
            )
        );


        $this->dependencyInjector->singleton(abstract: IdentityInterface::class, concrete: fn(
        ) : SessionIdentity => new SessionIdentity(
            session     : $this->dependencyInjector->get(id: Session::class),
            userProvider: $this->dependencyInjector->get(id: User::class)
        ));
        $this->dependencyInjector->singleton(
            abstract: UserSourceInterface::class,
            concrete: fn() : User => new User(
                queryBuilder  : $this->dependencyInjector->get(id: QueryBuilder::class),
                passwordHasher: $this->dependencyInjector->get(PasswordHasher::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: AuthenticationMiddleware::class,
            concrete: AuthenticationMiddleware::class
        );
        $this->dependencyInjector->singleton(
            abstract: PermissionMiddleware::class,
            concrete: PermissionMiddleware::class
        );
        $this->dependencyInjector->singleton(abstract: RoleMiddleware::class, concrete: RoleMiddleware::class);
        $this->dependencyInjector->singleton(
            abstract: ApiLoginUseCase::class,
            concrete: ApiLoginUseCase::class
        );
        $this->dependencyInjector->singleton(abstract: ApiLogoutUseCase::class, concrete: ApiLogoutUseCase::class);
        $this->dependencyInjector->singleton(abstract: ApiRegisterUseCase::class, concrete: ApiRegisterUseCase::class);

        $this->dependencyInjector->singleton(
            abstract: LoginUseCase::class,
            concrete: fn() => new LoginUseCase(
                loginAction: $this->dependencyInjector->get(LoginAction::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: LogoutAction::class,
            concrete: fn() => new LogoutAction(
                authenticationService: $this->dependencyInjector->get(AuthenticationService::class),
                csrfTokenManager     : $this->dependencyInjector->get(CsrfTokenManager::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: LogoutUseCase::class,
            concrete: fn() => new LogoutUseCase(
                logoutService: $this->dependencyInjector->get(LogoutAction::class)
            )
        );
        $this->dependencyInjector->singleton(
            abstract: RetrieveCurrentUserUseCase::class,
            concrete: RetrieveCurrentUserUseCase::class
        );
    }

    /**
     * Additional bootstrapping logic for authentication services.
     *
     * This method can be used to initialize additional configurations or dependencies required
     * for the authentication services after all services have been registered.
     */
    public function boot() : void
    {
        // Additional boot logic for auth services if required
    }
}
=== ServiceProviders/Providers/BootstrapServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\Containers\Application;
use Gemini\Container\Containers\Bootstrapper;
use Gemini\Container\Containers\Kernel;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Router\Router;
use Gemini\Logging\ErrorHandler;

/**
 * Class BootstrapServiceProvider
 *
 * This service provider is responsible for registering core services into the service container.
 * It follows the Dependency Inversion Principle, ensuring high-level modules depend on abstractions
 * rather than concrete implementations, enhancing flexibility and testability.
 */
class BootstrapServiceProvider extends ServiceProvider
{
    /**
     * Registers the necessary services into the service container.
     *
     * This method defines how services or configurations should be registered
     * within the service container, making them available for dependency injection
     * and use throughout the application.
     *
     */
    public function register() : void
    {
        // Register Bootstrapper singleton with required dependencies.
        $this->dependencyInjector->singleton(
            abstract: Bootstrapper::class,
            concrete: fn() : Bootstrapper => new Bootstrapper(
                envFilePath    : AppPath::getRoot() . 'env.php', // Dynamically resolves the env file path.
                helpersFilePath: AppPath::HELPERS_PATH->get(), // Dynamically resolves the helpers file path.
            )
        );

        // Register Application singleton with Kernel dependency.
        $this->dependencyInjector->singleton(
            abstract: Application::class,
            concrete: static fn() : Application => new Application()
        );

        // Register Kernel singleton with Router and ErrorHandler dependencies.
        $this->dependencyInjector->singleton(
            abstract: Kernel::class,
            concrete: fn() : Kernel => new Kernel(
                router      : $this->dependencyInjector->get(Router::class),
                errorHandler: $this->dependencyInjector->get(ErrorHandler::class)
            )
        );
    }

    /**
     * Starts the boot process for the class.
     * This method can be optionally overridden by derived classes to implement specific boot logic.
     *
     * @throws \Exception
     */
    public function boot() : void
    {
        /** @var Bootstrapper $bootstrapper */
        $bootstrapper = $this->dependencyInjector->get(Bootstrapper::class);
        $bootstrapper->bootstrap($this->dependencyInjector);
    }
}
=== ServiceProviders/Providers/CommandServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Commands\App\MakeControllerCommand;
use Gemini\Commands\App\MakeEntityCommand;
use Gemini\Commands\App\MakeRepositoryCommand;
use Gemini\Commands\App\MakeServiceCommand;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Design\Mapper\FluentFieldToDslMapper;
use Gemini\Database\Migration\Runner\Commands\{ValidateStubsCommand};
use Gemini\Database\Migration\Runner\Commands\MakeMigrationCommand;
use Gemini\Database\Migration\Runner\Generators\{Repository\RepositoryGenerator};
use Gemini\Database\Migration\Runner\Generators\Controller\ControllerGenerator;
use Gemini\Database\Migration\Runner\Generators\DTO\DtoGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityQueryBuilderGenerator;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\SchemaBuilder;
use Gemini\Database\Migration\Runner\Service\MigrationService;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Psr\Log\LoggerInterface;

class CommandServiceProvider extends ServiceProvider
{
    /**
     * Registers all services and commands into the container.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: Column::class,
            concrete: static fn() => new Column()
        );


        $this->dependencyInjector->singleton(
            abstract: FieldToDslMapperInterface::class,
            concrete: static fn() => new FluentFieldToDslMapper()
        );

        $this->dependencyInjector->singleton(
            abstract: MigrationGenerator::class,
            concrete: fn() => new MigrationGenerator(
                mapper: $this->dependencyInjector->get(FieldToDslMapperInterface::class)
            )
        );


        $this->dependencyInjector->singleton(
            abstract: EntityGenerator::class,
            concrete: static fn() => new EntityGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: EntityQueryBuilderGenerator::class,
            concrete: static fn() => new EntityQueryBuilderGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: DtoGenerator::class,
            concrete: static fn() => new DtoGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: RepositoryGenerator::class,
            concrete: static fn() => new RepositoryGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: ServiceGenerator::class,
            concrete: static fn() => new ServiceGenerator()
        );

        $this->dependencyInjector->singleton(
            abstract: ControllerGenerator::class,
            concrete: static fn() => new ControllerGenerator()
        );

        // Register the MigrationService
        $this->dependencyInjector->singleton(
            abstract: MigrationRepositoryInterface::class,
            concrete: fn() => new MigrationService(
                queryBuilder: $this->dependencyInjector->get(QueryBuilder::class),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MigrationService::class,
            concrete: MigrationService::class
        );

        // Bind migration state manager
        $this->dependencyInjector->singleton(
            abstract: MigrationStateManager::class,
            concrete: fn() => new MigrationStateManager(
                migrationRepository: $this->dependencyInjector->get(MigrationService::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        // Schema builder and transaction manager
        $this->dependencyInjector->singleton(
            abstract: SchemaBuilder::class,
            concrete: fn() => new SchemaBuilder(
                queryBuilder: $this->dependencyInjector->get(QueryBuilder::class),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        // Bind each command to the container
        $this->dependencyInjector->singleton(
            abstract: MakeMigrationCommand::class,
            concrete: fn() => new MakeMigrationCommand(
                migrationGenerator:          $this->dependencyInjector->get(MigrationGenerator::class),
                entityGenerator:             $this->dependencyInjector->get(EntityGenerator::class),
                entityQueryBuilderGenerator: $this->dependencyInjector->get(EntityQueryBuilderGenerator::class),
                dtoGenerator:                $this->dependencyInjector->get(DtoGenerator::class),
                repositoryGenerator:         $this->dependencyInjector->get(RepositoryGenerator::class),
                serviceGenerator:            $this->dependencyInjector->get(ServiceGenerator::class),
                migrationStateManager:       $this->dependencyInjector->get(MigrationStateManager::class),
                logger:                      $this->dependencyInjector->get(LoggerInterface::class)
            )
        );


        $this->dependencyInjector->singleton(
            abstract: MakeControllerCommand::class,
            concrete: fn() => new MakeControllerCommand(
                controllerGenerator: $this->dependencyInjector->get(ControllerGenerator::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeEntityCommand::class,
            concrete: fn() => new MakeEntityCommand(
                entityGenerator: $this->dependencyInjector->get(EntityGenerator::class),
                logger         : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeRepositoryCommand::class,
            concrete: fn() => new MakeRepositoryCommand(
                repositoryGenerator: $this->dependencyInjector->get(RepositoryGenerator::class),
                logger             : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: MakeServiceCommand::class,
            concrete: fn() => new MakeServiceCommand(
                serviceGenerator: $this->dependencyInjector->get(ServiceGenerator::class),
                logger          : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: ValidateStubsCommand::class,
            concrete: fn() => new ValidateStubsCommand(
                stubResolver: $this->dependencyInjector->get('stubResolver'),
                logger      : $this->dependencyInjector->get(LoggerInterface::class)
            )
        );
    }

    /**
     * Boots the services (if needed).
     *
     * @throws \Exception
     * @throws \Throwable
     */
    public function boot() : void {}
}

=== ServiceProviders/Providers/ConfigurationServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Config\Configurator\FileLoader\ConfigFileLoader;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Infrastructure\Config\Service\Config;

class ConfigurationServiceProvider extends ServiceProvider
{
    /**
     * Registers configuration-related services in the IoC container.
     *
     * This approach ensures that the application configuration is
     * only instantiated once and shared across the entire application lifecycle.
     *
     */
    public function register() : void
    {
        // Register ConfigFileLoader as a singleton to make sure
        // it is used consistently across the application.
        $this->dependencyInjector->singleton(abstract: ConfigFileLoader::class, concrete: ConfigFileLoader::class);

        // Register Config as a singleton and use a closure to lazy-load it,
        // injecting the ConfigFileLoader instance as a dependency dynamically.
        $this->dependencyInjector->singleton(
            abstract: Config::class,
            concrete: fn() : Config => new Config(
                configLoader: $this->dependencyInjector->get(id: ConfigFileLoader::class)
            )
        );
    }

    /**
     * Starts the boot process for the class. This method can be optionally
     * overridden by derived classes to implement specific boot logic.
     * It outputs a default boot message.
     */
    public function boot() : void
    {
        // TODO: Implement boot() method.
    }
}
=== ServiceProviders/Providers/DatabaseServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Database\{Connection\ConnectionPool, DatabaseConnection, QueryBuilder\QueryBuilder, QueryBuilder\UnitOfWork};
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class DatabaseServiceProvider
 *
 * Registers and configures database-related services inside the dependency injection (DI) container.
 *
 * - ✅ **Connection Pool**: Manages database connections efficiently.
 * - ✅ **Database Connection**: Fetches connections from the pool.
 * - ✅ **Unit of Work**: Handles batch transactions.
 * - ✅ **Query Builder**: Provides a fluent API for building and executing queries.
 */
class DatabaseServiceProvider extends ServiceProvider
{
    /**
     * Registers database services in the DI container.
     */
    public function register() : void
    {
        // ✅ Regis  ter ConnectionPool
        $this->dependencyInjector->singleton(
            abstract: ConnectionPool::class,
            concrete: fn() : ConnectionPool => new ConnectionPool(
                config        : [
                                    'connections' => [
                                        'mysql' => [
                                            'connection' => config(key: 'database.connections.mysql.connection'),
                                            'username'   => config(key: 'database.connections.mysql.username'),
                                            'password'   => config(key: 'database.connections.mysql.password'),
                                            'options'    => config(
                                                key:     'database.connections.mysql.options',
                                                default: []
                                            ),
                                        ],
                                    ],
                                ],
                logger        : $this->dependencyInjector->get(LoggerInterface::class),
                maxConnections: 10
            )
        );

        // ✅ Register DatabaseConnection
        $this->dependencyInjector->singleton(
            abstract: DatabaseConnection::class,
            concrete: fn() : DatabaseConnection => new DatabaseConnection(
                connectionPool: $this->dependencyInjector->get(id: ConnectionPool::class),
                logger        : $this->dependencyInjector->get(id: LoggerInterface::class)
            )
        );

        // ✅ Register UnitOfWork (MUST be shared across multiple QueryBuilder instances)
        $this->dependencyInjector->singleton(
            abstract: UnitOfWork::class,
            concrete: fn() : UnitOfWork => new UnitOfWork(
                databaseConnection: $this->dependencyInjector->get(id: DatabaseConnection::class)
            )
        );

        // ✅ Register QueryBuilder
        $this->dependencyInjector->singleton(
            abstract: QueryBuilder::class,
            concrete: fn() : QueryBuilder => new QueryBuilder(
                databaseConnection: $this->dependencyInjector->get(id: DatabaseConnection::class),
                unitOfWork        : $this->dependencyInjector->get(id: UnitOfWork::class),
                logger            : $this->dependencyInjector->get(id: LoggerInterface::class)
            )
        );
    }

    /**
     * Performs an optional database connectivity test during boot.
     *
     * Ensures that the database is accessible before usage.
     */
    public function boot() : void
    {
        try {
            $this->dependencyInjector->get(id: DatabaseConnection::class)->testConnection();
        } catch (Throwable $throwable) {
            // ❌ Log database connection errors
            $logger = $this->dependencyInjector->get(id: LoggerInterface::class);
            $logger->error(
                'Database connection failed in DatabaseServiceProvider::boot() : ' .
                $throwable->getMessage()
            );
        }
    }
}

=== ServiceProviders/Providers/FilesystemServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\Filesystem\Storage\FileStorageInterface;
use Gemini\Filesystem\Storage\Filesystem;
use Gemini\Filesystem\Storage\LocalFileStorage;

class FilesystemServiceProvider extends ServiceProvider
{
    public function register() : void
    {
        // Bind FileStorageInterface to its implementation
        $this->dependencyInjector->singleton(abstract: FileStorageInterface::class, concrete: LocalFileStorage::class);

        // Bind Filesystem class to provide file management functionality
        $this->dependencyInjector->singleton(
            abstract: Filesystem::class,
            concrete: fn() : Filesystem => new Filesystem(
                fileStorage: $this->dependencyInjector->get(id: FileStorageInterface::class)
            )
        );

        // Bind 'Storage' alias to resolve to Filesystem
        $this->dependencyInjector->singleton(
            abstract: 'Storage',
            concrete: fn() : mixed => $this->dependencyInjector->get(
                id: Filesystem::class
            )
        );
    }

    public function boot() : void {}
}

=== ServiceProviders/Providers/HttpClientServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\HttpClient\Config\Clients\Guzzle\GuzzleClient;
use Gemini\HTTP\HttpClient\Config\Clients\Guzzle\HttpClient;
use Gemini\HTTP\HttpClient\Config\Middleware\Policies\Concrats\RetryPolicyInterface;
use Gemini\HTTP\HttpClient\Config\Middleware\Policies\ServerErrorRetryPolicy;
use Gemini\HTTP\HttpClient\Config\Middleware\RetryMiddleware;
use Gemini\HTTP\Response\ResponseFactory;
use GuzzleHttp\Client;
use GuzzleHttp\HandlerStack;
use Psr\Http\Message\UriInterface;
use Psr\Log\LoggerInterface;

/**
 * Class HttpClientServiceProvider
 *
 * Registers HTTP client-related services in the container.
 */
class HttpClientServiceProvider extends ServiceProvider
{
    /**
     * Registers the necessary services into the service container.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: RetryPolicyInterface::class,
            concrete: static fn() : ServerErrorRetryPolicy => new ServerErrorRetryPolicy() // TODO: double check
        );

        // Register RetryMiddleware
        $this->dependencyInjector->singleton(
            abstract: RetryMiddleware::class,
            concrete: fn() : RetryMiddleware => new RetryMiddleware(
                logger    : $this->dependencyInjector->get(LoggerInterface::class),
                maxRetries: 3, // Configurable retry wait time in ms
            )
        );

        // Register HttpClient
        $this->dependencyInjector->singleton(
            abstract: HttpClient::class,
            concrete: fn() : HttpClient => new HttpClient(
                retryMiddleware: $this->dependencyInjector->get(RetryMiddleware::class),
                logger         : $this->dependencyInjector->get(LoggerInterface::class),
                baseUri        : $this->dependencyInjector->get(UriInterface::class) // Inject base API URL
            )
        );

        // Register GuzzleClient
        $this->dependencyInjector->singleton(
            abstract: GuzzleClient::class,
            concrete: fn() : GuzzleClient => new GuzzleClient(
                httpClient     : $this->dependencyInjector->get(HttpClient::class),
                dataLogger     : $this->dependencyInjector->get(LoggerInterface::class),
                responseFactory: $this->dependencyInjector->get(ResponseFactory::class)
            )
        );

        // Optional: Register Guzzle HandlerStack
        $this->dependencyInjector->singleton(
            abstract: HandlerStack::class,
            concrete: static fn() : HandlerStack => HandlerStack::create()
        );

        // Optional: Register Guzzle Client
        $this->dependencyInjector->singleton(
            abstract: Client::class,
            concrete: fn() : Client => new Client(
                ['handler' => $this->dependencyInjector->get(HandlerStack::class)]
            )
        );
    }

    /**
     * Starts the boot process for the class.
     */
    public function boot() : void
    {
        // Optionally add bootstrapping logic if necessary
        // This could include preloading configurations or resolving dependencies
    }
}

=== ServiceProviders/Providers/HTTPServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Request\Request;
use Gemini\HTTP\Response\Classes\{Response, Stream, StreamFactory};
use Gemini\HTTP\Response\ResponseFactory;
use Gemini\HTTP\URI\UriBuilder;
use Psr\Http\Message\{ResponseFactoryInterface,
    ResponseInterface,
    ServerRequestInterface,
    StreamFactoryInterface,
    StreamInterface,
    UriInterface};
use RuntimeException;
use Throwable;

class HTTPServiceProvider extends ServiceProvider
{
    /**
     * Registers HTTP-related services in the container as singletons.
     *
     * - StreamInterface is configured to use a temporary stream.
     * - StreamFactoryInterface, ResponseFactoryInterface, and UriInterface are registered for dependency injection.
     * - ResponseInterface uses the configured StreamInterface.
     */
    public function register() : void
    {
        // Register StreamInterface with a temporary stream
        $this->dependencyInjector->singleton(abstract: StreamInterface::class, concrete: static function () : Stream {
            $streamResource = fopen('php://temp', 'rw+');
            if ($streamResource === false) {
                throw new RuntimeException(message: "Failed to create temporary stream.");
            }

            return new Stream(stream: $streamResource);
        });

        // Register StreamFactoryInterface
        $this->dependencyInjector->singleton(abstract: StreamFactoryInterface::class, concrete: StreamFactory::class);

        // Register ResponseInterface
        $this->dependencyInjector->singleton(abstract: ResponseInterface::class, concrete: function () : Response {
            try {
                $stream = $this->dependencyInjector->get(id: StreamInterface::class);
            } catch (Throwable $throwable) {
                throw new RuntimeException(
                    message : "Failed to resolve StreamInterface for ResponseInterface.",
                    code    : 0,
                    previous: $throwable
                );
            }

            return new Response(stream: $stream);
        });

        // Register ResponseFactoryInterface
        $this->dependencyInjector->singleton(abstract: ResponseFactoryInterface::class, concrete: function (
        ) : ResponseFactory {
            try {
                $streamFactory = $this->dependencyInjector->get(id: StreamFactoryInterface::class);
                $response      = $this->dependencyInjector->get(id: ResponseInterface::class);
            } catch (Throwable $throwable) {
                throw new RuntimeException(
                    message : "Failed to resolve dependencies for ResponseFactoryInterface.",
                    code    : 0,
                    previous: $throwable
                );
            }

            return new ResponseFactory(streamFactory: $streamFactory, response: $response);
        });


        // Response factory
        $this->dependencyInjector->singleton(
            abstract: ResponseFactory::class,
            concrete: static fn($container) => $container->get(ResponseFactoryInterface::class)
        );

        // Register UriInterface
        $this->dependencyInjector->singleton(
            abstract: UriInterface::class,
            concrete: static fn() : UriBuilder => UriBuilder::createFromString(
                env(key: 'APP_URL', default: 'http://localhost')
            )
        );

        // Request
        $this->dependencyInjector->singleton(
            abstract: ServerRequestInterface::class,
            concrete: static fn($container) : Request => Request::createFromGlobals()
        );

        // Request facade
        $this->dependencyInjector->singleton(
            abstract: 'Request',
            concrete: fn() : mixed => $this->dependencyInjector->get(id: ServerRequestInterface::class)
        );
    }

    /**
     * Placeholder for HTTP service bootstrapping logic.
     */
    public function boot() : void {}

}

=== ServiceProviders/Providers/LoggingServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Session\Contracts\SessionLoggerInterface;
use Gemini\Logging\ErrorHandler;
use Gemini\Logging\LoggerFactory;
use Psr\Log\LoggerInterface;
use RuntimeException;

class LoggingServiceProvider extends ServiceProvider
{
    /**
     * Registers all necessary services related to logging.
     *
     * @throws \Exception
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: LoggerFactory::class,
            concrete: static fn() : LoggerFactory => new LoggerFactory()
        );

        $this->dependencyInjector->singleton(
            abstract: LoggerInterface::class,
            concrete: fn() : LoggerInterface => $this->resolveDependency(abstract: LoggerFactory::class)->create()
        );

        $this->dependencyInjector->singleton(
            abstract: ErrorHandler::class,
            concrete: fn() : ErrorHandler => new ErrorHandler(
                logger: $this->resolveDependency(abstract: LoggerInterface::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: SessionLoggerInterface::class,
            concrete: fn() => $this
                ->resolveDependency(abstract: LoggerFactory::class)
                ->createLoggerFor(channel: 'session')
        );
    }

    /**
     * Resolves a dependency from the container with additional validation.
     *
     * @template T
     * @param class-string<T> $abstract The class name of the dependency.
     *
     * @return T
     */
    private function resolveDependency(string $abstract) : mixed
    {
        if (! $this->dependencyInjector->has(id: $abstract)) {
            throw new RuntimeException(message: sprintf("Action '%s' is not registered in the container.", $abstract));
        }

        return $this->dependencyInjector->get(id: $abstract);
    }

    public function boot() : void {}
}

=== ServiceProviders/Providers/MiddlewareServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Auth\Interface\HTTP\Middleware\AuthenticationMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\PermissionMiddleware;
use Gemini\Auth\Interface\HTTP\Middleware\RoleMiddleware;
use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Middleware\CorsMiddleware;
use Gemini\HTTP\Middleware\CSRF\CsrfMiddleware;
use Gemini\HTTP\Middleware\ExceptionHandlerMiddleware;
use Gemini\HTTP\Middleware\JsonResponseMiddleware;
use Gemini\HTTP\Middleware\MiddlewareGroupResolver;
use Gemini\HTTP\Middleware\MiddlewarePipeline;
use Gemini\HTTP\Middleware\MiddlewarePipelineLogger;
use Gemini\HTTP\Middleware\MiddlewareResolver;
use Gemini\HTTP\Middleware\RateLimiterMiddleware;
use Gemini\HTTP\Middleware\RequestLoggerMiddleware;
use Gemini\HTTP\Middleware\SecurityHeadersMiddleware;
use Gemini\HTTP\Middleware\SessionLifecycleMiddleware;
use Gemini\HTTP\Response\ResponseFactory;
use Psr\Log\LoggerInterface;

/**
 * Registers and configures middleware components used throughout the application.
 *
 * This provider ensures centralized and DI-compliant binding of all middleware, middleware groups,
 * and the core pipeline orchestration infrastructure.
 */
final class MiddlewareServiceProvider extends ServiceProvider
{
    /**
     * Registers all middleware-related services into the container.
     */
    public function register() : void
    {
        $this->registerPipelineInfrastructure();
        $this->registerMiddlewareCore();
        $this->registerIndividualMiddlewares();
        $this->registerResolver();
        $this->registerGroupResolver();
    }

    /**
     * Registers the core pipeline and middleware manager infrastructure.
     */
    private function registerPipelineInfrastructure() : void
    {
        $this->dependencyInjector->singleton(
            abstract: MiddlewarePipeline::class,
            concrete: static fn() : MiddlewarePipeline => new MiddlewarePipeline()
        );

        $this->dependencyInjector->singleton(
            abstract: MiddlewarePipelineLogger::class,
            concrete: fn() => new MiddlewarePipelineLogger(
                logger: $this->dependencyInjector->get(LoggerInterface::class)
            )
        );
    }

    /**
     * Registers middlewares that require dependency injection manually.
     */
    private function registerMiddlewareCore() : void
    {
        $this->dependencyInjector->singleton(
            abstract: ExceptionHandlerMiddleware::class,
            concrete: fn() => new ExceptionHandlerMiddleware(
                logger:          $this->dependencyInjector->get(LoggerInterface::class),
                responseFactory: $this->dependencyInjector->get(ResponseFactory::class)
            )
        );
    }

    /**
     * Registers stateless singleton middleware instances with no required dependencies.
     */
    private function registerIndividualMiddlewares() : void
    {
        $middlewares = [
            AuthenticationMiddleware::class,
            PermissionMiddleware::class,
            RoleMiddleware::class,
            CorsMiddleware::class,
            CsrfMiddleware::class,
            JsonResponseMiddleware::class,
            RateLimiterMiddleware::class,
            RequestLoggerMiddleware::class,
            SecurityHeadersMiddleware::class,
            SessionLifecycleMiddleware::class,
        ];

        foreach ($middlewares as $middleware) {
            $this->dependencyInjector->singleton(abstract: $middleware, concrete: $middleware);
        }
    }

    /**
     * Registers a singleton instance of the middleware resolver.
     * The resolver is responsible for resolving middleware groups and handles their configuration dependencies.
     *
     * @return void
     */
    private function registerResolver() : void
    {
        $this->dependencyInjector->singleton(
            abstract: MiddlewareResolver::class,
            concrete: fn() => new MiddlewareResolver(
                groupResolver: $this->dependencyInjector->get(MiddlewareGroupResolver::class)
            )
        );
    }

    /**
     * Registers the `MiddlewareGroupResolver` class as a singleton in the dependency injector.
     *
     * This method ensures that only one instance of `MiddlewareGroupResolver` is created
     * during the application's lifecycle while managing its dependency injection.
     */
    private function registerGroupResolver() : void
    {
        // Registering MiddlewareGroupResolver as a singleton within the DependencyInjector,
        // ensuring that a single instance of the resolver is shared across the application's lifecycle.
        $this->dependencyInjector->singleton(
        // The abstract class or interface to bind to.
            abstract: MiddlewareGroupResolver::class,

            // The concrete implementation or closure defining how to resolve the abstract type.
            // In this case, an anonymous function creates and returns a new instance of MiddlewareGroupResolver.
            concrete: static fn() => new MiddlewareGroupResolver(
            // Injecting the configuration array for middleware groups, loaded from the middleware configuration file.
                config: require AppPath::CONFIG->get() . '/' . 'middleware.php'
            )
        );
    }

    /**
     * Boots global and grouped middleware for runtime execution.
     */
    public function boot() : void {}
}

=== ServiceProviders/Providers/RouterServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Dispatcher\ControllerDispatcher;
use Gemini\HTTP\Middleware\MiddlewareResolver;
use Gemini\HTTP\Router\Bootstrap\RouteBootstrapper;
use Gemini\HTTP\Router\Cache\RouteCacheCompiler;
use Gemini\HTTP\Router\Cache\RouteCacheLoader;
use Gemini\HTTP\Router\Kernel\RouterKernel;
use Gemini\HTTP\Router\Router;
use Gemini\HTTP\Router\RouterInterface;
use Gemini\HTTP\Router\Routing\HttpRequestRouter;
use Gemini\HTTP\Router\Routing\RouteGroupRegistrar;
use Gemini\HTTP\Router\Routing\RoutePipelineFactory;
use Gemini\HTTP\Router\Support\HeadRequestFallback;
use Gemini\HTTP\Router\Validation\RouteConstraintValidator;
use Psr\Log\LoggerInterface;

/**
 * Service Provider for setting up the routing services.
 * This class is responsible for registering and booting the necessary services related to routing.
 */
class RouterServiceProvider extends ServiceProvider
{
    /**
     * Register routing-related services in the container.
     * Using singleton to ensure a single instance of these classes is used throughout the application.
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: RouterInterface::class,
            concrete: fn() => $this->dependencyInjector->get(Router::class)
        );

        $this->dependencyInjector->singleton(
            abstract: RouteConstraintValidator::class,
            concrete: static fn() => new RouteConstraintValidator()
        );

        $this->dependencyInjector->singleton(
            abstract: HttpRequestRouter::class,
            concrete: fn() : HttpRequestRouter => new HttpRequestRouter(
                constraintValidator: $this->dependencyInjector->get(RouteConstraintValidator::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: ControllerDispatcher::class,
            concrete: fn() : ControllerDispatcher => new ControllerDispatcher(
                container: $this->dependencyInjector
            )
        );

        $this->dependencyInjector->singleton(
            abstract: HeadRequestFallback::class,
            concrete: fn() => new HeadRequestFallback(
                router: $this->dependencyInjector->get(id: HttpRequestRouter::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RoutePipelineFactory::class,
            concrete: fn() => new RoutePipelineFactory(
                container         : $this->dependencyInjector,
                dispatcher        : $this->dependencyInjector->get(ControllerDispatcher::class),
                middlewareResolver: $this->dependencyInjector->get(MiddlewareResolver::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouterKernel::class,
            concrete: fn() : RouterKernel => new RouterKernel(
                httpRequestRouter  : $this->dependencyInjector->get(id: HttpRequestRouter::class),
                pipelineFactory    : $this->dependencyInjector->get(id: RoutePipelineFactory::class),
                headRequestFallback: $this->dependencyInjector->get(id: HeadRequestFallback::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteConstraintValidator::class,
            concrete: static fn() => new RouteConstraintValidator()
        );

        $this->dependencyInjector->singleton(
            abstract: Router::class,
            concrete: fn() : Router => new Router(
                httpRequestRouter: $this->dependencyInjector->get(id: HttpRequestRouter::class),
                kernel           : $this->dependencyInjector->get(id: RouterKernel::class),
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteGroupRegistrar::class,
            concrete: static fn() : RouteGroupRegistrar => new RouteGroupRegistrar()
        );

        // Optional alias
        $this->dependencyInjector->singleton(
            abstract: 'Route',
            concrete: fn() => $this->dependencyInjector->get(id: Router::class)
        );

        $this->dependencyInjector->singleton(
            abstract: RouteCacheCompiler::class,
            concrete: static fn() => new RouteCacheCompiler()
        );

        $this->dependencyInjector->singleton(
            abstract: RouteCacheLoader::class,
            concrete: fn() => new RouteCacheLoader(
                router: $this->dependencyInjector->get(Router::class)
            )
        );

        $this->dependencyInjector->singleton(
            abstract: RouteBootstrapper::class,
            concrete: fn() => new RouteBootstrapper(
                routeCacheLoader : $this->dependencyInjector->get(RouteCacheLoader::class),
                httpRequestRouter: $this->dependencyInjector->get(HttpRequestRouter::class),
                logger           : $this->dependencyInjector->get(LoggerInterface::class),
            )
        );
    }

    /**
     * Boot the router service provider, ensuring configuration settings are loaded.
     *
     * @throws \Throwable
     */
    public function boot() : void
    {
        /** @var RouteBootstrapper $bootstrapper */
        $bootstrapper = $this->dependencyInjector->get(RouteBootstrapper::class);
        $bootstrapper->bootstrap();
    }
}
=== ServiceProviders/Providers/SecurityServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Auth\Application\Service\AccessControl\AccessControlService;
use Gemini\Auth\Application\Service\RateLimiterService;
use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Security\CsrfTokenManager;
use Gemini\HTTP\Session\Contracts\SessionInterface;
use Psr\Log\LoggerInterface;

/**
 * Service provider for security-related services.
 *
 * Registers security services and components,
 * specifically the CsrfTokenManager, with the application container.
 */
class SecurityServiceProvider extends ServiceProvider
{

    /**
     * Register services into the container.
     *
     * This method registers the CsrfTokenManager as a singleton in the container.
     * It ensures a single instance is used throughout the application lifecycle.
     *
     */
    public function register() : void
    {
        $this->dependencyInjector->singleton(
            abstract: CsrfTokenManager::class,
            concrete: fn() : CsrfTokenManager => new CsrfTokenManager(
            // Injecting SessionInterface dependency into CsrfTokenManager,
            // indicating the necessity of session management for CSRF token handling.
                session: $this->dependencyInjector->get(id: SessionInterface::class),
                logger : $this->dependencyInjector->get(id: LoggerInterface::class),
            )
        );

        $this->dependencyInjector->singleton(
            abstract: AccessControlService::class,
            concrete: AccessControlService::class
        );

        $this->dependencyInjector->singleton(abstract: RateLimiterService::class, concrete: fn(
        ) : RateLimiterService => new RateLimiterService(
            session: $this->dependencyInjector->get(id: SessionInterface::class)
        ));
    }

    /**
     * Perform additional bootstrapping for security.
     *
     * Intended for any security-related initialization that
     * might be required after the service registration.
     */
    public function boot() : void
    {
        // Additional bootstrapping for security if necessary
    }
}
=== ServiceProviders/Providers/SessionServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\HTTP\Session\Contracts\{Factories\BagRegistryFactoryInterface,
    SessionBuilderInterface,
    SessionInterface,
    SessionManagerInterface,
    SessionStoreInterface};
use Gemini\HTTP\Session\Drivers\NativeSession;
use Gemini\HTTP\Session\SessionBuilder;
use Gemini\HTTP\Session\SessionContext;
use Gemini\HTTP\Session\SessionManager;
use Gemini\HTTP\Session\Stores\NativeSessionStore;
use Gemini\HTTP\Session\Support\Factories\BagRegistryFactory;

final class SessionServiceProvider extends ServiceProvider
{
    /**
     * @throws \Random\RandomException
     */
    public function register() : void
    {
        $this->bindSingleton(abstract: SessionStoreInterface::class, concrete: NativeSessionStore::class);
        $this->bindSingleton(abstract: BagRegistryFactoryInterface::class, concrete: BagRegistryFactory::class);

        // Main SessionInterface (deferred registry via closure)
        $this->dependencyInjector->bind(
            abstract: SessionInterface::class,
            concrete: static fn($c) => new NativeSession(
                store          : $c->get(SessionStoreInterface::class),
                registryFactory: static fn(SessionInterface $session) => $c
                    ->get(BagRegistryFactoryInterface::class)
                    ->create($session)
            )
        );

        // Use session->getRegistry() directly wherever needed
        $this->dependencyInjector->singleton(
            abstract: SessionBuilderInterface::class,
            concrete: fn() => new SessionBuilder(
                session : $this->resolve(abstract: SessionInterface::class),
                registry: $this->resolve(abstract: SessionInterface::class)->getRegistry(),
                context : new SessionContext(namespace: 'default')
            )
        );

        $this->dependencyInjector->singleton(
            abstract: SessionManagerInterface::class,
            concrete: fn() => new SessionManager(
                session: $this->resolve(abstract: SessionInterface::class),
                bags   : $this->resolve(abstract: SessionInterface::class)->getRegistry()
            )
        );
    }

    private function bindSingleton(string $abstract, string $concrete) : void
    {
        $this->dependencyInjector->singleton(
            abstract: $abstract,
            concrete: static fn() => new $concrete()
        );
    }

    private function resolve(string $abstract) : mixed
    {
        return $this->dependencyInjector->get(id: $abstract);
    }

    public function boot() : void {}
}

=== ServiceProviders/Providers/ViewServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders\Providers;

use Gemini\Container\ServiceProviders\ServiceProvider;
use Gemini\View\BladeTemplateEngine;
use Infrastructure\Config\Service\Config;

class ViewServiceProvider extends ServiceProvider
{
    public function register() : void
    {
//        $this->dependencyInjector->singleton(
//            abstract: TemplateEngine::class,
//            concrete: fn() => new TemplateEngine(
//                templatePath: $this->dependencyInjector->get(Config::class)->get('views.views_path'),
//                compiledPath: $this->dependencyInjector->get(Config::class)->get('views.cache_path')
//            )
//        );

        $this->dependencyInjector->singleton(
            abstract: BladeTemplateEngine::class,
            concrete: fn() : BladeTemplateEngine => new BladeTemplateEngine(
                viewsPath: $this->dependencyInjector->get(Config::class)->get('views.views_path'),
                cachePath: $this->dependencyInjector->get(Config::class)->get('views.cache_path')
            )
        );
    }

    public function boot() : void
    {
        // Optional: Additional view-related logic
    }
}

=== ServiceProviders/ServiceProvider.php ===
<?php

declare(strict_types=1);

namespace Gemini\Container\ServiceProviders;

use Gemini\Container\Containers\DependencyInjector;
use Gemini\Container\ServiceProviders\Contracts\ServiceProviderInterface;

/**
 * Class ServiceProvider
 *
 * The base class for all service providers.
 */
abstract class ServiceProvider implements ServiceProviderInterface
{
    /**
     * Constructor method for initializing the class with an application container.
     *
     * @param DependencyInjector $dependencyInjector The application container for managing dependencies.
     */
    public function __construct(protected DependencyInjector $dependencyInjector) {}

    /**
     * Registers the necessary services into the service container.
     */
    abstract public function register(): void;

    /**
     * Starts the boot process for the class.
     */
    abstract public function boot(): void;
}

