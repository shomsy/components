=== BaseCollection.php ===
<?php

/** @noinspection PhpMemberCanBePulledUpInspection */

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Closure;
use Traversable;

/**
 * BaseCollection provides an abstract foundation for collections,
 * handling core functionalities and item storage while leaving specific collection behaviors to subclasses.
 *
 * This class is designed to be extended, providing common methods
 * that can be used by all types of collections.
 */
abstract class BaseCollection implements CollectionInterface
{
    /**
     * @var array Holds the items of the collection.
     * Using a protected array allows subclasses to access and manipulate the stored items directly.
     */
    protected array $items = [];

    /**
     * BaseCollection constructor.
     * Initializes the collection with the provided items.
     *
     * By accepting any iterable type, this constructor ensures flexibility in initializing the collection.
     *
     * @param iterable $items Initial items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Convert various types of inputs to an array.
     *
     * Ensures compatibility regardless of the input type,
     * whether it's an instance of self, Traversable, or an array.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array
    {
        if ($items instanceof self) {
            return $items->all();
        }

        if ($items instanceof Traversable) {
            return iterator_to_array(iterator: $items);
        }

        return (array) $items;
    }

    /**
     * Retrieve all items in the collection.
     *
     * Provides a consistent way to access all the items stored in the collection.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return $this->getItems();
    }

    /**
     * Abstract method to retrieve the internal items.
     * To be implemented by subclasses.
     *
     * Forces each subclass to define how items should be retrieved,
     * allowing for flexibility in different types of collections.
     *
     * @return array The items in the collection.
     */
    abstract public function getItems() : array;

    /**
     * Abstract method to set the internal items.
     * To be implemented by subclasses.
     *
     * Ensures that subclasses handle the specific logic for setting the items,
     * which can vary based on the type of collection.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Get an iterator for the collection.
     *
     * Supports iteration over the collection using foreach.
     *
     * @return Traversable An iterator over the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->getItems());
    }

    /**
     * Get the count of items in the collection.
     *
     * Provides a quick way to determine how many items are currently in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int
    {
        return count(value: $this->getItems());
    }

    /**
     * Convert the collection to an array for JSON serialization.
     *
     * Ensures that when the collection is JSON-encoded, it gets correctly represented as an array.
     *
     * @return array Data ready for JSON serialization.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Recursively converts nested collections to arrays.
     *
     * Handles nested collections to ensure they are also converted to arrays,
     * preserving the structure when serialized or manipulated.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array
    {
        return array_map(callback: fn($item) => $item instanceof self ? $item->toArray() : $item, array: $this->getItems());
    }

    // Abstract methods to be implemented by subclasses for specific functionalities

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|CollectionInterface $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function merge(array|CollectionInterface $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function tap(Closure $callback) : static;
}

=== Collection.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Avax\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Avax\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Avax\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Avax\DataHandling\ArrayHandling\Traits\DebugTrait;
use Avax\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Avax\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Avax\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Avax\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Avax\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Avax\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Avax\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\TransformationTrait;
use Closure;
use Traversable;

/**
 * Collection class providing utilities for array manipulations.
 * Combines traits to enable sorting, filtering, partitioning, and more.
 */
class Collection extends BaseCollection implements CollectionInterface
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;

    /**
     * Internal storage for collection items specific to Collection.
     */
    protected array $elements = [];

    /**
     * Collection constructor.
     *
     * Initializes the collection with an optional set of items.
     *
     * @param iterable $items Initial set of items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        parent::__construct(items: $items);
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Set the internal elements array.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    public function setItems(iterable $items) : static
    {
        $this->elements = $items;

        return $this;
    }

    /**
     * Invokes a callback on the collection and returns the collection itself.
     *
     * Useful for debugging and inspection without altering chainability.
     *
     * @param Closure $callback The callback to execute.
     *
     * @return static The current collection instance for method chaining.
     */
    public function tap(Closure $callback) : static
    {
        $callback($this);

        return $this;
    }

    /**
     * Retrieves the first item that matches a given key-value pair.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value to compare against.
     *
     * @return mixed|null The first matching item or null if not found.
     */
    public function firstWhere(string $key, mixed $value) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (($item[$key] ?? null) === $value) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Get the internal elements array.
     *
     * @return array The elements in the collection.
     */
    public function getItems() : array
    {
        return $this->elements;
    }

    /**
     * Determine the maximum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The maximum value or null if the collection is empty.
     */
    public function max(string|null $key = null) : mixed
    {
        return max(
            value: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
    }

    /**
     * Determine the minimum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The minimum value or null if the collection is empty.
     */
    public function min(string|null $key = null) : mixed
    {
        return min(
            value: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
    }

    /**
     * Determine the mode (most frequent value) in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return string|int|null The mode or null if the collection is empty.
     */
    public function mode(string|null $key = null) : string|int|null
    {
        $counts = array_count_values(
            array: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
        arsort(array: $counts);

        return array_key_first(array: $counts);
    }

    /**
     * Count items in the collection based on a given callback.
     *
     * @param Closure $callback The callback to determine the key for counting.
     *
     * @return static A new collection containing count values.
     */
    public function countBy(Closure $callback) : static
    {
        $counts = [];
        foreach ($this->getItems() as $item) {
            $key          = $callback($item);
            $counts[$key] = ($counts[$key] ?? 0) + 1;
        }

        return new static($counts);
    }

    /**
     * Appends a value to the end of the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static The current collection instance for method chaining.
     */
    public function append(mixed $value) : static
    {
        $this->elements[] = $value;

        return $this;
    }

    /**
     * Prepends a value to the beginning of the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static The current collection instance for method chaining.
     */
    public function prepend(mixed $value) : static
    {
        array_unshift($this->elements, $value);

        return $this;
    }

    /**
     * Merges the collection with another collection or array.
     *
     * Supports merging arrays or other collections seamlessly.
     *
     * @param CollectionInterface|array $items The items to merge.
     *
     * @return static The current collection instance for method chaining.
     */
    public function merge(CollectionInterface|array $items) : static
    {
        $mergedItems = array_merge($this->getItems(), is_array(value: $items) ? $items : $items->all());
        $this->setItems(items: $mergedItems);

        return $this;
    }

    /**
     * Returns the count of items in the collection.
     *
     * @return int The number of items in the collection.
     */
    public function count() : int
    {
        return count(value: $this->getItems());
    }

    /**
     * Returns an iterator for the collection.
     *
     * @return Traversable An iterator for the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->getItems());
    }
}

=== CollectionInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayAccess;
use Closure;
use Countable;
use IteratorAggregate;
use JsonSerializable;

/**
 * CollectionInterface serves as a contract for collection operations that
 * supports various interfaces such as Countable, ArrayAccess, IteratorAggregate,
 * and JsonSerializable. This ensures a standardized way to manipulate
 * collections across the application.
 */
interface CollectionInterface extends Countable, ArrayAccess, IteratorAggregate, JsonSerializable
{
    /**
     * Retrieve all items in the collection.
     *
     * @return array All items in the collection.
     */
    public function all() : array;

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|self $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function merge(array|self $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function tap(Closure $callback) : static;

    /**
     * Convert the collection to an array.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array;

    /**
     * Get the count of items in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int;

    /**
     * Convert various types of inputs to an array.
     * This accommodates different forms of collection items.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array;

    /**
     * Find the first item in the collection where a given key has a specific value.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value of the key.
     *
     * @return mixed The first item matching the criteria.
     */
    public function firstWhere(string $key, mixed $value) : mixed;

    /**
     * Find the maximum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The maximum value.
     */
    public function max(string|null $key = null) : mixed;

    /**
     * Find the minimum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The minimum value.
     */
    public function min(string|null $key = null) : mixed;

    /**
     * Calculate the mode (most frequent value) for a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for determining mode of the whole item.
     *
     * @return string|int|null The mode value, or null if no mode is found.
     */
    public function mode(string|null $key = null) : string|int|null;

    /**
     * Count items in the collection based on the given closure.
     *
     * @param Closure $callback The closure to determine the count criteria.
     *
     * @return static The collection instance, enabling method chaining.
     */
    public function countBy(Closure $callback) : static;
}

=== Exceptions/ItemNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections\Exceptions;

use Exception;

/**
 * Exception thrown when a specified item is not found in the collection.
 *
 * This exception is used to signal cases where an operation expected a specific
 * item to be available in the collection, but it wasn't found. It simplifies
 * error handling across the application by providing a specific exception type
 * for missing items, allowing for cleaner and more specific catch blocks.
 */
class ItemNotFoundException extends Exception
{
    /**
     * The default exception message indicating the item was not found.
     *
     * This message is pre-set to provide a consistent error message throughout
     * the application whenever an item is missing from a collection, avoiding
     * the need to define a message each time this exception is thrown.
     *
     * @var string
     */
    protected $message = 'The specified item was not found in the collection.';
}

=== LazyCollection.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use Avax\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Closure;
use Traversable;

/**
 * Class LazyCollection
 *
 * This class represents a collection with lazy evaluation, where items are generated on the fly.
 * The primary benefit is memory efficiency, especially for large datasets.
 */
class LazyCollection extends Collection
{
    use LazyEvaluationTrait;

    /**
     * LazyCollection constructor.
     *
     * @param Closure $generator A generator function to build the collection lazily.
     */
    public function __construct(protected Closure $generator)
    {
        parent::__construct();
    }

    /**
     * Retrieve all items in the collection as an array.
     *
     * Converts the lazy-loaded items into a straightforward array.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return iterator_to_array(iterator: $this->getIterator());
    }

    /**
     * Get an iterator for the collection.
     *
     * This method facilitates the lazy evaluation by returning the generator.
     *
     * @return Traversable The generator yielding items of the collection.
     */
    public function getIterator() : Traversable
    {
        return ($this->generator)();
    }

    /**
     * Get every nth item in the collection.
     *
     * This method is useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved.
     *
     * @return static A new lazy collection containing every nth item.
     */
    public function nth(int $step) : static
    {
        return new static(generator: function () use ($step) {
            $index = 0;
            foreach ($this->getIterator() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection while the callback returns true.
     *
     * This allows conditional data processing where items are taken as long as a condition holds.
     *
     * @param Closure $callback The condition used to continue taking items.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(generator: function () use ($callback) {
            foreach ($this->getIterator() as $item) {
                if (! $callback($item)) {
                    break;
                }

                yield $item;
            }
        });
    }
}

