=== ArrayHandling/Arrhae.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling;

use ArrayAccess;
use ArrayIterator;
use Avax\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Avax\DataHandling\ArrayHandling\Traits\AdvancedStringSearchTrait;
use Avax\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Avax\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Avax\DataHandling\ArrayHandling\Traits\DebugTrait;
use Avax\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Avax\DataHandling\ArrayHandling\Traits\LockableTrait;
use Avax\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Avax\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Avax\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Avax\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Avax\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Avax\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\StringManipulationTrait;
use Avax\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\TransformationTrait;
use Closure;
use Countable;
use InvalidArgumentException;
use IteratorAggregate;
use Traversable;


/**
 * Class Arrhae
 *
 * The `Arrhae` class is a comprehensive utility for working with arrays. It offers a variety of methods
 * for transforming, querying, and manipulating complex arrays. It supports features like dot notation for nested
 * arrays, lazy evaluation, optimized array access, conditional operations, and more.
 *
 * This class implements the `ArrayAccess`, `IteratorAggregate`, and `Countable` interfaces, allowing it to work
 * seamlessly with array operations, iteration, and counting.
 *
 * Additionally, it leverages several traits to modularize functionality:
 * - `AbstractDependenciesTrait`: Manages dependencies required by the class.
 * - `AggregationTrait`: Provides methods for aggregating data (e.g., sum, average).
 * - `ArrayAccessTrait`: Implements array access methods.
 * - `ArrayConversionTrait`: Offers methods to convert arrays to different formats.
 * - `CollectionWalkthroughTrait`: Facilitates iteration and traversal of collections.
 * - `ConditionalsTrait`: Provides conditional operations on arrays.
 * - `DebugTrait`: Contains debugging utilities.
 * - `LazyEvaluationTrait`: Enables lazy evaluation of array operations.
 * - `MacrosTrait`: Allows adding custom macros to the class.
 * - `ManageItemsTrait`: Manages items within the array.
 * - `MetaInfoTrait`: Provides metadata information about the array.
 * - `OrderManipulationTrait`: Handles ordering and sorting of array items.
 * - `PartitioningTrait`: Facilitates partitioning of the array into subsets.
 * - `SetOperationsTrait`: Implements set operations like union and intersection.
 * - `SortOperationsTrait`: Offers advanced sorting capabilities.
 * - `StructureConversionTrait`: Converts the array structure as needed.
 * - `TransformationTrait`: Provides methods to transform array data.
 *
 * @method float|int sum(string|callable $key) Sums all numeric values in the array.
 * @method float|null average() Calculates the average of all numeric values in the array.
 * @method Arrhae fromJson(string $json) Creates an Arrhae instance from a JSON string.
 * @method string toJson() Converts the array to a JSON string.
 *
 * @package Avax\DataHandling\ArrayHandling
 */
class Arrhae implements ArrayAccess, IteratorAggregate, Countable
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;
    use AdvancedStringSearchTrait;
    use StringManipulationTrait;
    use LockableTrait;

    /**
     * @var array The underlying items of the collection.
     */
    protected array $items = [];

    /**
     * Arrhae constructor.
     *
     * Initializes the `Arrhae` instance with an optional array of items. This constructor is called when a new
     * instance of `Arrhae` is created, and it optionally accepts an array of items that will be stored internally.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Converts an iterable to an array.
     *
     * This helper method ensures that the provided items are converted to an array,
     * regardless of whether they are initially an array or a Traversable object.
     *
     * @param iterable $items The items to convert.
     *
     * @return array The converted array of items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     */
    protected function convertToArray(iterable $items) : array
    {
        if (is_array(value: $items)) {
            return $items;
        }

        return iterator_to_array(iterator: $items, preserve_keys: false);
    }

    /**
     * Creates a new locked collection instance from the given items.
     *
     * This named constructor enforces immutability by creating a locked collection,
     * preventing any modifications after instantiation - adhering to DDD value object principles.
     *
     * @template TKey of array-key
     * @template TValue
     * @param iterable<TKey, TValue> $items The source items to populate the collection
     *
     * @return static<TKey, TValue> A new locked collection instance
     * @throws \RuntimeException If the collection cannot be locked
     * @immutable
     */
    public static function lockedFrom(iterable $items) : self
    {
        // First create a new collection instance from the provided items
        // Then immediately lock it to ensure immutability
        return self::make(items: $items)->lock();
    }

    /**
     * Static factory method to create a new Arrhae instance.
     *
     * This method provides a convenient way to instantiate the Arrhae collection
     * with an initial set of items. It accepts any iterable data type, including
     * arrays and objects implementing the Traversable interface.
     *
     * @param iterable $items Initial items for the collection. Can be an array or any Traversable object.
     *
     * @return self A new instance of Arrhae initialized with the provided items.
     *
     * @throws InvalidArgumentException If the provided items cannot be converted to an array.
     *
     * @example
     * use Avax\DataHandling\Arrhae;
     *
     * // Creating a collection from an array
     * $collection = Arrhae::make(['apple', 'banana', 'cherry']);
     *
     * // Creating a collection from a Traversable object
     * $iterator = new ArrayIterator(['apple', 'banana', 'cherry']);
     * $collection = Arrhae::make($iterator);
     */
    public static function make(iterable $items = []) : self
    {
        return new self(items: $items);
    }

    /**
     * Creates an immutable copy of the current instance.
     *
     * This method ensures thread-safety and immutability by creating a deep clone
     * of the current instance and applying a lock mechanism to prevent further modifications.
     * Implement the Immutable Object Pattern for defensive programming.
     *
     * @return self Returns a new locked instance
     * @throws \RuntimeException If the locking mechanism fails
     * @since 8.3.0
     * @immutable
     * @final
     */
    public function toImmutable() : self
    {
        // Create a defensive copy and apply immutability lock
        return clone $this->lock();
    }

    /**
     * Retrieves all items in the `Arrhae` instance.
     *
     * This method returns all items currently stored in the instance as a plain array. It is helpful for getting
     * access to the full dataset.
     *
     * @return array All items in the instance as a standard array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * print_r($arrh->all()); // Output: [1, 2, 3]
     * ```
     */
    public function all() : array
    {
        return $this->items;
    }

    /**
     * Sets a value at the specified key using dot notation for nested arrays.
     *
     * This method allows setting a value at a specific key, even within nested arrays, by using dot notation.
     * If a nested array doesn't exist, it will be created automatically.
     *
     * @param string|int $key   The key to set, which may include dot notation for nested arrays.
     * @param mixed      $value The value to set at the specified key.
     *
     * @return $this Returns the current instance for method chaining.
     *
     * @throws InvalidArgumentException If the key is not a string or integer.
     *
     * ```
     * $arrh = new Arrhae();
     * $arrh->set('user.name', 'Alice');
     * print_r($arrh->all()); // Output: ['user' => ['name' => 'Alice']]
     * ```
     */
    public function set(string|int $key, mixed $value) : self
    {
        if (! is_string(value: $key) && ! is_int(value: $key)) {
            throw new InvalidArgumentException(message: "Key must be a string or an integer.");
        }

        $this->assertNotLocked();

        if (is_string(value: $key) && str_contains(haystack: $key, needle: '.')) {
            $array = &$this->items;
            foreach (explode(separator: '.', string: $key) as $segment) {
                if (! isset($array[$segment]) || ! is_array(value: $array[$segment])) {
                    $array[$segment] = [];
                }

                $array = &$array[$segment];
            }

            $array = $value;
        } else {
            $this->items[$key] = $value;
        }

        return $this;
    }

    /**
     * Checks if a specific key exists using dot notation for nested keys.
     *
     * This method checks if a key exists in the array. If the key contains dot notation, it checks recursively
     * through the nested arrays.
     *
     * @param string|int $key The key to check for existence.
     *
     * @return bool True if the key exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->has('user.name'); // Output: true
     * ```
     */
    public function has(string|int $key) : bool
    {
        return $this->get(key: $key) !== null;
    }

    /**
     * Gets a value by key using dot notation for nested arrays.
     *
     * This method retrieves a value for a specific key, supporting dot notation for nested keys.
     * If the key doesn't exist, it returns the provided default value.
     *
     * @param string|int $key     The key to retrieve, supports dot notation for nested arrays.
     * @param mixed      $default The default value to return if the key does not exist. Default is `null`.
     *
     * @return mixed The value associated with the key or the default if the key does not exist.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * echo $arrh->get('user.name'); // Output: 'Alice'
     * ```
     */
    public function get(string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists(key: $key, array: $this->items)) {
            return $this->items[$key];
        }

        if (is_string(value: $key) && str_contains(haystack: $key, needle: '.')) {
            $array = $this->items;
            foreach (explode(separator: '.', string: $key) as $segment) {
                if (is_array(value: $array) && array_key_exists(key: $segment, array: $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Removes an item by key, supporting dot notation for nested keys.
     *
     * This method removes a specific key and its associated value from the array. If the key is nested, dot notation
     * will be used to traverse through the levels and remove the item.
     *
     * @param string|int $key The key to remove.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae(['user' => ['name' => 'Alice']]);
     * $arrh->forget('user.name');
     * print_r($arrh->all()); // Output: ['user' => []]
     * ```
     */
    public function forget(string|int $key) : self
    {
        $this->assertNotLocked();

        if (array_key_exists(key: $key, array: $this->items)) {
            unset($this->items[$key]);
        } elseif (is_string(value: $key) && str_contains(haystack: $key, needle: '.')) {
            $array = &$this->items;
            $keys  = explode(separator: '.', string: $key);
            while (count(value: $keys) > 1) {
                $segment = array_shift(array: $keys);
                if (! isset($array[$segment]) || ! is_array(value: $array[$segment])) {
                    return $this;
                }

                $array = &$array[$segment];
            }

            unset($array[array_shift(array: $keys)]);
        }

        return $this;
    }

    /**
     * Appends a value to the end of the array.
     *
     * This method adds a new value to the end of the current array, allowing dynamic expansion of the items.
     *
     * @param mixed $value The value to append to the array.
     *
     * @return $this The current instance for method chaining.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $arrh->add(4);
     * print_r($arrh->all()); // Output: [1, 2, 3, 4]
     * ```
     */
    public function add(mixed $value) : self
    {
        $this->assertNotLocked();

        $this->items[] = $value;

        return $this;
    }

    /**
     * Returns an iterator for the array.
     *
     * This method returns an iterator that can be used to loop through the items in the array using a `foreach`
     * loop or other iteration methods.
     *
     * @return Traversable An iterator for the items in the collection.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * foreach ($arrh as $item) {
     *     echo $item; // Outputs: 1 2 3
     * }
     * ```
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->items);
    }

    /**
     * Counts the number of items in the array.
     *
     * This method returns the total number of items in the array, equivalent to the result of the `count()` function.
     *
     * @return int The number of items in the array.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->count(); // Output: 3
     * ```
     */
    public function count() : int
    {
        return count(value: $this->items);
    }

    /**
     * Extracts a list of values from the array using the specified key or applies a Closure.
     *
     * This method maps through the items and extracts the values associated with the specified key from each item.
     * If a Closure is provided instead of a key, it applies the Closure to each item and returns the results.
     * If a value doesn't exist or isn't an array when using a key, `null` is returned for that item.
     *
     * @param string|\Closure $key The key to pluck from each item or a Closure to apply to each item.
     *
     * @return array An array containing the plucked values or the results of the Closure for each item.
     *
     * ```
     * // Using a key
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'John'],
     *     ['id' => 2, 'name' => 'Jane'],
     *     ['id' => 3, 'name' => 'Bob']
     * ]);
     * $names = $arrh->pluck('name');
     * print_r($names); // Output: ['John', 'Jane', 'Bob']
     *
     * // Using a Closure
     * $ages = $arrh->pluck(function($item) {
     *     return $item['id'] * 10;
     * });
     * print_r($ages); // Output: [10, 20, 30]
     * ```
     */
    public function pluck(string|Closure $key) : array
    {
        return match (true) {
            $key instanceof Closure => array_map(callback: $key, array: $this->items),
            default                 => array_map(
                callback: static fn($item) => is_array(value: $item) && array_key_exists(key: $key, array: $item) ? $item[$key] : null,
                array   : $this->items
            ),
        };
    }

    /**
     * Retrieves a value from the items array using the specified key.
     *
     * This method retrieves the value associated with a specific key if it exists in the array, or returns
     * the provided default value if the key is absent.
     *
     * @param string $key     The key to retrieve from the items array.
     * @param mixed  $default The default value to return if the key doesn't exist. Default is `null`.
     *
     * @return mixed The value associated with the key, or the default value if the key doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['id' => 1, 'name' => 'Alice']);
     * echo $arrh->arrGet('name'); // Output: 'Alice'
     * echo $arrh->arrGet('age', 30); // Output: 30
     * ```
     */
    public function arrGet(string $key, mixed $default = null) : mixed
    {
        if (is_array(value: $this->items) && array_key_exists(key: $key, array: $this->items)) {
            return $this->items[$key];
        }

        return $default;
    }

    /**
     * Retrieves a nested value from an array using a dot-notated key.
     *
     * This method allows retrieving values from a nested array using a dot notation key. If the value is
     * not found at any level, it returns the provided default value.
     *
     * @param string $key     The dot-notated key to retrieve the value.
     * @param mixed  $default The default value to return if the key is not found.
     *
     * @return mixed The nested value associated with the key or the default value if not found.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->getValue('user.name'); // Output: 'Alice'
     * ```
     */
    public function getValue(string $key, mixed $default = null) : mixed
    {
        $firstItem = $this->first();
        if (! $firstItem || ! is_array(value: $firstItem)) {
            return $default;
        }

        foreach (explode(separator: '.', string: $key) as $segment) {
            if (is_array(value: $firstItem) && array_key_exists(key: $segment, array: $firstItem)) {
                $firstItem = $firstItem[$segment];
            } else {
                return $default;
            }
        }

        return $firstItem;
    }

    /**
     * Retrieves the first item in the array, optionally extracting a specific key using dot notation or applying a
     * Closure.
     *
     * This method returns the first item in the array. If a `$key` is provided, it retrieves the value associated
     * with that key using dot notation, similar to the `get()` method. If `$key` is a Closure, it applies the Closure
     * to the first item and returns the result. If the array is empty or the key does not exist, it returns `null` or
     * the provided default value.
     *
     * @param string|int|Closure|null $key      Optional key to retrieve from the first item, supports dot notation or
     *                                          a Closure.
     * @param mixed                   $default  The default value to return if the key is not found. Default is `null`.
     *
     * @return mixed The first item, the value of the specified key in the first item, the result of the Closure, or
     *               the default value.
     *
     * ```
     * // Without key
     * $arrh = new Arrhae([1, 2, 3]);
     * echo $arrh->first(); // Output: 1
     *
     * // With key
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice']],
     *     ['user' => ['name' => 'Bob']],
     * ]);
     * echo $arrh->first('user.name'); // Output: 'Alice'
     *
     * // With Closure
     * $arrh = new Arrhae([
     *     ['user' => ['name' => 'Alice', 'age' => 25]],
     *     ['user' => ['name' => 'Bob', 'age' => 30]],
     * ]);
     * $firstUserAge = $arrh->first(function($item) {
     *     return $item['user']['age'];
     * });
     * echo $firstUserAge; // Output: 25
     *
     * // With key that does not exist
     * echo $arrh->first('user.gender', 'unknown'); // Output: 'unknown'
     * ```
     * @noinspection PhpParameterNameChangedDuringInheritanceInspection
     */
    public function first(string|int|Closure|null $key = null, mixed $default = null) : mixed
    {
        if ($this->items === []) {
            return $default;
        }

        $firstItem = reset(array: $this->items);
        if ($key === null) {
            return $firstItem;
        }

        if ($key instanceof Closure) {
            return $key($firstItem);
        }

        return $this->getFromItem(item: $firstItem, key: $key, default: $default);
    }

    /**
     * Retrieves a value from a single array item using a key with dot notation or applies a Closure.
     *
     * This helper method is used internally to extract a value from a single array item using a dot-notated key
     * or apply a Closure to it.
     *
     * @param mixed               $item    The array item to extract the value from.
     * @param string|int|\Closure $key     The key to retrieve, supports dot notation or a Closure.
     * @param mixed               $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key, the result of the Closure, or the default value if the key does
     *               not exist.
     */
    protected function getFromItem(mixed $item, string|int|Closure $key, mixed $default = null) : mixed
    {
        if ($key instanceof Closure) {
            return $key($item);
        }

        if (is_array(value: $item)) {
            return $this->getValueFromArray(array: $item, key: $key, default: $default);
        }

        return $default;
    }

    /**
     * Retrieves a value from an array using a key with dot notation.
     *
     * This helper method is used internally to extract a value from an array using a dot-notated key.
     *
     * @param array      $array   The array to extract the value from.
     * @param string|int $key     The key to retrieve, supports dot notation.
     * @param mixed      $default The default value to return if the key does not exist.
     *
     * @return mixed The value associated with the key or the default value if the key does not exist.
     */
    protected function getValueFromArray(array $array, string|int $key, mixed $default = null) : mixed
    {
        if (array_key_exists(key: $key, array: $array)) {
            return $array[$key];
        }

        if (is_string(value: $key) && str_contains(haystack: $key, needle: '.')) {
            $segments = explode(separator: '.', string: $key);
            foreach ($segments as $segment) {
                if (is_array(value: $array) && array_key_exists(key: $segment, array: $array)) {
                    $array = $array[$segment];
                } else {
                    return $default;
                }
            }

            return $array;
        }

        return $default;
    }

    /**
     * Determines whether some items in the array match a given condition.
     *
     * This method iterates over the items and applies the callback function to each item. It returns `true`
     * if the callback returns `true` for any item, and `false` otherwise.
     *
     * @param callable $callback The callback to apply to each item.
     *
     * @return bool `true` if at least one item satisfies the condition, `false` otherwise.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->some(fn($item) => $item > 2); // Output: true
     * ```
     */
    public function some(callable $callback) : bool
    {
        foreach ($this->items as $item) {
            if ($callback($item)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Determines if the collection is operating in batch mode.
     *
     * Batch mode indicates that the collection is handling multiple items
     * as a single unit of work, which can be useful for bulk operations
     * and performance optimization in data processing scenarios.
     *
     * @return bool True if the collection is in batch mode, false otherwise
     *
     * @since 1.0.0
     * @api
     *
     * @see   \Avax\DataHandling\ArrayHandling\Arrhae::setItems() For setting batch mode
     */
    public function isBatch() : bool
    {
        // Verify the existence of 'batch' flag in the internal items collection
        return isset($this->items['batch']);
    }

    /**
     * Retrieves the items stored in the `Arrhae` instance.
     *
     * This is a protected method that returns the array of items, which is useful in internal operations.
     *
     * @return array The items in the collection.
     */
    protected function getItems() : array
    {
        return $this->items;
    }

    /**
     * Sets the array of items for the current instance.
     *
     * This method allows setting a new array of items for the `Arrhae` instance. It is useful when you want
     * to replace the current set of items with a different array.
     *
     * @param array|iterable $items The new items array to set.
     *
     * @return $this The current instance for method chaining.
     */
    protected function setItems(iterable $items) : static
    {
        $this->assertNotLocked();

        $this->items = $items;

        return $this;
    }
}

=== ArrayHandling/Traits/AbstractDependenciesTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

/**
 * This trait provides common query operations for collections.
 * It includes methods for filtering and checking the existence of items based on different conditions.
 */
trait AbstractDependenciesTrait
{
    /**
     * Retrieve the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @return array The items in the collection.
     */
    abstract protected function getItems() : array;

    /**
     * Sets the items in the collection.
     *
     * This method is abstract and should be implemented in any class using this trait.
     *
     * @param array $items The items to set in the collection.
     */
    abstract protected function setItems(array $items) : static;
}

=== ArrayHandling/Traits/AdvancedStringSearchTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use FuzzyWuzzy\Fuzz;
use FuzzyWuzzy\Process;
use InvalidArgumentException;

/**
 * Trait AdvancedStringSearchTrait
 *
 * Provides advanced string search functionalities for collections, including fuzzy search and similarity-based search.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait AdvancedStringSearchTrait
{
    /**
     * Performs a fuzzy match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the query and each item using FuzzyWuzzy,
     * returning items that meet or exceed the specified similarity threshold.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->fuzzyMatch('aple', 80);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->fuzzyMatch('Alic', 70, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * //     ['name' => 'Alina'],
     * // ]
     */
    public function fuzzyMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold(threshold: $threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower(string: $query), s2: strtolower(string: $target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Helper method to validate the threshold.
     *
     * @param float $threshold The threshold to validate.
     *
     *
     * @throws InvalidArgumentException If the threshold is not between 0 and 100.
     */
    protected function isProperThreshold(float $threshold) : void
    {
        if ($threshold < 0 || $threshold > 100) {
            throw new InvalidArgumentException(message: 'Threshold must be between 0 and 100.');
        }
    }

    /**
     * Searches for items with a similarity percentage above a specified threshold.
     *
     * This method uses the similarity percentage between the query and each item to determine matches.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100).
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->similaritySearch('apple', 80);
     * // Returns ['apple', 'aple', 'apply']
     *
     * $arrhAssoc = new Arrhae([
     *     ['title' => 'Introduction to PHP'],
     *     ['title' => 'Advanced PHP Techniques'],
     *     ['title' => 'PHP for Beginners'],
     *     ['title' => 'JavaScript Essentials'],
     * ]);
     * $resultsAssoc = $arrhAssoc->similaritySearch('PHP Intro', 70, 'title');
     * // Returns [
     * //     ['title' => 'Introduction to PHP'],
     * //     ['title' => 'PHP for Beginners'],
     * // ]
     */
    public function similaritySearch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold(threshold: $threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: function ($item) use ($key, $fuzz, $query, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                $similarity = $fuzz->ratio(s1: strtolower(string: $query), s2: strtolower(string: $target));

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Performs a Levenshtein-based search and sorts the results by similarity.
     *
     * This method finds items within a certain distance from the query and sorts them by their similarity to the query.
     *
     * @param string      $query       The search query string.
     * @param int|null    $maxDistance The maximum Levenshtein distance allowed.
     * @param string|null $key         The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items sorted by similarity.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'apricot', 'banana', 'grape', 'pineapple']);
     * $results = $arrh->levenshteinSearch('appel', 2);
     * // Returns ['apple']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->levenshteinSearch('Alic', 2, 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function levenshteinSearch(string $query, int|null $maxDistance = null, string|null $key = null) : static
    {
        $maxDistance ??= 2;
        if ($maxDistance < 0) {
            throw new InvalidArgumentException(message: 'Maximum distance cannot be negative.');
        }

        $matchedItems = [];

        foreach ($this->getItems() as $item) {
            $target = $key !== null ? ($item[$key] ?? '') : $item;

            if (! is_string(value: $target)) {
                continue;
            }

            $distance = levenshtein(string1: strtolower(string: $query), string2: strtolower(string: $target));

            if ($distance <= $maxDistance) {
                $matchedItems[$distance][] = $item;
            }
        }

        ksort(array: $matchedItems);

        // Flatten the array while preserving order
        $sortedMatchedItems = [];
        foreach ($matchedItems as $matchedItem) {
            foreach ($matchedItem as $item) {
                $sortedMatchedItems[] = $item;
            }
        }

        return new static(items: $sortedMatchedItems);
    }

    /**
     * Performs a partial match on the collection items based on a given query.
     *
     * This method checks if the query string is a substring of the target string.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->partialMatch('app');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->partialMatch('Ali', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function partialMatch(string $query, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: static function ($item) use ($key, $query) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                // Check if query is a substring of target
                return stripos(haystack: $target, needle: $query) !== false;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Performs a token sort match on the collection items based on a given query.
     *
     * This method sorts the tokens in both the query and target strings and then calculates the similarity ratio.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSortMatch('banana apple', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSortMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold(threshold: $threshold);

        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Sort tokens in the query
        $sortedQuery = $this->sortTokens(string: $query);

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: function ($item) use ($key, $fuzz, $sortedQuery, $threshold) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                // Sort tokens in the target
                $sortedTarget = $this->sortTokens(string: $target);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Helper method to sort tokens in a string.
     *
     * @param string $string The string to sort tokens for.
     *
     * @return string The string with sorted tokens.
     */
    protected function sortTokens(string $string) : string
    {
        $tokens = explode(separator: ' ', string: strtolower(string: $string));
        sort(array: $tokens); // Sort tokens in ascending order

        return implode(separator: ' ', array: $tokens);
    }

    /**
     * Performs a token set match on the collection items based on a given query.
     *
     * This method calculates the similarity ratio between the unique tokens of the query and target strings.
     *
     * @param string      $query     The search query string.
     * @param float|null  $threshold The minimum similarity percentage (0 to 100) required for a match.
     * @param string|null $key       The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple banana', 'banana apple', 'apple grape', 'banana grape']);
     * $results = $arrh->tokenSetMatch('apple banana', 90);
     * // Returns ['apple banana', 'banana apple']
     */
    public function tokenSetMatch(string $query, float|null $threshold = null, string|null $key = null) : static
    {
        $threshold ??= 70.0;
        $this->isProperThreshold(threshold: $threshold);

        // Initializing FuzzyWuzzy components
        $fuzz    = new Fuzz();
        $process = new Process(fuzz: $fuzz);

        // Get unique tokens in the query
        $uniqueQueryTokens = array_unique(array: explode(separator: ' ', string: strtolower(string: $query)));
        sort(array: $uniqueQueryTokens);
        $sortedQuery = implode(separator: ' ', array: $uniqueQueryTokens);

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: function ($item) use ($key, $fuzz, $sortedQuery, $threshold, $process) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                // Get unique tokens in the target
                $uniqueTargetTokens = array_unique(array: explode(separator: ' ', string: strtolower(string: $target)));
                sort(array: $uniqueTargetTokens);
                $sortedTarget = implode(separator: ' ', array: $uniqueTargetTokens);

                // Calculating similarity using FuzzyWuzzy
                $similarity = $fuzz->ratio(s1: $sortedQuery, s2: $sortedTarget);

                return $similarity >= $threshold;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Performs a phonetic match on the collection items based on a given query.
     *
     * This method uses the Metaphone algorithm to find phonetically similar strings.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['Smith', 'Smyth', 'Smithe', 'Johnson']);
     * $results = $arrh->phoneticMatch('Smyth');
     * // Returns ['Smith', 'Smyth', 'Smithe']
     */
    public function phoneticMatch(string $query, string|null $key = null) : static
    {
        $queryPhonetic = metaphone(string: strtolower(string: $query));

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: static function ($item) use ($key, $queryPhonetic) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                // Calculate phonetic code
                $targetPhonetic = metaphone(string: strtolower(string: $target));

                return $queryPhonetic === $targetPhonetic;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Performs a regular expression search on the collection items based on a given pattern.
     *
     * This method returns items that match the provided regular expression pattern.
     *
     * @param string      $pattern The regular expression pattern.
     * @param string|null $key     The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @throws InvalidArgumentException If the provided pattern is invalid.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->regexSearch('/^ap/');
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Alicia'],
     *     ['name' => 'Alina'],
     *     ['name' => 'Bob'],
     * ]);
     * $resultsAssoc = $arrhAssoc->regexSearch('/^Ali/', 'name');
     * // Returns [
     * //     ['name' => 'Alice'],
     * //     ['name' => 'Alicia'],
     * // ]
     */
    public function regexSearch(string $pattern, string|null $key = null) : static
    {
        if (@preg_match(pattern: $pattern, subject: '') === false) {
            throw new InvalidArgumentException(message: 'Invalid regular expression pattern.');
        }

        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: static function ($item) use ($key, $pattern) : bool {
                $target = $key !== null ? ($item[$key] ?? '') : $item;

                if (! is_string(value: $target)) {
                    return false;
                }

                return preg_match(pattern: $pattern, subject: $target) === 1;
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Performs a custom match on the collection items using a user-defined callback.
     *
     * This method allows for highly flexible and customizable search criteria.
     *
     * @param callable    $callback The callback function to determine a match. Should return a boolean.
     * @param string|null $key      The key to search within if items are associative arrays.
     *
     * @return static A new instance containing the matched items.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'banana', 'apricot', 'grape']);
     * $results = $arrh->customMatch(function($item) {
     *     return strpos($item, 'ap') === 0;
     * });
     * // Returns ['apple', 'apricot']
     *
     * $arrhAssoc = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30],
     *     ['name' => 'Alicia', 'age' => 25],
     *     ['name' => 'Alina', 'age' => 28],
     *     ['name' => 'Bob', 'age' => 35],
     * ]);
     * $resultsAssoc = $arrhAssoc->customMatch(function($value, $item) {
     *     return $item['age'] > 27;
     * }, 'age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 30],
     * //     ['name' => 'Alina', 'age' => 28],
     * // ]
     */
    public function customMatch(callable $callback, string|null $key = null) : static
    {
        $matchedItems = array_filter(
            array   : $this->getItems(),
            callback: static function ($item) use ($key, $callback) {
                $target = $key !== null ? ($item[$key] ?? null) : $item;

                return $callback($target, $item);
            }
        );

        return new static(items: array_values(array: $matchedItems));
    }

    /**
     * Sorts the matched items by similarity in descending order.
     *
     * This method is typically used after a search to rank the results based on how closely they match the query.
     *
     * @param string      $query The search query string.
     * @param string|null $key   The key to search within if items are associative arrays.
     *
     * @return array An array of matched items sorted by similarity.
     *
     * @example
     * $arrh = new Arrhae(['apple', 'aple', 'apply', 'banana']);
     * $results = $arrh->fuzzyMatch('apple', 60, 'name')->sortBySimilarity('apple', 'name');
     * // Returns items sorted by similarity to 'apple'
     */
    public function sortBySimilarity(string $query, string|null $key = null) : array
    {
        $queryLower = strtolower(string: $query);

        $sortedItems = $this->getItems();
        usort(array: $sortedItems, callback: function ($a, $b) use ($key, $queryLower) : int {
            $fuzz   = new Fuzz();
            $aValue = $key !== null ? ($a[$key] ?? '') : $a;
            $bValue = $key !== null ? ($b[$key] ?? '') : $b;

            if (! is_string(value: $aValue) || ! is_string(value: $bValue)) {
                return 0;
            }

            $similarityA = $fuzz->ratio(s1: $queryLower, s2: strtolower(string: $aValue));
            $similarityB = $fuzz->ratio(s1: $queryLower, s2: strtolower(string: $bValue));

            return $similarityB <=> $similarityA;
        });

        return $sortedItems;
    }
}

=== ArrayHandling/Traits/AggregationTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use LogicException;

/**
 * Trait AggregationTrait
 *
 * Provides robust aggregation methods for handling data collections.
 * Supports summation, averaging, min/max determination, and counting by keys or callbacks.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It offers flexible methods
 * that can operate on specific keys or use callbacks for dynamic value extraction.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait AggregationTrait
{
    /**
     * Calculate the average of values for a specified key or callback.
     *
     * This method computes the average (arithmetic mean) of all numeric values obtained
     * from the specified key or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float The resulting average or 0.0 if the collection is empty.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $averageScore = $arrh->average('score'); // Returns 80.0
     *
     * // Using a callback to calculate average age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $averageAge = $arrh->average(fn($item) => $item['age']); // Returns 30.0
     * ```
     */
    public function average(string|callable $key) : float
    {
        $count = count(value: $this->getItems());

        return $count !== 0 ? $this->sum(key: $key) / $count : 0.0;
    }

    /**
     * Sum the values of a specified key or computed by a callback.
     *
     * This method calculates the total sum of all numeric values obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return float|int The resulting sum of the values.
     *
     * @throws InvalidArgumentException If non-numeric values are encountered during sum calculation.
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'amount' => 100.50],
     *     ['id' => 2, 'amount' => 200.75],
     *     ['id' => 3, 'amount' => 150.25],
     * ]);
     * $totalAmount = $arrh->sum('amount'); // Returns 451.5
     *
     * // Using a callback to sum ages
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $totalAge = $arrh->sum(fn($item) => $item['age']); // Returns 90
     * ```
     */
    public function sum(string|callable $key) : float|int
    {
        $this->validateData();

        return array_reduce(
            array   : $this->getItems(),
            callback: static function ($carry, $item) use ($key) : int|float {
                $value = is_callable(value: $key) ? $key($item) : ($item[$key] ?? 0);

                if (! is_numeric(value: $value)) {
                    throw new InvalidArgumentException(message: 'Non-numeric value encountered in sum calculation.');
                }

                return $carry + $value;
            },
            initial : 0
        );
    }

    /**
     * Validate the data structure before applying aggregation.
     *
     * Ensures that the collection is a valid array. This prevents unexpected errors
     * during aggregation operations.
     *
     * @throws LogicException If `getItems` does not return a valid array.
     */
    private function validateData() : void
    {
        $items = $this->getItems();

        if (! is_array(value: $items)) {
            throw new LogicException(message: 'Expected data to be an array.');
        }
    }

    /**
     * Find the minimum value for a specified key or callback.
     *
     * This method identifies the smallest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The minimum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $minScore = $arrh->min('score'); // Returns 70
     *
     * // Using a callback to find minimum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $minAge = $arrh->min(fn($item) => $item['age']); // Returns 25
     * ```
     */
    public function min(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException(message: 'Cannot determine minimum value of an empty collection.');
        }

        return min(value: $values);
    }

    /**
     * Map items to values based on a key or callback.
     *
     * Extracts values from each item in the collection based on the specified key or by applying a callback.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array The extracted values.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Mapping scores
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $scores = $arrh->mapValues('score'); // Returns [80, 90, 70]
     *
     * // Using a callback to extract names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $names = $arrh->mapValues(fn($item) => $item['name']); // Returns ['Alice', 'Bob', 'Charlie']
     * ```
     */
    private function mapValues(string|callable $key) : array
    {
        $this->validateData();

        return array_map(
            callback: static fn($item) => is_callable(value: $key) ? $key($item) : ($item[$key] ?? null),
            array   : $this->getItems()
        );
    }

    /**
     * Find the maximum value for a specified key or callback.
     *
     * This method identifies the largest numeric value obtained from the specified key
     * or by applying a callback to each item in the collection.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return mixed The maximum value.
     *
     * @throws LogicException If the collection is empty or contains non-numeric values.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $maxScore = $arrh->max('score'); // Returns 90
     *
     * // Using a callback to find maximum age
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     * ]);
     * $maxAge = $arrh->max(fn($item) => $item['age']); // Returns 35
     * ```
     */
    public function max(string|callable $key) : mixed
    {
        $values = $this->mapValues(key: $key);

        if (empty($values)) {
            throw new LogicException(message: 'Cannot determine maximum value of an empty collection.');
        }

        return max(value: $values);
    }

    /**
     * Count occurrences of unique values by a specified key or callback.
     *
     * This method tallies the number of times each unique value appears in the collection,
     * based on the specified key or by applying a callback to each item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the value.
     *
     * @return array Associative array with counts for each unique value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $categoryCounts = $arrh->countBy('category');
     * // Returns ['A' => 2, 'B' => 2, 'C' => 1]
     *
     * // Using a callback to count based on a derived value
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 30],
     * ]);
     * $ageCounts = $arrh->countBy(fn($item) => $item['age']);
     * // Returns [25 => 1, 30 => 2, 35 => 1]
     * ```
     */
    public function countBy(string|callable $key) : array
    {
        $this->validateData();

        $result = [];
        foreach ($this->getItems() as $item) {
            $value          = is_callable(value: $key) ? $key($item) : ($item[$key] ?? null);
            $result[$value] = ($result[$value] ?? 0) + 1;
        }

        return $result;
    }

    /**
     * Reduce the collection to a single value using a callback.
     *
     * This method applies a callback function cumulatively to the items of the collection,
     * from left to right, to reduce the collection to a single value.
     *
     * @param callable   $callback  Callback to apply to each item. It should accept two parameters:
     *                              the carry (accumulator) and the current item.
     * @param mixed|null $initial   Initial value to start the reduction. If not provided, the first item of the
     *                              collection is used.
     *
     * @return mixed The reduced value.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $product = $arrh->reduce(fn($carry, $item) => $carry * $item, 1); // Returns 24
     *
     * // Using reduce to concatenate names
     * $arrh = new Arrhae([
     *     ['name' => 'Alice'],
     *     ['name' => 'Bob'],
     *     ['name' => 'Charlie'],
     * ]);
     * $names = $arrh->reduce(fn($carry, $item) => $carry . ', ' . $item['name'], '');
     * // Returns ', Alice, Bob, Charlie'
     * ```
     */
    public function reduce(callable $callback, mixed $initial = null) : mixed
    {
        $this->validateData();

        return array_reduce(array: $this->getItems(), callback: $callback, initial: $initial);
    }

    /**
     * Group items by a specified key or callback.
     *
     * This method organizes the collection into groups based on the specified key or by applying a callback to each
     * item.
     *
     * @param string|callable $key The key to extract values from each item or a callable that returns the grouping
     *                             value.
     *
     * @return array The grouped items.
     *
     * @throws LogicException If the data structure is invalid.
     *
     * ```
     * // Grouping by category
     * $arrh = new Arrhae([
     *     ['id' => 1, 'category' => 'A'],
     *     ['id' => 2, 'category' => 'B'],
     *     ['id' => 3, 'category' => 'A'],
     *     ['id' => 4, 'category' => 'C'],
     *     ['id' => 5, 'category' => 'B'],
     * ]);
     * $grouped = $arrh->aggregateGroupBy('category');
     *
     * Returns:
     * [
     *     'A' => [
     *         ['id' => 1, 'category' => 'A'],
     *         ['id' => 3, 'category' => 'A'],
     *     ],
     *     'B' => [
     *         ['id' => 2, 'category' => 'B'],
     *         ['id' => 5, 'category' => 'B'],
     *     ],
     *     'C' => [
     *         ['id' => 4, 'category' => 'C'],
     *     ],
     * ]
     *
     *
     * // Grouping by age range using a callback
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 35],
     *     ['name' => 'David', 'age' => 40],
     * ]);
     * $groupedByAgeRange = $arrh->aggregateGroupBy(function($item) {
     *     if ($item['age'] < 30) {
     *         return 'Under 30';
     *     } elseif ($item['age'] < 40) {
     *         return '30-39';
     *     } else {
     *         return '40 and above';
     *     }
     * });
     *
     * Returns:
     * [
     *     'Under 30' => [
     *         ['name' => 'Alice', 'age' => 25],
     *     ],
     *     '30-39' => [
     *         ['name' => 'Bob', 'age' => 30],
     *         ['name' => 'Charlie', 'age' => 35],
     *     ],
     *     '40 and above' => [
     *         ['name' => 'David', 'age' => 40],
     *     ],
     * ]
     *
     */
    public function aggregateGroupBy(string|callable $key) : array
    {
        $this->validateData();

        $grouped = [];
        foreach ($this->getItems() as $item) {
            $groupKey             = is_callable(value: $key) ? $key($item) : ($item[$key] ?? null);
            $grouped[$groupKey][] = $item;
        }

        return $grouped;
    }
}

=== ArrayHandling/Traits/ArrayAccessTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ArrayAccessTrait
 *
 * Provides array-like access to a collection of items, enabling operations such as
 * checking existence, retrieving, setting, unsetting, and manipulating multiple items.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait ArrayAccessTrait
{
    use AbstractDependenciesTrait;

    /**
     * Check if an offset exists in the collection items.
     *
     * Determines whether a specific key or index exists within the collection.
     *
     * @param mixed $offset The offset to check.
     *
     * @return bool True if the offset exists, false otherwise.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $exists = $arrh->offsetExists(1); // Returns true
     * $exists = $arrh->offsetExists(5); // Returns false
     * ```
     */
    public function offsetExists(mixed $offset) : bool
    {
        return isset($this->getItems()[$offset]);
    }

    /**
     * Get the value at a specific offset in the collection.
     *
     * Retrieves the value associated with a given key or index. Returns null if the offset does not exist.
     *
     * @param mixed $offset The offset to retrieve.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->offsetGet(1); // Returns 'banana'
     * $fruit = $arrh->offsetGet(5); // Returns null
     * ```
     */
    public function offsetGet(mixed $offset) : mixed
    {
        return $this->getItems()[$offset] ?? null;
    }

    /**
     * Set a value at a specific offset in the collection.
     *
     * Assigns a value to a specified key or index. If the offset is null, the value is appended to the collection.
     *
     * @param mixed $offset The offset to assign the value to.
     * @param mixed $value  The value to set.
     *
     *
     * @throws InvalidArgumentException If the key is invalid or cannot be set.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->offsetSet(1, 'blueberry'); // Collection becomes ['apple', 'blueberry']
     * $arrh->offsetSet(null, 'cherry'); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function offsetSet(mixed $offset, mixed $value) : void
    {
        $items = $this->getItems();
        if (is_null(value: $offset)) {
            $items[] = $value;
        } else {
            $items[$offset] = $value;
        }

        $this->setItems(items: $items);
    }

    /**
     * Unset the value at a specific offset in the collection.
     *
     * Removes the value associated with a given key or index from the collection.
     *
     * @param mixed $offset The offset to unset.
     *
     *
     * @throws InvalidArgumentException If the offset cannot be unset.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->offsetUnset(1); // Collection becomes ['apple', 'cherry']
     * ```
     */
    public function offsetUnset(mixed $offset) : void
    {
        $items = $this->getItems();
        unset($items[$offset]);
        $this->setItems(items: $items);
    }

    /**
     * Retrieve multiple values by an array of offsets.
     *
     * Fetches values corresponding to the provided array of keys or indexes.
     *
     * @param array $keys The offsets to retrieve.
     *
     * @return array An array of values corresponding to the given offsets.
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * $fruits = $arrh->getMultiple([0, 2]); // Returns ['apple', 'cherry']
     * ```
     */
    public function getMultiple(array $keys) : array
    {
        $items = $this->getItems();

        return array_intersect_key($items, array_flip(array: $keys));
    }

    /**
     * Set multiple values at once.
     *
     * Assigns multiple values to the collection based on an associative array of offsets and values.
     *
     * @param array $values An associative array of offsets and their corresponding values.
     *
     *
     * @throws InvalidArgumentException If any of the keys are invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $arrh->setMultiple([1 => 'blueberry', 2 => 'cherry']); // Collection becomes ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function setMultiple(array $values) : void
    {
        $items = $this->getItems();

        foreach ($values as $key => $value) {
            $items[$key] = $value;
        }

        $this->setItems(items: $items);
    }

    /**
     * Retrieve and remove an item by its offset.
     *
     * Fetches the value at the specified offset and removes it from the collection.
     *
     * @param mixed $offset The offset to retrieve and remove.
     *
     * @return mixed|null The value at the specified offset, or null if it doesn't exist.
     *
     * @throws InvalidArgumentException If the offset is invalid.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $fruit = $arrh->pull(1); // Returns 'banana' and collection becomes ['apple', 'cherry']
     * $fruit = $arrh->pull(5); // Returns null
     * ```
     */
    public function pull(mixed $offset) : mixed
    {
        $items = $this->getItems();
        $value = $items[$offset] ?? null;

        if (array_key_exists(key: $offset, array: $items)) {
            unset($items[$offset]);
            $this->setItems(items: $items);
        }

        return $value;
    }

    /**
     * Swap two items in the collection.
     *
     * Exchanges the values at the specified offsets within the collection.
     *
     * @param mixed $offset1 The first offset.
     * @param mixed $offset2 The second offset.
     *
     *
     * @throws OutOfBoundsException If either offset does not exist.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->swap(0, 2); // Collection becomes ['cherry', 'banana', 'apple']
     *
     * $arrh->swap(1, 3); // Throws OutOfBoundsException
     * ```
     */
    public function swap(mixed $offset1, mixed $offset2) : void
    {
        $items = $this->getItems();

        if (! isset($items[$offset1]) || ! isset($items[$offset2])) {
            throw new OutOfBoundsException(message: "One or both offsets do not exist.");
        }

        [$items[$offset1], $items[$offset2]] = [$items[$offset2], $items[$offset1]];

        $this->setItems(items: $items);
    }

    /**
     * Retrieve all keys of the collection.
     *
     * Provides an array of all keys or indexes present in the collection.
     *
     * @return array An array of keys.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $keys = $arrh->keys(); // Returns [0, 1, 2]
     * ```
     */
    public function keys() : array
    {
        return array_keys(array: $this->getItems());
    }

    /**
     * Retrieve all values of the collection.
     *
     * Provides an array of all values present in the collection.
     *
     * @return array An array of values.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $values = $arrh->values(); // Returns ['apple', 'banana', 'cherry']
     * ```
     */
    public function values() : array
    {
        return array_values(array: $this->getItems());
    }
}

=== ArrayHandling/Traits/ArrayConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Exception;
use InvalidArgumentException;
use LogicException;
use SimpleXMLElement;

/**
 * Trait ArrayConversionTrait
 *
 * Provides methods to convert the collection to various formats such as JSON, XML, and arrays.
 * Also includes methods to filter the collection by including or excluding specific keys.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait ArrayConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Convert the collection to a JSON string.
     *
     * This method serializes the collection into a JSON-formatted string. It accepts optional
     * JSON encoding options to customize the output.
     *
     * @param int $options Optional JSON encoding options. Default is 0.
     *
     * @return string JSON-encoded string representation of the collection.
     *
     * @throws InvalidArgumentException If the collection contains data that cannot be encoded to JSON.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $json = $arrh->toJson(); // Returns '["apple","banana","cherry"]'
     *
     * // With JSON_PRETTY_PRINT option
     * $jsonPretty = $arrh->toJson(JSON_PRETTY_PRINT);
     * /*
     * Returns:
     * [
     *     "apple",
     *     "banana",
     *     "cherry"
     * ]
     *
     */
    public function toJson(int $options = 0) : string
    {
        $json = json_encode(value: $this->toArray(), flags: $options);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new InvalidArgumentException(
                message: 'Failed to encode collection to JSON: ' . json_last_error_msg()
            );
        }

        return $json;
    }

    /**
     * Convert the collection and nested collections to an array.
     *
     * This method recursively converts each item in the collection to an array if it implements
     * the `toArray` method. Otherwise, it retains the item's original value.
     *
     * @return array Array representation of the collection.
     *
     * @throws LogicException If the collection contains non-escapable items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'score' => 80],
     *     ['id' => 2, 'score' => 90],
     *     ['id' => 3, 'score' => 70],
     * ]);
     * $array = $arrh->toArray();
     * // Returns [
     * //     ['id' => 1, 'score' => 80],
     * //     ['id' => 2, 'score' => 90],
     * //     ['id' => 3, 'score' => 70],
     * // ]
     * ```
     */
    public function toArray() : array
    {
        return array_map(callback: static function ($item) {
            if (is_object(value: $item) && method_exists(object_or_class: $item, method: 'toArray')) {
                return $item->toArray();
            }

            return $item;
        },               array   : $this->getItems());
    }

    /**
     * Convert the collection to an XML string with a customizable root element.
     *
     * This method serializes the collection into an XML-formatted string. It allows specifying
     * a custom root element name. All values are escaped to ensure valid XML.
     *
     * @param string $rootElement The root element name for the XML. Default is 'root'.
     *
     * @return string XML representation of the collection.
     *
     * @throws Exception If the XML conversion fails.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $xml = $arrh->toXml('fruits');
     * /*
     * Returns:
     * <?xml version="1.0"?>
     * <fruits>
     *     <item>apple</item>
     *     <item>banana</item>
     *     <item>cherry</item>
     * </fruits>
     *
     */
    public function toXml(string $rootElement = 'root') : string
    {
        try {
            $xml = new SimpleXMLElement(data: sprintf('<%s/>', $rootElement));
            $this->arrayToXml(data: $this->toArray(), xml: $xml);

            return $xml->asXML();
        } catch (Exception $exception) {
            throw new Exception(
                message : 'Failed to convert collection to XML: ' . $exception->getMessage(),
                code    : $exception->getCode(),
                previous: $exception
            );
        }
    }

    /**
     * Helper method to recursively convert an array to XML.
     *
     * @param array            $data The data to convert.
     * @param SimpleXMLElement $xml  The XML element to append data to.
     */
    private function arrayToXml(array $data, SimpleXMLElement &$xml) : void
    {
        foreach ($data as $key => $value) {
            // Handle numeric keys by using 'item' as the tag name
            if (is_numeric(value: $key)) {
                $key = 'item';
            }

            if (is_array(value: $value)) {
                $child = $xml->addChild(qualifiedName: $key);
                $this->arrayToXml(data: $value, xml: $child);
            } else {
                $xml->addChild(qualifiedName: $key, value: htmlspecialchars(string: (string) $value));
            }
        }
    }

    /**
     * Include only specified keys in the collection.
     *
     * This method filters the collection to retain only the specified keys. It returns a new
     * instance of the collection with the filtered items.
     *
     * @param array $keys Keys to retain in the collection.
     *
     * @return static Collection instance with specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->only(['name', 'city']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function only(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            array   : $this->getItems(),
            callback: static fn($item, $key) : bool => in_array(needle: $key, haystack: $keys, strict: true),
            mode    : ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Exclude specified keys from the collection.
     *
     * This method filters the collection to remove the specified keys. It returns a new
     * instance of the collection without the excluded items.
     *
     * @param array $keys Keys to exclude from the collection.
     *
     * @return static Collection instance without specified keys.
     *
     * @throws InvalidArgumentException If the keys array is empty.
     *
     * ```
     * $arrh = new Arrhae(['name' => 'Alice', 'age' => 25, 'city' => 'Wonderland']);
     * $filtered = $arrh->except(['age']);
     * // Returns ['name' => 'Alice', 'city' => 'Wonderland']
     * ```
     */
    public function except(array $keys) : static
    {
        if ($keys === []) {
            throw new InvalidArgumentException(message: 'Keys array cannot be empty.');
        }

        $filteredItems = array_filter(
            array   : $this->getItems(),
            callback: static fn($item, $key) : bool => ! in_array(needle: $key, haystack: $keys, strict: true),
            mode    : ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }
}

=== ArrayHandling/Traits/CollectionWalkthroughTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait CollectionWalkthroughTrait
 *
 * A comprehensive trait for traversing, querying, filtering, and searching collections.
 * This trait combines essential methods to enable structured and efficient collection handling.
 *
 * It is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait CollectionWalkthroughTrait
{
    use AbstractDependenciesTrait;

    /** ***Traversal and Filtering Methods*** */

    /**
     * Applies a callback to each item in the collection, transforming the items
     * and returning a new collection with the modified values.
     *
     * This method allows for the transformation of each item in the collection by
     * applying the provided callback function. The resulting collection contains
     * the transformed items.
     *
     * @param Closure $callback The callback to apply to each item. It should accept the item as a parameter and return
     *                          the transformed value.
     *
     * @return static A new instance with the mapped items.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $squared = $arrh->map(fn($item) => $item * $item); // Returns [1, 4, 9]
     * ```
     */
    public function map(Closure $callback) : static
    {
        $mappedItems = array_map(callback: $callback, array: $this->getItems());

        return new static(items: $mappedItems);
    }

    /**
     * Applies a callback to each item in the collection without modifying it.
     *
     * This method iterates over each item in the collection and applies the provided callback.
     * It is useful for performing operations that do not require modifying the collection,
     * such as logging or side effects.
     *
     * @param Closure $callback The callback to apply. It should accept the item and its key as parameters.
     *
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->each(fn($item) => echo $item . "\n");
     * // Outputs:
     * // apple
     * // banana
     * // cherry
     * ```
     */
    public function each(Closure $callback) : void
    {
        foreach ($this->getItems() as $key => $item) {
            $callback($item, $key);
        }
    }

    /**
     * Gets the first item passing a given truth test.
     *
     * This method retrieves the first item in the collection that satisfies the provided callback.
     * If no callback is provided, it returns the first item in the collection.
     *
     * @param Closure|null $callback The callback for the truth test. It should accept the item as a parameter and
     *                               return a boolean.
     *
     * @return mixed The first item passing the test, or null if none found.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $firstEven = $arrh->first(fn($item) => $item % 2 === 0); // Returns 2
     *
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $first = $arrh->first(); // Returns 'apple'
     * ```
     */
    public function first(Closure|null $callback = null) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (! $callback instanceof Closure || $callback($item)) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Zips items in the collection with additional arrays.
     *
     * This method combines the collection with one or more additional arrays. The resulting collection
     * contains arrays where each array contains elements from the corresponding positions of the input arrays.
     * If the input arrays have different lengths, the missing values are filled with `null`.
     *
     * @param array ...$items Arrays to zip with the collection.
     *
     * @return static A new collection with zipped items.
     *
     * @throws InvalidArgumentException If no additional arrays are provided.
     *
     * ```
     * $arrh1 = new Arrhae([1, 2, 3]);
     * $arrh2 = new Arrhae(['a', 'b', 'c']);
     * $zipped = $arrh1->zip($arrh2->getItems()); // Returns [[1, 'a'], [2, 'b'], [3, 'c']]
     *
     * $arrh3 = new Arrhae(['x', 'y']);
     * $zipped = $arrh1->zip($arrh2->getItems(), $arrh3->getItems());
     * // Returns [[1, 'a', 'x'], [2, 'b', 'y'], [3, 'c', null]]
     * ```
     */
    public function zip(array ...$items) : static
    {
        if ($items === []) {
            throw new InvalidArgumentException(message: 'At least one array must be provided to zip with.');
        }

        $zipped = array_map(null, $this->getItems(), ...$items);

        return new static(items: $zipped);
    }

    /**
     * Checks if the collection contains a specific value.
     *
     * This method determines whether a given value exists within the collection.
     * It uses strict comparison to ensure accurate matching.
     *
     * @param mixed $value The value to search for.
     *
     * @return bool True if found, false otherwise.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $hasBanana = $arrh->contains('banana'); // Returns true
     * $hasDate = $arrh->contains('date'); // Returns false
     * ```
     */
    public function contains(mixed $value) : bool
    {
        return in_array(needle: $value, haystack: $this->getItems(), strict: true);
    }

    /** ***Query and Search Methods*** */

    /**
     * Alias for the search method.
     *
     * This method provides an alternative name for the `search` method for better readability.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $index = $arrh->indexOf('cherry'); // Returns 2
     * $index = $arrh->indexOf('date'); // Returns false
     * ```
     */
    public function indexOf(mixed $value) : int|false
    {
        return $this->search(value: $value);
    }

    /**
     * Finds the index of the first occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its first occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value  The value to search for.
     * @param bool  $strict Use strict comparison.
     *
     * @return int|false The index or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $index = $arrh->search('banana'); // Returns 1
     * $index = $arrh->search('date'); // Returns false
     * ```
     */
    public function search(mixed $value, bool $strict = false) : int|false
    {
        return array_search(needle: $value, haystack: $this->getItems(), strict: $strict);
    }

    /**
     * Finds the last occurrence of a value in the collection.
     *
     * This method searches for the specified value and returns the index of its last occurrence.
     * If the value is not found, it returns `false`.
     *
     * @param mixed $value The value to search for.
     *
     * @return int|false The index of the last occurrence, or false if not found.
     *
     * @throws InvalidArgumentException If the value type is unsupported.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'banana']);
     * $lastIndex = $arrh->lastIndexOf('banana'); // Returns 3
     * $lastIndex = $arrh->lastIndexOf('date'); // Returns false
     * ```
     */
    public function lastIndexOf(mixed $value) : int|false
    {
        $reversedItems = array_reverse(array: $this->getItems(), preserve_keys: true);

        return array_search(needle: $value, haystack: $reversedItems, strict: true);
    }

    /**
     * Filters items where a specific key matches a given value.
     *
     * This method filters the collection to include only items where the specified key's value
     * is equal to the provided value.
     *
     * @param string $key   The key to filter by.
     * @param mixed  $value The value to match.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => 25],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => 25],
     * ]);
     * $filtered = $arrh->where('age', 25);
     * // Returns [
     * //     ['name' => 'Alice', 'age' => 25],
     * //     ['name' => 'Charlie', 'age' => 25],
     * // ]
     * ```
     */
    public function where(string $key, mixed $value) : static
    {
        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => ($item[$key] ?? null) === $value
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is between the provided minimum and maximum values, inclusive.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Alice', 'score' => 85],
     * //     ['name' => 'Bob', 'score' => 90],
     * // ]
     * ```
     */
    public function whereBetween(string $key, array $range) : static
    {
        if (count(value: $range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => ($item[$key] ?? null) >= $min &&
                ($item[$key] ?? null) <= $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values are in an array.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of values.
     *
     * @param string $key    The key to filter by.
     * @param array  $values Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the values array is empty.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     * $filtered = $arrh->whereIn('role', ['admin', 'editor']);
     * // Returns [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Bob', 'role' => 'editor'],
     * // ]
     * ```
     */
    public function whereIn(string $key, array $values) : static
    {
        if ($values === []) {
            throw new InvalidArgumentException(message: 'Values array cannot be empty.');
        }

        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => in_array(needle: $item[$key] ?? null, haystack: $values, strict: true)
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key's value is not within a given range.
     *
     * This method filters the collection to include only items where the specified key's value
     * is outside the provided minimum and maximum values.
     *
     * @param string $key   The key to filter by.
     * @param array  $range An array containing exactly two elements: [min, max].
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the range array does not contain exactly two elements.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'score' => 85],
     *     ['name' => 'Bob', 'score' => 90],
     *     ['name' => 'Charlie', 'score' => 75],
     * ]);
     * $filtered = $arrh->whereNotBetween('score', [80, 90]);
     * // Returns [
     * //     ['name' => 'Charlie', 'score' => 75],
     * // ]
     * ```
     */
    public function whereNotBetween(string $key, array $range) : static
    {
        if (count(value: $range) !== 2) {
            throw new InvalidArgumentException(message: 'Range array must contain exactly two elements: [min, max].');
        }

        [$min, $max] = $range;

        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => ($item[$key] ?? null) < $min ||
                ($item[$key] ?? null) > $max
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNull('age');
     * // Returns [
     * //     ['name' => 'Alice', 'age' => null],
     * //     ['name' => 'Charlie', 'age' => null],
     * // ]
     * ```
     */
    public function whereNull(string $key) : static
    {
        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => ($item[$key] ?? null) === null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items where a specific key is not null.
     *
     * This method filters the collection to include only items where the specified key's value
     * is not `null`.
     *
     * @param string $key The key to filter by.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in any of the items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'age' => null],
     *     ['name' => 'Bob', 'age' => 30],
     *     ['name' => 'Charlie', 'age' => null],
     * ]);
     * $filtered = $arrh->whereNotNull('age');
     * // Returns [
     * //     ['name' => 'Bob', 'age' => 30],
     * // ]
     * ```
     */
    public function whereNotNull(string $key) : static
    {
        $filtered = array_filter(
            array   : $this->getItems(),
            callback: static fn($item) : bool => ($item[$key] ?? null) !== null
        );

        return new static(items: $filtered);
    }

    /**
     * Filters items by a specific key where values belong to a group of acceptable values.
     *
     * This method filters the collection to include only items where the specified key's value
     * is present in the provided array of groups. It allows for grouping-based filtering of collections.
     *
     * @param string $key    The key to filter by.
     * @param array  $groups Array of acceptable values.
     *
     * @return static A new instance with the filtered items.
     *
     * @throws InvalidArgumentException If the key does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'Alice', 'role' => 'admin'],
     *     ['name' => 'Bob', 'role' => 'editor'],
     *     ['name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $filtered = $arrh->whereInGroup('role', ['admin', 'subscriber']);
     *
     * // $filtered contains:
     * // [
     * //     ['name' => 'Alice', 'role' => 'admin'],
     * //     ['name' => 'Charlie', 'role' => 'subscriber'],
     * // ]
     * ```
     */
    public function whereInGroup(string $key, array $groups) : static
    {
        return $this->filter(callback: static fn($item) : bool => in_array(needle: $item[$key] ?? null, haystack: $groups, strict: true));
    }

    /**
     * Filters items in the collection based on a callback.
     *
     * This method filters the collection by applying the provided callback to each item.
     * Only items for which the callback returns `true` are included in the resulting collection.
     *
     * @param Closure $callback The callback to filter items. It should accept the item and its key as parameters and
     *                          return a boolean.
     *
     * @return static A new instance containing only the filtered items.
     *
     * @throws InvalidArgumentException If the callback is not callable.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $evens = $arrh->filter(fn($item) => $item % 2 === 0); // Returns [2, 4]
     * ```
     */
    public function filter(Closure $callback) : static
    {
        $filteredItems = array_filter(
            array   : $this->getItems(),
            callback: $callback,
            mode    : ARRAY_FILTER_USE_BOTH
        );

        return new static(items: $filteredItems);
    }

    /**
     * Updates items in the collection based on a condition.
     *
     * This method applies the provided update callback to items that satisfy the specified condition.
     * It returns a new instance with the updated items, ensuring immutability.
     *
     * @param Closure $condition The condition to check for each item. It should accept an item as a parameter and
     *                           return a boolean indicating whether the item should be updated.
     * @param Closure $updater   The callback to apply to items that satisfy the condition. It should accept an item
     *                           as a parameter and return the updated item.
     *
     * @return static A new instance with the updated items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     *     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     *     ['id' => 3, 'name' => 'Charlie', 'role' => 'subscriber'],
     * ]);
     *
     * $updated = $arrh->updateWhere(
     *     fn($item) => $item['role'] === 'subscriber',
     *     fn($item) => array_merge($item, ['role' => 'member'])
     * );
     *
     * // $updated contains:
     * // [
     * //     ['id' => 1, 'name' => 'Alice', 'role' => 'admin'],
     * //     ['id' => 2, 'name' => 'Bob', 'role' => 'editor'],
     * //     ['id' => 3, 'name' => 'Charlie', 'role' => 'member'],
     * // ]
     * ```
     */
    public function updateWhere(Closure $condition, Closure $updater) : static
    {
        $updated = array_map(
            callback: static fn($item) => $condition($item) ? $updater($item) : $item,
            array   : $this->getItems()
        );

        return new static(items: $updated);
    }

    /**
     * Adds a whereIs clause to filter the array based on a condition.
     *
     * This method filters the items in the array based on the specified condition applied to a given column.
     * It supports a wide range of operators such as '=', '==', '===', '!=', '<>', '!==', '>', '<', '>=', '<=',
     * '<=>', 'contains', 'not contains', 'in', and 'not in'. The column can be specified using dot notation to access
     * nested values.
     *
     * @param string $column   The column name for the where clause.
     * @param string $operator The operator to be used in the where clause (e.g., '=', '==', '!=', '>', '<',
     *                         'contains', 'in', '<=>').
     * @param mixed  $value    The value to be compared with the column.
     */
    public function whereIs(string $column, string $operator, mixed $value) : self
    {
        // add more here if needed
        $supportedOperators = [
            '=',
            '==',
            '===',
            '!=',
            '<>',
            '!==',
            '>',
            '<',
            '>=',
            '<=',
            '<=>',
            'contains',
            'not contains',
            'in',
            'not in',
        ];

        if (! in_array(needle: $operator, haystack: $supportedOperators, strict: true)) {
            throw new InvalidArgumentException(message: 'Unsupported operator: ' . $operator);
        }

        $filteredItems = array_filter(
            array   : $this->items,
            callback: function ($item) use ($column, $operator, $value) : bool {
                $itemValue = $this->getFromItem(item: $item, key: $column);

                return match ($operator) {
                    '=', '=='      => $itemValue == $value,
                    '==='          => $itemValue === $value,
                    '!=', '<>'     => $itemValue != $value,
                    '!=='          => $itemValue !== $value,
                    '>'            => $itemValue > $value,
                    '<'            => $itemValue < $value,
                    '>='           => $itemValue >= $value,
                    '<='           => $itemValue <= $value,
                    '<=>'          => $itemValue <=> $value,
                    'contains'     => match (true) {
                        is_string(value: $itemValue) && is_string(value: $value) => str_contains(haystack: $itemValue, needle: $value),
                        is_array(value: $itemValue)                              => in_array(needle: $value, haystack: $itemValue, strict: true),
                        default                                                  => false,
                    },
                    'not contains' => match (true) {
                        is_string(value: $itemValue) && is_string(value: $value) => ! str_contains(haystack: $itemValue, needle: $value),
                        is_array(value: $itemValue)                              => ! in_array(needle: $value, haystack: $itemValue, strict: true),
                        default                                                  => true,
                    },
                    'in'           => in_array(needle: $itemValue, haystack: (array) $value, strict: true),
                    'not in'       => ! in_array(needle: $itemValue, haystack: (array) $value, strict: true),
                    default        => false,
                };
            }
        );

        $this->items = array_values(array: $filteredItems);

        return new static(items: $this->items);
    }

}

=== ArrayHandling/Traits/ConditionalsTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait ConditionalsTrait
 *
 * Adds conditional behaviors to collections, enabling the application of callbacks
 * based on specific conditions. This promotes more expressive and readable code
 * when dealing with collections.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait ConditionalsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Apply a callback if the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on a boolean condition. If the condition is true,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is true. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->when(true, fn($collection) => $collection->filter(fn($item) => $item > 2));
     * // $result contains [3, 4]
     * ```
     */
    public function when(bool $condition, Closure $callback) : static
    {
        if ($condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the given condition is true.
     *
     * This method allows you to conditionally apply transformations or operations
     * to the collection based on the inverse of a boolean condition. If the condition is false,
     * the callback is executed with the current instance as its parameter.
     *
     * @param bool    $condition The condition to evaluate.
     * @param Closure $callback  The callback to execute if the condition is false. It should accept the instance and
     *                           return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4]);
     * $result = $arrh->unless(false, fn($collection) => $collection->map(fn($item) => $item * 2));
     * // $result contains [2, 4, 6, 8]
     * ```
     */
    public function unless(bool $condition, Closure $callback) : static
    {
        if (! $condition) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Apply a callback unless the collection is empty.
     *
     * This method provides an inverse conditional application. It checks if the collection
     * is not empty, and if so, executes the provided callback with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->unlessEmpty(fn($collection) => $collection->remove(2));
     * // $result contains [1, 3]
     * ```
     */
    public function unlessEmpty(Closure $callback) : static
    {
        return $this->whenNotEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is not empty.
     *
     * This method checks if the collection has items. If it is not empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is not empty. It should accept the instance
     *                          and return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $result = $arrh->whenNotEmpty(fn($collection) => $collection->map(fn($item) => $item + 1));
     * // $result contains [2, 3, 4]
     * ```
     */
    public function whenNotEmpty(Closure $callback) : static
    {
        if (! $this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }

    /**
     * Check if the collection is empty.
     *
     * This method determines whether the collection contains any items.
     *
     * @return bool True if the collection has no items, false otherwise.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $isEmpty = $arrh->isEmpty(); // Returns true
     *
     * $arrh = new Arrhae([1, 2, 3]);
     * $isEmpty = $arrh->isEmpty(); // Returns false
     * ```
     */
    public function isEmpty() : bool
    {
        return empty($this->getItems());
    }

    /**
     * Apply a callback unless the collection is not empty.
     *
     * This method checks if the collection is empty, and if so, executes the provided callback
     * with the current instance as its parameter. It serves as a semantic alternative to `whenEmpty`.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->unlessNotEmpty(fn($collection) => $collection->add('default'));
     * // $result contains ['default']
     * ```
     */
    public function unlessNotEmpty(Closure $callback) : static
    {
        return $this->whenEmpty(callback: $callback);
    }

    /**
     * Apply a callback if the collection is empty.
     *
     * This method checks if the collection has no items. If it is empty,
     * the provided callback is executed with the current instance as its parameter.
     *
     * @param Closure $callback The callback to execute if the collection is empty. It should accept the instance and
     *                          return the modified instance.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If the callback does not return the instance.
     *
     * ```
     * $arrh = new Arrhae([]);
     * $result = $arrh->whenEmpty(fn($collection) => $collection->setItems(['default']));
     * // $result contains ['default']
     * ```
     */
    public function whenEmpty(Closure $callback) : static
    {
        if ($this->isEmpty()) {
            $result = $callback($this);
            if (! $result instanceof self) {
                throw new InvalidArgumentException(message: 'Callback must return the instance.');
            }

            return $result;
        }

        return $this;
    }
}

=== ArrayHandling/Traits/DebugTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait DebugTrait
 *
 * Provides debugging capabilities for classes that implement the required methods.
 * This trait enforces the presence of `toArray` and `count` methods in the using class.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait DebugTrait
{
    /**
     * Dumps the array representation of the class and returns the instance.
     *
     * This method outputs the array representation using `var_dump` and returns
     * the current instance to allow method chaining.
     *
     * @return static The current instance for method chaining.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dump();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * ```
     */
    public function dump() : static
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array(value: $arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump(value: $arrayRepresentation);

        return $this;
    }

    /**
     * Enforce the implementation of toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The array representation of the collection.
     */
    abstract public function toArray() : array;

    /**
     * Dumps the array representation of the class and terminates execution.
     *
     * This method outputs the array representation using `var_dump` and then
     * terminates the script execution.
     *
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh->dd();
     * // Outputs:
     * // array(3) {
     * //   [0]=>
     * //   string(5) "apple"
     * //   [1]=>
     * //   string(6) "banana"
     * //   [2]=>
     * //   string(6) "cherry"
     * // }
     * // Script execution terminated.
     * ```
     */
    public function dd() : void
    {
        $arrayRepresentation = $this->toArray();

        if (! is_array(value: $arrayRepresentation)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        var_dump(value: $arrayRepresentation);
        die();
    }

    /**
     * Overrides the __debugInfo magic method to provide custom debugging information.
     *
     * This method is automatically called by `var_dump` and similar functions to retrieve
     * debugging information about the object.
     *
     * @return array The debugging information.
     */
    public function __debugInfo() : array
    {
        return $this->debugInfo();
    }

    /**
     * Provides debugging information including count and items.
     *
     * This method returns an associative array containing the count of items
     * and their array representation. It can be used to log or inspect the collection's state.
     *
     * @return array The debugging information for the current instance.
     *
     * @throws InvalidArgumentException If `toArray` does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $debugInfo = $arrh->debugInfo();
     * // Returns:
     * // [
     * //     'count' => 3,
     * //     'items' => ['apple', 'banana', 'cherry']
     * // ]
     * ```
     */
    public function debugInfo() : array
    {
        $items = $this->toArray();

        if (! is_array(value: $items)) {
            throw new InvalidArgumentException(message: 'toArray method must return an array.');
        }

        return [
            'count' => $this->count(),
            'items' => $items,
        ];
    }

    /**
     * Enforce the implementation of count method.
     *
     * Classes using this trait must implement this method.
     *
     * @return int The number of items in the collection.
     */
    abstract public function count() : int;
}

=== ArrayHandling/Traits/LazyEvaluationTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait LazyEvaluationTrait
 *
 * Provides methods to enable lazy evaluation on collections.
 * It offers a set of functions to manipulate collections in a memory-efficient manner
 * using generator functions, enabling operations like taking or skipping elements
 * based on conditions, selecting every nth element, and sliding windows of elements.
 *
 * This trait is intended to be used within classes that manage collections of data,
 * such as arrays of associative arrays or objects. It leverages the `AbstractDependenciesTrait`
 * for dependency management, ensuring that the underlying data collection is properly handled.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait LazyEvaluationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Take items from the collection while the callback returns true.
     *
     * Creates a new collection taking elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to continue taking items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeWhile(fn($item) => $item < 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool(value: $result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if (! $result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /** ***Traversal and Filtering Methods*** */


    /**
     * Skip items in the collection while the callback returns true.
     *
     * Creates a new collection that skips initial elements while the specified condition is met.
     *
     * @param Closure $callback The condition used to skip items. It should accept the item and its key as parameters
     *                          and return a boolean.
     *
     * @return static A new lazy collection skipping items while the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipWhile(fn($item) => $item < 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipWhile(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool(value: $result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if (! $result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Get every nth item in the collection.
     *
     * Useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved. Must be a positive integer.
     *
     * @return static A new lazy collection containing every nth item.
     *
     * @throws InvalidArgumentException If $step is not a positive integer.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5, 6]);
     * $result = $arrh->nth(2);
     * // $result yields 1, 3, 5
     * ```
     */
    public function nth(int $step) : static
    {
        if ($step <= 0) {
            throw new InvalidArgumentException(message: 'Step must be a positive integer.');
        }

        return new static(function () use ($step) {
            $index = 0;
            foreach ($this->getItems() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection until the callback returns true.
     *
     * Creates a new collection taking elements until the specified condition is met.
     *
     * @param Closure $callback The condition that stops the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection containing items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->takeUntil(fn($item) => $item === 4);
     * // $result yields 1, 2, 3
     * ```
     */
    public function takeUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            foreach ($this->getItems() as $key => $item) {
                $result = $callback($item, $key);
                if (! is_bool(value: $result)) {
                    throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                }

                if ($result) {
                    break;
                }

                yield $item;
            }
        });
    }

    /**
     * Skip items in the collection until the callback returns true.
     *
     * Creates a new collection that starts taking elements once the specified
     * condition is met.
     *
     * @param Closure $callback The condition that starts the taking of items. It should accept the item and its key as
     *                          parameters and return a boolean.
     *
     * @return static A new lazy collection skipping items until the callback returns true.
     *
     * @throws InvalidArgumentException If the callback does not return a boolean.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skipUntil(fn($item) => $item === 3);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skipUntil(Closure $callback) : static
    {
        return new static(function () use ($callback) {
            $yielding = false;
            foreach ($this->getItems() as $key => $item) {
                if (! $yielding) {
                    $result = $callback($item, $key);
                    if (! is_bool(value: $result)) {
                        throw new InvalidArgumentException(message: 'Callback must return a boolean.');
                    }

                    if ($result) {
                        $yielding = true;
                        yield $item;
                    }
                } else {
                    yield $item;
                }
            }
        });
    }

    /**
     * Creates a sliding window of items in the collection.
     *
     * Produces sub-arrays (chunks) of size specified, sliding by step count.
     * Useful for windowed computations or batch processing.
     *
     * @param int $size The size of each sliding window. Must be a positive integer.
     * @param int $step The step by which the window slides. Must be a positive integer. Defaults to 1.
     *
     * @return static A new lazy collection containing sliding windows of items.
     *
     * @throws InvalidArgumentException If $size or $step are not positive integers.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->sliding(3, 1);
     * // $result yields [1, 2, 3], [2, 3, 4], [3, 4, 5]
     * ```
     */
    public function sliding(int $size = 2, int $step = 1) : static
    {
        if ($size <= 0 || $step <= 0) {
            throw new InvalidArgumentException(message: 'Size and step must be positive integers.');
        }

        return new static(function () use ($size, $step) {
            $buffer = [];
            foreach ($this->getItems() as $item) {
                $buffer[] = $item;
                if (count(value: $buffer) === $size) {
                    yield $buffer;
                    array_splice(array: $buffer, offset: 0, length: $step);
                }
            }

            // Yield remaining items if needed (optional)
            // if (count($buffer) > 0) {
            //     yield $buffer;
            // }
        });
    }

    /**
     * Returns a new instance with the first $limit items of the current collection.
     *
     * This method uses generator functions to yield only the specified number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $limit The number of items to take from the beginning of the collection. Must be a non-negative
     *                   integer.
     *
     * @return static A new lazy collection with the first $limit items.
     *
     * @throws InvalidArgumentException If $limit is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->take(3);
     * // $result yields 1, 2, 3
     * ```
     */
    public function take(int $limit) : static
    {
        if ($limit < 0) {
            throw new InvalidArgumentException(message: 'Limit must be a non-negative integer.');
        }

        return new static(
            iterator_to_array(
                iterator     : (function () use ($limit) {
                    if ($limit === 0) {
                        return;
                    }

                    $count = 0;
                    foreach ($this->getItems() as $item) {
                        yield $item;
                        if (++$count >= $limit) {
                            break;
                        }
                    }
                })(),
                preserve_keys: false
            )
        );
    }

    /**
     * Returns a new instance with the items starting from the $offset position of the current collection.
     *
     * This method utilizes generator functions to skip a certain number of items,
     * promoting memory efficiency for large datasets.
     *
     * @param int $offset The number of items to skip from the beginning of the collection. Must be a non-negative
     *                    integer.
     *
     * @return static A new lazy collection with items starting from the $offset position.
     *
     * @throws InvalidArgumentException If $offset is negative.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3, 4, 5]);
     * $result = $arrh->skip(2);
     * // $result yields 3, 4, 5
     * ```
     */
    public function skip(int $offset) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset must be a non-negative integer.');
        }

        return new static(function () use ($offset) {
            if ($offset === 0) {
                foreach ($this->getItems() as $item) {
                    yield $item;
                }

                return;
            }

            $count = 0;
            foreach ($this->getItems() as $item) {
                if ($count++ < $offset) {
                    continue;
                }

                yield $item;
            }
        });
    }

    /**
     * Converts a lazy collection to an eagerly-loaded collection.
     *
     * This method resolves all deferred (lazy) items into an array, allowing for immediate
     * in-memory operations. It's useful for scenarios where further operations require
     * the collection to be fully loaded in memory.
     *
     * @return static A new instance containing the eagerly-loaded collection.
     *
     * ```
     * // Example: Processing a large dataset lazily, then converting to eager for final transformation.
     * $lazyCollection = new Arrhae((function () {
     *     // Simulate fetching a large dataset lazily.
     *     for ($i = 1; $i <= 10000; $i++) {
     *         yield [
     *             'id' => $i,
     *             'value' => $i * 2,
     *             'category' => $i % 2 === 0 ? 'even' : 'odd',
     *         ];
     *     }
     * })());
     *
     * // Step 1: Lazy filtering and mapping.
     * $filteredLazyCollection = $lazyCollection
     *     ->filter(fn($item) => $item['id'] > 5000)  // Keep items with IDs > 5000.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'value' => $item['value'] + 10,
     *         'is_even' => $item['category'] === 'even',
     *     ]);
     *
     * // Step 2: Convert to eager-loaded collection.
     * $eagerCollection = $filteredLazyCollection->toEager();
     *
     * // Step 3: Further eager operations.
     * $finalResult = $eagerCollection
     *     ->filter(fn($item) => $item['is_even'])     // Only keep even items.
     *     ->map(fn($item) => [
     *         'id' => $item['id'],
     *         'summary' => "Item ID: {$item['id']}, Value: {$item['value']}",
     *     ])
     *     ->toArray();
     *
     * // Output: $finalResult contains an eagerly-loaded array with transformed data.
     * [
     *     ['id' => 5002, 'summary' => 'Item ID: 5002, Value: 10014'],
     *     ['id' => 5004, 'summary' => 'Item ID: 5004, Value: 10018'],
     *     ...
     * ]
     * ```
     */
    public function toEager() : static
    {
        return new static(iterator_to_array(iterator: $this->getItems()));
    }


}

=== ArrayHandling/Traits/LockableTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use LogicException;

/**
 * Trait LockableTrait
 *
 * Provides a locking mechanism to enforce immutability on collection-like objects.
 * Intended for use in data container classes (e.g., value object arrays) where mutation
 * should be explicitly prohibited after initialization or transformation.
 *
 * When locked, any attempt to mutate the object via methods like `set`, `forget`, `add`,
 * or internal `setItems` should result in a runtime exception.
 *
 * This trait enforces strict runtime safety in contexts such as:
 * - Domain-driven value object snapshots
 * - Immutable API response structures
 * - Secure, read-only configuration holders
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait LockableTrait
{
    /**
     * Indicates whether the current instance is locked and protected from mutation.
     */
    protected bool $locked = false;

    /**
     * Locks the current instance, making all mutating operations forbidden.
     *
     * This method should be called once the object reaches a stable state, typically
     * after construction, transformation, or hydration from a DTO.
     *
     * @return static Returns the same instance for fluent chaining.
     */
    public function lock() : static
    {
        // Enables the immutability flag
        $this->locked = true;

        // Return self to support fluent calls
        return $this;
    }

    /**
     * Indicates whether this instance has been locked.
     *
     * Useful for consumers to check immutability status.
     *
     * @return bool True if locked, false otherwise.
     */
    public function isLocked() : bool
    {
        return $this->locked;
    }

    /**
     * Checks whether mutation is allowed. Throws an exception if the instance is locked.
     *
     * Should be called at the top of any mutating method (e.g., set, forget, etc.)
     * to enforce write protection contract.
     *
     * @throws LogicException If mutation is attempted on a locked instance.
     */
    protected function assertNotLocked() : void
    {
        // Enforces immutability post-lock
        if ($this->locked === true) {
            throw new LogicException(message: 'Mutation is forbidden: this instance is locked and read-only.');
        }
    }
}

=== ArrayHandling/Traits/MacrosTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use BadMethodCallException;
use Closure;
use InvalidArgumentException;

/**
 * Trait MacrosTrait
 *
 * Provides the ability to register and handle macros (dynamic methods) within a class.
 * This trait allows for the registration of global macros and namespaced macros,
 * enabling flexible and organized method extensions.
 *
 * The trait enforces the implementation of the `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait MacrosTrait
{
    // Store macros and namespaced macros
    protected static array $macros = [];

    protected static array $macroNamespaces = [];

    /**
     * Register a new global macro.
     *
     * This method allows you to define a macro (dynamic method) that can be called
     * on instances of the class using this trait.
     *
     * @param string  $name  The name of the macro.
     * @param Closure $macro The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macro('toUpperCase', function() {
     *     return array_map(fn($item) => strtoupper($item), $this->getItems());
     * });
     *
     * $instance->toUpperCase(); // Transforms all items to uppercase.
     * ```
     */
    public static function macro(string $name, Closure $macro) : void
    {
        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macros[$name])) {
            throw new InvalidArgumentException(message: sprintf("Macro '%s' is already registered.", $name));
        }

        self::$macros[$name] = $macro;
    }

    /**
     * Register a new namespaced macro.
     *
     * This method allows you to define a macro within a specific namespace, enabling
     * better organization and avoiding naming collisions.
     *
     * @param string  $namespace The namespace for organizing macros.
     * @param string  $name      The name of the macro within the namespace.
     * @param Closure $macro     The closure representing the macro's functionality.
     *
     *
     * @throws InvalidArgumentException If the namespace or macro name is empty or already exists.
     * @example
     * ```
     * MacrosTrait::macroNamespace('string', 'toCamelCase', function() {
     *     return array_map(fn($item) => lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $item)))),
     *     $this->getItems());
     * });
     *
     * $instance->string::toCamelCase(); // Converts snake_case strings to camelCase.
     * ```
     */
    public static function macroNamespace(string $namespace, string $name, Closure $macro) : void
    {
        if ($namespace === '' || $namespace === '0') {
            throw new InvalidArgumentException(message: 'Namespace cannot be empty.');
        }

        if ($name === '' || $name === '0') {
            throw new InvalidArgumentException(message: 'Macro name cannot be empty.');
        }

        if (isset(self::$macroNamespaces[$namespace][$name])) {
            throw new InvalidArgumentException(
                message: sprintf("Macro '%s' is already registered in namespace '%s'.", $name, $namespace)
            );
        }

        self::$macroNamespaces[$namespace][$name] = $macro;
    }

    /**
     * Dynamically handle static method calls to macros.
     *
     * This magic method intercepts static calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     *
     * @param string $name      The name of the static method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Static global macro
     * MacrosTrait::macro('staticMethod', function() {
     *     return 'Static method called';
     * });
     *
     * Arrhae::staticMethod(); // Returns 'Static method called'
     * ```
     */
    public static function __callStatic(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains(haystack: $name, needle: '::')) {
            [$namespace, $macro] = explode(separator: '::', string: $name, limit: 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo(null, static::class);

                return call_user_func_array(callback: $boundMacro, args: $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo(null, static::class);

            return call_user_func_array(callback: $boundMacro, args: $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Static method '%s' does not exist.", $name));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return iterable The collection of items.
     */
    abstract public function getItems() : iterable;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param iterable $items The collection of items to set.
     */
    abstract public function setItems(iterable $items) : static;

    /**
     * Handle dynamic method calls to macros.
     *
     * This magic method intercepts calls to methods that are not explicitly defined
     * within the class. It checks if a macro with the given name exists and invokes it.
     * It supports both global macros and namespaced macros (using the '::' separator).
     *
     * @param string $name      The name of the method being called.
     * @param array  $arguments The arguments passed to the method.
     *
     * @return mixed The result of the macro invocation.
     *
     * @throws BadMethodCallException If the macro does not exist.
     *
     * @example
     * ```
     * // Global macro
     * MacrosTrait::macro('sum', function() {
     *     return array_sum($this->getItems());
     * });
     *
     * $instance->sum(); // Returns the sum of all items.
     *
     * // Namespaced macro
     * MacrosTrait::macroNamespace('math', 'average', function() {
     *     return array_sum($this->getItems()) / count($this->getItems());
     * });
     *
     * $instance->math::average(); // Returns the average of all items.
     * ```
     */
    public function __call(string $name, array $arguments)
    {
        // Handle namespaced macros (e.g., 'namespace::macro')
        if (str_contains(haystack: $name, needle: '::')) {
            [$namespace, $macro] = explode(separator: '::', string: $name, limit: 2);
            if (isset(self::$macroNamespaces[$namespace][$macro])) {
                $boundMacro = self::$macroNamespaces[$namespace][$macro]->bindTo($this, static::class);

                return call_user_func_array(callback: $boundMacro, args: $arguments);
            }
        }

        // Handle global macros
        if (isset(self::$macros[$name])) {
            $boundMacro = self::$macros[$name]->bindTo($this, static::class);

            return call_user_func_array(callback: $boundMacro, args: $arguments);
        }

        throw new BadMethodCallException(message: sprintf("Method '%s' does not exist.", $name));
    }
}

=== ArrayHandling/Traits/ManageItemsTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;
use OutOfBoundsException;

/**
 * Trait ManageItemsTrait
 *
 * Provides methods to manage items within a collection.
 * This trait offers functionalities to append, prepend, concatenate, remove,
 * replace, and slice items in a collection in an immutable and memory-efficient manner.
 *
 * The trait enforces the implementation of `getItems` and `setItems` methods
 * in the using class to manage the underlying data collection.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait ManageItemsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Append a value to the end of the collection.
     *
     * This method adds a new item to the end of the collection and returns a new instance
     * with the appended item, ensuring immutability.
     *
     * @param mixed $value The value to append.
     *
     * @return static A new instance with the appended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana']);
     * $newArrh = $arrh->append('cherry');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function append(mixed $value) : static
    {
        $items   = $this->getItems();
        $items[] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /** ***Item Management Methods*** */

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Prepend a value to the beginning of the collection.
     *
     * This method adds a new item to the beginning of the collection and returns a new instance
     * with the prepended item, ensuring immutability.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static A new instance with the prepended item.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['banana', 'cherry']);
     * $newArrh = $arrh->prepend('apple');
     * // $newArrh contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function prepend(mixed $value) : static
    {
        $items = $this->getItems();
        array_unshift($items, $value);

        return $this->setItems(items: $items);
    }

    /**
     * Concatenate the given iterable items to the current collection.
     *
     * This method merges the current collection with another iterable (array or instance of the using class)
     * and returns a new instance with the concatenated items, ensuring immutability.
     *
     * @param iterable $items The items to concatenate.
     *
     * @return static A new instance with concatenated items.
     *
     * @throws InvalidArgumentException If the provided items are not iterable.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $concatenated = $arrh1->concat($arrh2);
     * // $concatenated contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function concat(iterable $items) : static
    {
        $currentItems = $this->getItems();

        if ($items instanceof self) {
            $items = $items->getItems();
        } elseif (! is_array(value: $items)) {
            throw new InvalidArgumentException(
                message: 'Concat method expects an array or an instance of the using class.'
            );
        }

        $newItems = array_merge($currentItems, $items);

        return $this->setItems(items: $newItems);
    }

    /**
     * Remove and return the first item of the collection.
     *
     * This method removes the first item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the first item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->shift();
     * // $newArrh contains ['banana', 'cherry']
     * ```
     */
    public function shift() : static|null
    {
        $items = $this->getItems();
        $value = array_shift(array: $items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove and return the last item of the collection.
     *
     * This method removes the last item from the collection and returns a new instance
     * without that item. If the collection is empty, it returns null.
     *
     * @return static|null A new instance without the last item, or null if the collection is empty.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->pop();
     * // $newArrh contains ['apple', 'banana']
     * ```
     */
    public function pop() : static|null
    {
        $items = $this->getItems();
        $value = array_pop(array: $items);

        if ($value === null && $items === []) {
            return null;
        }

        return $this->setItems(items: $items);
    }

    /**
     * Remove an item at a specific index.
     *
     * This method removes the item at the specified index and returns a new instance
     * without that item. It throws an exception if the index is invalid.
     *
     * @param int $index The index of the item to remove.
     *
     * @return static A new instance without the specified item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->removeAt(1);
     * // $newArrh contains ['apple', 'cherry']
     * ```
     */
    public function removeAt(int $index) : static
    {
        $items = $this->getItems();

        if (! array_key_exists(key: $index, array: $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        unset($items[$index]);

        // Reindex the array to maintain sequential keys
        $items = array_values(array: $items);

        return $this->setItems(items: $items);
    }

    /**
     * Replace an item at a specific index.
     *
     * This method replaces the item at the specified index with a new value and returns a new instance
     * with the updated item. It throws an exception if the index is invalid.
     *
     * @param int   $index The index to replace.
     * @param mixed $value The new value.
     *
     * @return static A new instance with the replaced item.
     *
     * @throws OutOfBoundsException If the index does not exist in the collection.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->replaceAt(1, 'blueberry');
     * // $newArrh contains ['apple', 'blueberry', 'cherry']
     * ```
     */
    public function replaceAt(int $index, mixed $value) : static
    {
        $items = $this->getItems();

        if (! array_key_exists(key: $index, array: $items)) {
            throw new OutOfBoundsException(message: "Invalid index " . $index . ".");
        }

        $items[$index] = $value;

        return $this->setItems(items: $items);
    }

    /**
     * Returns a sliced portion of the collection.
     *
     * This method returns a new instance containing a subset of the collection based on the provided offset and
     * length.
     *
     * @param int      $offset The starting index of the slice.
     * @param int|null $length The number of items to include in the slice. If null, slices to the end of the
     *                         collection.
     *
     * @return static A new instance containing the sliced portion.
     *
     * @throws InvalidArgumentException If the offset or length is negative.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $sliced = $arrh->slice(1, 3);
     * // $sliced contains ['banana', 'cherry', 'date']
     * ```
     */
    public function slice(int $offset, int|null $length = null) : static
    {
        if ($offset < 0) {
            throw new InvalidArgumentException(message: 'Offset cannot be negative.');
        }

        if ($length !== null && $length < 0) {
            throw new InvalidArgumentException(message: 'Length cannot be negative.');
        }

        $slicedItems = array_slice(array: $this->getItems(), offset: $offset, length: $length, preserve_keys: true);

        // If slicing preserves keys and you want sequential keys, reindex
        // $slicedItems = array_values($slicedItems);

        return new static(items: $slicedItems);
    }

    /**
     * Get all items in the collection.
     *
     * This method provides a complete array of all items in the collection.
     *
     * @return array The array of all items.
     *
     * @example
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $allItems = $arrh->all();
     * // $allItems contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function all() : array
    {
        return $this->getItems();
    }
}

=== ArrayHandling/Traits/MetaInfoTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Carbon\Carbon;
use Closure;
use Exception;
use InvalidArgumentException;
use Ramsey\Uuid\Exception\UnsatisfiedDependencyException;
use Ramsey\Uuid\Uuid;

/**
 * Trait MetaInfoTrait
 *
 * Provides methods to enrich items within a collection with metadata such as GUIDs, timestamps, and version
 * information. It also offers functionality to clone the collection.
 *
 * This trait enforces the implementation of `getItems()`, `setItems()`, `map()`, and `toArray()` methods
 * in the using class to manage and transform the underlying data collection.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait MetaInfoTrait
{
    use AbstractDependenciesTrait;
    use TransformationTrait;

    /**
     * Add a unique GUID to each item in the collection.
     *
     * This method enriches each item with a universally unique identifier (UUID) under the 'id' key.
     *
     * @return static A new instance with GUIDs added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $newArrh = $arrh->guid();
     * // $newArrh contains:
     * // [
     * //     ['id' => 'uuid1', 'data' => 'apple'],
     * //     ['id' => 'uuid2', 'data' => 'banana'],
     * //     ['id' => 'uuid3', 'data' => 'cherry']
     * // ]
     * ```
     */
    public function guid() : static
    {
        return $this->map(callback: static function ($item) : array {
            try {
                return [
                    'id'   => Uuid::uuid4()->toString(),
                    'data' => $item,
                ];
            } catch (Exception $e) {
                throw new InvalidArgumentException(message: 'Failed to generate UUID: ' . $e->getMessage(), code: $e->getCode(), previous: $e);
            }
        });
    }

    /**
     * Enforce the implementation of the map method.
     *
     * Classes using this trait must implement this method.
     *
     * @param Closure $callback The callback to apply to each item.
     *
     * @return static A new instance with the transformed items.
     */
    abstract public function map(Closure $callback) : static;

    /**
     * Set or retrieve timestamps for items in the collection.
     *
     * When setting, this method adds a 'timestamp' key with the current time formatted as specified.
     * When retrieving, it extracts the 'timestamp' from each item.
     *
     * @param bool   $set    True to set the current timestamp, false to retrieve.
     * @param string $format Optional date format for timestamp. Defaults to Unix timestamp ('U').
     *
     * @return static A new instance with timestamps set or retrieved.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $timestamped = $arrh->timestamp();
     * // $timestamped contains:
     * // [
     * //     ['timestamp' => 'current_timestamp', 'data' => 'apple'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'banana'],
     * //     ['timestamp' => 'current_timestamp', 'data' => 'cherry']
     * // ]
     *
     * $timestamps = $arrh->timestamp(false);
     * // $timestamps contains: ['current_timestamp', 'current_timestamp', 'current_timestamp']
     * ```
     */
    public function timestamp(bool|null $set = null, string $format = 'U') : static
    {
        $set ??= true;
        try {
            $timestamp = Carbon::now()->format(format: $format);
        } catch (Exception $exception) {
            throw new InvalidArgumentException(
                message : 'Invalid date format: ' . $exception->getMessage(),
                code    : $exception->getCode(),
                previous: $exception
            );
        }

        return $this->map(
            callback: static function ($item) use ($set, $timestamp) {
                if ($set) {
                    return [
                        'timestamp' => $timestamp,
                        'data'      => $item,
                    ];
                }

                return $item['timestamp'] ?? null;
            }
        );
    }

    /**
     * Add version information to each item in the collection.
     *
     * This method enriches each item with a 'version' key indicating the version number.
     *
     * @param int $version Version number to assign. Defaults to 1.
     *
     * @return static A new instance with version numbers added to each item.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $versioned = $arrh->version(2);
     * // $versioned contains:
     * // [
     * //     ['version' => 2, 'data' => 'apple'],
     * //     ['version' => 2, 'data' => 'banana'],
     * //     ['version' => 2, 'data' => 'cherry']
     * // ]
     * ```
     */
    public function version(int $version = 1) : static
    {
        return $this->map(callback: static fn($item) : array => [
            'version' => $version,
            'data'    => $item,
        ]);
    }

    /**
     * Create a deep clone of the collection.
     *
     * This method creates a new instance of the collection with a deep copy of the current items.
     *
     * @return static Cloned collection.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $cloned = $arrh->clone();
     * // $cloned is a separate instance with the same items
     * ```
     */
    public function clone() : static
    {
        return new static(items: $this->toArray());
    }

    /**
     * Enforce the implementation of the toArray method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The collection represented as an array.
     */
    abstract public function toArray() : array;
}

=== ArrayHandling/Traits/OrderManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait OrderManipulationTrait
 *
 * Provides methods to manipulate the order of arrays.
 * This trait allows sorting arrays in ascending order
 * and shuffling array elements.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait OrderManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Sort items in ascending order based on a given key.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param string|callable $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new instance with sorted items.
     *
     * @throws InvalidArgumentException If the key is a string and does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortAsc('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAscending(string|callable $key) : static
    {
        $items = $this->getItems();

        // If sorting by a string key, ensure all items are arrays and contain the key
        if (is_string(value: $key)) {
            foreach ($items as $item) {
                if (! is_array(value: $item) || ! array_key_exists(key: $key, array: $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            usort(array: $items, callback: static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable(value: $key)) {
            usort(array: $items, callback: $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $items);
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Shuffle the items.
     *
     * This method randomizes the order of items in the collection and returns a new instance
     * with the shuffled items, ensuring immutability.
     *
     * @return static A new instance with shuffled items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $shuffled = $arrh->shuffle();
     * // $shuffled might contain ['cherry', 'apple', 'banana']
     * ```
     */
    public function shuffle() : static
    {
        $items = $this->getItems();

        // Shuffle items to randomize their order
        shuffle(array: $items);

        // Return a new instance to preserve immutability
        return new static(items: $items);
    }
}

=== ArrayHandling/Traits/PartitioningTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait PartitioningTrait
 *
 * Provides methods to partition and group items within a collection.
 * This trait allows splitting collections based on conditions, grouping by keys or callbacks,
 * and dividing collections into specified numbers of groups or chunks.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait PartitioningTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Splits the collection into two groups based on a callback.
     *
     * This method partitions the collection into two separate collections:
     * one where items satisfy the provided callback condition,
     * and another where items do not.
     *
     * @param Closure $callback The callback to determine the split condition.
     *
     * @return array Two collections: one matching the condition, one not.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date']);
     * [$fruitsWithA, $fruitsWithoutA] = $arrh->partition(fn($item) => strpos($item, 'a') !== false);
     * // $fruitsWithA contains ['apple', 'banana', 'date']
     * // $fruitsWithoutA contains ['cherry']
     * ```
     */
    public function partition(Closure $callback) : array
    {
        $matches    = [];
        $nonMatches = [];

        foreach ($this->getItems() as $item) {
            if ($callback($item)) {
                $matches[] = $item;
            } else {
                $nonMatches[] = $item;
            }
        }

        return [new static(items: $matches), new static(items: $nonMatches)];
    }

    /** ***Partitioning Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Groups the collection items by a specific key or callback.
     *
     * This method organizes the collection into groups based on a specified key or a callback function.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param Closure|string $key The key to group by, or a callback function to determine the group key.
     *
     * @return static A collection containing grouped items.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * // Grouping by a string key
     * $arrh = new Arrhae([
     *     ['type' => 'fruit', 'name' => 'apple'],
     *     ['type' => 'fruit', 'name' => 'banana'],
     *     ['type' => 'vegetable', 'name' => 'carrot'],
     * ]);
     * $grouped = $arrh->groupBy('type');
     * // $grouped contains:
     * // [
     * //     'fruit' => new Arrhae([
     * //         ['type' => 'fruit', 'name' => 'apple'],
     * //         ['type' => 'fruit', 'name' => 'banana'],
     * //     ]),
     * //     'vegetable' => new Arrhae([
     * //         ['type' => 'vegetable', 'name' => 'carrot'],
     * //     ]),
     * // ]
     *
     * // Grouping by a callback
     * $groupedByLength = $arrh->groupBy(fn($item) => strlen($item['name']));
     * // $groupedByLength contains:
     * // [
     * //     5 => new Arrhae([['type' => 'fruit', 'name' => 'apple']]),
     * //     6 => new Arrhae([['type' => 'fruit', 'name' => 'banana'], ['type' => 'vegetable', 'name' => 'carrot']]),
     * // ]
     * ```
     */
    public function groupBy(Closure|string $key) : static
    {
        $grouped = [];

        foreach ($this->getItems() as $item) {
            if (is_callable(value: $key)) {
                $groupKey = $key($item);
            } elseif (is_string(value: $key)) {
                if (! is_array(value: $item) || ! array_key_exists(key: $key, array: $item)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }

                $groupKey = $item[$key];
            } else {
                throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
            }

            $grouped[$groupKey][] = $item;
        }

        return new static(items: array_map(callback: static fn($group) : static => new static(items: $group), array: $grouped));
    }

    /**
     * Splits the collection into a specified number of groups.
     *
     * This method divides the collection into the desired number of groups as evenly as possible.
     * Each group is represented as a sub-collection within the main collection.
     *
     * @param int $numberOfGroups The number of groups to split into.
     *
     * @return static A collection containing the specified number of groups.
     *
     * @throws InvalidArgumentException If the number of groups is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $groups = $arrh->split(2);
     * // $groups contains:
     * // [
     * //     new Arrhae(['apple', 'banana', 'cherry']),
     * //     new Arrhae(['date', 'elderberry']),
     * // ]
     * ```
     */
    public function split(int $numberOfGroups) : static
    {
        if ($numberOfGroups < 1) {
            throw new InvalidArgumentException(message: 'Number of groups must be at least 1.');
        }

        $totalItems = count(value: $this->getItems());
        $groupSize  = (int) ceil(num: $totalItems / $numberOfGroups);
        $groups     = array_chunk(array: $this->getItems(), length: $groupSize);

        return new static(items: array_map(callback: static fn($group) : static => new static(items: $group), array: $groups));
    }

    /**
     * Splits the collection into chunks of a given size.
     *
     * This method divides the collection into chunks, each containing a specified number of items.
     * Each chunk is represented as a sub-collection within the main collection.
     *
     * @param int $size The size of each chunk.
     *
     * @return static A collection containing the chunks.
     *
     * @throws InvalidArgumentException If the chunk size is less than 1.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry', 'date', 'elderberry']);
     * $chunks = $arrh->chunk(2);
     * // $chunks contains:
     * // [
     * //     new Arrhae(['apple', 'banana']),
     * //     new Arrhae(['cherry', 'date']),
     * //     new Arrhae(['elderberry']),
     * // ]
     * ```
     */
    public function chunk(int $size) : static
    {
        if ($size < 1) {
            throw new InvalidArgumentException(message: 'Chunk size must be at least 1.');
        }

        $chunks = array_chunk(array: $this->getItems(), length: $size);

        return new static(items: array_map(callback: static fn($chunk) : static => new static(items: $chunk), array: $chunks));
    }
}

=== ArrayHandling/Traits/SetOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait SetOperationsTrait
 *
 * Provides set operations methods to manipulate collections, including intersection, union, difference, and merging.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait SetOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Return the intersection of two collections.
     *
     * This method returns a new collection containing items that are present in both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to intersect with.
     *
     * @return static A new collection with intersected items.
     *
     * @throws InvalidArgumentException If the provided collection is empty.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'cherry', 'date']);
     * $intersection = $arrh1->intersect($arrh2);
     * // $intersection contains ['banana', 'cherry']
     * ```
     */
    public function intersect(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        if (empty($otherItems)) {
            throw new InvalidArgumentException(message: 'The provided collection for intersection is empty.');
        }

        $intersected = array_intersect($currentItems, $otherItems);

        return new static(items: $intersected);
    }

    /** ***Set Operations Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Return the union of two collections.
     *
     * This method returns a new collection containing all unique items from both the current collection and the
     * provided collection.
     *
     * @param self $collection The collection to union with.
     *
     * @return static A new collection with unique combined items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['banana', 'cherry']);
     * $union = $arrh1->union($arrh2);
     * // $union contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function union(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);
        $unique = array_unique(array: $merged, flags: SORT_REGULAR); // SORT_REGULAR ensures proper uniqueness for arrays

        return new static(items: $unique);
    }

    /**
     * Return the difference of two collections.
     *
     * This method returns a new collection containing items that are present in the current collection but not in the
     * provided collection.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with items in the original but not in the compared collection.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date']);
     * $difference = $arrh1->diff($arrh2);
     * // $difference contains ['apple', 'cherry']
     * ```
     */
    public function diff(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $diff = array_diff($currentItems, $otherItems);

        return new static(items: $diff);
    }

    /**
     * Merge two collections together.
     *
     * This method merges the current collection with the provided collection and returns a new collection containing
     * all items.
     *
     * @param self $collection The collection to merge with.
     *
     * @return static A new collection with merged items.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana']);
     * $arrh2 = new Arrhae(['cherry', 'date']);
     * $merged = $arrh1->merge($arrh2);
     * // $merged contains ['apple', 'banana', 'cherry', 'date']
     * ```
     */
    public function merge(self $collection) : static
    {
        $currentItems = $this->getItems();
        $otherItems   = $collection->toArray();

        $merged = array_merge($currentItems, $otherItems);

        return new static(items: $merged);
    }

    /**
     * Returns the symmetric difference of two sets.
     *
     * This method returns a new collection containing elements that are present in either the current collection or
     * the
     * provided collection, but not in both. The symmetric difference is the combination of the differences in both
     * directions between the two sets.
     *
     * @param self $collection The collection to compare against.
     *
     * @return static A new collection with the symmetric difference of elements.
     *
     * @throws InvalidArgumentException If the provided collection is invalid or contains incompatible element types.
     *
     * ```
     * $arrh1 = new Arrhae(['apple', 'banana', 'cherry']);
     * $arrh2 = new Arrhae(['banana', 'date', 'fig']);
     * $symDifference = $arrh1->symmetricDifference($arrh2);
     * print_r($symDifference->toArray());
     * // Outputs:
     * // ['apple', 'cherry', 'date', 'fig']
     * ```
     */
    public function symmetricDifference(self $collection) : static
    {
        $diff1         = array_diff($this->getItems(), $collection->toArray());
        $diff2         = array_diff($collection->toArray(), $this->getItems());
        $symDifference = array_merge($diff1, $diff2);

        return new static(items: $symDifference);
    }
}

=== ArrayHandling/Traits/SortOperationsTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;

/**
 * Trait SortOperationsTrait
 *
 * Provides methods to sort and manipulate the order of items within a collection.
 * This trait allows sorting in ascending or descending order based on a key or callback,
 * reversing the order of items, and sorting by keys.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait SortOperationsTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Sort the collection in descending order based on a given key or callback.
     *
     * This method sorts the collection in descending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $sortedDesc = $arrh->sortDesc('name');
     * // $sortedDesc contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function sortDesc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key)->reverse();
    }

    /** ***Sorting Methods*** */

    /**
     * Reverse the order of the items in the collection.
     *
     * This method returns a new instance with the items in reverse order, ensuring immutability.
     *
     * @return static A new instance with the items in reverse order.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $reversed = $arrh->reverse();
     * // $reversed contains ['cherry', 'banana', 'apple']
     * ```
     */
    public function reverse() : static
    {
        return new static(items: array_reverse(array: $this->getItems(), preserve_keys: true));
    }

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Sort the collection based on a given key or callback.
     *
     * This method sorts the collection in ascending order either by a specified key or using a custom comparison
     * function. It returns a new instance with the sorted items, ensuring immutability.
     *
     * @param Closure|string $key The key to sort by, or a callable function to compare items.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more items.
     *
     * ```
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sorted = $arrh->sortBy('name');
     * // $sorted contains:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortBy(Closure|string $key) : static
    {
        $sortedItems = $this->getItems();

        if (is_string(value: $key)) {
            foreach ($sortedItems as $sortedItem) {
                if (! is_array(value: $sortedItem) || ! array_key_exists(key: $key, array: $sortedItem)) {
                    throw new InvalidArgumentException(
                        message: sprintf("Each item must be an array containing the key '%s'.", $key)
                    );
                }
            }

            uasort(array: $sortedItems, callback: static fn($a, $b) : int => $a[$key] <=> $b[$key]);
        } elseif (is_callable(value: $key)) {
            uasort(array: $sortedItems, callback: $key);
        } else {
            throw new InvalidArgumentException(message: 'The key must be either a string or a callable.');
        }

        return new static(items: $sortedItems);
    }

    /**
     * Sort the collection by its keys in ascending order.
     *
     * This method sorts the collection by its keys in ascending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeys = $arrh->sortKeys();
     * // $sortedKeys contains ['a' => 'apple', 'b' => 'banana', 'c' => 'cherry']
     * ```
     */
    public function sortKeys() : static
    {
        $sorted = $this->getItems();
        ksort(array: $sorted);

        return new static(items: $sorted);
    }

    /**
     * Sort the collection by its keys in descending order.
     *
     * This method sorts the collection by its keys in descending order and returns a new instance,
     * ensuring immutability.
     *
     * @return static A new key-sorted collection instance.
     *
     * ```
     * $arrh = new Arrhae(['b' => 'banana', 'a' => 'apple', 'c' => 'cherry']);
     * $sortedKeysDesc = $arrh->sortKeysDesc();
     * // $sortedKeysDesc contains ['c' => 'cherry', 'b' => 'banana', 'a' => 'apple']
     * ```
     */
    public function sortKeysDesc() : static
    {
        $sorted = $this->getItems();
        krsort(array: $sorted);

        return new static(items: $sorted);
    }

    /**
     * Sorts the collection in ascending order based on a given key or callback.
     *
     * This method sorts the collection in ascending order using the specified key or a callback function for comparing
     * elements. If the key is a string, it is expected that the collection's elements are associative arrays
     * containing the specified key. If a callback function is provided, it is used to dynamically compare elements.
     *
     * @param Closure|string $key The key to sort by or a callable function for comparison.
     *
     * @return static A new sorted collection instance.
     *
     * @throws InvalidArgumentException If a string key is provided but does not exist in one or more elements,
     *                                  or if the provided parameter is neither a Closure nor a string.
     *
     * ```
     * // Sorting by the 'price' key in ascending order
     * $arrh = new Arrhae([
     *     ['name' => 'banana', 'price' => 1.2],
     *     ['name' => 'apple', 'price' => 0.8],
     *     ['name' => 'cherry', 'price' => 2.5],
     * ]);
     * $sortedAsc = $arrh->sortAsc('price');
     * print_r($sortedAsc->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     *
     * // Sorting using a callback function
     * $sortedAscCallback = $arrh->sortAsc(function($a, $b) {
     *     return strlen($a['name']) <=> strlen($b['name']);
     * });
     * print_r($sortedAscCallback->toArray());
     * // Outputs:
     * // [
     * //     ['name' => 'apple', 'price' => 0.8],
     * //     ['name' => 'banana', 'price' => 1.2],
     * //     ['name' => 'cherry', 'price' => 2.5],
     * // ]
     * ```
     */
    public function sortAsc(Closure|string $key) : static
    {
        return $this->sortBy(key: $key);
    }

    /**
     * Sorts the collection by multiple criteria.
     *
     * This method allows sorting by multiple keys with specified orders (ascending or descending).
     * It accepts an associative array where keys represent the attributes to sort by,
     * and values specify the sorting order (`'asc'` for ascending, `'desc'` for descending).
     *
     * @param array $criteria Associative array of sorting criteria.
     *                        Keys are the item attributes, and values are sorting orders.
     *                        Example: `['name' => 'asc', 'age' => 'desc']`.
     *
     * @return static A new collection instance sorted by the given criteria.
     *
     * ```
     * $collection = new Arrhae([
     *     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     *     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     *     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     *     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * ]);
     *
     * // Sort by name (ascending), then by age (ascending), and then by score (descending).
     * $sortedCollection = $collection->sortByMultiple([
     *     'name' => 'asc',
     *     'age' => 'asc',
     *     'score' => 'desc',
     * ]);
     *
     * // Result:
     * // [
     * //     ['name' => 'Alice', 'age' => 25, 'score' => 80],
     * //     ['name' => 'Alice', 'age' => 30, 'score' => 85],
     * //     ['name' => 'Bob', 'age' => 25, 'score' => 90],
     * //     ['name' => 'Charlie', 'age' => 35, 'score' => 70],
     * // ]
     * ```
     */
    public function sortByMultiple(array $criteria) : static
    {
        $items = $this->getItems();
        usort(array: $items, callback: static function (array $a, array $b) use ($criteria) : int {
            foreach ($criteria as $key => $order) {
                $result = $a[$key] <=> $b[$key];
                if ($result !== 0) {
                    return $order === 'desc' ? -$result : $result;
                }
            }

            return 0;
        });

        return new static(items: $items);
    }
}

=== ArrayHandling/Traits/StringManipulationTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StringManipulationTrait
 *
 * Provides advanced string manipulation capabilities to the Arrhae class, including
 * concatenation, case transformation, trimming, replacing, and more.
 */
trait StringManipulationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Defines the default characters to be trimmed.
     */
    private const string DEFAULT_TRIM_CHARACTERS = " \t\n\r\0\x0B";

    /**
     * Concatenates the items of the collection into a string using a glue string.
     *
     * @param string $glue The string to use between items. Defaults to an empty string.
     *
     * @return string The concatenated string.
     *
     * @throws InvalidArgumentException If the collection contains non-string items.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana', 'cherry']);
     * echo $arrh->implode(', '); // Output: 'apple, banana, cherry'
     */
    public function implode(string $glue = '') : string
    {
        // Ensure all items are strings
        foreach ($this->getItems() as $item) {
            if (! is_string(value: $item)) {
                throw new InvalidArgumentException(message: 'All items must be strings to perform implode.');
            }
        }

        return implode(separator: $glue, array: $this->getItems());
    }

    /**
     * Converts all string items in the collection to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to uppercase.
     *
     * @example
     * $arrh = Arrhae::make(['apple', 'banana']);
     * $uppercased = $arrh->uppercase();
     * // ['APPLE', 'BANANA']
     */
    public function uppercase(string|null $key = null) : static
    {
        return $this->processItems(callback: static fn(string $value) : string => strtoupper(string: $value), key: $key);
    }

    /**
     * A helper method to process items within the collection and apply string transformations.
     *
     * @param callable    $callback The transformation to apply to string items.
     * @param string|null $key      The key to target within associative arrays if applicable.
     *
     * @return static A new Arrhae instance with processed items.
     */
    private function processItems(callable $callback, string|null $key = null) : static
    {
        return $this->map(callback: static function ($item) use ($callback, $key) {
            if ($key !== null && is_array(value: $item) && isset($item[$key]) && is_string(value: $item[$key])) {
                $item[$key] = $callback($item[$key]);

                return $item;
            }

            if (is_string(value: $item)) {
                return $callback($item);
            }

            return $item;
        });
    }

    /**
     * Converts all string items in the collection to lowercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to lowercase.
     *
     * @example
     * $arrh = Arrhae::make(['APPLE', 'BANANA']);
     * $lowercased = $arrh->lowercase();
     * // ['apple', 'banana']
     */
    public function lowercase(string|null $key = null) : static
    {
        return $this->processItems(callback: static fn(string $value) : string => strtolower(string: $value), key: $key);
    }

    /**
     * Converts the first character of each word in the string items to uppercase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to the title case.
     *
     * @example
     * $arrh = Arrhae::make(['hello world', 'php is great']);
     * $titlecased = $arrh->title();
     * // ['Hello World', 'Php Is Great']
     */
    public function title(string|null $key = null) : static
    {
        return $this->processItems(callback: static fn(string $value) : string => ucwords(string: strtolower(string: $value)), key: $key);
    }

    /**
     * Removes whitespace or other predefined characters from the beginning and end of string items.
     *
     * @param string|null $characters The characters to trim. Defaults to trimming common whitespace characters.
     * @param string|null $key        The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items trimmed.
     *
     * @example
     * $arrh = Arrhae::make([' apple  ', "\tbanana\n", ' cherry ']);
     * $trimmed = $arrh->trim();
     * // ['apple', 'banana', 'cherry']
     */
    public function trim(string|null $characters = null, string|null $key = null) : static
    {
        $characters ??= self::DEFAULT_TRIM_CHARACTERS;

        return $this->processItems(callback: static fn(string $value) : string => trim(string: $value, characters: $characters), key: $key);
    }

    /**
     * Converts string items in the collection to camelCase.
     *
     * @param string|null $key The key to target within associative arrays. If null, apply to all string items.
     *
     * @return static A new Arrhae instance with items converted to camelCase.
     *
     * @example
     * $arrh = Arrhae::make(['hello_world', 'php-is-great', 'convert this']);
     * $camelCased = $arrh->camelCase();
     * // ['helloWorld', 'phpIsGreat', 'convertThis']
     */
    public function camelCase(string|null $key = null) : static
    {
        return $this->processItems(
            callback: static fn(string $value) : string => lcfirst(
                string: str_replace(search: ' ', replace: '', subject: ucwords(string: str_replace(search: ['-', '_'], replace: ' ', subject: $value)))
            ),
            key     : $key
        );
    }
}
=== ArrayHandling/Traits/StructureConversionTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use InvalidArgumentException;

/**
 * Trait StructureConversionTrait
 *
 * Provides methods to convert the structure of collections,
 * including flattening multidimensional arrays into dot-notated arrays
 * and converting collections to indexed lists.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait StructureConversionTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multidimensional collection into a dot-notated array.
     *
     * Dot notation represents nested elements in a flat structure with keys such as "key.subkey".
     * This method returns a new instance with flattened keys and corresponding values.
     *
     * @return static A new instance with dot-notated keys and values.
     *
     * @throws InvalidArgumentException If the collection contains non-array nested items.
     *
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'address' => [
     *             'street' => '123 Main St',
     *             'city' => 'Anytown'
     *         ]
     *     ],
     *     'status' => 'active'
     * ]);
     * $flattened = $arrh->dot();
     * // $flattened contains:
     * // [
     * //     'user.name' => 'John Doe',
     * //     'user.address.street' => '123 Main St',
     * //     'user.address.city' => 'Anytown',
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function dot() : static
    {
        $results = [];
        $flatten = static function (array $items, string $prefix = '') use (&$flatten, &$results) : void {
            foreach ($items as $key => $value) {
                if (! is_scalar(value: $key) && ! is_null(value: $key)) {
                    throw new InvalidArgumentException(message: 'Keys must be scalar or null.');
                }

                $dotKey = $prefix . $key;
                if (is_array(value: $value)) {
                    $flatten($value, $dotKey . '.');
                } else {
                    $results[$dotKey] = $value;
                }
            }
        };

        $items = $this->getItems();
        if (! is_array(value: $items)) {
            throw new InvalidArgumentException(
                message: 'The collection must be an array to perform dot notation flattening.'
            );
        }

        $flatten(items: $items);

        return new static(items: $results);
    }

    /** ***Design Conversion Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Converts the collection to a list (indexed array).
     *
     * This method returns only the values, disregarding the keys.
     * It returns a new instance containing an indexed list of the original values.
     *
     * @return static A new instance with an indexed list of array values.
     *
     * ```
     * $arrh = new Arrhae(['first' => 'apple', 'second' => 'banana', 'third' => 'cherry']);
     * $list = $arrh->toList();
     * // $list contains ['apple', 'banana', 'cherry']
     * ```
     */
    public function toList() : static
    {
        $list = array_values(array: $this->getItems());

        return new static(items: $list);
    }

    /**
     * Reconstruct a dot-notated array back into a multidimensional array.
     *
     * This method reverses the flattening process, restoring the original multidimensional structure.
     *
     * @return static A new instance with the original multidimensional array structure.
     *
     * ```
     * $flattened = new Arrhae([
     *     'user.name' => 'John Doe',
     *     'user.address.street' => '123 Main St',
     *     'user.address.city' => 'Anytown',
     *     'status' => 'active'
     * ]);
     * $original = $flattened->unDot();
     * // $original contains:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'address' => [
     * //             'street' => '123 Main St',
     * //             'city' => 'Anytown'
     * //         ]
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function unDot() : static
    {
        $results = [];
        foreach ($this->getItems() as $dotKey => $item) {
            $keys = explode(separator: '.', string: (string) $dotKey);
            $temp = &$results;
            foreach ($keys as $key) {
                if (! isset($temp[$key]) || ! is_array(value: $temp[$key])) {
                    $temp[$key] = [];
                }

                $temp = &$temp[$key];
            }

            $temp = $item;
            unset($temp);
        }

        return new static(items: $results);
    }
}

=== ArrayHandling/Traits/TransformationTrait.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ArrayHandling\Traits;

use Closure;
use InvalidArgumentException;
use RecursiveArrayIterator;
use RecursiveIteratorIterator;

/**
 * Trait TransformationTrait
 *
 * Provides methods to transform the structure of collections,
 * including flattening multidimensional arrays, applying callbacks,
 * and mapping with custom keys.
 *
 * @package Avax\DataHandling\ArrayHandling\Traits
 */
trait TransformationTrait
{
    use AbstractDependenciesTrait;

    /**
     * Enforce the implementation of the setItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @param array $items The new collection of items.
     *
     * @return static A new instance with the updated collection.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Flatten a multi-dimensional array into a single-dimensional array.
     *
     * This method recursively flattens a multi-dimensional array into a single-dimensional
     * array, disregarding the original keys.
     *
     * @return static A new instance with the flattened array.
     *
     * @throws InvalidArgumentException If the collection is not an array.
     *
     * ```
     * $arrh = new Arrhae([
     *     'fruits' => ['apple', 'banana'],
     *     'vegetables' => ['carrot', 'lettuce'],
     *     'dairy' => 'milk'
     * ]);
     * $flattened = $arrh->flatten();
     * // $flattened contains:
     * // ['apple', 'banana', 'carrot', 'lettuce', 'milk']
     * ```
     */
    public function flatten() : static
    {
        $items = $this->getItems();
        if (! is_array(value: $items)) {
            throw new InvalidArgumentException(message: 'The collection must be an array to perform flattening.');
        }

        $iterator  = new RecursiveIteratorIterator(iterator: new RecursiveArrayIterator(array: $items));
        $flattened = [];

        foreach ($iterator as $value) {
            $flattened[] = $value;
        }

        return new static(items: $flattened);
    }


    /** ***Transformation Methods*** */

    /**
     * Enforce the implementation of the getItems method.
     *
     * Classes using this trait must implement this method.
     *
     * @return array The current collection of items.
     */
    abstract public function getItems() : array;

    /**
     * Apply a callback to each item and flatten the results into a single array.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an array, and the results are merged into a single, flattened array.
     *
     * @param Closure $callback The callback to apply. It should return an array for each item.
     *
     * @return static A new instance with the mapped and flattened array.
     *
     * @throws InvalidArgumentException If the callback does not return an array.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $flatMapped = $arrh->flatMap(function($item) {
     *     return [$item, strtoupper($item)];
     * });
     * // $flatMapped contains ['apple', 'APPLE', 'banana', 'BANANA', 'cherry', 'CHERRY']
     * ```
     */
    public function flatMap(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $item) {
            $result = $callback($item);
            if (! is_array(value: $result)) {
                throw new InvalidArgumentException(message: 'The callback for flatMap must return an array.');
            }

            $mapped = array_merge($mapped, $result);
        }

        return new static(items: $mapped);
    }

    /**
     * Apply a callback to each item, using returned keys as the new array keys.
     *
     * This method applies the provided callback to each item in the collection. The callback
     * should return an associative array with a single key-value pair, where the key becomes
     * the new key in the resulting collection.
     *
     * @param Closure $callback The callback to apply. It should return an associative array with one key-value pair.
     *
     * @return static A new instance with mapped keys and values.
     *
     * @throws InvalidArgumentException If the callback does not return an associative array with one key-value pair.
     *
     * ```
     * $arrh = new Arrhae(['apple', 'banana', 'cherry']);
     * $mappedWithKeys = $arrh->mapWithKeys(function($item, $key) {
     *     return [$item => strlen($item)];
     * });
     * // $mappedWithKeys contains ['apple' => 5, 'banana' => 6, 'cherry' => 6]
     * ```
     */
    public function mapWithKeys(Closure $callback) : static
    {
        $mapped = [];
        foreach ($this->getItems() as $key => $item) {
            $result = $callback($item, $key);
            if (! is_array(value: $result) || count(value: $result) !== 1) {
                throw new InvalidArgumentException(
                    message: 'The callback for mapWithKeys must return an associative array with exactly one key-value pair.'
                );
            }

            $newKey   = key(array: $result);
            $newValue = reset(array: $result);
            if (array_key_exists(key: $newKey, array: $mapped)) {
                throw new InvalidArgumentException(
                    message: sprintf("Duplicate key '%s' returned by mapWithKeys callback.", $newKey)
                );
            }

            $mapped[$newKey] = $newValue;
        }

        return new static(items: $mapped);
    }

    /**
     * Transform the current items using a callback.
     *
     * This method applies the provided callback to each item in the collection and returns
     * a new instance with the transformed items, ensuring immutability.
     *
     * @param Closure $callback The callback to apply.
     *
     * @return static A new instance with transformed items.
     *
     * ```
     * $arrh = new Arrhae([1, 2, 3]);
     * $transformed = $arrh->transform(function($item) {
     *     return $item * 2;
     * });
     * // $transformed contains [2, 4, 6]
     * ```
     */
    public function transform(Closure $callback) : static
    {
        $transformedItems = array_map(callback: $callback, array: $this->getItems());

        return new static(items: $transformedItems);
    }

    /**
     * Apply a complex transformation using SPL iterators.
     *
     * This method allows applying a callback to each element during iteration,
     * enabling complex transformations beyond simple mapping.
     *
     * @param Closure $callback The callback to apply to each element.
     *
     * @return static A new instance with the transformed collection.
     *
     * @throws InvalidArgumentException If the callback does not return a valid value.
     *
     * @example
     * ```
     * $arrh = new Arrhae([
     *     'user' => [
     *         'name' => 'John Doe',
     *         'age' => 30
     *     ],
     *     'status' => 'active'
     * ]);
     * $advancedTransformed = $arrh->advancedTransform(function($value, $key) {
     *     if ($key === 'age') {
     *         return $value + 1; // Increment age by 1
     *     }
     *     return $value;
     * });
     * print_r($advancedTransformed->toArray());
     * // Outputs:
     * // [
     * //     'user' => [
     * //         'name' => 'John Doe',
     * //         'age' => 31
     * //     ],
     * //     'status' => 'active'
     * // ]
     * ```
     */
    public function advancedTransform(Closure $callback) : static
    {
        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveArrayIterator(array: $this->getItems()),
            mode    : RecursiveIteratorIterator::CHILD_FIRST
        );

        $transformed = $this->getItems();

        foreach ($iterator as $key => $value) {
            if (! is_array(value: $value)) {
                $transformed[$key] = $callback($value, $key);
            }
        }

        return new static(items: $transformed);
    }
}

=== Cache/ReflectionCache.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Cache;

use ReflectionClass;

class ReflectionCache
{
    private static array $reflectionCache = [];

    /**
     * @throws \ReflectionException
     */
    public static function getReflectionClass(string $dtoClass) : ReflectionClass
    {
        return self::$reflectionCache[$dtoClass] ??= new ReflectionClass(objectOrClass: $dtoClass);
    }
}

=== ObjectHandling/Collections/BaseCollection.php ===
<?php

/** @noinspection PhpMemberCanBePulledUpInspection */

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Closure;
use Traversable;

/**
 * BaseCollection provides an abstract foundation for collections,
 * handling core functionalities and item storage while leaving specific collection behaviors to subclasses.
 *
 * This class is designed to be extended, providing common methods
 * that can be used by all types of collections.
 */
abstract class BaseCollection implements CollectionInterface
{
    /**
     * @var array Holds the items of the collection.
     * Using a protected array allows subclasses to access and manipulate the stored items directly.
     */
    protected array $items = [];

    /**
     * BaseCollection constructor.
     * Initializes the collection with the provided items.
     *
     * By accepting any iterable type, this constructor ensures flexibility in initializing the collection.
     *
     * @param iterable $items Initial items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Convert various types of inputs to an array.
     *
     * Ensures compatibility regardless of the input type,
     * whether it's an instance of self, Traversable, or an array.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array
    {
        if ($items instanceof self) {
            return $items->all();
        }

        if ($items instanceof Traversable) {
            return iterator_to_array(iterator: $items);
        }

        return (array) $items;
    }

    /**
     * Retrieve all items in the collection.
     *
     * Provides a consistent way to access all the items stored in the collection.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return $this->getItems();
    }

    /**
     * Abstract method to retrieve the internal items.
     * To be implemented by subclasses.
     *
     * Forces each subclass to define how items should be retrieved,
     * allowing for flexibility in different types of collections.
     *
     * @return array The items in the collection.
     */
    abstract public function getItems() : array;

    /**
     * Abstract method to set the internal items.
     * To be implemented by subclasses.
     *
     * Ensures that subclasses handle the specific logic for setting the items,
     * which can vary based on the type of collection.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    abstract public function setItems(array $items) : static;

    /**
     * Get an iterator for the collection.
     *
     * Supports iteration over the collection using foreach.
     *
     * @return Traversable An iterator over the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->getItems());
    }

    /**
     * Get the count of items in the collection.
     *
     * Provides a quick way to determine how many items are currently in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int
    {
        return count(value: $this->getItems());
    }

    /**
     * Convert the collection to an array for JSON serialization.
     *
     * Ensures that when the collection is JSON-encoded, it gets correctly represented as an array.
     *
     * @return array Data ready for JSON serialization.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Recursively converts nested collections to arrays.
     *
     * Handles nested collections to ensure they are also converted to arrays,
     * preserving the structure when serialized or manipulated.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array
    {
        return array_map(callback: fn($item) => $item instanceof self ? $item->toArray() : $item, array: $this->getItems());
    }

    // Abstract methods to be implemented by subclasses for specific functionalities

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|CollectionInterface $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function merge(array|CollectionInterface $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    abstract public function tap(Closure $callback) : static;
}

=== ObjectHandling/Collections/Collection.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayIterator;
use Avax\DataHandling\ArrayHandling\Traits\AbstractDependenciesTrait;
use Avax\DataHandling\ArrayHandling\Traits\AggregationTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayAccessTrait;
use Avax\DataHandling\ArrayHandling\Traits\ArrayConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\CollectionWalkthroughTrait;
use Avax\DataHandling\ArrayHandling\Traits\ConditionalsTrait;
use Avax\DataHandling\ArrayHandling\Traits\DebugTrait;
use Avax\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Avax\DataHandling\ArrayHandling\Traits\MacrosTrait;
use Avax\DataHandling\ArrayHandling\Traits\ManageItemsTrait;
use Avax\DataHandling\ArrayHandling\Traits\MetaInfoTrait;
use Avax\DataHandling\ArrayHandling\Traits\OrderManipulationTrait;
use Avax\DataHandling\ArrayHandling\Traits\PartitioningTrait;
use Avax\DataHandling\ArrayHandling\Traits\SetOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\SortOperationsTrait;
use Avax\DataHandling\ArrayHandling\Traits\StructureConversionTrait;
use Avax\DataHandling\ArrayHandling\Traits\TransformationTrait;
use Closure;
use Traversable;

/**
 * Collection class providing utilities for array manipulations.
 * Combines traits to enable sorting, filtering, partitioning, and more.
 */
class Collection extends BaseCollection implements CollectionInterface
{
    use AbstractDependenciesTrait;
    use AggregationTrait;
    use ArrayAccessTrait;
    use ArrayConversionTrait;
    use CollectionWalkthroughTrait;
    use ConditionalsTrait;
    use DebugTrait;
    use LazyEvaluationTrait;
    use MacrosTrait;
    use ManageItemsTrait;
    use MetaInfoTrait;
    use OrderManipulationTrait;
    use PartitioningTrait;
    use SetOperationsTrait;
    use SortOperationsTrait;
    use StructureConversionTrait;
    use TransformationTrait;

    /**
     * Internal storage for collection items specific to Collection.
     */
    protected array $elements = [];

    /**
     * Collection constructor.
     *
     * Initializes the collection with an optional set of items.
     *
     * @param iterable $items Initial set of items to populate the collection.
     */
    public function __construct(iterable $items = [])
    {
        parent::__construct(items: $items);
        $this->setItems(items: $this->convertToArray(items: $items));
    }

    /**
     * Set the internal elements array.
     *
     * @param array $items The items to set.
     *
     * @return static This collection instance.
     */
    public function setItems(iterable $items) : static
    {
        $this->elements = $items;

        return $this;
    }

    /**
     * Invokes a callback on the collection and returns the collection itself.
     *
     * Useful for debugging and inspection without altering chainability.
     *
     * @param Closure $callback The callback to execute.
     *
     * @return static The current collection instance for method chaining.
     */
    public function tap(Closure $callback) : static
    {
        $callback($this);

        return $this;
    }

    /**
     * Retrieves the first item that matches a given key-value pair.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value to compare against.
     *
     * @return mixed|null The first matching item or null if not found.
     */
    public function firstWhere(string $key, mixed $value) : mixed
    {
        foreach ($this->getItems() as $item) {
            if (($item[$key] ?? null) === $value) {
                return $item;
            }
        }

        return null;
    }

    /**
     * Get the internal elements array.
     *
     * @return array The elements in the collection.
     */
    public function getItems() : array
    {
        return $this->elements;
    }

    /**
     * Determine the maximum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The maximum value or null if the collection is empty.
     */
    public function max(string|null $key = null) : mixed
    {
        return max(
            value: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
    }

    /**
     * Determine the minimum value in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return mixed The minimum value or null if the collection is empty.
     */
    public function min(string|null $key = null) : mixed
    {
        return min(
            value: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
    }

    /**
     * Determine the mode (most frequent value) in the collection for a specific key.
     *
     * @param string|null $key The key to consider.
     *
     * @return string|int|null The mode or null if the collection is empty.
     */
    public function mode(string|null $key = null) : string|int|null
    {
        $counts = array_count_values(
            array: array_map(
                callback: static fn($item) => $key !== null && $key !== '' && $key !== '0' ? ($item[$key] ?? null) : $item,
                array   : $this->getItems(),
            ),
        );
        arsort(array: $counts);

        return array_key_first(array: $counts);
    }

    /**
     * Count items in the collection based on a given callback.
     *
     * @param Closure $callback The callback to determine the key for counting.
     *
     * @return static A new collection containing count values.
     */
    public function countBy(Closure $callback) : static
    {
        $counts = [];
        foreach ($this->getItems() as $item) {
            $key          = $callback($item);
            $counts[$key] = ($counts[$key] ?? 0) + 1;
        }

        return new static($counts);
    }

    /**
     * Appends a value to the end of the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static The current collection instance for method chaining.
     */
    public function append(mixed $value) : static
    {
        $this->elements[] = $value;

        return $this;
    }

    /**
     * Prepends a value to the beginning of the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static The current collection instance for method chaining.
     */
    public function prepend(mixed $value) : static
    {
        array_unshift($this->elements, $value);

        return $this;
    }

    /**
     * Merges the collection with another collection or array.
     *
     * Supports merging arrays or other collections seamlessly.
     *
     * @param CollectionInterface|array $items The items to merge.
     *
     * @return static The current collection instance for method chaining.
     */
    public function merge(CollectionInterface|array $items) : static
    {
        $mergedItems = array_merge($this->getItems(), is_array(value: $items) ? $items : $items->all());
        $this->setItems(items: $mergedItems);

        return $this;
    }

    /**
     * Returns the count of items in the collection.
     *
     * @return int The number of items in the collection.
     */
    public function count() : int
    {
        return count(value: $this->getItems());
    }

    /**
     * Returns an iterator for the collection.
     *
     * @return Traversable An iterator for the items.
     */
    public function getIterator() : Traversable
    {
        return new ArrayIterator(array: $this->getItems());
    }
}

=== ObjectHandling/Collections/CollectionInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use ArrayAccess;
use Closure;
use Countable;
use IteratorAggregate;
use JsonSerializable;

/**
 * CollectionInterface serves as a contract for collection operations that
 * supports various interfaces such as Countable, ArrayAccess, IteratorAggregate,
 * and JsonSerializable. This ensures a standardized way to manipulate
 * collections across the application.
 */
interface CollectionInterface extends Countable, ArrayAccess, IteratorAggregate, JsonSerializable
{
    /**
     * Retrieve all items in the collection.
     *
     * @return array All items in the collection.
     */
    public function all() : array;

    /**
     * Append an item to the collection.
     *
     * @param mixed $value The value to append.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function append(mixed $value) : static;

    /**
     * Prepend an item to the collection.
     *
     * @param mixed $value The value to prepend.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function prepend(mixed $value) : static;

    /**
     * Merge another collection or an array of items into this collection.
     *
     * @param array|self $items The items to merge.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function merge(array|self $items) : static;

    /**
     * Invoke the provided callback with the collection instance.
     * This allows operations to be performed on the collection within the callback.
     *
     * @param Closure $callback The callback to invoke.
     *
     * @return static This collection instance, enabling method chaining.
     */
    public function tap(Closure $callback) : static;

    /**
     * Convert the collection to an array.
     *
     * @return array The collection items as an array.
     */
    public function toArray() : array;

    /**
     * Get the count of items in the collection.
     *
     * @return int The number of items.
     */
    public function count() : int;

    /**
     * Convert various types of inputs to an array.
     * This accommodates different forms of collection items.
     *
     * @param mixed $items The items to convert.
     *
     * @return array The converted array.
     */
    public function convertToArray(mixed $items) : array;

    /**
     * Find the first item in the collection where a given key has a specific value.
     *
     * @param string $key   The key to search for.
     * @param mixed  $value The value of the key.
     *
     * @return mixed The first item matching the criteria.
     */
    public function firstWhere(string $key, mixed $value) : mixed;

    /**
     * Find the maximum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The maximum value.
     */
    public function max(string|null $key = null) : mixed;

    /**
     * Find the minimum value of a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for the whole item.
     *
     * @return mixed The minimum value.
     */
    public function min(string|null $key = null) : mixed;

    /**
     * Calculate the mode (most frequent value) for a given key in the collection.
     *
     * @param string|null $key The key to search by. Defaults to null for determining mode of the whole item.
     *
     * @return string|int|null The mode value, or null if no mode is found.
     */
    public function mode(string|null $key = null) : string|int|null;

    /**
     * Count items in the collection based on the given closure.
     *
     * @param Closure $callback The closure to determine the count criteria.
     *
     * @return static The collection instance, enabling method chaining.
     */
    public function countBy(Closure $callback) : static;
}

=== ObjectHandling/Collections/Exceptions/ItemNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections\Exceptions;

use Exception;

/**
 * Exception thrown when a specified item is not found in the collection.
 *
 * This exception is used to signal cases where an operation expected a specific
 * item to be available in the collection, but it wasn't found. It simplifies
 * error handling across the application by providing a specific exception type
 * for missing items, allowing for cleaner and more specific catch blocks.
 */
class ItemNotFoundException extends Exception
{
    /**
     * The default exception message indicating the item was not found.
     *
     * This message is pre-set to provide a consistent error message throughout
     * the application whenever an item is missing from a collection, avoiding
     * the need to define a message each time this exception is thrown.
     *
     * @var string
     */
    protected $message = 'The specified item was not found in the collection.';
}

=== ObjectHandling/Collections/LazyCollection.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\Collections;

use Avax\DataHandling\ArrayHandling\Traits\LazyEvaluationTrait;
use Closure;
use Traversable;

/**
 * Class LazyCollection
 *
 * This class represents a collection with lazy evaluation, where items are generated on the fly.
 * The primary benefit is memory efficiency, especially for large datasets.
 */
class LazyCollection extends Collection
{
    use LazyEvaluationTrait;

    /**
     * LazyCollection constructor.
     *
     * @param Closure $generator A generator function to build the collection lazily.
     */
    public function __construct(protected Closure $generator)
    {
        parent::__construct();
    }

    /**
     * Retrieve all items in the collection as an array.
     *
     * Converts the lazy-loaded items into a straightforward array.
     *
     * @return array The entire collection as an array.
     */
    public function all() : array
    {
        return iterator_to_array(iterator: $this->getIterator());
    }

    /**
     * Get an iterator for the collection.
     *
     * This method facilitates the lazy evaluation by returning the generator.
     *
     * @return Traversable The generator yielding items of the collection.
     */
    public function getIterator() : Traversable
    {
        return ($this->generator)();
    }

    /**
     * Get every nth item in the collection.
     *
     * This method is useful for scenarios where sampling at regular intervals is required.
     *
     * @param int $step The interval at which items are retrieved.
     *
     * @return static A new lazy collection containing every nth item.
     */
    public function nth(int $step) : static
    {
        return new static(generator: function () use ($step) {
            $index = 0;
            foreach ($this->getIterator() as $item) {
                if ($index++ % $step === 0) {
                    yield $item;
                }
            }
        });
    }

    /**
     * Take items from the collection while the callback returns true.
     *
     * This allows conditional data processing where items are taken as long as a condition holds.
     *
     * @param Closure $callback The condition used to continue taking items.
     *
     * @return static A new lazy collection containing items while the callback returns true.
     */
    public function takeWhile(Closure $callback) : static
    {
        return new static(generator: function () use ($callback) {
            foreach ($this->getIterator() as $item) {
                if (! $callback($item)) {
                    break;
                }

                yield $item;
            }
        });
    }
}

=== ObjectHandling/DTO/AbstractDTO.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO;

use Avax\DataHandling\ObjectHandling\DTO\Traits\CastsTypes;
use Avax\DataHandling\ObjectHandling\DTO\Traits\HandlesAttributes;
use Avax\DataHandling\ObjectHandling\DTO\Traits\HandlesHydration;
use Avax\DataHandling\ObjectHandling\DTO\Traits\InspectsProperties;
use Avax\DataHandling\ObjectHandling\DTO\Traits\Serialization;
use ReflectionException;

/**
 * Base abstract class for Data Transfer Objects (DTOs).
 *
 * This class provides the foundational structure for Data Transfer Objects within the application.
 * It is responsible for implementing shared behavior and logic such as:
 *
 * - Hydration from associative arrays.
 * - Property casting based on defined types.
 * - Attribute handling and lifecycle interactions.
 * - Inspection of available properties.
 * - Efficient serialization for DTO representations.
 *
 * The use of traits ensures a modular and reusable design, promoting separation of concerns.
 */
abstract class AbstractDTO
{
    /**
     * Include the `HandlesHydration` trait.
     *
     * Provides functionality for mapping external data (like arrays) into object properties.
     */
    use HandlesHydration;

    /**
     * Include the `CastsTypes` trait.
     *
     * Enables strict casting of properties into specified types, ensuring type safety when working
     * with data.
     */
    use CastsTypes;

    /**
     * Include the `HandlesAttributes` trait.
     *
     * Adds methods to manipulate and interact with internal object attributes dynamically.
     */
    use HandlesAttributes;

    /**
     * Include the `InspectsProperties` trait.
     *
     * Adds utilities to inspect the state of object properties during runtime, allowing access to
     * their metadata or dynamic availability checks.
     */
    use InspectsProperties;

    /**
     * Include the `Serialization` trait.
     *
     * Defines methods for serializing and deserializing object data to formats like arrays or JSON,
     * ensuring compatibility with external systems.
     */
    use Serialization;

    /**
     * Constructor with array hydration capability.
     *
     * Constructs a new instance of the Data Transfer Object (DTO) from an array of data.
     * This constructor leverages the `HandlesHydration` trait to populate DTO properties
     * with data provided in the array.
     *
     * @param array $data The associative array containing the initial properties of the DTO.
     *
     * @throws ReflectionException If reflection fails to evaluate class or property metadata during hydration.
     */
    public function __construct(array $data)
    {
        // Hydrate the object with the given data array.
        $this->hydrateFrom(data: $data);
    }
}
=== ObjectHandling/DTO/DTOValidationException.php ===
<?php

declare(strict_types=1); // Strict type declarations to enforce type safety and ensure predictable behavior of code.

namespace Avax\DataHandling\ObjectHandling\DTO;

use InvalidArgumentException;

/**
 * DTOValidationException
 *
 * This final exception class is specifically designed to encapsulate multiple
 * validation errors when dealing with Data Transfer Objects (DTOs).
 *
 * As part of Domain-Driven Design (DDD), this exception helps to clearly define
 * validation-related errors, thereby enhancing the domain layer's adherence to constraints
 * and encapsulating the behavior required to handle such errors.
 *
 * Extends:
 *  - InvalidArgumentException: This base exception aligns with the concept of invalid
 *    arguments being passed to a DTO during validation, enhancing semantic meaning.
 */
final class DTOValidationException extends InvalidArgumentException
{
    /**
     * A collection of validation errors.
     *
     * This property holds an associative array containing validation error messages,
     * where the key represents the invalid field name, and the value represents
     * the reason or detailed validation error message.
     *
     * The `readonly` contract ensures immutability of this object property after construction,
     * adhering to clean code principles for simple and predictable objects.
     *
     * @var array<string, string> An associative array where the keys are field names,
     *                            and the values are validation error messages.
     */
    public readonly array $errors;

    /**
     * Constructs a new DTOValidationException.
     *
     * Leverages constructor promotion for leaner and more expressive class construction
     * while ensuring appropriate validation messages and errors are encapsulated.
     *
     * @param string                $message A detailed exception message providing context about the DTO validation
     *                                       failure.
     * @param array<string, string> $errors  Associative array of validation errors, with keys as field names
     *                                       and values as corresponding messages explaining the validation failure.
     */
    public function __construct(
        string $message,
        array  $errors,
    )
    {
        $formattedErrors = [];

        foreach ($errors as $field => $errorMsg) {
            $formattedErrors[] = sprintf('%s: %s', $field, $errorMsg);
        }

        $message .= "\n" . implode(separator: "\n", array: $formattedErrors);

        parent::__construct(message: $message);
        $this->errors = $errors;
    }


    public function jsonSerialize() : array
    {
        return [
            'error'  => $this->getMessage(),
            'fields' => $this->getErrors(),
        ];
    }

    /**
     * Retrieves the collection of validation errors.
     *
     * This method provides read-only access to the `errors` property containing detailed
     * validation error information for the failed DTO attributes or fields.
     *
     * Keeping this method focused and simple aligns with the principles of clean code
     * by facilitating immutability and enforcing predictable behavior.
     *
     * @return array<string, string> Returns an associative array of validation errors, where the
     *                               keys represent the invalid fields or attributes, and the values
     *                               detail the validation issues.
     */
    public function getErrors() : array
    {
        // Return the immutably defined validation error details to the caller.
        return $this->errors;
    }

}
=== ObjectHandling/DTO/Support/PropertyMetadata.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Support;

use ReflectionAttribute;
use ReflectionProperty;

final readonly class PropertyMetadata
{
    public function __construct(
        public string             $name,
        public ReflectionProperty $property,
        /** @var array<ReflectionAttribute> */
        public array              $attributes,
    ) {}

    /**
     * Checks whether the property has an explicit type.
     */
    public function isTyped() : bool
    {
        return $this->property->hasType();
    }

    /**
     * Checks whether the property is nullable.
     */
    public function isNullable() : bool
    {
        $type = $this->property->getType();

        return $type?->allowsNull() ?? true;
    }

    /**
     * Returns true if at least one attribute matches the given FQCN (case-sensitive).
     */
    public function hasAttribute(string $fqcn) : bool
    {
        return $this->property->getAttributes(name: $fqcn) !== [];
    }

    /**
     * Instantiates all attributes.
     *
     * @return object[] List of attribute instances.
     */
    public function instantiateAttributes() : array
    {
        return array_map(
            callback: static fn(ReflectionAttribute $attr) => $attr->newInstance(),
            array   : $this->attributes
        );
    }
}

=== ObjectHandling/DTO/Support/Reflector.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Support;

use Avax\DataHandling\ObjectHandling\DTO\DTOValidationException;
use Avax\DataHandling\ObjectHandling\DTO\Traits\CastsTypes;
use Avax\DataHandling\ObjectHandling\DTO\Traits\HandlesAttributes;
use Avax\DataHandling\ObjectHandling\DTO\Traits\InspectsProperties;
use Avax\DataHandling\ObjectHandling\DTO\Traits\Serialization;
use InvalidArgumentException;
use ReflectionClass;
use ReflectionException;
use ReflectionProperty;
use Throwable;

/**
 * A utility class for handling deep reflection-based operations on DTOs.
 *
 * This class provides functionality for manipulating, inspecting, and hydrating
 * Data Transfer Objects (DTOs) through reflection, while maintaining domain and type safety.
 *
 * ### Key Responsibilities:
 * - Hydration of DTO properties with strict validation and error reporting.
 * - Reflection and inspection of public properties and their metadata.
 * - Handling complex business rules through attributes and type casting.
 *
 * @final This class is immutable in its implementation and should not be extended.
 */
final class Reflector
{
    /**
     * Use traits that modularize reflection-based behaviors.
     * - `InspectsProperties`: Adds the ability to inspect DTO object's properties.
     * - `CastsTypes`: Handles casting raw values to expected types as part of hydration.
     * - `HandlesAttributes`: Processes and applies custom attribute-based rules on properties.
     * - `Serialization`: Offers serialization support for the DTO.
     */
    use InspectsProperties;
    use CastsTypes;
    use HandlesAttributes;
    use Serialization;

    /**
     * The target object being reflected and operated on.
     *
     * This object is the primary reference for all reflection-based operations
     * such as property inspection, hydration, and serialization.
     *
     * @var object The DTO or object being managed by this reflector.
     */
    private object $target;

    /**
     * Constructs a Reflector instance and initializes it with a target object.
     *
     * Follows constructor promotion for lean and expressive initialization.
     *
     * @param object $target The target object for reflection and operations.
     */
    public function __construct(object $target)
    {
        $this->target = $target;
    }

    /**
     * Creates a Reflector instance for a specific object instance.
     *
     * This factory method enables a fluent and semantic API for initializing
     * a Reflector from an existing object.
     *
     * @param object $instance The object instance being wrapped by the reflector.
     *
     * @return self Returns a new Reflector instance.
     */
    public static function fromInstance(object $instance) : self
    {
        return new self(target: $instance);
    }

    /**
     * Creates a Reflector instance for a given class name.
     *
     * Uses `ReflectionClass` to instantiate the object without calling its constructor,
     * allowing flexibility for reflection-based object construction and hydration.
     *
     * @param string $className The fully qualified class name of the target object.
     *
     * @return self Returns a new Reflector instance wrapping the created object.
     * @throws ReflectionException If the provided class does not exist or cannot be instantiated.
     *
     */
    public static function fromClass(string $className) : self
    {
        return new self(target: (new ReflectionClass(objectOrClass: $className))->newInstanceWithoutConstructor());
    }

    /**
     * Hydrates the target object with the provided raw data.
     *
     * Iterates over the public properties of the target object and applies the
     * given raw data to each property. Attributes and type safety rules are
     * respected during the process, ensuring that all DTO constraints are enforced.
     *
     * @param array<string, mixed> $data An associative array mapping property names
     *                                   to their corresponding values.
     *
     * @throws DTOValidationException If hydration fails due to validation or type casting errors.
     * @throws ReflectionException    If reflection operations encounter an issue.
     */
    public function hydrate(array $data) : void
    {
        // Initialize an empty array to collect errors during the hydration process.
        $errors = [];

        // Iterate through all public fields of the target object.
        foreach ($this->reflectPublicFields() as $meta) {
            try {
                // Attempt to hydrate the given field using the metadata and data provided.
                $this->hydrateField(
                    name      : $meta->name,
                    property  : $meta->property,
                    attributes: $meta->attributes,
                    data      : $data
                );
            } catch (Throwable $exception) {
                // Capture and format any errors that occur during hydration.
                $errors[$meta->name] = $this->formatHydrationError(
                    fieldName: $meta->name,
                    exception: $exception
                );
            }
        }

        // If any errors occurred during hydration, throw a validation exception.
        if (! empty($errors)) {
            throw new DTOValidationException(
                message: 'DTO hydration failed.',
                errors : $errors
            );
        }
    }

    /**
     * Populates a specific field of the target object with a value from the data array.
     *
     * The method validates the presence of the field in the raw data, handles type casting,
     * and applies any field-specific attributes before assigning the final value.
     *
     * @param string             $name       The name of the property being hydrated.
     * @param ReflectionProperty $property   The reflection of the target property.
     * @param array              $attributes An array of attributes applied to the property.
     * @param array              $data       The raw input data used for hydration.
     */
    private function hydrateField(
        string             $name,
        ReflectionProperty $property,
        array              $attributes,
        array              $data
    ) : void
    {
        // If the field is not present in the data array, handle it as missing.
        if (! array_key_exists(key: $name, array: $data)) {
            $this->handleMissingField(name: $name, property: $property);

            return;
        }

        // Extract the raw value corresponding to the field.
        $rawValue = $data[$name];

        // Cast the raw value to the expected type of the property.
        $resolvedValue = $this->castToExpectedType(property: $property, value: $rawValue);

        // Apply attribute-specific rules or transformations to the field value.
        $resolvedValue = $this->applyFieldAttributes(
            fieldName : $name,
            value     : $resolvedValue,
            attributes: $attributes
        );

        // Assign the resolved value to the corresponding property of the target object.
        $this->target->{$name} = $resolvedValue;
    }

    /**
     * Handles cases where required data for a field is missing.
     *
     * This method sets default values or null based on the property's attributes
     * or throws an exception if the property is mandatory and cannot be resolved.
     *
     * @param string             $name     The name of the missing property.
     * @param ReflectionProperty $property The reflection of the target property.
     *
     * @throws InvalidArgumentException If no suitable value is found for the missing property.
     */
    private function handleMissingField(string $name, ReflectionProperty $property) : void
    {
        // If the property is nullable, assign a null value to the field.
        if ($this->isPropertyNullable(property: $property)) {
            $this->target->{$name} = null;

            return;
        }

        // If the property has a default value, assign it to the field.
        if ($property->hasDefaultValue()) {
            $this->target->{$name} = $property->getDefaultValue();

            return;
        }

        // Throw an exception when no suitable value is available for the property.
        throw new InvalidArgumentException(message: "Missing required field: {$name}");
    }

    /**
     * Formats detailed error messages for failed hydration of a single field.
     *
     * @param string    $fieldName The name of the field where hydration failed.
     * @param Throwable $exception The exception that occurred during hydration.
     *
     * @return string Returns a string describing the error with the field's name and exception message.
     */
    private function formatHydrationError(string $fieldName, Throwable $exception) : string
    {
        return sprintf(
            '%s  Field "%s": %s',
            $this->target::class,
            $fieldName,
            $exception->getMessage()
        );
    }

    /**
     * Retrieves the target object being operated on by the Reflector.
     *
     * @return object The target object.
     */
    public function getTarget() : object
    {
        return $this->target;
    }

    /**
     * Converts the public properties of a target object into a schema-friendly array format.
     *
     * This method inspects the metadata of all public fields in the object,
     * including property type, nullability, and attributes,
     * and formats this data into an array representation.
     *
     * @return array An array representing the schema of the object's public fields.
     * @throws \ReflectionException If reflection operations encounter an error.
     */
    public function toSchema() : array
    {
        // Apply a transformation to each metadata entry from reflectPublicFields().
        // The resulting array will contain a schema representation for each public property.
        return array_map(
            callback: fn($meta) => [
                // Add the property name to the schema array.
                'name'       => $meta->name,

                // Add the property type to the schema array. If no type is defined, default to 'mixed'.
                'type'       => $meta->property->getType()?->getName() ?? 'mixed',

                // Add the nullability information of the property to the schema array.
                'nullable'   => $meta->isNullable(),

                // Map the attributes of the property to their names and add them to the schema array.
                'attributes' => array_map(callback: fn($a) => $a->getName(), array: $meta->attributes),
            ],

            // Retrieve metadata for all public fields of the target object.
            // Metadata includes details about the properties of the object being reflected.
            array   : $this->reflectPublicFields()
        );
    }
}
=== ObjectHandling/DTO/Traits/CastsTypes.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Traits;

use Avax\DataHandling\ObjectHandling\DTO\AbstractDTO;
use BackedEnum;
use InvalidArgumentException;
use ReflectionIntersectionType;
use ReflectionNamedType;
use ReflectionProperty;
use ReflectionUnionType;

/**
 * Trait CastsTypes
 *
 * This trait provides sophisticated value-casting mechanisms
 * to enable flexible and reliable data transfer object (DTO) hydration.
 *
 * Supports:
 * - Nested DTO instances
 * - Arrays of DTOs (DTO[])
 * - Backed Enums
 * - Primitive type fallback pass through
 *
 * Uses strict type checking and powerful casting techniques
 * to resolve property type constraints dynamically.
 */
trait CastsTypes
{
    /**
     * Provides a public entry point to the internal casting mechanism.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return mixed The casted value matching the expected type of the property.
     */
    public function castTo(ReflectionProperty $property, mixed $value) : mixed
    {
        // Delegates to the internal casting method.
        return $this->castToExpectedType(property: $property, value: $value);
    }

    /**
     * Dynamically dispatches value casting logic based on the property's type metadata.
     *
     * Uses `match` to select the appropriate casting method:
     * - DTO detection
     * - Array of DTOs detection
     * - Backed Enums detection
     *
     * Falls back to the raw value if no special handling is needed.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return mixed The casted value (or the original value if no special casting is applied).
     */
    protected function castToExpectedType(ReflectionProperty $property, mixed $value) : mixed
    {
        return match (true) {
            $this->isDTOType(property: $property)    => $this->castToDTO(property: $property, value: $value),
            $this->isDTOArray(property: $property)   => $this->castToDTOArray(property: $property, value: $value),
            $this->isBackedEnum(property: $property) => $this->castToEnum(property: $property, value: $value),
            default                                  => $value,
        };
    }

    /**
     * Checks if the given property is a subclass of the current DTO base class.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property maps to a DTO class, `false` otherwise.
     */
    protected function isDTOType(ReflectionProperty $property) : bool
    {
        $type = $this->resolvePropertyType(property: $property);

        return $type !== null && is_subclass_of(object_or_class: $type, class: AbstractDTO::class);
    }

    /**
     * Resolves the fully qualified class name or built-in type of a property.
     *
     * Prioritizes class names over scalars when multiple union types are present.
     *
     * @param ReflectionProperty $property The property for which to determine the type.
     *
     * @return string|null The resolved class or scalar type name, or null if unavailable.
     */
    protected function resolvePropertyType(ReflectionProperty $property) : string|null
    {
        $type = $property->getType();

        // If no type is declared, return null
        if ($type === null) {
            return null;
        }

        // Handle single-named types directly
        if ($type instanceof ReflectionNamedType) {
            return $type->getName();
        }

        // Handle union types (e.g., string|int|EnumType)
        if ($type instanceof ReflectionUnionType) {
            // Extract only named types excluding null/mixed/etc.
            $types = array_filter(
                array   : $type->getTypes(),
                callback: fn($t) => $t instanceof ReflectionNamedType && $t->getName() !== 'null'
            );

            // Prioritize classes (DTO/Enum) over scalar primitives
            usort(
                array   : $types,
                callback: fn(ReflectionNamedType $a, ReflectionNamedType $b) : int => class_exists(
                        class: $b->getName()
                    ) <=> class_exists(class: $a->getName())
            );

            return $types[0]?->getName();
        }

        // Handle intersection types (PHP 8.2+)
        if ($type instanceof ReflectionIntersectionType) {
            foreach ($type->getTypes() as $named) {
                if ($named instanceof ReflectionNamedType) {
                    return $named->getName();
                }
            }
        }

        return null;
    }

    /**
     * Casts a given value to a DTO instance.
     *
     * Initializes a new DTO instance by passing a normalized array of values to its constructor.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value to be casted.
     *
     * @return object A new DTO instance based on the resolved class type.
     *
     * @throws InvalidArgumentException If the resolved class is invalid or not a DTO.
     */
    protected function castToDTO(ReflectionProperty $property, mixed $value) : object
    {
        $class = $this->resolvePropertyType(property: $property);
        $this->assertDTOClass(class: $class, property: $property);

        // Instantiate the DTO using the normalized array of input data.
        return new $class($this->normalizeToArray(value: $value));
    }

    /**
     * Validates whether the given class is a valid subclass of the DTO base class.
     *
     * @param string|null        $class    The class name to validate.
     * @param ReflectionProperty $property The property for which the class is being validated.
     *
     * @throws InvalidArgumentException If the class is not a valid DTO.
     */
    protected function assertDTOClass(string|null $class, ReflectionProperty $property) : void
    {
        if ($class === null || ! class_exists(class: $class) || ! is_subclass_of(object_or_class: $class, class: AbstractDTO::class)) {
            throw new InvalidArgumentException(
                message: sprintf(
                    "Invalid DTO class '%s' for property '%s'.",
                    $class ?? 'null',
                    $property->getName()
                )
            );
        }
    }

    /**
     * Normalizes a mixed input value into an array.
     *
     * Ensures that values can be safely passed as an array during DTO instantiation.
     *
     * @param mixed $value The raw input value.
     *
     * @return array The normalized array representation of the input.
     */
    protected function normalizeToArray(mixed $value) : array
    {
        return is_array(value: $value) ? $value : (array) $value;
    }

    /**
     * Checks if the given property corresponds to an array of DTO instances.
     *
     * Determines this by analyzing the type information and optional metadata
     * from PHPDoc annotations or attributes.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property is an array of DTOs, `false` otherwise.
     */
    protected function isDTOArray(ReflectionProperty $property) : bool
    {
        return $this->resolvePropertyType(property: $property) === 'array'
            && $this->resolveDTOClassFromAnnotationsOrAttributes(property: $property) !== null;
    }

    /**
     * Resolves the class name of the DTO from either PHP attributes or @param ReflectionProperty $property The
     * property for which to resolve the class.
     *
     * @return string|null The fully qualified class name of the DTO, or `null` if not found.
     * "@var annotations"
     *
     */
    protected function resolveDTOClassFromAnnotationsOrAttributes(ReflectionProperty $property) : string|null
    {
        // Check for attributes first.
        foreach ($property->getAttributes() as $attribute) {
            $instance = $attribute->newInstance();
            if (method_exists(object_or_class: $instance, method: 'of')) {
                return $instance->of();
            }
        }

        // Fallback to PHPDoc annotations.
        $doc = $property->getDocComment();
        if ($doc && preg_match(pattern: '/@var\s+([\w\\\\]+)\[\]/', subject: $doc, matches: $matches)) {
            return ltrim(string: $matches[1], characters: '\\');
        }

        return null;
    }

    /**
     * Casts a given value to an array of DTO instances.
     *
     * Iterates over the input array and creates a new DTO instance for each element.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw value (array) to be casted.
     *
     * @return array An array of DTO instances.
     *
     * @throws InvalidArgumentException If the DTO class is invalid.
     */
    protected function castToDTOArray(ReflectionProperty $property, mixed $value) : array
    {
        $class = $this->resolveDTOClassFromAnnotationsOrAttributes(property: $property);
        $this->assertDTOClass(class: $class, property: $property);

        // Map each array element to a new DTO instance.
        return array_map(
            callback: fn($item) => new $class($this->normalizeToArray(value: $item)),
            array   : is_array(value: $value) ? $value : []
        );
    }

    /**
     * Checks if the given property maps to a backed enum.
     *
     * @param ReflectionProperty $property The property to inspect.
     *
     * @return bool `true` if the property type is a subclass of `BackedEnum`, `false` otherwise.
     */
    protected function isBackedEnum(ReflectionProperty $property) : bool
    {
        $type = $this->resolvePropertyType(property: $property);

        return $type !== null
            && enum_exists(enum: $type)
            && is_subclass_of(object_or_class: $type, class: BackedEnum::class);
    }

    /**
     * Casts a scalar value to its corresponding backed enum instance.
     *
     * @param ReflectionProperty $property The property to cast the value for.
     * @param mixed              $value    The raw scalar value to be converted.
     *
     * @return BackedEnum|string|null The enum instance corresponding to the given value.
     *
     */
    protected function castToEnum(ReflectionProperty $property, mixed $value) : BackedEnum|string|null
    {
        if ($value === null) {
            return null;
        }

        $type = $this->resolvePropertyType(property: $property);
        $this->assertEnumClass(class: $type, property: $property);

        /** @var class-string<BackedEnum> $type */
        if ($value instanceof $type) {
            return $value;
        }

        $enum = $type::tryFrom(value: $value);

        if (! $enum) {
            throw new InvalidArgumentException(
                message: sprintf(
                    "Invalid enum value '%s' for '%s' on property '%s'. Valid: [%s]",
                    is_scalar(value: $value) ? $value : gettype(value: $value),
                    $type,
                    $property->getName(),
                    implode(separator: ', ', array: array_map(callback: static fn($case) => $case->value, array: $type::cases()))
                )
            );
        }

        return $enum;
    }


    /**
     * Asserts that the given type is a valid backed enum class.
     *
     * @param string|null        $class    The class name to validate.
     * @param ReflectionProperty $property The property for which the enum is being validated.
     *
     * @throws InvalidArgumentException If the class is not a valid backed enum.
     */
    protected function assertEnumClass(string|null $class, ReflectionProperty $property) : void
    {
        if ($class === null || ! enum_exists(enum: $class) || ! is_subclass_of(object_or_class: $class, class: BackedEnum::class)) {
            throw new InvalidArgumentException(
                message: sprintf(
                    "Invalid enum type '%s' for property '%s'. Must be a backed enum.",
                    $class ?? 'null',
                    $property->getName()
                )
            );
        }
    }
}
=== ObjectHandling/DTO/Traits/HandlesAttributes.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Traits;

use InvalidArgumentException;
use ReflectionAttribute;
use Throwable;

/**
 * Trait HandlesAttributes
 *
 * **Purpose**: This trait provides reusable functionality to apply transformations
 * and validations to object fields via custom attributes. It centralizes attribute
 * handling logic for better maintainability and reusability.
 *
 * **Context in DDD**: Designed for entities or value objects that require attribute-driven
 * field transformations and validations, fostering clean and declarative object definitions.
 *
 * **Key Features**:
 * - Instantiation of attributes.
 * - Transformation of field values using attribute logic.
 * - Validation of field values against attribute-defined rules.
 */
trait HandlesAttributes
{
    /**
     * Applies the given attributes to modify and/or validate the value of a field.
     * Each attribute may define transformation (`apply`) logic or validation (`validate`) logic.
     *
     * **Usage in DDD**: Enables well-encapsulated validation and behavior adjustments
     * directly linked to the domain model's field attributes.
     *
     * @param string                $fieldName  The name of the field currently being processed.
     * @param mixed                 $value      The current value of the field, passed by reference for in-place
     *                                          updates.
     * @param ReflectionAttribute[] $attributes A collection of `ReflectionAttribute` instances to apply.
     *
     * @return mixed
     *
     */
    protected function applyFieldAttributes(string $fieldName, mixed &$value, array $attributes) : mixed
    {
        // Iterate over all attributes associated with the field.
        foreach ($attributes as $attribute) {
            // Instantiate the attribute into a usable object.
            $instance = $this->instantiateAttribute(attribute: $attribute);

            // Apply transformation logic if the attribute defines the `apply` method.
            if (method_exists(object_or_class: $instance, method: 'apply')) {
                $value = $this->applyAttribute(instance: $instance, value: $value, fieldName: $fieldName);
            }

            // Perform validation if the attribute defines the `validate` method.
            if (method_exists(object_or_class: $instance, method: 'validate')) {
                $this->validateAttribute(instance: $instance, value: $value, fieldName: $fieldName);
            }
        }

        return $value;
    }

    /**
     * Instantiates an attribute safely and ensures its validity for further processing.
     *
     * **Delegated Responsibility**: Verifies the integrity of an attribute's instantiation,
     * ensuring downstream logic (like `apply` or `validate`) receives a valid object.
     *
     * @param ReflectionAttribute $attribute The `ReflectionAttribute` instance to instantiate.
     *
     * @return object The instantiated attribute object, ready for application.
     *
     * @throws InvalidArgumentException If attribute instantiation fails due to invalid parameters
     *                                  or a runtime exception.
     */
    private function instantiateAttribute(ReflectionAttribute $attribute) : object
    {
        try {
            // Create an instance of the attribute dynamically.
            return $attribute->newInstance();
        } catch (Throwable $e) {
            // Throw a developer-friendly error with contextual information.
            throw new InvalidArgumentException(
                message : sprintf(
                    'Failed to instantiate attribute of type "%s": %s',
                    $attribute->getName(),
                    $e->getMessage()
                ),
                code    : 422, // Exception code (standardized as 0 for consistent exception chaining).
                previous: $e // Preserve the original exception for backtrace details.
            );
        }
    }

    /**
     * Applies the transformation logic defined by the `apply` method of an attribute.
     *
     * **Domain Use Case**: Alters the field value as determined by attribute-specific
     * transformation rules, enriching the domain model with declarative behavior logic.
     *
     * @param object $instance  The instantiated attribute object with the `apply` method.
     * @param mixed  $value     The current field value to be transformed.
     * @param string $fieldName The name of the field to provide context in case of errors.
     *
     * @return mixed The transformed value after applying the attribute's logic.
     *
     * @throws InvalidArgumentException If the `apply` method fails or is improperly implemented.
     */
    private function applyAttribute(object $instance, mixed $value, string $fieldName) : mixed
    {
        try {
            // Invoke the attribute's `apply` method and return the modified value.
            return $instance->apply($value);
        } catch (Throwable $e) {
            // Throw an exception with clear diagnostic information.
            throw new InvalidArgumentException(
                message : sprintf(
                    'The "apply" method of attribute "%s" failed for field "%s": %s',
                    $instance::class,
                    $fieldName,
                    $e->getMessage()
                ),
                code    : 422, // Exception code to maintain consistent exception hierarchy.
                previous: $e // Preserve chained exception details for diagnosis.
            );
        }
    }

    /**
     * Validates a value against the rules defined by an attribute's `validate` method.
     *
     * **Domain Implication**: Ensures that field values adhere to domain-driven constraints encapsulated
     * by attributes, supporting robust domain model invariants.
     *
     * @param object $instance  The instantiated attribute object with validation capability.
     * @param mixed  $value     The current field value to be validated.
     * @param string $fieldName The name of the field being validated for error reporting.
     *
     * @return void
     *
     * @throws InvalidArgumentException If validation rules are violated or improperly implemented.
     */
    private function validateAttribute(object $instance, mixed $value, string $fieldName) : void
    {
        try {
            // Invoke the attribute's `validate` method to perform validation checks.
            $instance->validate($value, $fieldName);
        } catch (Throwable $e) {
            // Throw informative validation exceptions to aid debugging.
            throw new InvalidArgumentException(
                message : sprintf(
                    'Validation failed for field "%s" with attribute "%s": %s',
                    $fieldName,
                    $instance::class,
                    $e->getMessage()
                ),
                code    : 422, // Maintain consistent exception codes.
                previous: $e // Include original exception for additional debug trace.
            );
        }
    }
}
=== ObjectHandling/DTO/Traits/HandlesHydration.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Traits;

use Avax\DataHandling\ObjectHandling\DTO\DTOValidationException;
use InvalidArgumentException;
use ReflectionProperty;
use Throwable;

/**
 * The `HandlesHydration` trait provides advanced hydration logic for DTO objects.
 *
 * It operates by using reflection to dynamically populate object properties with
 * provided raw data while performing type casting, validation, and handling attributes.
 * This ensures that the hydrated object adheres to the defined structure and constraints.
 */
trait HandlesHydration
{
    /**
     * Method responsible for dynamic hydration of the object with raw input data.
     *
     * The method processes each public field of the DTO using reflection, applying
     * type validation, attribute-based transformations, and error handling for invalid data.
     *
     * @param array<string, mixed> $data An associative array of input data for hydration,
     *                                   where keys correspond to public property names
     *                                   and values represent their respective input values.
     *
     * @throws DTOValidationException Thrown if one or more fields fail validation during hydration.
     * @throws \ReflectionException   Raised when an error occurs in accessing reflective metadata for the class.
     */
    public function hydrateFrom(array $data) : void
    {
        $errors        = [];
        $simpleMessage = null;

        foreach ($this->reflectPublicFields() as $meta) {
            try {
                $this->hydrateField(
                    name      : $meta->name,
                    property  : $meta->property,
                    attributes: $meta->attributes,
                    data      : $data
                );
            } catch (Throwable $e) {
                $errors[$meta->name] = $this->formatHydrationError(
                    fieldName: $meta->name,
                    e        : $e
                );

                $simpleMessage = $e->getMessage();
            }
        }

        if (! empty($errors)) {
            logger()->warning(
                message: 'DTO hydration failed - ' . $simpleMessage,
                context: ['errors' => $errors]
            );

            throw new DTOValidationException(
                message: 'DTO hydration failed - ' . $simpleMessage,
                errors : $errors
            );
        }
    }

    /**
     * Hydrates a single field of the DTO by casting, validating, and assigning the value.
     *
     * @param string             $name
     * @param ReflectionProperty $property
     * @param array              $attributes
     * @param array              $data
     */
    protected function hydrateField(
        string             $name,
        ReflectionProperty $property,
        array              $attributes,
        array              $data
    ) : void
    {
        if (! array_key_exists(key: $name, array: $data)) {
            $this->handleMissingField(name: $name, property: $property);

            return;
        }

        $rawValue = $data[$name];

        //  STEP 1: Type casting FIRST
        $resolvedValue = $this->castToExpectedType(
            property: $property,
            value   : $rawValue
        );

        //  STEP 2: Validate AFTER casting
        $this->validateField(
            fieldName : $name,
            value     : $resolvedValue,
            attributes: $attributes
        );

        //  STEP 3: Set property after validation
        $this->$name = $resolvedValue;
    }

    /**
     * Handles scenarios where a field is missing during hydration by
     * either assigning a default value, setting it to `null` if nullable,
     * or throwing an exception for required fields.
     *
     * @param string             $name      The name of the missing property in the DTO.
     * @param ReflectionProperty $property  Reflective metadata for the missing property,
     *                                      used to inspect its type and default value.
     *
     * @throws InvalidArgumentException If the field is required but no value or default is provided.
     */
    protected function handleMissingField(string $name, ReflectionProperty $property) : void
    {
        // Check if the property explicitly allows null values using type reflection.
        if ($this->isPropertyNullable(property: $property)) {
            // Assign null to the property if it is nullable.
            $this->$name = null;

            return;
        }

        // Check if the property has a default value defined in the class.
        if ($property->hasDefaultValue()) {
            // Retrieve and assign the default value to the property if available.
            $this->$name = $property->getDefaultValue();

            return;
        }

        // Log a warning indicating that a required field is missing during hydration.
        logger()->warning(
            message: 'Missing required field: ' . $name, // Descriptive message for the log entry.
            context: ['class' => static::class] // Include the class name for debugging context.
        );

        // Throw an exception if the field is required and no value or default is provided.
        throw new InvalidArgumentException(
            message: "Missing required field: {$name}" // Provide a clear error message.
        );
    }

    /**
     * Validates the resolved value with all assigned attributes.
     *
     * @param string $fieldName
     * @param mixed  $value
     * @param array  $attributes
     */
    private function validateField(string $fieldName, mixed $value, array $attributes) : void
    {
        foreach ($attributes as $attribute) {
            if (method_exists(object_or_class: $attribute, method: 'validate')) {
                $attribute->validate(
                    value   : $value,
                    property: $fieldName
                );
            }
        }
    }

    /**
     * Formats a hydration error for detailed exception reporting.
     *
     * @param string    $fieldName
     * @param Throwable $e
     *
     * @return string
     */
    private function formatHydrationError(string $fieldName, Throwable $e) : string
    {
        return sprintf(
            '%s  Field "%s": %s',
            static::class,
            $fieldName,
            $e->getMessage()
        );
    }
}

=== ObjectHandling/DTO/Traits/InspectsProperties.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Traits;

use Avax\DataHandling\ObjectHandling\DTO\Support\PropertyMetadata;
use ReflectionClass;
use ReflectionException;
use ReflectionProperty;

/**
 * Trait InspectsProperties
 *
 * Provides a set of metadata reflection utilities for Data Transfer Objects (DTOs),
 * enabling efficient and consistent introspection of public properties.
 *
 * Key features:
 * - Caches reflection metadata per class for optimized performance.
 * - Supplies structured metadata constructs (`PropertyMetadata`), making them reusable across the application.
 * - Supports property-level logic that promotes composition, testability, and maintainability.
 */
trait InspectsProperties
{
    /**
     * @var array<class-string, PropertyMetadata[]> Stores cached metadata for each class.
     *                                              This cache prevents redundant reflection calls, thereby improving
     *                                              performance.
     */
    private static array $metadataCache = [];

    /**
     * Queries and retrieves metadata for a specific property of the DTO by its name.
     *
     * @param string $name The name of the property for which metadata is being retrieved.
     *
     * @return PropertyMetadata|null The structured metadata for the given property, or `null`
     *                               if the property does not exist or is inaccessible.
     *
     * @throws ReflectionException If there are issues during reflection (e.g., invalid class or property access).
     */
    protected function reflectField(string $name) : PropertyMetadata|null
    {
        // Iterate through all public property metadata; match the target property by name
        foreach ($this->reflectPublicFields() as $metadata) {
            if ($metadata->name === $name) {
                // Return the matched metadata if found
                return $metadata;
            }
        }

        // Return null if the property is not found
        return null;
    }

    /**
     * Retrieves metadata for all publicly accessible properties of the current DTO class.
     *
     * @return PropertyMetadata[] An array of `PropertyMetadata` instances, representing all metadata
     *                            for the public properties of the DTO.
     *
     * @throws ReflectionException If reflection fails during metadata construction.
     */
    protected function reflectPublicFields() : array
    {
        // Use the static class name as a reference for caching
        $class = static::class;

        // Attempt to retrieve cached metadata or lazily generate it if unavailable
        return self::$metadataCache[$class] ??= $this->buildMetadataFor(class: $class);
    }

    /**
     * Dynamically builds and caches property metadata for a given class.
     *
     * This provides efficient inspection of all public properties and ensures a reusable
     * metadata structure for future operations like validation or serialization.
     *
     * @param class-string $class The fully qualified name of the class whose properties will be inspected.
     *
     * @return PropertyMetadata[] An array of `PropertyMetadata` objects, one for each public property of the class.
     *
     * @throws ReflectionException If the class cannot be reflected upon (e.g., invalid class name).
     */
    private function buildMetadataFor(string $class) : array
    {
        // Initialize a ReflectionClass instance to inspect the class structure
        $reflection = new ReflectionClass(objectOrClass: $class);

        // Use an array mapping function to convert ReflectionProperty instances to PropertyMetadata objects
        return array_map(
            callback: static fn(ReflectionProperty $property) : PropertyMetadata => new PropertyMetadata(
                name      : $property->getName(),       // Assign the property name
                property  : $property,             // Embed the ReflectionProperty instance
                attributes: $property->getAttributes() // Extract any PHP attributes applied to the property
            ),
            array   : $reflection->getProperties(filter: ReflectionProperty::IS_PUBLIC) // Focus only on public properties
        );
    }

    /**
     * Determines whether a given property allows null values.
     *
     * This function is useful for validation or type safety checks where
     * nullable types impact business logic.
     *
     * @param ReflectionProperty $property The property to evaluate.
     *
     * @return bool Returns `true` if the property allows null values; otherwise, `false`.
     */
    protected function isPropertyNullable(ReflectionProperty $property) : bool
    {
        // Retrieve the property type and check if it explicitly allows null values
        $type = $property->getType();

        // Return true if the type allows null, or if no type is defined
        return $type?->allowsNull() ?? true;
    }

    /**
     * Checks if a specific attribute has been applied to a property.
     *
     * This method supports reflection-based checks for attributes, enabling flexible configuration
     * and behavior customization driven by annotations or metadata.
     *
     * @param ReflectionProperty $property     The property to check for attributes.
     * @param class-string       $attributeFqn The fully qualified name of the attribute class to look for.
     *
     * @return bool `true` if the property has been annotated with the given attribute; `false` otherwise.
     */
    protected function hasAttribute(ReflectionProperty $property, string $attributeFqn) : bool
    {
        // Use the ReflectionProperty API to fetch attributes by their fully qualified name
        return ! empty($property->getAttributes(name: $attributeFqn));
    }

    /**
     * Retrieves the first resolved attribute instance of a given type on a property.
     *
     * @param ReflectionProperty $property     The property to inspect. Represents a class property.
     *                                         Provides metadata about its type, visibility, and attributes.
     * @param class-string       $attributeFqn Fully qualified class name (FQN) of the attribute.
     *                                         Used to look up the attribute on the property.
     *
     * @return object|null The resolved attribute instance, or null if the attribute is not present on the property.
     *                     This ensures type-safe use of specific attributes in further logic.
     */
    protected function getAttribute(ReflectionProperty $property, string $attributeFqn) : object|null
    {
        // Retrieve all attributes that match the given fully qualified name on the property.
        $attributes = $property->getAttributes(name: $attributeFqn);

        // If no attributes of the provided class type are present, immediately return null.
        if (empty($attributes)) {
            return null;
        }

        // Instantiate and return the first attribute instance found. Assumes resolving the attribute is lightweight.
        return $attributes[0]->newInstance();
    }

    /**
     * Checks if the property has at least one attribute from a given list.
     *
     * Designed to optimize lookups when validating if a property contains any of several related attributes.
     *
     * @param ReflectionProperty $property The property to inspect. Provides introspection features
     *                                     for examining attribute metadata and existence.
     * @param string[]           $fqns     A list of fully qualified attribute class names (FQNs) to check against.
     *                                     Each entry should be a valid class-string.
     *
     * @return bool True if at least one of the specified attributes is defined on the property,
     *              otherwise false.
     */
    protected function hasAnyAttribute(ReflectionProperty $property, array $fqns) : bool
    {
        // Iterate through the provided list of attribute FQNs.
        foreach ($fqns as $attributeFqn) {
            // Check if any attributes matching the current FQN exist on the property.
            if (! empty($property->getAttributes(name: $attributeFqn))) {
                // Return true immediately if at least one attribute is found.
                return true;
            }
        }

        // Return false if no matching attributes exist for any provided FQN.
        return false;
    }
}
=== ObjectHandling/DTO/Traits/Serialization.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\ObjectHandling\DTO\Traits;

use Avax\DataHandling\ObjectHandling\Collections\Collection;
use Avax\DataHandling\Validation\Attributes\Hidden;
use BackedEnum;
use DateTimeInterface;
use JsonException;
use JsonSerializable;
use ReflectionException;
use ReflectionProperty;
use stdClass;
use Traversable;

/**
 * Trait Serialization
 *
 * Provides recursive, flexible serialization capabilities for Data Transfer Objects (DTO).
 * Includes support for:
 * - JSON serialization with optional formatting.
 * - Recursive normalization of nested data structures.
 * - Handling of custom types such as enums, dates, and objects.
 * - Filtering of fields using #[Hidden] attributes.
 *
 * Designed to integrate seamlessly with Domain-Driven Design (DDD) practices.
 */
trait Serialization
{
    /**
     * Converts the DTO to a JSON string representation.
     * Useful for logging or debugging purposes.
     *
     * @return string The JSON representation of the DTO.
     * @throws JsonException|ReflectionException If an error occurs during encoding.
     */
    public function __toString() : string
    {
        return $this->toJson(flags: JSON_PRETTY_PRINT); // Beautify JSON output for readability.
    }

    /**
     * Encodes the DTO to a JSON string with optional flags and encoding depth.
     *
     * @param int|null $flags Optional JSON encoding flags (e.g., JSON_PRETTY_PRINT).
     * @param int      $depth Maximum depth for JSON serialization to prevent infinite recursion.
     *
     * @return string The JSON-encoded string representation of the DTO.
     * @throws JsonException|ReflectionException If JSON encoding fails.
     */
    public function toJson(int|null $flags = null, int $depth = 512) : string
    {
        $flags ??= 0; // Default to no flags if none provided.

        return json_encode(value: $this->toArray(), flags: $flags | JSON_THROW_ON_ERROR, depth: $depth); // Encode object as JSON.
    }

    /**
     * Converts the DTO into an associative array representation.
     * Recurses through nested properties and filters hidden fields if configured.
     *
     * @param int|null $depth         Maximum recursion depth, null for unlimited depth.
     * @param bool     $excludeHidden Whether to exclude fields marked with #[Hidden] attribute.
     *
     * @return array<string, mixed> The DTO as an associative array.
     * @throws ReflectionException
     */
    public function toArray(int|null $depth = null, bool $excludeHidden = true) : array
    {
        // Normalize and filter object properties depending on the excludeHidden flag.
        return $this->normalizeValue(
            value: $excludeHidden
                ? $this->filterHiddenFields(properties: get_object_vars(object: $this)) // Filter hidden fields.
                : get_object_vars(object: $this),
            depth: $depth
        );
    }

    /**
     * Recursively normalizes a given value into a JSON-safe structure.
     * Supports enums, date objects, JSON-serializable objects, arrays, and iterables.
     *
     * @param mixed    $value Any value to normalize.
     * @param int|null $depth Maximum depth for recursion, null for unlimited depth.
     *
     * @return mixed The normalized, JSON-serializable value.
     * @throws ReflectionException
     */
    protected function normalizeValue(mixed $value, int|null $depth = null) : mixed
    {
        // Return early if recursion depth has reached zero.
        if ($depth === 0) {
            return null; // Prevent infinite recursion.
        }

        // Match on specific value types and normalize accordingly.
        return match (true) {
            $value instanceof self              => $value->toArray(
                depth: $depth !== null ? $depth - 1 : null
            ), // Normalize nested DTO objects recursively.
            $value instanceof BackedEnum        => $value->value, // Return enum value.
            $value instanceof DateTimeInterface => $value->format(
                format: DATE_ATOM
            ), // Format dates as ISO 8601 strings.
            $value instanceof JsonSerializable  => $value->jsonSerialize(), // Serialize JSON-serializable objects.
            $value instanceof Traversable       => array_map(
            // Convert iterable objects to arrays and normalize their items.
                callback: fn($item) => $this->normalizeValue(value: $item, depth: $depth !== null ? $depth - 1 : null),
                array   : iterator_to_array(iterator: $value)
            ),
            is_array(value: $value)             => array_map(
            // Normalize and recurse through array elements.
                callback: fn($item) => $this->normalizeValue(value: $item, depth: $depth !== null ? $depth - 1 : null),
                array   : $value
            ),
            is_object(value: $value) && method_exists(
                object_or_class: $value,
                method         : '__toString'
            )                                   => (string) $value, // Convert objects with __toString to strings.
            is_object(
                value: $value
            )                                   => (array) $value, // Fallback: convert objects to arrays.
            default                             => $value, // Default case: return the value as-is.
        };
    }

    /**
     * Implements the JsonSerializable interface by converting the DTO to an array.
     *
     * @return array A JSON-serializable representation of the DTO.
     * @throws ReflectionException
     */
    public function jsonSerialize() : array
    {
        return $this->toArray(); // Re-use the toArray method for serialization.
    }

    /**
     * Filters out fields marked with the #[Hidden] attribute from an array of properties.
     *
     * @param array<string, mixed> $properties The properties to be filtered.
     *
     * @return array<string, mixed> A filtered associative array of properties.
     * @throws ReflectionException If reflection fails while accessing class properties.
     */
    protected function filterHiddenFields(array $properties) : array
    {
        foreach ($this->reflectPublicFields() as $meta) {
            if ($this->shouldHideField(property: $meta->property)) {
                unset($properties[$meta->name]); // Remove fields marked as hidden.
            }
        }

        return $properties;
    }

    /**
     * Determines whether a given property should be hidden based on the #[Hidden] attribute.
     * Can be extended to provide more sophisticated filtering logic.
     *
     * @param ReflectionProperty $property The property to evaluate.
     *
     * @return bool True if the property should be hidden, false otherwise.
     */
    protected function shouldHideField(ReflectionProperty $property) : bool
    {
        // Check whether the property has the #[Hidden] attribute.
        return $this->hasAttribute(property: $property, attributeFqn: Hidden::class);
    }

    /**
     * Converts the DTO into a flat array with all its properties.
     * Does not normalize or filter hidden fields.
     *
     * @return array<string, mixed> A flat array of the DTO properties.
     */
    public function toFlatArray() : array
    {
        return get_object_vars(object: $this); // Return an associative array of all object properties.
    }

    /**
     * Converts the DTO into an instance of stdClass for compatibility with generic object types.
     *
     * @return stdClass The DTO represented as a standard class object.
     * @throws JsonException If the DTO cannot be encoded into JSON.
     * @throws \ReflectionException
     */
    public function toStdClass() : stdClass
    {
        return json_decode(
            json       : $this->toJson(), // Serialize DTO as JSON.
            associative: false, // Decode JSON as an object, not an array.
            depth      : 512, // Maximum decoding depth.
            flags      : JSON_THROW_ON_ERROR // Throw exceptions on JSON decoding errors.
        );
    }

    /**
     * Transforms the current object into a Collection instance.
     *
     * This method provides a convenient way to convert the object's array representation
     * into a Collection, enabling fluent collection operations on the object's data.
     * The resulting Collection inherits all the powerful collection manipulation methods
     * and can be further chained with other collection operations.
     *
     * @return Collection Immutable collection containing the object's data
     *
     * @throws \ReflectionException When reflection fails to analyze the object structure
     * @api
     * @since 1.0.0
     * @final
     */
    public function toCollection() : Collection
    {
        // Convert the object to an array and wrap it in a Collection instance
        return collect(items: $this->toArray());
    }

    /**
     * Transforms the Data Transfer Object into a JSON:API compliant format.
     *
     * This method implements the JSON:API specification (jsonapi.org) structure,
     * providing a standardized response format with type, id, and attributes.
     *
     * @param string $type The resource type identifier for the JSON:API document
     *
     * @return array<string, array<string, mixed>> The JSON:API formatted response
     * @throws \ReflectionException When reflection fails during property inspection
     *
     * @see https://jsonapi.org/format/ JSON:API Specification
     */
    public function toJsonApi(string $type) : array
    {
        // Create the outer JSON:API compliant structure
        return [
            // Root-level data container as per JSON:API spec
            'data' => [
                // Resource type identifier for the object
                'type'       => $type,
                // Unique identifier for the resource, null if not set
                'id'         => $this->id ?? null,
                // Object attributes normalized through toArray method
                'attributes' => $this->toArray(),
            ],
        ];
    }
}
=== Transformers/Mapper/AbstractApiMapper.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\DataTransformers\Mapper;

use Avax\DataHandling\Cache\ReflectionCache;
use Avax\DataHandling\DTO\DTOCollection;
use Avax\DataHandling\DTO\DTOInterface;
use Avax\DataHandling\DTO\Validation\Casting\ValueCaster;
use Avax\DataHandling\DTO\Validation\DTOValidator;
use ReflectionNamedType;
use ReflectionProperty;

/**
 * AbstractApiMapper
 *
 * This abstract class is responsible for mapping API responses to DTO (Data Transfer Object) instances.
 * It utilizes reflection to auto-populate DTO instances, providing flexibility and reusability
 * for different DTO types, including nested DTO structures.
 *
 * ### Example usage:
 * ```
 * class UserApiMapper extends AbstractApiMapper {
 *     protected function defineDtoClass(): string {
 *         return UserDTO::class;
 *     }
 *
 *     protected function defineDtoCollectionClass(): string {
 *         return UserDTOCollection::class;
 *     }
 * }
 *
 * $mapper = new UserApiMapper();
 * $userDto = $mapper->map(data: $data);
 * ```
 *
 * @implements MapperInterface<DTOInterface, DTOCollection>
 */
abstract class AbstractApiMapper implements MapperInterface
{
    /**
     * Maps data to a DTO or a collection of DTOs based on the given data.
     *
     * This method decides whether to map to a single DTO or a collection of DTOs
     * based on the size of the response.
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOInterface|DTOCollection Either a single DTO object or a DTOCollection.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoOrCollection = $this->map(data: $apiResponse);
     * ```
     */
    public function map(array $data) : DTOInterface|DTOCollection
    {
        return count(value: $data) === 1
            ? $this->mapSingleDTO(data: $data[0])
            : $this->mapToDTOCollection(data: $data);
    }

    /**
     * Maps a single data array to a DTO object.
     * Internal helper method used by map().
     *
     * @param array $data The data set to be mapped.
     *
     * @return DTOInterface The DTO object created from the provided data.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $singleDto = $this->mapSingleDTO(data: $dataArray);
     * ```
     */
    private function mapSingleDTO(array $data) : DTOInterface
    {
        $dtoClass = $this->getDtoClassName();
        DTOValidator::validateClassExistence(dtoClass: $dtoClass);

        return $this->transformToDTO(data: $data, dtoClass: $dtoClass);
    }

    /**
     * Getter method for the DTO class name.
     *
     * @return string The fully qualified class name of the DTO.
     */
    protected function getDtoClassName() : string
    {
        return $this->defineDtoClass();
    }

    /**
     * Abstract method to set the DTO class name for mapping.
     *
     * Child classes must implement this method to provide the DTO class name.
     *
     * @return string The fully qualified class name of the DTO.
     */
    abstract protected function defineDtoClass() : string;

    /**
     * Transforms an array of data into a DTO object.
     *
     * @param array  $data     The data set to be transformed.
     * @param string $dtoClass The fully qualified class name of the DTO.
     *
     * @return DTOInterface The DTO object created from the provided data.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoObject = $this->transformToDTO(data: $data, dtoClass: UserDTO::class);
     * ```
     */
    protected function transformToDTO(array $data, string $dtoClass) : DTOInterface
    {
        $castedData = $this->castData(data: $data, dtoClass: $dtoClass);

        return new $dtoClass(...$castedData);
    }

    /**
     * Casts data according to the type defined in the DTO class.
     *
     * This method uses reflection to find the type of each property in the DTO class,
     * and then casts the data accordingly using the `ValueCaster` class.
     *
     * @param array  $data     The data to be cast.
     * @param string $dtoClass The fully qualified class name of the DTO which contains type definitions.
     *
     * @return array An array of casted data that can be used to instantiate the DTO object.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $castedData = $this->castData(data: $dataArray, dtoClass: UserDTO::class);
     * ```
     */
    protected function castData(array $data, string $dtoClass) : array
    {
        $reflectionClass = ReflectionCache::getReflectionClass(dtoClass: $dtoClass);
        $castedData      = [];

        foreach ($reflectionClass->getProperties(filter: ReflectionProperty::IS_PUBLIC) as $reflectionProperty) {
            $propertyName = $reflectionProperty->getName();
            $type         = $reflectionProperty->getType();

            if ($type instanceof ReflectionNamedType && array_key_exists(key: $propertyName, array: $data)) {
                $castedData[$propertyName] = ValueCaster::castValue(
                    value     : $data[$propertyName],
                    type      : $type->getName(),
                    allowsNull: $type->allowsNull(),
                );
            }
        }

        return $castedData;
    }

    /**
     * Maps an array of data sets into an array or collection of DTO objects.
     * Internal helper method used by map().
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOCollection A collection of mapped DTO objects.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example usage:
     * ```
     * $dtoCollection = $this->mapToDTOCollection(data: $dataArray);
     * ```
     */
    private function mapToDTOCollection(array $data) : DTOCollection
    {
        $dtoCollection = new DTOCollection();

        foreach ($data as $item) {
            $dtoCollection->add(
                dto: $this->mapSingleDTO(data: $item),
            );
        }

        return $dtoCollection;
    }

    /**
     * Getter method for the DTO collection class name.
     *
     * @return string The fully qualified class name of the DTO collection.
     */
    protected function getDtoCollectionClassName() : string
    {
        return $this->defineDtoCollectionClass();
    }

    /**
     * Abstract method to set the DTO collection class name for mapping.
     *
     * Child classes must implement this method to provide the DTO collection class name.
     *
     * @return string The fully qualified class name of the DTO collection.
     */
    abstract protected function defineDtoCollectionClass() : string;
}

=== Transformers/Mapper/MapperInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\DataTransformers\Mapper;

use Avax\DataHandling\DTO\DTOCollection;
use Avax\DataHandling\DTO\DTOInterface;

/**
 * MapperInterface
 *
 * This interface defines methods for mapping data to DTO (Data Transfer Object) instances.
 *
 * ### Example Implementation:
 * ```
 * class UserApiMapper extends AbstractApiMapper implements MapperInterface {
 *     protected function defineDtoClass(): string {
 *         return UserDTO::class;
 *     }
 *
 *     protected function defineDtoCollectionClass(): string {
 *         return UserDTOCollection::class;
 *     }
 * }
 * ```
 */
interface MapperInterface
{
    /**
     * Maps data to a DTO or a collection of DTOs based on the given data.
     *
     * This method decides whether to map to a single DTO or a collection of DTOs
     * based on the size of the response.
     *
     * @param array $data The array of data sets to be mapped to DTOs.
     *
     * @return DTOInterface|DTOCollection Either a single DTO object or a DTOCollection.
     *
     * @throws \ReflectionException If an error occurs during reflection.
     *
     * ### Example implementation:
     * ```
     * class UserApiMapper implements MapperInterface {
     *     public function map(array $data): DTOInterface|DTOCollection {
     *         // Implement the mapping logic
     *     }
     * }
     * ```
     */
    public function map(array $data) : DTOInterface|DTOCollection;
}

=== Validation/Attributes/AbstractRule.php ===
<?php

namespace Avax\DataHandling\Validation\Attributes;

use Avax\DataHandling\Validation\Attributes\Contracts\RuleValidator;

abstract class AbstractRule implements RuleValidator
{
    use RuleHelpers;

    /**
     * Common error thrower.
     */
    protected function fail(string $message, string $property) : never
    {
        throw new ValidationException("Validation failed on '{$property}': {$message}");
    }
}

=== Validation/Attributes/Contracts/RuleValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Contracts;

use Avax\Exceptions\ValidationException;

/**
 * Interface RuleValidator
 *
 * A contract for implementing custom validation rules for a Data Transfer Object (DTO).
 * This interface enforces a consistent structure and ensures flexibility
 * when implementing reusable and testable validation logic.
 */
interface RuleValidator
{
    /**
     * Validates the input value for a specific property of a Data Transfer Object (DTO).
     *
     * @param mixed  $value    The value to be validated.
     *                         It can be of any data type and represents the value assigned to the DTO property.
     * @param array  $data     The complete data array representing the DTO.
     *                         This allows access to other properties of the DTO during validation, enabling
     *                         advanced validation logic that involves relationships between properties.
     * @param string $property The name of the DTO property being validated.
     *                         This parameter identifies which specific property the $value represents.
     *
     * @throws ValidationException If the validation fails.
     *                             The exception provides details of the validation failure, enabling the caller
     *                             to handle validation errors appropriately, such as returning user-friendly error
     *                             messages or logging the failure for debugging purposes.
     */
    public function validate(mixed $value, array $data, string $property) : void;
}
=== Validation/Attributes/Hidden.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes;

use Attribute;

/**
 * Attribute Hidden
 *
 * Marks a DTO property as hidden from serialization (toArray, toJson).
 *
 * Pure marker  contains no logic. Interpreted by Serialization trait.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
final class Hidden
{
    //
}

=== Validation/Attributes/Rules/Accepted.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class representing an "Accepted" validation rule.
 *
 * This class can be used as an attribute to ensure that a property
 * has an acceptable value such as 'yes', 'on', 1, or true.
 *
 * - Flags Attribute::TARGET_PROPERTY restricts usage to class properties.
 * - Throws ValidationException if the value does not meet acceptable criteria.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * This attribute class enforces that a property must be explicitly accepted.
 * It's used for properties where a confirmation or acknowledgment is required.
 * The acceptable values are 'yes', 'on', 1, or true.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Accepted
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array(needle: $value, haystack: ['yes', 'on', 1, true], strict: true)) {
            throw new ValidationException(message: $property . ' must be accepted.');
        }
    }
}

=== Validation/Attributes/Rules/AcceptedIf.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate if a property value is "accepted" conditionally based on another field's value.
 *
 * The 'AcceptedIf' attribute ensures the given property is validated as accepted (with specific valid values)
 * if a condition on a another field's value is met. This allows for conditional validation logic to be applied
 * on data transfer objects.
 *
 * The class is marked readonly to indicate that instances should have immutable properties. This ensures
 * consistency and reliability of the validation logic once an instance is created with a specific condition.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates that a property is "accepted" if a certain condition in the data is met.
 *
 * The "acceptance" means that the value should be one of 'yes', 'on', 1, or true. If the condition specified
 * by conditionField and conditionValue is met and the value is not one of these acceptable values,
 * a ValidationException is thrown.
 *
 * @throws \Avax\Exceptions\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AcceptedIf
{
    public function __construct(private string $conditionField, private mixed $conditionValue) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if (($data[$this->conditionField] ?? null) === $this->conditionValue
            && ! in_array(
                needle  : $value,
                haystack: ['yes', 'on', 1, true],
                strict  : true,
            )) {
            throw new ValidationException(message: $property . " must be accepted.");
        }
    }
}

=== Validation/Attributes/Rules/ActiveURL.php ===
<?php

declare(strict_types=1);

/**
 * ActiveURL Attribute class to enforce the validation of URLs.
 * This attribute can be applied to properties to ensure they are active URLs.
 * The requirement for the URL to be active involves both validation of URL format and DNS resolution.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates if the provided value is an active URL.
 *
 * This method checks if the given value is a valid URL format and also verifies
 * whether the host of the URL has a DNS A record. This dual-check ensures that
 * the URL is both syntactically correct and points to an existing domain.
 *
 * @param mixed  $value    The value to be validated as an active URL.
 * @param string $property The name of the property being validated, used in the exception message.
 *
 * @throws \Avax\Exceptions\ValidationException if the value is not a valid or active URL.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ActiveURL
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_URL) || ! checkdnsrr(hostname: parse_url(url: (string) $value, component: PHP_URL_HOST), type: 'A')) {
            throw new ValidationException(message: $property . ' must be an active URL.');
        }
    }
}

=== Validation/Attributes/Rules/After.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a date property must be after a specified date.
 *
 * The After attribute can be applied to properties to ensure the date value
 * assigned to the property is after a predefined date. This is particularly
 * useful in scenarios where certain events must occur after a specific date.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * Validates that the provided date is after the date specified during instantiation.
 *
 * @throws \Avax\Exceptions\ValidationException if the input date is not after the comparison date.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class After
{
    public function __construct(private string $date) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate <= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date after %s.', $property, $this->date));
        }
    }
}

=== Validation/Attributes/Rules/AfterOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a property to be a date after or equal to a specified date.
 *
 * This attribute is applied at the property level within a Data Transfer Object (DTO).
 * It ensures that the validated date is not earlier than the provided comparison date.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * Attribute class designed to enforce the rule that a given date must be
 * either after or equal to a specified date. This validation is used
 * in scenarios where certain business rules require dates to respect
 * a minimum threshold.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AfterOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate < $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                    '%s must be a date after or equal to %s.',
                    $property,
                    $this->date,
                ),
            );
        }
    }
}

=== Validation/Attributes/Rules/Alpha.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to ensure a property contains only alphabetic characters.
 *
 * This class uses the #[Attribute] annotation to indicate that it can be used as an attribute,
 * specifically targeting properties. The validation logic enforces that the value assigned to the
 * annotated property consists solely of letters (alpha characters).
 *
 * Using this class helps in maintaining data integrity by validating properties directly at the attribute definition
 * level.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class used to validate that a property contains only letters.
 * Targets properties, indicating this rule applies at the property level.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Alpha
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: '/^\pL+$/u', subject: (string) $value), haystack: [0, false], strict: true)) {
            throw new ValidationException(message: $property . ' must only contain letters.');
        }
    }
}

=== Validation/Attributes/Rules/AlphaDash.php ===
<?php

declare(strict_types=1);

/**
 * This class represents a validation rule to ensure that a given property
 * contains only letters, numbers, dashes, and underscores.
 *
 * The class is marked as an attribute and is intended to be used on class properties.
 * The Attribute::TARGET_PROPERTY flag restricts its use to properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates that the given value adheres to the AlphaDash rule.
 *
 * Ensures the value only contains letters, numbers, dashes, and underscores.
 *
 * @throws \Avax\Exceptions\ValidationException if the value does not match the allowed pattern.
 *
 * Rationale: This validation is necessary for sanitizing inputs where only alphanumeric characters,
 * dashes, and underscores are allowed. It helps prevent potential security risks
 * and ensures consistency in the values stored or processed.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaDash
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: '/^[\pL\pM\pN_-]+$/u', subject: (string) $value), haystack: [0, false], strict: true)) {
            throw new ValidationException(
                message: $property . ' may only contain letters, numbers, dashes, and underscores.',
            );
        }
    }
}

=== Validation/Attributes/Rules/AlphaNum.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce alphanumeric validation on properties.
 *
 * This class can be used to annotate class properties to indicate that
 * they must only contain letters and numbers. This is particularly useful
 * for ensuring data integrity in DTOs (Data Transfer Objects) by validating
 * their properties against the alphanumeric constraint.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * An attribute class to enforce that a property value consists solely of letters and numbers.
 *
 * This attribute can be applied to class properties to ensure data validation for alphanumeric characters.
 *
 * Note: This class relies on Unicode property escapes (\pL, \pM, \pN) to cover all letters, marks, and numbers,
 * allowing for internationalization support.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class AlphaNum
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: '/^[\pL\pM\pN]+$/u', subject: (string) $value), haystack: [0, false], strict: true)) {
            throw new ValidationException(message: $property . ' may only contain letters and numbers.');
        }
    }
}

=== Validation/Attributes/Rules/AlphaNumOrEmail.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute to validate that a value is either alphanumeric or in a valid email format.
 *
 * This rule can be applied to properties of a class to ensure their value adheres to
 * the specified format. It supports usernames (alphanumeric) or valid email addresses.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class AlphaNumOrEmail
{
    /**
     * Default error message template for validating either an alphanumeric username or a valid email.
     */
    private const string DEFAULT_ERROR_MESSAGE = 'The "%s" must be either an alphanumeric username or a valid email.';

    /**
     * Constructor for the AlphaNumOrEmail attribute.
     *
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private string|null $message = null) {}

    /**
     * Validates that the provided value is either alphanumeric or a valid email.
     *
     * @param mixed  $value The value to validate.
     * @param string $name  The property name being validated.
     *
     * @throws ValidationException If the value is not a valid alphanumeric string or email.
     */
    public function validate(mixed $value, string $name) : void
    {
        if (! $this->isValidValue(value: $value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $name),
                metadata: [
                    'property' => $name,
                    'value'    => $value,
                    'expected' => 'alphanumeric or valid email',
                ]
            );
        }
    }

    /**
     * Checks if the value is a valid alphanumeric string or email.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is valid; false otherwise.
     */
    private function isValidValue(mixed $value) : bool
    {
        return is_string(value: $value) && ($this->isAlphanumeric(value: $value) || $this->isEmail(value: $value));
    }

    /**
     * Determines if the string is alphanumeric.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is alphanumeric; false otherwise.
     */
    private function isAlphanumeric(string $value) : bool
    {
        return (bool) preg_match(pattern: '/^[a-zA-Z0-9]+$/', subject: $value);
    }

    /**
     * Determines if the string is a valid email.
     *
     * @param string $value The string to check.
     *
     * @return bool True if the string is a valid email; false otherwise.
     */
    private function isEmail(string $value) : bool
    {
        return filter_var(value: $value, filter: FILTER_VALIDATE_EMAIL) !== false;
    }
}

=== Validation/Attributes/Rules/ArrayType.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property value must be an array.
 *
 * Annotated properties treated with this attribute will have
 * their values validated to ensure they are arrays. If not,
 * an exception is thrown to signal a validation failure.
 *
 * To be used specifically on property level.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class intended to enforce array type validation for properties.
 *
 * This class is designed to ensure that certain properties, when decorated with
 * this attribute, must hold array values. It integrates with the validation
 * mechanism throwing exceptions when validation fails.
 *
 * Decorate properties in DTOs with this class to enforce type constraints and
 * keep data integrity.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class ArrayType
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_array(value: $value)) {
            throw new ValidationException(message: $property . ' must be an array.');
        }
    }
}

=== Validation/Attributes/Rules/Before.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce date validation rules.
 *
 * This Attribute can only be applied to properties.
 * It checks if a given date value is before a specified date.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * Attribute to validate if a given date is before a specified date.
 *
 * The "Before" class is a read-only attribute designed to enforce a date validation rule.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Before
{
    public function __construct(private string $date) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate >= $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date before %s.', $property, $this->date));
        }
    }
}

=== Validation/Attributes/Rules/BeforeOrEqual.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class that ensures a property is a date before or equal to a specified date.
 *
 * This attribute can be applied to properties and ensures that their value is a date
 * formatted as 'Y-m-d' that is before or equal to the date specified during instantiation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * This attribute class enforces that a given date must be before or equal to a specified date.
 *
 * The readonly modifier ensures immutability, providing a safeguard against accidental changes to the date property.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class BeforeOrEqual
{
    public function __construct(private string $date) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate > $comparisonDate) {
            throw new ValidationException(
                message: sprintf(
                    '%s must be a date before or equal to %s.',
                    $property,
                    $this->date,
                ),
            );
        }
    }
}

=== Validation/Attributes/Rules/Between.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to impose a "between" validation rule on a property.
 *
 * This attribute is intended to be used on properties that need to ensure
 * their values lie between a specified minimum and maximum range.
 *
 * The class is marked as read-only to prevent changes to the min and max
 * values after instantiation, ensuring the integrity of the validation rule.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class for enforcing that a property's value is within a specified range.
 *
 * Modifiers:
 * - This class is read-only to ensure immutability once it is constructed.
 * - It is intended to be used as a property attribute.
 *
 * Use this class to validate that a given property falls within a specific minimum and maximum range.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Between
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value < $this->min || $value > $this->max) {
            throw new ValidationException(
                message: sprintf(
                    '%s must be between %d and %d.',
                    $property,
                    $this->min,
                    $this->max,
                ),
            );
        }
    }
}

=== Validation/Attributes/Rules/Boolean.php ===
<?php

declare(strict_types=1);

/**
 * A custom attribute to validate boolean values.
 *
 * This attribute is applied to properties within Data Transfer Objects (DTOs). The validation ensures that the
 * property
 * value adheres to a boolean format. The attribute itself helps enforce data consistency and integrity, typically in
 * data handling and transfer scenarios.
 *
 * Note: The #[Attribute(flags: Attribute::TARGET_PROPERTY)] syntax ensures this attribute can only be applied to
 * properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates that the provided value is a boolean.
 * Throws a ValidationException if the value is not a boolean.
 *
 * The use of filter_var with FILTER_VALIDATE_BOOLEAN and FILTER_NULL_ON_FAILURE
 * ensures that we are only accepting true or false values. This is important
 * as some values (e.g., "yes", "no") might incorrectly pass simple boolean checks.
 *
 * The rationale here is to provide strict validation for a boolean context,
 * ensuring data consistency and avoiding potential bugs arising from loosely
 * validated values.
 *
 * @throws \Avax\Exceptions\ValidationException if the value is not a boolean.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Boolean
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_bool(value: filter_var(value: $value, filter: FILTER_VALIDATE_BOOLEAN, options: FILTER_NULL_ON_FAILURE))) {
            throw new ValidationException(message: $property . ' field must be true or false.');
        }
    }
}

=== Validation/Attributes/Rules/Custom.php ===
<?php

declare(strict_types=1);

/**
 * The Custom attribute class allows for custom validation logic to be applied
 * to object properties. This is particularly useful for defining property-specific
 * validation rules that don't fit standard validation patterns.
 *
 * - `Attribute::TARGET_PROPERTY` ensures this attribute is applied to properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use Closure;

/**
 * Indicates that this attribute is targeting a property and is immutable.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Custom
{
    public function __construct(private Closure $callback) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $isValid = ($this->callback)($value);
        if (! $isValid) {
            throw new ValidationException(message: $property . ' is invalid according to custom rule.');
        }
    }
}

=== Validation/Attributes/Rules/DTOArrayOf.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Attribute to automatically transform an array into an array of DTOs.
 *
 * Used for fields like: array<int, FieldDTO>
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DTOArrayOf
{
    /**
     * @param class-string<AbstractDTO> $class Fully-qualified DTO class name
     */
    public function __construct(public string $class) {}

    /**
     * Transforms the input array into DTO instances
     *
     * @param array|null $value
     *
     * @return array<int, AbstractDTO>
     */
    public function apply(array|null $value) : array
    {
        return array_map(
            callback: fn(array $item) => new ($this->class)($item),
            array   : $value ?? []
        );
    }
}

=== Validation/Attributes/Rules/DTOObjectOf.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\DataHandling\ObjectHandling\DTO\AbstractDTO;

#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DTOObjectOf
{
    public function __construct(public string $class) {}

    public function apply(array|object|null $value) : AbstractDTO|null
    {
        if (is_null(value: $value)) {
            return null;
        }

        return new ($this->class)((array) $value);
    }
}

=== Validation/Attributes/Rules/Database/Query/IsValidColumnName.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules\Database\Query;

use Attribute;
use Avax\DataHandling\Validation\Attributes\AbstractRule;

/**
 * Validates that a value is a valid SQL column identifier.
 *
 * It allows:
 * - Alphanumeric characters and underscores.
 * - Dot separator (table.column).
 * - Wildcard asterisk (*) or table.* notation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY | Attribute::TARGET_PARAMETER | Attribute::TARGET_METHOD)]
class IsValidColumnName extends AbstractRule
{
    public function __construct(
        private readonly string $message = 'The :attribute must be a valid column name (alphanumeric, underscore, optional dot, wildcard).'
    ) {}

    public function validate(mixed $value, array $data, string $property) : void
    {
        if (! is_string(value: $value)) {
            $this->fail(message: $this->message, property: $property);
        }

        // Allow wildcard '*'
        if ($value === '*') {
            return;
        }

        // Allow 'table.*'
        if (preg_match(pattern: '/^[a-zA-Z0-9_]+\.\*$/', subject: $value)) {
            return;
        }

        // Standard column name validation (same as table name)
        if (! preg_match(pattern: '/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?$/', subject: $value)) {
            $this->fail(message: str_replace(search: ':attribute', replace: $property, subject: $this->message), property: $property);
        }
    }
}

=== Validation/Attributes/Rules/Database/SqlIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules\Database;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates that a value is a valid SQL identifier (table or column name).
 *
 * It allows literal alphanumeric characters and underscores, with an optional dot separator
 * for schema.table or table.column notation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class SqlIdentifier
{
    public function __construct(
        private string $message = 'The :attribute must be a valid SQL identifier (alphanumeric, underscore, optional dot).'
    ) {}

    /**
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_string(value: $value) || ! preg_match(pattern: '/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?$/', subject: $value)) {
            throw new ValidationException(
                message: str_replace(search: ':attribute', replace: $property, subject: $this->message)
            );
        }
    }
}

=== Validation/Attributes/Rules/Database/Table/IsValidTableName.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules\Database\Table;

use Attribute;
use Avax\DataHandling\Validation\Attributes\AbstractRule;
use Avax\Exceptions\ValidationException;

/**
 * Validates that a value is a valid SQL table identifier.
 *
 * It allows literal alphanumeric characters and underscores, with an optional dot separator
 * for schema.table notation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY | Attribute::TARGET_PARAMETER | Attribute::TARGET_METHOD)]
class IsValidTableName extends AbstractRule
{
    public function __construct(
        private readonly string $message = 'The :attribute must be a valid table name (alphanumeric, underscore, optional schema dot).'
    ) {}

    public function validate(mixed $value, array $data, string $property) : void
    {
        if (! is_string(value: $value) || ! preg_match(pattern: '/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?$/', subject: $value)) {
            throw new ValidationException(
                message: str_replace(search: ':attribute', replace: $property, subject: $this->message)
            );
        }
    }
}

=== Validation/Attributes/Rules/Date.php ===
<?php

declare(strict_types=1);


/**
 * Includes a date validation attribute which targets properties.
 * Ensures that property values conform to date formats 'Y-m-d' or 'Y-m-d H:i:s'.
 *
 * This attribute can be instantiated and used to provide a clear validation rule
 * for date properties, simplifying validation logic in the broader application.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * This class is an attribute used to validate date properties.
 *
 * It ensures that the value assigned to a property is a valid date
 * in the standard formats 'Y-m-d' or 'Y-m-d H:i:s'. If the value
 * does not conform to these formats, a ValidationException is thrown.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Date
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! DateTime::createFromFormat(format: 'Y-m-d', datetime: $value) && ! DateTime::createFromFormat(
                format  : 'Y-m-d H:i:s',
                datetime: $value,
            )) {
            throw new ValidationException(message: $property . " is not a valid date.");
        }
    }
}

=== Validation/Attributes/Rules/DateEquals.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a date equality rule on a DTO property.
 *
 * This attribute ensures that a property's date value matches a specified date.
 * Useful for scenarios where a particular date needs to be strictly validated,
 * such as ensuring a creation date matches a record date.
 *
 * - Declared readonly to emphasize immutability once initialized.
 * - Can only be applied to class properties (TARGET_PROPERTY).
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * Validates that the given value matches the specified date.
 *
 * The validation checks for strict equality between the input date
 * and the configured date. The date format used is 'Y-m-d'.
 *
 * @throws \Avax\Exceptions\ValidationException if the dates do not match or if either date is invalid.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateEquals
{
    public function __construct(private string $date) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $inputDate      = DateTime::createFromFormat(format: 'Y-m-d', datetime: $value);
        $comparisonDate = DateTime::createFromFormat(format: 'Y-m-d', datetime: $this->date);

        if (! $inputDate || ! $comparisonDate || $inputDate != $comparisonDate) {
            throw new ValidationException(message: sprintf('%s must be a date equal to %s.', $property, $this->date));
        }
    }
}

=== Validation/Attributes/Rules/DateFormat.php ===
<?php

declare(strict_types=1);

/**
 * This class is an attribute that enforces a specific date format on a property.
 *
 * The 'readonly' keyword ensures immutability, making sure that once the attribute
 * is instantiated, its properties cannot be modified.
 *
 * Applied for property-level validation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTime;

/**
 * The DateFormat class is a read-only attribute used to enforce a specific date format on a property.
 *
 * It leverages PHP's native DateTime class to attempt parsing the string into a date
 * according to the specified format. If the parsing fails, or if the parsed date does not match
 * the original string, a ValidationException is thrown. This is crucial for ensuring date fields
 * consistently conform to expected formats, which can help prevent errors related to date handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DateFormat
{
    public function __construct(private string $format) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $date = DateTime::createFromFormat(format: $this->format, datetime: $value);
        if (! $date || $date->format(format: $this->format) !== $value) {
            throw new ValidationException(
                message: sprintf('%s does not match the format %s.', $property, $this->format),
            );
        }
    }
}

=== Validation/Attributes/Rules/Different.php ===
<?php

declare(strict_types=1);

/**
 * The Different validation attribute is used to enforce that a property must have a different value
 * from another specified property within the same data context.
 *
 * This is a read-only attribute applied to a class property, ensuring immutability after instantiation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * The Different class is an immutable validator to ensure that a given property in a dataset
 * differs from another specified property. It is intended to be used as an attribute for data validation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Different
{
    public function __construct(private string $field) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if ($value === ($data[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be different from %s.', $property, $this->field));
        }
    }
}

=== Validation/Attributes/Rules/Digits.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce a property to contain exactly a specified number of digits.
 *
 * - This class can only be used as a property attribute (TARGET_PROPERTY).
 * - The 'readonly' keyword denotes that the property values cannot be changed after instantiation.
 * - Instantiated with a single parameter 'digits' to determine the number of digits required.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Readonly class to validate that a property consists of a specific number of digits.
 *
 * @Attribute aims to use this class as a property attribute in another class.
 * This is useful for validating property values against a specific constraint.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Digits
{
    public function __construct(private int $digits) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: sprintf('/^\d{%d}$/', $this->digits), subject: (string) $value), haystack: [0, false], strict: true)) {
            throw new ValidationException(message: sprintf('%s must be %d digits.', $property, $this->digits));
        }
    }
}

=== Validation/Attributes/Rules/DigitsBetween.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce a digit-based range constraint on a property.
 *
 * This Attribute is declared as read-only and targets properties.
 * It ensures that the value of the property contains only digits and
 * that the number of digits falls within the specified minimum and maximum range.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Class DigitsBetween
 *
 * This class contains validation logic to ensure that a given value is a string
 * composed only of digits and that its length falls within a specified minimum
 * and maximum range.
 *
 * Marked as readonly to indicate immutability: once instantiated, the properties
 * $min and $max should not be altered.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class DigitsBetween
{
    public function __construct(private int $min, private int $max) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: '/^\d+$/', subject: (string) $value), haystack: [0, false], strict: true) || strlen(
                string: (string) $value,
            ) < $this->min || strlen(
                string: (string) $value,
            ) > $this->max) {
            throw new ValidationException(
                message: sprintf(
                    '%s must be between %d and %d digits.',
                    $property,
                    $this->min,
                    $this->max,
                ),
            );
        }
    }
}

=== Validation/Attributes/Rules/Distinct.php ===
<?php

declare(strict_types=1);

/**
 * The Distinct attribute is used to ensure that all elements in a property array are unique.
 * It is applied to a property using the PHP attribute syntax.
 *
 * @Attribute(flags: Attribute::TARGET_PROPERTY)
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class to enforce uniqueness constraint on property values.
 * This class uses the Attribute flag TARGET_PROPERTY to specify that it
 * should be used on class properties. Ensures that an array property
 * contains unique elements only.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Distinct
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (count(value: $value) !== count(value: array_unique(array: $value))) {
            throw new ValidationException(message: $property . ' field has a duplicate value.');
        }
    }
}

=== Validation/Attributes/Rules/Email.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to mark a property as needing email validation.
 *
 * This custom attribute can be used on property declarations to enforce
 * email validation rules, encapsulating the validation logic in a reusable manner.
 *
 * Example:
 *
 * #[Email]
 * private string $email;
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates whether the provided value is a valid email address.
 *
 * @throws \Avax\Exceptions\ValidationException if the value is not a valid email address.
 *
 * The rationale for this approach is to ensure that only valid email addresses are accepted and
 * stored within the system. By enforcing this validation at the point where the attribute is used,
 * it provides a centralized validation mechanism that ensures consistency across different parts
 * of the application where the Email attribute is applied.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Email
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_EMAIL)) {
            throw new ValidationException(message: $property . ' must be a valid email address.');
        }
    }
}

=== Validation/Attributes/Rules/EndsWith.php ===
<?php

declare(strict_types=1);

/**
 * Represents a validation rule that asserts a property must end with one of the specified suffixes.
 *
 * This attribute is exclusively designed to be used on class properties, ensuring that the designated
 * property ends with one of the provided suffixes during validation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * The EndsWith class is used to validate that a given value ends with one of the specified suffixes.
 *
 * This is particularly useful for ensuring values like file extensions, URLs, or other string properties
 * meet specific criteria. Instead of marking individual properties with multiple attributes, this class
 * allows for a centralized validation logic.
 *
 * ## Why Readonly:
 * The readonly class modifier is used here to ensure immutability of class instances. Once instantiated,
 * the suffixes cannot be altered, providing consistent behaviour throughout the lifetime of the object.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EndsWith
{
    public function __construct(private array $suffixes) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->suffixes as $suffix) {
            if (str_ends_with(haystack: (string) $value, needle: (string) $suffix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must end with one of the following: ' . implode(separator: ', ', array: $this->suffixes),
        );
    }
}

=== Validation/Attributes/Rules/Enum.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use BackedEnum;
use UnitEnum;

/**
 * Enum Validator Attribute
 *
 * Ensures that the provided value matches the specified enum type.
 * Supports both:
 * - Standard enum instances.
 * - Scalar values mapping to `BackedEnum` values.
 * Throws a validation exception when the value violates the constraint.
 *
 * Use attribute declaration to enable declarative validations for Data Objects.
 * Complies with strict type safety and clean code principles.
 *
 * @template T of UnitEnum
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Enum
{
    /**
     * Initializes the Enum Validator Attribute.
     *
     * @param class-string<T> $enumClass The fully qualified class name of the target enum.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates whether the provided value is a valid enum instance or a scalar value
     * that can be mapped to a `BackedEnum`.
     *
     * @param mixed  $value    The value being validated; expected to be an enum instance or backed value.
     * @param string $property The name of the property being validated (for meaningful exception messages).
     *
     * @throws ValidationException When the value does not match the expected enum or backed enum type.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the provided class exists and is a valid enum.
        if (! enum_exists(enum: $this->enumClass)) {
            // Throws an exception when the class does not exist or is not declared as an enum.
            throw new ValidationException(
                message: "Enum class '{$this->enumClass}' does not exist."
            );
        }

        // If the value is already an instance of the specified enum, accept it as valid.
        if ($value instanceof $this->enumClass) {
            return; // Validation passes with no further checks needed.
        }

        // If the value is scalar, validate its compatibility with BackedEnum.
        if (is_scalar(value: $value) && is_subclass_of(object_or_class: $this->enumClass, class: BackedEnum::class)) {
            // Extract all scalar values (backed values) from the enum cases.
            $values = array_column(array: $this->enumClass::cases(), column_key: 'value');

            // If the scalar value matches one of the allowed enum backed values, validation passes.
            if (in_array(needle: $value, haystack: $values, strict: true)) {
                return; // Validation passes; exit early.
            }

            // Throw an exception if the scalar value does not match any of the allowed backed values.
            throw new ValidationException(
                message: "{$property} must be one of: " . implode(separator: ', ', array: $values)
            );
        }

        // Fallback: Reject any other types (e.g., arrays, objects without compatibility).
        throw new ValidationException(message: "{$property} must be a valid enum of type {$this->enumClass}");
    }
}
=== Validation/Attributes/Rules/EnumAreValuesAllowed.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * EnumAreValuesAllowed Attribute
 *
 * This validation attribute ensures that a property is an array containing only
 * valid values of a specified Enum class. It applies validation rules during runtime and
 * supports declarative validation of Data Transfer Objects (DTOs) in a clean and DDD-friendly way.
 *
 * Example usage:
 * ```
 * #[EnumAreValuesAllowed(MyEnum::class)]
 * private array $myProperty;
 * ```
 *
 * - The `readonly` modifier ensures immutability after instantiation.
 * - The attribute works only on class properties (`TARGET_PROPERTY`).
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EnumAreValuesAllowed
{
    /**
     * Fully qualified class name of the Enum to validate against.
     *
     * @var string $enumClass The expected Enum class, which must implement `BackedEnum` to support `tryFrom`.
     */
    public function __construct(
        private string $enumClass,
        private bool   $strict = false // disallow null if strict = true
    ) {}

    /**
     * Validates whether the given value is an array of valid Enum instances or Enum-backed values.
     *
     * @param mixed  $value    The property value to validate.
     * @param string $property The name of the property (used for exception messages).
     *
     * @throws ValidationException If the validation fails due to:
     *                              - The value not being an array.
     *                              - The array containing invalid Enum values.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; //  Null is valid  ignore further validation
        }

        // Ensure the value is an array
        if (! is_array(value: $value)) {
            throw new ValidationException(
                message: "{$property} must be an array of {$this->enumClass}"
            );
        }

        // Iterate through the array to validate each element
        foreach ($value as $v) {
            if ($v === null) {
                throw new ValidationException(message: "{$property} must not contain null values");
            }

            $resolved = is_object(value: $v) ? $v : ($this->enumClass)::tryFrom($v);

            if (! $resolved instanceof $this->enumClass) {
                throw new ValidationException(
                    message: "{$property} contains invalid enum value: " . var_export(value: $v, return: true)
                );
            }
        }
    }

    /**
     * Applies the Enum resolution to each element of the value if valid.
     *
     * This method accepts an array of Enum-backed values or Enum instances and ensures
     * that all elements are converted into instances of the specified Enum class.
     *
     * @param mixed $value The property value to process.
     *
     * @return array|null Returns an array of Enum instances if the input is valid, null otherwise.
     */
    public function apply(mixed $value) : array|null
    {
        // Resolve each array element to its respective Enum instance, or return null if not an array
        return is_array(value: $value)
            ? array_map(
                callback: fn($v) => is_object(value: $v) ? $v : ($this->enumClass)::tryFrom($v),
                array   : $value
            )
            : null;
    }
}
=== Validation/Attributes/Rules/EnumIsValueAllowed.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use BackedEnum;

/**
 * Attribute: EnumIsValueAllowed
 *
 * A declarative validation rule that ensures a property adheres to a specified enum constraint.
 * This attribute enforces that the annotated property either:
 * - Is already an instance of the specified Enum class.
 * - Resolves from a scalar value (if the Enum class is backed).
 *
 * If the value cannot be resolved to a valid Enum instance or scalar value, a ValidationException
 * is thrown with an appropriate error describing the issue.
 *
 * **Key Usage:**
 * - This Attribute ensures cleaner and more maintainable DTO properties within DDD contexts.
 * - Limited to `#[Attribute::TARGET_PROPERTY]` for enforcement at the property level.
 *
 * This validator relies on the PHP 8.1+ `BackedEnum` interface for backed enums.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class EnumIsValueAllowed
{
    /**
     * Constructor for the EnumIsValueAllowed Attribute.
     *
     * Leverages Constructor Promotion for concise and expressive class definition.
     *
     * @param class-string<BackedEnum> $enumClass Fully qualified Enum class name.
     *                                            This must be a valid class implementing PHP's `BackedEnum` interface.
     */
    public function __construct(private string $enumClass) {}

    /**
     * Validates the value against the specified Enum class.
     *
     * This method ensures the following:
     * - If the value is already an instance of the predefined Enum class, no further action is required.
     * - For scalar values (e.g., strings, integers), the method attempts to resolve the value into a backed Enum case.
     * - Throws a `ValidationException` if:
     *   1. The resolution fails (e.g., the provided scalar does not map to any Enum case).
     *   2. The provided value is not an Enum instance or a valid scalar convertible to a case.
     *
     * @param mixed  $value    The value to validate. This can refer to any mixed-type data.
     *                         Passed as a reference (`&`) to apply inline transformations (e.g., scalar -> Enum
     *                         conversion).
     * @param string $property The name of the property being validated.
     *                         Used to provide meaningful error messages for exceptions.
     *
     * @throws ValidationException If the value cannot be validated or resolved to the specified Enum.
     */
    public function validate(mixed &$value, string $property) : void
    {
        // Retrieve the Enum class provided in the attribute.
        $enumClass = $this->enumClass;

        // Step 1: If the value is already an instance of the given Enum class, validation succeeds.
        if ($value instanceof $enumClass) {
            return;
        }

        // Step 2: If the value is a scalar (e.g., string, int), check for compatibility with backed Enums.
        if (is_scalar(value: $value) && is_subclass_of(object_or_class: $enumClass, class: BackedEnum::class)) {
            // Attempt to resolve the scalar value into a backed Enum case using 'tryFrom'.
            $resolved = $enumClass::tryFrom(value: $value);

            // If the value was successfully resolved, update the reference and exit.
            if ($resolved !== null) {
                $value = $resolved;

                return;
            }

            // Step 3: If resolution failed, enumerate all possible backed values for error clarity.
            $allowed = implode(
                separator: ', ',
                array    : array_map(
                    callback: static fn(BackedEnum $e) => $e->value, // Extract each Enum's value.
                    array   : $enumClass::cases() // Retrieve all cases for the Enum.
                )
            );

            // Throw an exception with the allowed values for better debugging and usage feedback.
            throw new ValidationException(
                message: "{$property} must be one of enum {$enumClass}: {$allowed}"
            );
        }

        // Step 4: If the value is neither a valid Enum instance nor a valid scalar convertible to an Enum, throw an exception.
        throw new ValidationException(
            message: "{$property} must be an instance or value of {$enumClass}"
        );
    }
}
=== Validation/Attributes/Rules/FileException.php ===
<?php

declare(strict_types=1);

/**
 * FileException ensures that a given property's value is a valid file.
 *
 * This attribute is applied to properties of a Data Transfer Object (DTO)
 * to enforce file validation rules. The class uses PHP's Attribute feature,
 * which allows adding metadata to classes, methods, properties, and more.
 *
 * The class operates under the assumption that file validation is critical
 * for the correctness and security of the business logic in the application
 * where it's used.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Custom exception for file validation errors.
 *
 * This class is used as an attribute to indicate that the associated property
 * should be validated to ensure it is a file. The rationale behind this custom
 * exception is to provide a more specific and meaningful error when validation fails.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FileException
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_file(filename: $value)) {
            throw new ValidationException(message: $property . ' must be a file.');
        }
    }
}

=== Validation/Attributes/Rules/Filled.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce that a property must have a value.
 * Applied as a property validator using attributes.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property must have a value.
 *
 * This Attribute is intended to be used on properties to ensure they are not empty.
 * The rationale behind this class is to provide a simple way to perform validation
 * through an attribute-based validation mechanism which enhances readability and maintains
 * validation logic closer to the data definition.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Filled
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (empty($value)) {
            throw new ValidationException(message: $property . ' must have a value.');
        }
    }
}

=== Validation/Attributes/Rules/FloatRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property value must be a float.
 *
 * This attribute validates that the value of a property is a float. It is
 * primarily used in DTOs to ensure data integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class FloatRule
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a valid float.';

    /**
     * Constructor for the FloatRule attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a float or numeric.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a float or numeric.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_float(value: $value) && ! is_numeric(value: $value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                    'property' => $property,
                    'value'    => $value,
                    'expected' => 'float',
                    'actual'   => gettype(value: $value),
                ]
            );
        }
    }
}

=== Validation/Attributes/Rules/IP.php ===
<?php

declare(strict_types=1);

/**
 * IP Attribute class used to validate that a property holds a valid IP address.
 *
 * This class is designed to be instantiated as an attribute to enforce that a property
 * within a Data Transfer Object (DTO) is a valid IP address. Utilizing PHP's Attribute
 * syntax makes the validation declarative and more maintainable.
 *
 * - The `TARGET_PROPERTY` flag ensures that this attribute can only be applied to properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validate if the given value is a valid IP address.
 * Throws an exception if validation fails.
 *
 * @throws \Avax\Exceptions\ValidationException
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IP
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== Validation/Attributes/Rules/IPAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to indicate that a property must be a valid IP address.
 *
 * This class is designed to be used as an attribute on properties within
 * Data Transfer Objects (DTOs). It validates that the given property value is a
 * valid IP address, ensuring data integrity and consistency.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * This class is designed to validate IP addresses for properties marked with the TARGET_PROPERTY attribute.
 *
 * The primary behavior of this class is to ensure that values assigned to certain properties are valid IP addresses,
 * throwing a ValidationException otherwise. This ensures data integrity and consistency across the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPAddress
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_IP)) {
            throw new ValidationException(message: $property . ' must be a valid IP address.');
        }
    }
}

=== Validation/Attributes/Rules/IPv4.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to enforce IPv4 validation on properties.
 *
 * This class will be used to annotate properties and ensure they contain valid IPv4 addresses.
 * The main decision here is to leverage PHP's filter_var function with the FILTER_VALIDATE_IP flag.
 * This is a better approach than regular expressions due to its efficiency and robustness.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * An attribute class to validate if a given value is a valid IPv4 address.
 *
 * The validation is essential for ensuring that the property this attribute
 * is applied to adheres to the IPv4 format, which can be critical for
 * network configurations and communication protocols.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv4
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_IP, options: FILTER_FLAG_IPV4)) {
            throw new ValidationException(message: $property . ' must be a valid IPv4 address.');
        }
    }
}

=== Validation/Attributes/Rules/IPv6.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to designate a property that must be a valid IPv6 address.
 * The use of this attribute triggers validation against the IPv6 format.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates that the given value is a proper IPv6 address. If not, it throws a ValidationException.
 *
 * @param mixed  $value    The value to be validated as an IPv6 address.
 * @param string $property The name of the property being validated.
 *
 * @throws \Avax\Exceptions\ValidationException If the value is not a valid IPv6 address.
 *
 * The use of filter_var function with FILTER_VALIDATE_IP and FILTER_FLAG_IPV6 ensures that only valid IPv6 formats are
 * accepted, reinforcing data integrity especially where IP addresses are critical.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class IPv6
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_IP, options: FILTER_FLAG_IPV6)) {
            throw new ValidationException(message: $property . ' must be a valid IPv6 address.');
        }
    }
}

=== Validation/Attributes/Rules/Image.php ===
<?php

declare(strict_types=1);

/**
 * Defines an attribute to validate that a property is an image.
 *
 * This attribute should be used to annotate properties that are expected to
 * hold image file names or paths. The validation logic checks the file
 * extension against a pre-defined list of allowed image formats.
 *
 * Usage:
 * #[Image]
 * private $imageProperty;
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validate that the provided file's extension is among the allowed image types.
 *
 * INTENT: Ensure that the input value is a valid image format to prevent
 * invalid data from entering the system, which could cause errors downstream.
 * This method throws an exception if validation fails to enforce strict conformity.
 *
 * @throws \Avax\Exceptions\ValidationException If the file extension is not permitted.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Image
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $allowedMimes = ['jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'];
        $extension    = strtolower(string: pathinfo(path: (string) $value, flags: PATHINFO_EXTENSION));
        if (! in_array(needle: $extension, haystack: $allowedMimes, strict: true)) {
            throw new ValidationException(message: $property . ' must be an image.');
        }
    }
}

=== Validation/Attributes/Rules/ImageDimension.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to validate image dimensions for a property in a DTO.
 *
 * This class checks various constraints like specific width, height,
 * minimum and maximum dimensions, and aspect ratio. It is designed to
 * be used as an attribute on properties within data transfer objects (DTOs).
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use Exception;

/**
 * This readonly class is used to encapsulate the dimensions of an image and ensure they adhere to specified validation
 * rules. The readonly modifier ensures immutability, which is crucial for maintaining consistency in image validation
 * parameters.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class ImageDimension
{
    public function __construct(
        private int|null   $width = null,
        private int|null   $height = null,
        private int|null   $min_width = null,
        private int|null   $min_height = null,
        private int|null   $max_width = null,
        private int|null   $max_height = null,
        private float|null $ratio = null,
    ) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        try {
            $dimensions = getimagesize(filename: $value);

            $width  = $dimensions[0];
            $height = $dimensions[1];

            if ($this->width !== null && $width !== $this->width) {
                throw new ValidationException(message: sprintf('%s must be %d pixels wide.', $property, $this->width));
            }

            if ($this->height !== null && $height !== $this->height) {
                throw new ValidationException(message: sprintf('%s must be %d pixels tall.', $property, $this->height));
            }

            if ($this->min_width !== null && $width < $this->min_width) {
                throw new ValidationException(
                    message: sprintf(
                        '%s must be at least %d pixels wide.',
                        $property,
                        $this->min_width,
                    ),
                );
            }

            if ($this->min_height !== null && $height < $this->min_height) {
                throw new ValidationException(
                    message: sprintf(
                        '%s must be at least %d pixels tall.',
                        $property,
                        $this->min_height,
                    ),
                );
            }

            if ($this->max_width !== null && $width > $this->max_width) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels wide.', $property, $this->max_width),
                );
            }

            if ($this->max_height !== null && $height > $this->max_height) {
                throw new ValidationException(
                    message: sprintf('%s may not be greater than %d pixels tall.', $property, $this->max_height),
                );
            }

            if ($this->ratio !== null && abs(num: $width / $height - $this->ratio) > 0.0001) {
                throw new ValidationException(message: sprintf('%s aspect ratio must be %s.', $property, $this->ratio));
            }
        } catch (Exception) {
            throw new ValidationException(message: $property . ' has invalid image dimensions.');
        }
    }
}

=== Validation/Attributes/Rules/In.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute that validates a property's value is one of a predefined set.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class In
{
    /**
     * @param array<int|string> $values List of accepted values for the field.
     */
    public function __construct(private array $values) {}

    /**
     * Validates whether a given value is in the allowed set.
     *
     * @param mixed  $value    Value to validate.
     * @param string $property Property name (for exception context).
     *
     * @throws ValidationException If the value is not in the list of allowed values.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Unwrap enum to scalar value if needed
        if (is_object(value: $value) && method_exists(object_or_class: $value, method: 'value')) {
            $value = $value->value;
        }

        // Perform strict comparison against an allowed set
        if (! in_array(needle: $value, haystack: $this->values, strict: true)) {
            $allowed = implode(separator: ', ', array: array_map(callback: 'strval', array: $this->values));

            throw new ValidationException(
                message: "{$property} must be one of: {$allowed}"
            );
        }
    }
}

=== Validation/Attributes/Rules/Integer.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Class Integer
 *
 * This class is an attribute used for validating that the targeted property is an integer.
 * It is designed to enforce validation rules declaratively using PHP's Attribute syntax
 * and ensures that incorrect data types are rejected with clear exception handling.
 *
 * Domain-Driven Design (DDD) implications:
 * - Acts as a declarative rule for property validation within domain entities or value objects.
 * - Short-circuits invalid input before further operations, preserving domain integrity.
 *
 * @package Avax\DataHandling\Validation\Attributes\Rules
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)] // Restricts this attribute to properties.
class Integer
{
    /**
     * The default error message used when the validation fails.
     *
     * This constant defines a generic error message indicating that the value must be an integer.
     * It uses a placeholder to include the property name dynamically.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be an integer.';

    /**
     * Custom error message for validation failures.
     *
     * @var string|null $message A custom message provided at instantiation to override the default.
     *                           If null, the default error message will be used.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the given value is an integer.
     *
     * A property is validated against this rule. If the value does not satisfy the constraint,
     * a `ValidationException` is thrown, containing detailed metadata about the failure.
     *
     * @param mixed  $value    The value to be validated. Can be any type, as mixed is used.
     * @param string $property The name of the property being validated, for error context.
     *
     * @return void
     *
     * @throws ValidationException If the value is not an integer.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Check if the value is not an integer.
        if (! is_int(value: $value)) {
            // Throw a detailed validation exception if the value is invalid.
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                // Use a custom or default error message.
                metadata: [
                    'property' => $property, // The name of the property being validated.
                    'value'    => $value,    // The actual value that failed validation.
                    'expected' => 'int',     // The expected type of the value (integer).
                    'actual'   => gettype(value: $value), // The actual type of the provided value.
                ]
            );
        }
    }
}
=== Validation/Attributes/Rules/IntegerRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\DataHandling\Validation\Contracts\RuleInterface;
use Avax\Exceptions\ValidationException;

/**
 * Validates that a property is an integer.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
final readonly class IntegerRule
{
    /**
     * @param string|null $message Custom error message
     */
    public function __construct(
        private string|null $message = null
    ) {}

    /**
     * Validates that the provided value is an integer.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_int(value: $value) && ! ctype_digit(text: (string) $value)) {
            throw new ValidationException(
                message : $this->message ?? "The {$property} field must be an integer.",
                metadata: [
                    'property' => $property,
                    'value'    => $value,
                    'expected' => 'integer'
                ]
            );
        }
    }
}

=== Validation/Attributes/Rules/JSON.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for marking properties that should be validated as JSON.
 * Using #[Attribute(flags: Attribute::TARGET_PROPERTY)] to limit usage to properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates if the provided value is a valid JSON string.
 *
 * @throws \Avax\Exceptions\ValidationException If the value is not a valid JSON string.
 *
 * The rationale for this function is to ensure that properties using this attribute
 * always contain valid JSON data. This helps maintain data integrity within the application.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class JSON
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        json_decode(json: (string) $value);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new ValidationException(message: $property . ' must be a valid JSON string.');
        }
    }
}

=== Validation/Attributes/Rules/MACAddress.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for defining a MAC address validation rule to be used on DTO properties.
 *
 * This class leverages PHP's Attribute feature introduced in PHP 8. It is intended to be
 * used as an attribute on properties in Data Transfer Objects (DTOs) to enforce that the
 * value of the property is a valid MAC address.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validate the given MAC address.
 *
 * This method uses PHP's built-in `filter_var` function to check if the input value
 * is a valid MAC address. If it's not, a `ValidationException` is thrown.
 *
 * @throws \Avax\Exceptions\ValidationException If the given value is not a valid MAC address.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class MACAddress
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_MAC)) {
            throw new ValidationException(message: $property . ' must be a valid MAC address.');
        }
    }
}

=== Validation/Attributes/Rules/Max.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use Countable;
use InvalidArgumentException;

/**
 * Attribute to enforce a maximum value or length constraint on a property.
 *
 * Supports validation for strings, numerics, arrays, and countable objects.
 **/
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Max
{
    /** Error messages for different validation types. */
    private const string ERROR_NUMERIC = 'The value of "%s" must not exceed %d.';

    private const string ERROR_STRING = 'The length of "%s" must not exceed %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must not exceed %d.';

    private const string ERROR_INVALID = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';

    /**
     * Constructor for the Max attribute.
     *
     * @param int         $max     The maximum value or size.
     * @param string|null $message Optional custom error message.
     *
     * @throws InvalidArgumentException If the max value provided is negative.
     */
    public function __construct(private readonly int $max, private readonly string|null $message = null)
    {
        // Ensure the maximum value is a non-negative integer.
        if ($max < 0) {
            throw new InvalidArgumentException(message: 'The maximum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the maximum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     **/
    public function validate(mixed $value, string $property) : void
    {
        // Allow null values (no validation required for null).
        if ($value === null) {
            return;
        }

        // Match the type of value to the appropriate validation method.
        match (true) {
            is_numeric(value: $value)   => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string(value: $value)    => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable(value: $value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                     => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    /**
     * Validates numeric values against the maximum constraint.
     *
     * @param float  $value    The numeric value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value exceeds the maximum.
     */
    private function validateNumeric(float $value, string $property) : void
    {
        if ($value > $this->max) {
            // The Numeric value exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    /**
     * Throws a ValidationException with relevant error details.
     *
     * @param string $errorKey The error key identifying the type of validation error.
     * @param string $property The name of the property being validated.
     * @param mixed  $value    The value that caused the validation failure.
     *
     * @throws ValidationException Always triggered when called.
     */
    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        // Constructs and throws a detailed ValidationException.
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at most %d.', ucfirst(string: $property), $this->max),
            metadata: [
                'property' => $property,
                'value'    => $value,
                'max'      => $this->max,
                'errorKey' => $errorKey,
            ]
        );
    }

    /**
     * Validates string values against the maximum length constraint.
     *
     * @param string $value    The string value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the string length exceeds the maximum.
     */
    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen(string: $value) > $this->max) {
            // String length exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    /**
     * Validates array or countable values against the maximum count constraint.
     *
     * @param array|Countable $value    The array or countable value to validate.
     * @param string          $property The name of the property being validated.
     *
     * @throws ValidationException If the count exceeds the maximum.
     */
    private function validateCountable(array|Countable $value, string $property) : void
    {
        // Determine the count of elements.
        $count = is_array(value: $value) ? count(value: $value) : iterator_count(iterator: $value);

        if ($count > $this->max) {
            // Element count exceeds the maximum allowed.
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}
=== Validation/Attributes/Rules/MigrationArrayRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates and casts to array from native array or JSON stringified array.
 *
 * Accepts:
 * - native PHP array
 * - JSON-encoded array string
 * - null
 *
 * Rejects:
 * - all other types (objects, ints, resources, strings that are not valid JSON arrays)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationArrayRule
{
    /**
     * Validates that the value is either a PHP array or a valid JSON string representing an array.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_array(value: $value)) {
            return;
        }

        if (is_string(value: $value) && json_validate(json: $value)) {
            $decoded = json_decode(json: $value, associative: true);

            if (is_array(value: $decoded)) {
                return;
            }
        }

        throw new ValidationException(
            message: "{$property} must be a valid array or JSON array string. Got: " . get_debug_type(value: $value)
        );
    }

    /**
     * Converts value to PHP array if valid. Returns null if value is null.
     *
     * @param mixed $value
     *
     * @return array|null
     */
    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Validation/Attributes/Rules/MigrationFieldAttributesRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Database\Migration\Design\Table\Enum\FieldModifierEnum;
use Avax\Exceptions\ValidationException;

/**
 * Validates and casts an array of migration field modifiers.
 *
 * Accepts:
 * - FieldModifierEnum[]
 * - string[] matching FieldModifierEnum values
 *
 * Rejects:
 * - any non-array input
 * - values not resolvable via FieldModifierEnum::tryFrom()
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldAttributesRule
{
    /**
     * Validates an array of enum-compatible modifiers.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! is_array(value: $value)) {
            throw new ValidationException(
                message: "{$property} must be an array of FieldModifierEnum values or string equivalents."
            );
        }

        foreach ($value as $item) {
            if ($item === null) {
                continue;
            }

            if ($item instanceof FieldModifierEnum) {
                continue;
            }

            if (! is_string(value: $item)) {
                throw new ValidationException(
                    message: "{$property} contains non-string value: " . var_export(value: $item, return: true)
                );
            }

            if (! FieldModifierEnum::tryFrom($item)) {
                throw new ValidationException(
                    message: "{$property} contains invalid field modifier: " . var_export(value: $item, return: true)
                );
            }
        }
    }

    public function apply(mixed $value) : array|null
    {
        return is_array(value: $value) ? $value : null;
    }

}

=== Validation/Attributes/Rules/MigrationFieldTypeRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Avax\Exceptions\ValidationException;

/**
 * Validation rule for the 'type' field in FieldDTO.
 *
 * Ensures the field is either:
 * - an instance of FieldTypeEnum (hydrated previously), or
 * - null (optional field)
 *
 * No casting is done here  hydration must have resolved the correct type.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationFieldTypeRule
{
    /**
     * Validates the 'type' field value without casting.
     *
     * @param mixed  $value    The raw or hydrated value of the property
     * @param string $property The property name being validated
     *
     * @throws ValidationException If the value is not null or a FieldTypeEnum instance
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (! $value instanceof FieldTypeEnum) {
            throw new ValidationException(
                message: "{$property} must be an instance of FieldTypeEnum or null. Got: " . get_debug_type(value: $value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}
=== Validation/Attributes/Rules/MigrationForeignActionRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Avax\Exceptions\ValidationException;

/**
 * Validates the 'onDelete' and 'onUpdate' fields as valid ForeignActionEnum values.
 *
 * Accepts:
 * - null (no validation error)
 * - ForeignActionEnum instance (direct assignment)
 * - string (cast to enum via tryFrom)
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationForeignActionRule
{
    /**
     * Validates that the input is either null or a valid ForeignActionEnum (or castable string).
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException If an invalid type or unknown enum case is given.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || $value instanceof ForeignActionEnum) {
            return;
        }

        if (! is_string(value: $value)) {
            throw new ValidationException(message: "{$property} must be a string or ForeignActionEnum instance.");
        }

        if (ForeignActionEnum::tryFrom(value: $value) === null) {
            throw new ValidationException(
                message: "{$property} is not a valid ForeignActionEnum. Got: " . var_export(value: $value, return: true)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Validation/Attributes/Rules/MigrationIntegerRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates and casts integer-compatible inputs.
 *
 * Accepts:
 * - Native integer (e.g. 42)
 * - Numeric strings representing non-negative integers (e.g. "42")
 *
 * Rejects:
 * - Floats (e.g. 3.14)
 * - Negative numeric strings with non-digit chars (e.g. "-42", "42a")
 * - Booleans, arrays, objects, null (except null is accepted)
 *
 * Example:
 *   "42" => 42
 *   42 => 42
 *   null => null
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationIntegerRule
{
    /**
     * Validates the value against integer or digit-only string formats.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null || is_int(value: $value)) {
            return;
        }

        if (is_string(value: $value) && preg_match(pattern: '/^\d+$/', subject: $value)) {
            return;
        }

        throw new ValidationException(
            message: "{$property} must be an integer or numeric string. Got: " . get_debug_type(value: $value)
        );
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Validation/Attributes/Rules/MigrationStringRule.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Validates and casts a value to string if allowed.
 *
 * Accepts:
 * - native string
 * - int, float, bool (castable scalars)
 * - objects implementing __toString()
 * Rejects:
 * - arrays, resources, objects without __toString
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class MigrationStringRule
{
    /**
     * Validates the string-compatibility of a value.
     *
     * @param mixed  $value
     * @param string $property
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return;
        }

        if (is_bool(value: $value)) {
            throw new ValidationException(message: "{$property} cannot be a boolean when casting to string.");
        }

        if (! is_scalar(value: $value) && ! (is_object(value: $value) && method_exists(object_or_class: $value, method: '__toString'))) {
            throw new ValidationException(
                message: "{$property} must be a string or string-castable object. Got: " . get_debug_type(value: $value)
            );
        }
    }

    public function apply(mixed $value) : mixed
    {
        return $value;
    }
}

=== Validation/Attributes/Rules/Mimes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class Mimes to enforce file type restrictions on a given property.
 *
 * This class is marked as `readonly` to indicate that once instantiated, the `$mimes` array should not be modified,
 * maintaining the integrity of the type rules it enforces.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * ########################################################################
 * Represents a validation rule for file mime types.
 *
 * `readonly` keyword ensures the $mimes array cannot be modified after
 * the object is constructed, which guarantees immutability and consistency.
 * This is crucial for validation logic as allowed mime types must remain constant.
 * ########################################################################
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimes
{
    public function __construct(private array $mimes) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $extension = strtolower(string: pathinfo(path: (string) $value, flags: PATHINFO_EXTENSION));
        if (! in_array(needle: $extension, haystack: $this->mimes)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(separator: ', ', array: $this->mimes),
            );
        }
    }
}

=== Validation/Attributes/Rules/Mimetypes.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define permissible MIME types for a file property.
 *
 * The class is marked as readonly to ensure immutability after initialization.
 * It is targeted specifically for class properties using the `Attribute::TARGET_PROPERTY` flag.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use finfo;

/**
 * This class is designed to enforce validation of file MIME types.
 * Declared as `readonly` to ensure immutability of `mimetypes` after instantiation.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Mimetypes
{
    public function __construct(private array $mimetypes) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $finfo    = new finfo(flags: FILEINFO_MIME_TYPE);
        $mimeType = $finfo->file(filename: $value);

        if (! in_array(needle: $mimeType, haystack: $this->mimetypes, strict: true)) {
            throw new ValidationException(
                message: $property . ' must be a file of type: ' . implode(
                    separator: ', ',
                    array    : $this->mimetypes,
                ),
            );
        }
    }
}

=== Validation/Attributes/Rules/Min.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use Countable;
use InvalidArgumentException;

/**
 * Attribute to enforce a minimum value or length constraint on a property.
 *
 * Supports numeric values, strings, and countable objects/arrays.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Min
{
    private const string ERROR_NUMERIC = 'The value of "%s" must be at least %d.';

    private const string ERROR_STRING = 'The length of "%s" must be at least %d characters.';

    private const string ERROR_COUNTABLE = 'The number of items in "%s" must be at least %d.';

    private const string ERROR_INVALID = 'Invalid value type for "%s". Expected a numeric, string, or countable value, but got "%s".';


    /**
     * Constructor for the Min attribute.
     *
     * @param int         $min     The minimum value or size.
     * @param string|null $message Optional custom error message.
     */
    public function __construct(private readonly int $min, private readonly string|null $message = null)
    {
        if ($min < 0) {
            throw new InvalidArgumentException(message: 'The minimum value must be a non-negative integer.');
        }
    }

    /**
     * Validates the value against the minimum constraint.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($value === null) {
            return; // Allow nulls; other validators handle required constraints.
        }

        match (true) {
            is_numeric(value: $value)   => $this->validateNumeric(
                value   : (float) $value,
                property: $property
            ),
            is_string(value: $value)    => $this->validateString(
                value   : $value,
                property: $property
            ),
            is_countable(value: $value) => $this->validateCountable(
                value   : $value,
                property: $property
            ),
            default                     => $this->throwValidationException(
                errorKey: self::ERROR_INVALID,
                property: $property,
                value   : $value
            ),
        };
    }

    private function validateNumeric(float $value, string $property) : void
    {
        if ($value < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_NUMERIC, property: $property, value: $value);
        }
    }

    private function throwValidationException(string $errorKey, string $property, mixed $value) : void
    {
        throw new ValidationException(
            message : $this->message ?? sprintf('%s must be at least %d.', ucfirst(string: $property), $this->min),
            metadata: [
                'property' => $property,
                'value'    => $value,
                'min'      => $this->min,
                'errorKey' => $errorKey,
            ]
        );
    }

    private function validateString(string $value, string $property) : void
    {
        if (mb_strlen(string: $value) < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_STRING, property: $property, value: $value);
        }
    }

    private function validateCountable(array|Countable $value, string $property) : void
    {
        $count = is_array(value: $value) ? count(value: $value) : iterator_count(iterator: $value);

        if ($count < $this->min) {
            $this->throwValidationException(errorKey: self::ERROR_COUNTABLE, property: $property, value: $count);
        }
    }
}

=== Validation/Attributes/Rules/NotIn.php ===
<?php

declare(strict_types=1);

/**
 * An attribute class applied to a property to ensure the property value is not
 * within a specified set of values. This uses a 'NotIn' validation rule.
 *
 * This class is marked as 'readonly' to signify that it should not be modified
 * after instantiation, enhancing its immutability and ensuring integrity.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property value is not within a specified array of values.
 *
 * The readonly modifier ensures that instances of this class are immutable once constructed.
 * This design choice prevents accidental changes to the array of invalid values after instantiation,
 * which is critical for maintaining consistent validation rules.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotIn
{
    public function __construct(private array $values) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: $value, haystack: $this->values, strict: true)) {
            throw new ValidationException(message: $property . ' must not be one of: ' . implode(separator: ', ', array: $this->values));
        }
    }
}

=== Validation/Attributes/Rules/NotRegex.php ===
<?php

declare(strict_types=1);

/**
 * The NotRegex class is an attribute used to validate that a property does not match a given regex pattern.
 *
 * This attribute is applied at the property level (TARGET_PROPERTY) and enforces validation rules at runtime.
 * The primary use case is to ensure that certain input properties do not conform to particular patterns,
 * which is critical for enforcing business rules and avoiding invalid data submissions.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * This attribute class ensures that a value does not match a specific regex pattern.
 *
 * Using the #[Attribute(flags: Attribute::TARGET_PROPERTY)] directive to target properties only,
 * it integrates with validation mechanisms seamlessly.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class NotRegex
{
    public function __construct(private string $pattern) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (preg_match(pattern: $this->pattern, subject: (string) $value)) {
            throw new ValidationException(message: $property . ' format is invalid.');
        }
    }
}

=== Validation/Attributes/Rules/Nullable.php ===
<?php

declare(strict_types=1);

/**
 * This class represents an attribute that can be used to mark a property as nullable.
 *
 * By using the #[Nullable] attribute, it indicates that a property on a data transfer object (DTO)
 * can accept a null value, which is relevant in many scenarios like optional fields or partial updates.
 *
 * The use of #[Attribute(flags: Attribute::TARGET_PROPERTY)] specifies that this attribute can only
 * be applied to properties, ensuring it isn't misapplied to methods or classes.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * This class is used as an attribute to indicate that a property can be null.
 * The lack of validation signifies that null values are permissible, simplifying the handling of such properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Nullable
{
    public function validate(mixed $value, string $property) : void
    {
        // No validation needed; the property being null is acceptable.
    }
}

=== Validation/Attributes/Rules/Numeric.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce numeric validation on a property.
 *
 * This attribute is applied to properties that must contain numeric values.
 * The `validate` method will be called to ensure the property value adheres to the numeric constraint.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class used to enforce that a property must be numeric.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Numeric
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_numeric(value: $value)) {
            throw new ValidationException(message: $property . ' must be a number.');
        }
    }
}

=== Validation/Attributes/Rules/Present.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class intended to mark properties that are required to be 'present'.
 * While commonly attributes enforce validation rules, this class only ensures
 * that the marked property is flagged as existing within the data set.
 *
 * This can be used in situations where simply the presence (even null or empty)
 * signifies a valid state. The property carrying this attribute thus should be checked
 * for its existence, but no further validation on its value is performed.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;

/**
 * Attribute class that enforces the presence of a property.
 * This is typically used in situations where merely setting the property is enough to confirm its presence.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Present
{
    public function validate(mixed $value, array $data, string $property) : void
    {
        // No validation needed; the property being set means it is present.
    }
}

=== Validation/Attributes/Rules/RegexException.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use InvalidArgumentException;

/**
 * Attribute for enforcing regular expression validation on class properties.
 *
 * Validates that a property value matches a specified regular expression.
 * Includes optional custom error messages for flexible validation error handling.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RegexException
{
    private const string DEFAULT_ERROR_MESSAGE = '%s format is invalid.';

    /**
     * Constructor for the RegexException attribute.
     *
     * @param string      $pattern The regular expression pattern to validate against.
     * @param string|null $message Optional custom error message for validation failures.
     *
     * @throws InvalidArgumentException If the provided regex pattern is invalid.
     */
    public function __construct(
        private string      $pattern,
        private string|null $message = null
    )
    {
        $this->validatePattern(pattern: $pattern);
    }

    /**
     * Ensures the regex pattern is valid.
     *
     * @param string $pattern The regex pattern to validate.
     *
     * @throws InvalidArgumentException If the regex pattern is invalid.
     */
    private function validatePattern(string $pattern) : void
    {
        if (preg_match(pattern: $pattern, subject: '') === false) {
            throw new InvalidArgumentException(message: sprintf('Invalid regex pattern: %s', $pattern));
        }
    }

    /**
     * Validates a value against the regex pattern.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value does not match the regex pattern.
     */
    public function validate(mixed $value, string $property) : void
    {
        if ($this->isInvalidValue(value: $value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::DEFAULT_ERROR_MESSAGE, $property),
                metadata: [
                    'property' => $property,
                    'value'    => $value,
                    'pattern'  => $this->pattern,
                ]
            );
        }
    }

    /**
     * Checks if a value is invalid based on the regex pattern.
     *
     * @param mixed $value The value to check.
     *
     * @return bool True if the value is invalid; false otherwise.
     */
    private function isInvalidValue(mixed $value) : bool
    {
        if (! is_string(value: $value) && ! is_numeric(value: $value)) {
            return true; // Only strings and numeric values are valid
        }

        return preg_match(pattern: $this->pattern, subject: (string) $value) !== 1;
    }
}

=== Validation/Attributes/Rules/Required.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property (or a nested path) must be provided and not null.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY | Attribute::IS_REPEATABLE)]
class Required
{
    /**
     * Path within the object to validate (e.g., 'schema.fields')
     *
     * @var string|null
     */
    private string|null $path;

    /**
     * Custom validation error message.
     *
     * @var string|null
     */
    private string|null $message;

    /**
     * Constructor
     *
     * @param string|null $path    Optional deep path to validate (e.g., 'schema.fields')
     * @param string|null $message Optional custom error message
     */
    public function __construct(string|null $path = null, string|null $message = null)
    {
        $this->path    = $path;
        $this->message = $message;
    }

    /**
     * Validates a required value, supporting deep paths like 'schema.fields'.
     *
     * @param mixed  $value    The full object or field to validate.
     * @param string $property The property name being validated.
     *
     * @throws ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        $target = $value;

        if ($this->path !== null) {
            // Traverse nested properties (e.g., schema.fields)
            foreach (explode(separator: '.', string: $this->path) as $segment) {
                if (is_array(value: $target) && array_key_exists(key: $segment, array: $target)) {
                    $target = $target[$segment];
                } elseif (is_object(value: $target) && isset($target->$segment)) {
                    $target = $target->$segment;
                } else {
                    $target = null;
                    break;
                }
            }
        }

        if ($target === null) {
            throw new ValidationException(
                message : $this->message ?? sprintf(
                'The "%s" field is required and cannot be null.',
                $this->path ?? $property
            ),
                metadata: ['property' => $this->path ?? $property]
            );
        }
    }
}

=== Validation/Attributes/Rules/RequiredWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class enforcing a "required with" validation rule.
 *
 * This attribute ensures that a given property must have a value if the specified fields are present in the provided
 * data array. The class and its methods help enforce specific business rules where data interdependencies require
 * conditional validations.
 *
 * Attribute is set to TARGET_PROPERTY for use with class properties.
 * The class is marked as readonly as it doesn't require modification after instantiation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class for validating that a property is required if specified sibling properties are present.
 *
 * The readonly modifier ensures that the $fields property is immutable, providing safety by preventing accidental
 * changes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWith
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (isset($data[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf('%s is required when %s is present.', $property, $field),
                );
            }
        }
    }
}

=== Validation/Attributes/Rules/RequiredWithout.php ===
<?php

declare(strict_types=1);

/**
 * The RequiredWithout attribute marks a property as required only if certain other fields are not present.
 * This is useful for conditional validation scenarios where the presence of a property is dependent on the absence of
 * other properties.
 *
 * This attribute is intended to be applied to class properties (Target: PROPERTY).
 * It leverages PHP 8's attribute syntax to integrate seamlessly with the language's validation infrastructure.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Class RequiredWithout
 *
 * Attribute class to enforce the requirement of a property being non-empty unless certain other properties are present
 * in data.
 *
 * - The use of readonly ensures immutability, making fields immutable after instantiation.
 * - The __construct function takes an array of fields to check against, ensuring robustness and flexibility.
 * - The validate method includes complex business logic following a specific validation rule, demanding an explanation
 * for future maintainability.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class RequiredWithout
{
    public function __construct(private array $fields) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        foreach ($this->fields as $field) {
            if (! isset($data[$field]) && empty($value)) {
                throw new ValidationException(
                    message: sprintf(
                        '%s is required when %s is not present.',
                        $property,
                        $field,
                    ),
                );
            }
        }
    }
}

=== Validation/Attributes/Rules/Same.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class used to enforce that the value of the decorated property
 * must match the value of another specified property within the same data context.
 *
 * This attribute should be applied to properties within a DTO to ensure
 * that certain fields have equal values, which is helpful for tasks such as
 * confirming password or email fields.
 *
 * Using the readonly class guarantees immutability once instantiated, ensuring data consistency.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * This class defines a validation rule that ensures a given property value is the same as another specified property
 * value. It is an immutable class, signified by the 'readonly' keyword, meaning its state cannot be altered after
 * instantiation.
 *
 * The primary use case is validation scenarios where fields need to have matching values, such as password
 * confirmation fields.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Same
{
    public function __construct(private string $field) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, array $data, string $property) : void
    {
        if ($value !== ($data[$this->field] ?? null)) {
            throw new ValidationException(message: sprintf('%s must be the same as %s.', $property, $this->field));
        }
    }
}

=== Validation/Attributes/Rules/Size.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class to define a validation rule for the exact size of a property's value.
 *
 * This class is marked readonly to enforce immutability after instantiation, ensuring
 * the consistency of the size constraint.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class for enforcing fixed-size length constraints on properties.
 * Applied at the property level to validate that a property's length matches the specified size.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class Size
{
    public function __construct(private int $size) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (strlen(string: (string) $value) !== $this->size) {
            throw new ValidationException(
                message: sprintf('%s must be exactly %d characters.', $property, $this->size),
            );
        }
    }
}

=== Validation/Attributes/Rules/StartsWith.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to enforce that a property's value starts with one of the specified prefixes.
 * Using this attribute helps ensure consistent data formatting and validation across the application.
 *
 * The Attribute is restricted to be used on properties by the TARGET_PROPERTY flag.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class for validating that a given value starts with one of the specified prefixes.
 *
 * The class uses PHP 8.0's Attributes feature to provide declarative validation rules on class properties.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
readonly class StartsWith
{
    public function __construct(private array $prefixes) {}

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        foreach ($this->prefixes as $prefix) {
            if (str_starts_with(haystack: (string) $value, needle: (string) $prefix)) {
                return;
            }
        }

        throw new ValidationException(
            message: $property . ' must start with one of the following: ' . implode(separator: ', ', array: $this->prefixes),
        );
    }
}

=== Validation/Attributes/Rules/StringType.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute to enforce that a property value must be a string.
 *
 * This attribute validates that the value of a property is a string. It is
 * primarily used in DTOs to ensure data integrity and type safety.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class StringType
{
    /**
     * Validation error message template.
     */
    private const string ERROR_MESSAGE = 'The "%s" field must be a string.';

    /**
     * Constructor for the StringType attribute.
     */
    public function __construct(private readonly string|null $message = null) {}

    /**
     * Validates that the provided value is a string.
     *
     * @param mixed  $value    The value to validate.
     * @param string $property The name of the property being validated.
     *
     * @throws ValidationException If the value is not a string.
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! is_string(value: $value)) {
            throw new ValidationException(
                message : $this->message ?? sprintf(self::ERROR_MESSAGE, $property),
                metadata: [
                    'property' => $property,
                    'value'    => $value,
                    'expected' => 'string',
                    'actual'   => gettype(value: $value),
                ]
            );
        }
    }
}

=== Validation/Attributes/Rules/Timezone.php ===
<?php

declare(strict_types=1);

/**
 * Attribute to specify a property should hold a valid timezone.
 *
 * - Set the target to property to enforce the attribute can only be used on class properties.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;
use DateTimeZone;

/**
 * Validates whether the provided value is a valid timezone identifier.
 *
 * @throws \Avax\Exceptions\ValidationException If the value is not a valid timezone identifier.
 *
 * The method leverages the DateTimeZone::listIdentifiers() method to ensure
 * the value conforms to one of the recognized timezone identifiers. This is
 * crucial for maintaining consistency and avoiding errors related to time
 * calculations throughout the application. Any deviation triggers a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Timezone
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! in_array(needle: $value, haystack: DateTimeZone::listIdentifiers(), strict: true)) {
            throw new ValidationException(message: $property . ' must be a valid timezone.');
        }
    }
}

=== Validation/Attributes/Rules/Trimmed.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;

#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class Trimmed
{
    /**
     * Trims the given value if it is a string.
     *
     * @param mixed $value The value to trim.
     *
     * @return mixed The trimmed value.
     */
    public function apply(mixed $value) : mixed
    {
        return is_string(value: $value) ? trim(string: $value) : $value;
    }
}


=== Validation/Attributes/Rules/UUID.php ===
<?php

declare(strict_types=1);

/**
 * Attribute class for enforcing UUID validation on properties.
 *
 * This class is defined as an attribute which can be used to annotate properties within data transfer objects (DTOs).
 * The validation logic ensures that any property marked with this attribute contains a valid UUID string.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * This class defines a UUID attribute to be used for property validation.
 *
 * The class ensures that UUIDs conform to the standard format, making it useful for
 * database or API validations where UUIDs are commonly used as unique identifiers.
 *
 * The UUID class is marked as an attribute with the TARGET_PROPERTY flag, meaning
 * it can be assigned to class properties for validation purposes.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class UUID
{
    private const string UUID_REGEX
        = '/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i';

    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (in_array(needle: preg_match(pattern: self::UUID_REGEX, subject: (string) $value), haystack: [0, false], strict: true)) {
            throw new ValidationException(message: $property . ' must be a valid UUID.');
        }
    }
}

=== Validation/Attributes/Rules/Url.php ===
<?php

declare(strict_types=1);

/**
 * Class URL
 *
 * Defines a custom attribute for validating if a property is a valid URL.
 * Meant to be used on class properties to enforce URL format validation.
 */

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute class to represent URL validation.
 *
 * Applied at TARGET_PROPERTY level to ensure properties are valid URLs.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
class URL
{
    /**
     * @throws \Avax\Exceptions\ValidationException
     */
    public function validate(mixed $value, string $property) : void
    {
        if (! filter_var(value: $value, filter: FILTER_VALIDATE_URL)) {
            throw new ValidationException(message: $property . ' must be a valid URL.');
        }
    }
}

=== Validation/Attributes/Rules/ValidDTOArray.php ===
<?php

declare(strict_types=1);

namespace Avax\DataHandling\Validation\Attributes\Rules;

use Attribute;
use Avax\Exceptions\ValidationException;

/**
 * Attribute for validating an array of data transfer objects (DTOs).
 *
 * This attribute ensures that a property adheres to an array structure where all items
 * are valid DTOs inheriting from the specified target class (via `$dtoClass`).
 *
 * The validation process assumes that the target DTO class's constructor validates
 * its input automatically. Invalid data within the array will trigger a
 * ValidationException.
 */
#[Attribute(flags: Attribute::TARGET_PROPERTY)]
final readonly class ValidDTOArray
{
    /**
     * The fully-qualified class name of the Data Transfer Object (DTO) we expect.
     *
     * @param string $dtoClass The DTO class name to validate instantiated items.
     */
    public function __construct(private string $dtoClass) {}

    /**
     * Validates the given value to ensure it is an array of valid DTOs.
     *
     * Checks the following conditions:
     * - The value must be an array.
     * - Each item in the array must be either an array or an object.
     * - An instance of the specified `$dtoClass` must be successfully created for each item.
     *
     * If any of the above conditions are violated, a ValidationException is thrown.
     *
     * @param mixed  $value    The value of the property to be validated.
     * @param string $property The name of the property being validated, used in exception messages.
     *
     * @throws ValidationException If validation fails.
     */
    public function validate(mixed $value, string $property) : void
    {
        // Ensure the provided value is of type array.
        if (! is_array(value: $value)) {
            throw new ValidationException(
                message: "Expected array of DTOs for {$property}"
            );
        }

        // Iterate through the array to validate each item.
        foreach ($value as $item) {
            // Ensure each item is either an array or an object.
            if (! is_array(value: $item) && ! is_object(value: $item)) {
                throw new ValidationException(
                    message: "Invalid item in {$property}, must be an array or object"
                );
            }

            // Attempt to instantiate the target DTO class with the item.
            // This assumes the DTO constructor validates its input.
            new $this->dtoClass($item);
        }
    }

    /**
     * Converts all elements of the array into instances of the specified DTO class.
     *
     * This method applies a transformation where each element of the input array
     * is passed to the constructor of the defined `$dtoClass`, returning a new array
     * of fully instantiated DTO objects.
     *
     * @param mixed $value The input array to transform.
     *
     * @return array<int, object> An array of DTO objects.
     *
     * @throws ValidationException If construction of any DTO fails.
     */
    public function apply(mixed $value) : array
    {
        return array_map(
            callback: fn($v) => new $this->dtoClass($v), // Instantiate DTO for each item
            array   : $value // Input array
        );
    }
}
=== Validation/messages.php ===
<?php

declare(strict_types=1);

return [
    'validation.max.invalid_type' => 'Invalid type for {property}. Expected {expected}, got {actual}.',
    'validation.max.string'       => '{property} may not be longer than {max} characters.',
    'validation.max.numeric'      => '{property} may not be greater than {max}.',
    'validation.max.countable'    => '{property} may not contain more than {max} items.',
];
