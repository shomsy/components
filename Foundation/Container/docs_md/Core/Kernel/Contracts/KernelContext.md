# KernelContext

## Quick Summary
KernelContext serves as the mutable state container for service resolution operations, tracking the complete lifecycle of a dependency resolution from request to completion. It maintains the service identifier, resolved instance, resolution path, metadata accumulated by pipeline steps, and contextual information like recursion depth and parameter overrides. This context enables pipeline steps to communicate, store intermediate results, and maintain resolution state throughout the complex dependency resolution process.

### For Humans: What This Means
Imagine you're tracking a package through a complex delivery network. KernelContext is like the package's detailed manifest and journey log that follows it through every warehouse, truck, and delivery stop. It records where the package came from, where it's going, what special handling it needs, any problems encountered, and when it finally arrives. For dependency injection, it's the comprehensive record that follows each service request through its entire resolution journey.

## Terminology
**Resolution Context**: A container for all state and metadata associated with resolving a single service instance. In this file, the class maintains the complete resolution state. It matters because it provides the communication mechanism between pipeline steps.

**Service Identifier**: A unique string that identifies the service being resolved. In this file, stored as `$serviceId` and used for tracking and debugging. It matters because it enables correlation of resolution operations.

**Resolution Path**: A string representation showing the chain of service dependencies. In this file, generated by `getPath()` for circular dependency detection. It matters because it enables debugging of complex dependency graphs.

**Context Metadata**: Key-value data attached to the resolution context by pipeline steps. In this file, managed through `setMeta()`, `getMeta()`, etc. It matters because it enables steps to communicate without tight coupling.

**Resolution Depth**: The level of nesting in the dependency graph. In this file, tracked to prevent infinite recursion. It matters because it enables circular dependency detection.

**Parameter Overrides**: Runtime values that replace constructor or method parameters. In this file, stored in `$overrides` for dynamic service configuration. It matters because it enables contextual service customization.

**Parent Context**: A reference to the context that initiated the current resolution. In this file, used to build resolution chains. It matters because it enables hierarchical resolution tracking.

### For Humans: What This Means
These are the tracking and communication vocabulary. Resolution context is the package manifest. Service identifier is the tracking number. Resolution path is the delivery route. Context metadata is notes attached to the package. Resolution depth is how many transfers it's made. Parameter overrides are special delivery instructions. Parent context is where the package came from originally.

## Think of It
Picture a detective investigating a case, maintaining a detailed case file that follows the investigation through every lead, interview, and piece of evidence. KernelContext is that case file for dependency resolution—recording the service request, tracking every resolution step, noting important findings, maintaining the investigation trail, and storing evidence for later analysis. When the case is solved (service resolved), the file contains the complete story of how it happened.

### For Humans: What This Means
This analogy shows why KernelContext exists: comprehensive state tracking. Without it, each pipeline step would have to maintain its own records and find ways to communicate with others. KernelContext provides the shared investigation file that everyone can read from and write to, ensuring coordinated and traceable resolution processes.

## Story Example
Before KernelContext existed, pipeline steps had to use global variables or pass complex parameter objects to communicate. Debugging resolution issues required tracing through multiple methods with scattered state. With KernelContext, each resolution has a dedicated state container that pipeline steps use to store results, check conditions, and communicate metadata. A complex resolution now leaves a complete audit trail that makes debugging and optimization straightforward.

### For Humans: What This Means
This story illustrates the coordination problem KernelContext solves: distributed state management. Without it, pipeline steps were like investigators working separate cases with no way to share information. KernelContext creates the unified case file that enables collaborative, traceable dependency resolution.

## For Dummies
Let's break this down like managing a complex order at a restaurant:

1. **The Problem**: Tracking a single order through preparation, cooking, plating, and delivery with multiple cooks involved.

2. **KernelContext's Job**: The order ticket that follows the dish through every stage, recording notes, special instructions, and status updates.

3. **How You Use It**: Pipeline steps read from and write to the context as they process the service request.

4. **What Happens Inside**: Maintains all the state, metadata, and progress information for one resolution operation.

5. **Why It's Helpful**: Provides a complete record and communication channel for the entire resolution process.

Common misconceptions:
- "It's just a data holder" - It's an active state manager with safety checks and path tracking.
- "Context is global" - Each resolution gets its own isolated context instance.
- "It's immutable" - It's mutable by design to allow pipeline step communication.

### For Humans: What This Means
KernelContext isn't just storage—it's active coordination. It takes the complexity of tracking resolution state and makes it systematic and accessible. You get reliable state management without becoming a state tracking expert.

## How It Works (Technical)
KernelContext is a readonly class with controlled mutability for the instance and metadata. Constructor sets immutable properties, while methods like `resolvedWith()` and metadata setters provide controlled mutation. Child contexts maintain the resolution hierarchy. Path tracking enables circular dependency detection through parent context traversal.

### For Humans: What This Means
Under the hood, it's a carefully designed state container. Most properties are locked at creation, but key aspects like the resolved instance and metadata can be updated through controlled methods. Child contexts create the dependency tree structure. It's like a secure file cabinet where some documents are permanent and others can be updated with proper authorization.

## Architecture Role
KernelContext sits at the center of the pipeline communication architecture, defining the contract for state sharing between resolution steps while maintaining encapsulation and safety. It establishes the data flow patterns that enable the kernel's modular step design.

### For Humans: What This Means
In the kernel's architecture, KernelContext is the central nervous system—the communication protocol that allows all pipeline steps to work together. It defines how information flows and state is maintained, enabling the kernel's flexible, composable design.

## Risks, Trade-offs & Recommended Practices
**Risk**: Context metadata can become a dumping ground for unstructured data.

**Why it matters**: Unorganized metadata makes debugging difficult and increases memory usage.

**Design stance**: Use structured metadata with consistent naming and namespaces.

**Recommended practice**: Document metadata keys and establish naming conventions for pipeline steps.

**Risk**: Deep resolution paths can cause performance issues.

**Why it matters**: Complex dependency graphs create large context chains.

**Design stance**: Monitor path lengths and optimize dependency structures.

**Recommended practice**: Use path analysis to identify and refactor overly complex dependency graphs.

**Risk**: Mutable instance setting can cause race conditions.

**Why it matters**: Multiple steps might try to set the instance simultaneously.

**Design stance**: Use safe setting methods and clear step ordering.

**Recommended practice**: Design pipeline steps with clear responsibilities for instance setting.

### For Humans: What This Means
Like any communication system, KernelContext has information management trade-offs. It's powerful for coordination but requires discipline. The key is using it as designed—with structure, monitoring, and clear conventions.

## Related Files & Folders
**ResolutionPipeline**: Uses KernelContext as the data structure passed between steps. You create contexts for pipeline execution. It provides the operational context for resolution.

**KernelStep**: Receives KernelContext in its execution method. You implement steps that read from and write to contexts. It establishes the step-context interaction contract.

**KernelRuntime**: Creates initial KernelContext instances for resolution requests. You access context through runtime methods. It provides the entry point for context creation.

**Steps/**: Contains pipeline step implementations that manipulate KernelContext. You examine these for context usage patterns. It provides concrete examples of context interaction.

### For Humans: What This Means
KernelContext works with the entire pipeline ecosystem. The pipeline uses it as the communication medium, steps interact with it during execution, runtime creates it for requests, and the steps folder shows how it's used in practice. Understanding this ecosystem helps you work effectively with resolution state.

## Methods (MANDATORY)


This section is the API map of the file: it documents what each method does, why it exists, and how you should use it.

### For Humans: What This Means
When you’re trying to use or debug this file, this is the part you’ll come back to. It’s your “what can I call, and what happens?” cheat sheet.

### Method: child(string $serviceId, array $overrides = []): self

#### Technical Explanation
Creates a new child context for resolving nested dependencies, maintaining the resolution hierarchy while incrementing depth and establishing parent-child relationships for path tracking and circular dependency detection.

##### For Humans: What This Means
When resolving a service that has its own dependencies, this creates a "child context" that tracks the nested resolution while maintaining the connection to the parent. It's like creating a sub-task that knows it belongs to a larger task.

##### Parameters
- `string $serviceId`: Identifier for the service being resolved in the child context
- `array $overrides`: Parameter overrides specific to this child resolution

##### Returns
- `self`: New child context instance with incremented depth and parent reference

##### Throws
- None. Child context creation is always safe.

##### When to Use It
- During recursive dependency resolution in pipeline steps
- When a resolved service has its own dependencies to resolve
- In steps that need to track resolution hierarchies

##### Common Mistakes
- Forgetting that child contexts inherit properties from parent
- Not using overrides when child resolution needs different parameters
- Confusing child context depth with execution stack depth

### Method: getInstance(): mixed

#### Technical Explanation
Returns the resolved service instance if resolution has completed, or null if the resolution process is still in progress, providing access to the final result of the pipeline execution.

##### For Humans: What This Means
This is how you get the actual service object once it's been resolved. If the pipeline hasn't finished yet, it returns null. It's like checking if your order is ready at the counter.

##### Parameters
- None.

##### Returns
- `mixed`: The resolved service instance or null if not yet resolved

##### Throws
- None. Instance access is always safe.

##### When to Use It
- After pipeline execution to retrieve the resolved service
- In pipeline steps to check if resolution has already occurred
- When implementing conditional logic based on resolution status

##### Common Mistakes
- Assuming getInstance() will never return null
- Using getInstance() during pipeline execution (instance may not be set yet)
- Not checking isResolved() before using the instance

### Method: contains(string $serviceId): bool

#### Technical Explanation
Traverses the parent context chain to detect circular dependencies by checking if the given service ID appears anywhere in the resolution path, enabling early detection of infinite resolution loops.

##### For Humans: What This Means
This checks if we're already trying to resolve the same service higher up in the dependency chain, which would create an infinite loop. It's like checking if you're not ordering the same item twice in a circular way.

##### Parameters
- `string $serviceId`: Service identifier to check for in the resolution path

##### Returns
- `bool`: True if service is already in the resolution chain (circular dependency)

##### Throws
- None. Path checking is always safe.

##### When to Use It
- In pipeline steps before initiating new resolutions
- When implementing circular dependency detection
- During validation of service dependency graphs

##### Common Mistakes
- Not using contains() before recursive resolution
- Confusing contains() with checking registered services
- Assuming contains() only checks immediate parent

### Method: getPath(): string

#### Technical Explanation
Constructs a human-readable string representation of the complete resolution path by recursively traversing parent contexts and concatenating service identifiers with arrow separators.

##### For Humans: What This Means
This builds a nice string showing the full chain of dependencies, like "database -> userRepository -> userService". It's perfect for debugging to see exactly how you got to a particular resolution.

##### Parameters
- None.

##### Returns
- `string`: Resolution path string showing dependency chain

##### Throws
- None. Path construction is always safe.

##### When to Use It
- In error messages for debugging resolution failures
- When logging resolution paths for monitoring
- In development tools for visualizing dependency graphs

##### Common Mistakes
- Assuming getPath() is expensive (it's recursive but usually shallow)
- Using getPath() in performance-critical code without caching
- Not using getPath() in error messages when debugging

### Method: setMetaOnce(string $namespace, string $key, mixed $value): void

#### Technical Explanation
Stores a metadata value in the specified namespace and key, but only if that key doesn't already exist, preventing accidental overwrites of important pipeline step data.

##### For Humans: What This Means
This adds a note or piece of information to the context, but only if that particular note hasn't been added yet. It's like writing on a whiteboard, but only if that spot is still blank.

##### Parameters
- `string $namespace`: Metadata category (like 'pipeline', 'validation', etc.)
- `string $key`: Specific metadata key within the namespace
- `mixed $value`: The information to store

##### Returns
- `void`: Metadata storage doesn't return anything

##### Throws
- None. Metadata setting is always safe.

##### When to Use It
- When pipeline steps need to communicate information to later steps
- For one-time initialization or status flags
- When you want to ensure metadata isn't accidentally overwritten

##### Common Mistakes
- Using setMetaOnce() when you actually want to overwrite (use setMeta())
- Assuming setMetaOnce() will always set the value
- Not using consistent namespace conventions

### Method: setMeta(string $namespace, string $key, mixed $value): void

#### Technical Explanation
Stores a metadata value that can be retrieved by subsequent pipeline steps, enabling communication and state sharing between different stages of the resolution process.

##### For Humans: What This Means
This lets pipeline steps leave notes for each other. One step can store some information, and later steps can read it. It's the context's way of sharing knowledge.

##### Parameters
- `string $namespace`: Metadata category for organization
- `string $key`: Specific key within the namespace
- `mixed $value`: Information to share with other steps

##### Returns
- `void`: Metadata storage doesn't return anything

##### Throws
- None. Metadata setting is always safe.

##### When to Use It
- When steps need to pass information to subsequent steps
- For storing intermediate results or status information
- In complex pipelines with interdependent steps

##### Common Mistakes
- Using inconsistent namespace or key naming
- Storing large objects in metadata (increases memory usage)
- Not documenting what metadata keys steps expect

### Method: getMeta(string $namespace, string $key, mixed $default = null): mixed

#### Technical Explanation
Retrieves metadata values set by previous pipeline steps, returning a default value if the requested metadata doesn't exist, enabling safe access to optional context information.

##### For Humans: What This Means
This reads the notes that other pipeline steps have left. If the note doesn't exist, you can provide a default value. It's like checking if someone left you a message.

##### Parameters
- `string $namespace`: Metadata category to read from
- `string $key`: Specific key to retrieve
- `mixed $default`: Value to return if metadata doesn't exist

##### Returns
- `mixed`: The stored metadata value or the default

##### Throws
- None. Metadata retrieval is always safe.

##### When to Use It
- When steps need information from previous pipeline steps
- For conditional logic based on accumulated context
- When reading optional configuration or status information

##### Common Mistakes
- Not providing sensible defaults when metadata might not exist
- Assuming getMeta() will always return the expected type
- Using getMeta() for required data (should validate existence)

### Method: hasMeta(string $namespace, string $key): bool

#### Technical Explanation
Checks whether specific metadata has been set in the context, enabling conditional logic based on the presence of context information without retrieving the actual values.

##### For Humans: What This Means
This checks if a particular note has been left in the context, without reading what it says. It's like checking if you have a message without opening it.

##### Parameters
- `string $namespace`: Metadata category to check
- `string $key`: Specific key to check for

##### Returns
- `bool`: True if the metadata exists, false otherwise

##### Throws
- None. Metadata checking is always safe.

##### When to Use It
- Before reading metadata to avoid default value logic
- For conditional pipeline step behavior
- When validating that required context information is present

##### Common Mistakes
- Using hasMeta() when you actually need the value (just use getMeta() with default)
- Assuming hasMeta() checks for truthy values (it only checks existence)
- Not using hasMeta() before getMeta() when null defaults aren't acceptable

### Method: resolvedWith(mixed $instance): void

#### Technical Explanation
Safely sets the resolved service instance, but only if no instance has been set yet, preventing accidental overwrites and maintaining resolution state integrity.

##### For Humans: What This Means
This marks the service as successfully resolved and stores the final instance. It only works if nothing else has claimed the resolution yet, keeping things safe and predictable.

##### Parameters
- `mixed $instance`: The successfully resolved service instance

##### Returns
- `void`: Instance setting doesn't return anything

##### Throws
- `LogicException`: If instance has already been resolved

##### When to Use It
- When a pipeline step successfully resolves the service
- For initial instance setting in resolution steps
- When you want to ensure only one resolution succeeds

##### Common Mistakes
- Using resolvedWith() when you want to overwrite (use overwriteWith())
- Not handling the LogicException
- Calling resolvedWith() multiple times in the same pipeline

### Method: overwriteWith(mixed $instance): void

#### Technical Explanation
Replaces the current resolved instance with a new one, intended for use by extenders, decorators, or other transformations that modify the final service result.

##### For Humans: What This Means
This lets you replace the resolved service with a modified version, like wrapping it with logging or caching. It's for cases where you want to change the final result.

##### Parameters
- `mixed $instance`: New instance to replace the current one

##### Returns
- `void`: Instance replacement doesn't return anything

##### Throws
- None. Overwriting is always allowed.

##### When to Use It
- In extenders that modify service behavior
- When implementing decorators or proxies
- For post-resolution transformations

##### Common Mistakes
- Using overwriteWith() when you should use resolvedWith()
- Overwriting instances unintentionally
- Not documenting when and why overwriting occurs

### Method: isResolved(): bool

#### Technical Explanation
Determines whether the resolution process has completed by checking if a service instance has been set, providing a simple way to test resolution status.

##### For Humans: What This Means
This tells you whether the service has been successfully resolved yet. It's like checking if your order has been fulfilled.

##### Parameters
- None.

##### Returns
- `bool`: True if an instance has been resolved, false otherwise

##### Throws
- None. Status checking is always safe.

##### When to Use It
- After pipeline execution to verify success
- In conditional logic within pipeline steps
- When implementing resolution status monitoring

##### Common Mistakes
- Confusing isResolved() with checking if instance is not null (they're equivalent)
- Using isResolved() when you need the actual instance
- Not using isResolved() in status reporting

### Method: __toString(): string

#### Technical Explanation
Provides a human-readable string representation of the context's current state, including service ID, resolution depth, and resolution status for debugging and logging.

##### For Humans: What This Means
This creates a nice summary string showing the key information about the context, perfect for debugging or logging. It shows what's being resolved, how deep in the dependency tree, and if it's done.

##### Parameters
- None.

##### Returns
- `string`: Formatted context summary

##### Throws
- None. String conversion is always safe.

##### When to Use It
- In debug output and logging
- When implementing context inspection tools
- For error messages and status reporting

##### Common Mistakes
- Assuming the format is stable for parsing (it's for human consumption)
- Not using __toString() in exception messages
- Expecting detailed internal state (it only shows summary information)
