=== Foundation/Config/Config.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Config;

use Avax\DataHandling\ArrayHandling\Arrhae;

/**
 * A pragmatic, nested configuration registry with dot-notation support.
 *
 * -- intent: manage database-specific configuration parameters with easy access.
 */
final class Config
{
    // Storage for configuration parameters
    private array $items = [];

    /**
     * Initialize the configuration registry with optional starting items.
     *
     * -- intent: hydrate the configuration storage.
     *
     * @param array $items Initial configuration data
     */
    public function __construct(array $items = [])
    {
        $this->items = $items;
    }

    /**
     * Retrieve a specific configuration value using an optional dot-notation key.
     *
     * -- intent: provide flexible, depth-aware access to configuration items.
     *
     * @param string $key     Property technical name
     * @param mixed  $default Fallback value if key is not located
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return Arrhae::make(items: $this->items)->get(key: $key, default: $default);
    }

    /**
     * Assign a specific value to a configuration key.
     *
     * -- intent: allow runtime modification of the configuration Registry.
     *
     * @param string $key   Property identifier
     * @param mixed  $value Data to store
     *
     * @return void
     */
    public function set(string $key, mixed $value) : void
    {
        $this->items[$key] = $value;
    }

    /**
     * Retrieve the entire configuration registry as an array.
     *
     * -- intent: expose the raw configuration for mass-processing or debugging.
     *
     * @return array
     */
    public function all() : array
    {
        return $this->items;
    }
}

=== Foundation/Connection/ConnectionFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\Exceptions\ConnectionFailure;
use Avax\Database\Connection\ValueObjects\ConnectionConfig;
use Avax\Database\Connection\ValueObjects\Dsn;
use PDO;
use Throwable;

/**
 * Factory: creates DatabaseConnection instances from configuration.
 *
 * Intention:
 * Centralized, declarative, and secure connection assembly with explicit value objects.
 */
final readonly class ConnectionFactory
{
    /**
     * Build a DatabaseConnection from configuration array.
     *
     * @param array{
     *     driver?: string,
     *     host?: string,
     *     database?: string,
     *     username?: string,
     *     password?: string,
     *     charset?: string,
     *     name?: string
     * } $config
     *
     * @throws ConnectionFailure
     */
    public static function from(array $config) : DatabaseConnection
    {
        // Enforce strong typing via ConnectionConfig DTO.
        $config = ConnectionConfig::from(config: $config);

        // Generate DSN as a first-class Value Object.
        $dsn = Dsn::for(
            driver  : $config->driver,
            host    : $config->host,
            database: $config->database,
            charset : $config->charset
        );

        // Attempt secure connection using DTO parameters.
        try {
            $pdo = new PDO(
                dsn     : $dsn->toString(),
                username: $config->username,
                password: $config->password,
                options : [
                              PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                              PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                              PDO::ATTR_EMULATE_PREPARES   => false,
                          ],
            );

            // Return wrapped connection adhering to DatabaseConnection contract.
            return new PdoConnection(
                name: $config->name,
                pdo : $pdo,
            );
        } catch (Throwable $e) {
            // Enterprise-grade exception translation.
            throw new ConnectionFailure(
                name    : $config->name,
                message : sprintf(
                              'Database connection [%s] failed: %s',
                              $config->name,
                              $e->getMessage()
                          ),
                previous: $e
            );
        }
    }
}

=== Foundation/Connection/ConnectionManager.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\Exceptions\ConnectionException;
use Avax\Database\Connection\Exceptions\ConnectionFailure;
use Avax\Database\Foundation\Connection\ConnectionPool;
use PDO;
use Throwable;

/**
 * High-performance technician for managing physical database connections.
 *
 * -- intent: provide a unified entry point for retrieving active database connections.
 */
final class ConnectionManager
{
    // Storage for resolved connection instances
    private array $connections = [];

    /**
     * Constructor promoting the base configuration array.
     *
     * -- intent: store the configuration for lazy connection initialization.
     *
     * @param array $config The database configuration registry
     */
    public function __construct(private readonly array $config) {}

    /**
     * Execute a closure after acquiring a connection from the pool.
     *
     * @param callable    $callback Operation to perform with the pooled connection
     * @param string|null $name     Specific connection identifier
     *
     * @return mixed
     * @throws Throwable If callback or pool acquisition fails
     */
    public function pool(callable $callback, string|null $name = null) : mixed
    {
        $connection = $this->flow()->usePool();
        if ($name) {
            $connection->on(name: $name);
        }

        return $connection->run(callback: $callback);
    }

    /**
     * Start a fluent database operation flow.
     */
    public function flow() : DatabaseFlow
    {
        return new DatabaseFlow(manager: $this);
    }

    /**
     * Retrieve the native PDO instance for a specific connection.
     *
     * -- intent: provide low-level access to the database driver for raw operations.
     *
     * @param string|null $name Technical connection name
     *
     * @return PDO
     * @throws ConnectionException If connection fails
     */
    public function getPdo(string|null $name = null) : PDO
    {
        return $this->connection(name: $name)->getConnection();
    }

    /**
     * Retrieve a connection instance by its technical name.
     *
     * -- intent: resolve connections on-demand and cache them for subsequent use.
     *
     * @param string|null $name Technical identifier of the connection
     *
     * @return DatabaseConnection
     * @throws ConnectionException|ConnectionFailure If the requested configuration is missing or connection fails
     */
    public function connection(string|null $name = null) : DatabaseConnection
    {
        $name = $name ?: $this->getDefaultConnection();

        if (! isset($this->connections[$name])) {
            $this->connections[$name] = $this->makeConnection(name: $name);
        }

        return $this->connections[$name];
    }

    /**
     * Determine the default connection name from the configuration.
     *
     * -- intent: provide a fallback when no specific connection is requested.
     *
     * @return string
     */
    private function getDefaultConnection() : string
    {
        return $this->config['default'] ?? 'mysql';
    }

    /**
     * Create a fresh connection instance based on the technical name.
     *
     * -- intent: resolve the appropriate factory or pool implementation.
     *
     * @param string $name Configuration key for the connection
     *
     * @return DatabaseConnection|ConnectionPool
     */
    private function makeConnection(string $name) : DatabaseConnection|ConnectionPool
    {
        $config = $this->config['connections'][$name] ?? null;

        if ($config === null) {
            throw new ConnectionException(name: $name, message: "Database connection configuration not found.");
        }

        // Ensure the config knows its domain label
        $config['name'] = $name;

        if (isset($config['pool'])) {
            return new ConnectionPool(config: $config);
        }

        return ConnectionFactory::from(config: $config);
    }
}

=== Foundation/Connection/ConnectionPool.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Foundation\Connection;

use Avax\Database\Connection\ConnectionFactory;
use Avax\Database\Connection\Contracts\ConnectionPoolInterface;
use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\DTO\ConnectionPoolMetrics;
use Avax\Database\Connection\Exceptions\PoolLimitReachedException;
use PDO;
use ReflectionException;
use SplQueue;
use Throwable;

/**
 * Enterprise-grade technician for managing a pool of database connections.
 *
 * -- intent: optimize resource utilization by recycling active database connections.
 */
final class ConnectionPool implements DatabaseConnection, ConnectionPoolInterface
{
    /** @var SplQueue<array{connection: DatabaseConnection, released_at: float}> */
    private SplQueue $pool;

    // Tracks total number of spawned connections
    private int $activeCount = 0;

    // Metric: Total successful acquisitions
    private int $totalAcquisitions = 0;

    /**
     * Constructor promoting the pool configuration settings.
     *
     * -- intent: initialize pool limitations and heartbeat settings.
     *
     * @param array $config Pool-specific configuration
     */
    public function __construct(private readonly array $config)
    {
        $this->pool = new SplQueue();
    }

    /**
     * Fulfill the DatabaseConnection contract by acquiring a temporary connection.
     *
     * -- intent: allow the pool to be used as a standard connection wrapper.
     *
     * @return PDO
     * @throws PoolLimitReachedException If pool limit is reached
     */
    public function getConnection(): PDO
    {
        return $this->acquire()->getConnection();
    }

    /**
     * Logic to acquire a connection from the idle pool or create a fresh one.
     *
     * -- intent: balance between recycling and on-demand scaling.
     *
     * @return DatabaseConnection
     * @throws PoolLimitReachedException If maximum pool capacity is exceeded
     */
    public function acquire(): DatabaseConnection
    {
        if (! $this->pool->isEmpty()) {
            $item       = $this->pool->dequeue();
            $connection = $item['connection'];

            if ($this->validateConnection(connection: $connection)) {
                $this->totalAcquisitions++;

                return $connection;
            }
            $this->activeCount--;
        }

        $limit = $this->config['pool']['max_connections'] ?? 10;
        $name  = $this->config['name'] ?? 'anonymous';

        if ($this->activeCount >= $limit) {
            throw new PoolLimitReachedException(name: $name, limit: $limit);
        }

        $connection = ConnectionFactory::from(config: $this->config);
        $this->activeCount++;
        $this->totalAcquisitions++;

        return $connection;
    }

    /**
     * Verify the health of a specific pooled connection.
     *
     * -- intent: prevent broken connections from being delivered to the consumer.
     *
     * @param DatabaseConnection|null $connection Target connection
     *
     * @return bool
     */
    public function validateConnection(DatabaseConnection|null $connection = null): bool
    {
        if ($connection === null) {
            return false;
        }

        try {
            return $connection->ping();
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Verify the health of the pool itself.
     *
     * @return bool
     */
    public function ping(): bool
    {
        return true;
    }

    /**
     * Retrieve the logical name/label of the active connection pool.
     *
     * @return string
     */
    public function getName(): string
    {
        return $this->config['name'] ?? 'pool';
    }

    /**
     * Retrieve current pool usage metrics.
     *
     * @return ConnectionPoolMetrics
     * @throws ReflectionException
     */
    public function getMetrics(): ConnectionPoolMetrics
    {
        $maxIdleTime = 0;
        if (! $this->pool->isEmpty()) {
            $oldest      = $this->pool->bottom(); // Bottom is oldest in SplQueue (FIFO)
            $maxIdleTime = (int) (microtime(as_float: true) - $oldest['released_at']);
        }

        return new ConnectionPoolMetrics(
            data: [
                'activeConnections' => $this->activeCount,
                'idleConnections'   => $this->pool->count(),
                'maxConnections'    => (int) ($this->config['pool']['max_connections'] ?? 10),
                'totalAcquisitions' => $this->totalAcquisitions,
                'maxIdleTime'       => $maxIdleTime
            ]
        );
    }

    /**
     * Return a connection to the idle pool after usage.
     *
     * -- intent: recycle the resource for future requests.
     *
     * @param DatabaseConnection $connection The connection to release
     *
     * @return void
     */
    public function release(DatabaseConnection $connection): void
    {
        // ✅ Validation on release
        if (! $this->validateConnection(connection: $connection)) {
            $this->activeCount--;

            return;
        }

        $maxIdle = $this->config['pool']['max_idle_connections'] ?? 5;

        // ✅ Limit queue size and close oldest if full
        if ($this->pool->count() >= $maxIdle) {
            $this->pool->dequeue();
            $this->activeCount--;
        }

        $this->pool->enqueue(
            value: [
                'connection'  => $connection,
                'released_at' => microtime(as_float: true)
            ]
        );
    }
}

=== Foundation/Connection/ConnectionPoolFlow.php ===
<?php

// Enforce strict type safety for the entire Database module
declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Foundation\Connection\ConnectionPool;
use InvalidArgumentException;

/**
 * Class ConnectionPoolFlow
 *
 * -- intent: Fluent DSL builder for creating and configuring database connection pools.
 * -- context: Used by infrastructure bootstrapping to declaratively assemble connection pools.
 * -- guarantees: Always returns a valid ConnectionPool instance with provided configuration.
 *
 * Example:
 * ```php
 * $pool = ConnectionPoolFlow::begin()
 *     ->using(['driver' => 'mysql', 'host' => 'localhost'])
 *     ->pool();
 * ```
 *
 * @package Avax\Database\Connection
 * @since 1.0.0
 */
final class ConnectionPoolFlow
{
    /**
     * -- intent: Hold configuration for the pool being constructed.
     * -- role: Acts as a temporary state container between fluent builder steps.
     *
     * @var array<string,mixed>
     */
    private array $config = [];

    /**
     * -- intent: Prevent direct instantiation to enforce the fluent DSL entry point (begin()).
     */
    private function __construct() {}

    /**
     * -- intent: Entry point for starting a new connection pool DSL flow.
     * -- rationale: Mirrors natural language — “begin → using → pool”.
     *
     * Example:
     * ```php
     * ConnectionPoolFlow::begin();
     * ```
     *
     * @return self
     */
    public static function begin(): self
    {
        // -- intent: Start new configuration flow
        return new self();
    }

    /**
     * -- intent: Attach configuration array for connection pool creation.
     * -- rationale: Allows chaining for declarative style configuration.
     *
     * Example:
     * ```php
     * ->using(['driver' => 'mysql', 'host' => '127.0.0.1'])
     * ```
     *
     * @param array<string,mixed> $config Connection pool configuration.
     * @return self Fluent interface continuation.
     */
    public function using(array $config): self
    {
        // -- SECURITY: Defensive copy (never mutate external config reference)
        $this->config = $config;

        return $this;
    }

    /**
     * -- intent: Finalize DSL flow and build the ConnectionPool instance.
     * -- guarantees: Returns a ready-to-use pool with all connections managed.
     *
     * Example:
     * ```php
     * $pool = ConnectionPoolFlow::begin()->using($config)->pool();
     * ```
     *
     * @return ConnectionPool Ready connection pool instance.
     * @throws InvalidArgumentException If configuration is invalid.
     */
    public function pool(): ConnectionPool
    {
        // -- intent: Construct new ConnectionPool using provided configuration
        return new ConnectionPool(config: $this->config);
    }
}

=== Foundation/Connection/Contracts/ConnectionPoolInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Contracts;

/**
 * Technical contract for implementing connection pooling mechanisms.
 *
 * -- intent: define the standard lifecycle for acquiring and releasing pooled resources.
 */
interface ConnectionPoolInterface
{
    /**
     * Acquire a functional connection from the managed pool.
     *
     * -- intent: retrieve a recycled or fresh connection for immediate use.
     *
     * @return DatabaseConnection
     */
    public function acquire() : DatabaseConnection;

    /**
     * Return a connection instance back to the shared pool.
     *
     * -- intent: signal that the resource is available for other consumers.
     *
     * @param DatabaseConnection $connection The active resource to release
     *
     * @return void
     */
    public function release(DatabaseConnection $connection) : void;
}



=== Foundation/Connection/Contracts/DatabaseConnection.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Contracts;

use PDO;

/**
 * Defines the essential contract for any database driver or connection wrapper.
 *
 * -- intent: ensure a consistent API across different database technologies.
 */
interface DatabaseConnection
{
    /**
     * Retrieve the underlying technical connection instance (PDO).
     *
     * -- intent: provide access to the raw driver for low-level operations.
     *
     * @return PDO The active PHP driver instance
     */
    public function getConnection(): PDO;

    /**
     * Verify the health and responsiveness of the database connection.
     *
     * -- intent: check if the connection is still alive and ready for queries.
     *
     * @return bool True if the connection is active and responsive
     */
    public function ping(): bool;

    /**
     * Retrieve the logical name/label of the active connection.
     *
     * -- intent: identify the connection for telemetry, logging, and debugging.
     *
     * @return string
     */
    public function getName(): string;
}

=== Foundation/Connection/DTO/ConnectionPoolMetrics.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\DTO;

use Avax\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Avax\DataHandling\Validation\Attributes\Rules\IntegerRule;

/**
 * Data Transfer Object capturing the instantaneous state of the connection pool.
 */
final class ConnectionPoolMetrics extends AbstractDTO
{
    #[IntegerRule]
    public int $activeConnections;

    #[IntegerRule]
    public int $idleConnections;

    #[IntegerRule]
    public int $maxConnections;

    #[IntegerRule]
    public int $totalAcquisitions;

    #[IntegerRule]
    public int $maxIdleTime;
}

=== Foundation/Connection/DatabaseFlow.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Exception;
use Avax\Database\Connection\Contracts\ConnectionPoolInterface;
use Avax\Database\Connection\ConnectionManager;

/**
 * Fluent DSL for executing database operations with automatic resource management.
 */
final class DatabaseFlow
{
    /**
     * Target connection identifier for routing queries.
     */
    private string|null $connectionName = null;

    /**
     * Enable connection pooling with acquire/release semantics.
     */
    private bool        $pooled         = false;

    /**
     * Initialize the fluent query builder with connection manager.
     *
     * @param ConnectionManager $manager Connection lifecycle manager
     */
    public function __construct(private readonly ConnectionManager $manager) {}

    /**
     * Specify the target connection name for query routing.
     *
     * @param string $name Connection identifier
     *
     * @return self Fluent interface for method chaining
     */
    public function on(string $name) : self
    {
        $this->connectionName = $name;

        return $this;
    }

    /**
     * Enable connection pooling with acquire/release lifecycle management.
     *
     * @return self Fluent interface for method chaining
     */
    public function usePool() : self
    {
        $this->pooled = true;

        return $this;
    }

    /**
     * Execute the given logic using the resolved connection with automatic resource cleanup.
     *
     * -- intent: runs the callback with either pooled or direct connection, ensuring
     * proper resource acquisition and release semantics.
     *
     * @param callable $callback Logic to execute with connection instance
     *
     * @return mixed Result of the callback execution
     *
     * @throws Exception Any exception thrown by the callback or connection operations
     */
    public function run(callable $callback) : mixed
    {
        $connection = $this->manager->connection(name: $this->connectionName);

        if ($this->pooled && $connection instanceof ConnectionPoolInterface) {
            $instance = $connection->acquire();
            try {
                return $callback($instance);
            } finally {
                $connection->release(connection: $instance);
            }
        }

        return $callback($connection);
    }
}

=== Foundation/Connection/DirectConnectionFlow.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\ConnectionFactory;
use Avax\Database\Events\ConnectionFailed;
use Avax\Database\Events\ConnectionOpened;
use Avax\Database\Events\EventBus;
use Throwable;

/**
 * DSL for establishing direct (non-pooled) database connections.
 */
final class DirectConnectionFlow
{
    /**
     * Database connection configuration parameters.
     */
    private array         $config   = [];

    /**
     * Event dispatcher for connection lifecycle events.
     */
    private EventBus|null $eventBus = null;

    /**
     * Private constructor for static factory pattern.
     */
    private function __construct() {}

    /**
     * Create a new connection flow builder instance.
     *
     * @return self Fluent interface for method chaining
     */
    public static function begin() : self
    {
        return new self();
    }

    /**
     * Set the database connection configuration.
     *
     * @param array $config Connection parameters (host, port, database, etc.)
     *
     * @return self Fluent interface for method chaining
     */
    public function using(array $config) : self
    {
        $this->config = $config;

        return $this;
    }

    /**
     * Attach event dispatcher for connection lifecycle notifications.
     *
     * @param EventBus $eventBus Event dispatcher instance
     *
     * @return self Fluent interface for method chaining
     */
    public function withEvents(EventBus $eventBus) : self
    {
        $this->eventBus = $eventBus;

        return $this;
    }

    /**
     * Establish the database connection with event notifications.
     *
     * -- intent: creates a new connection instance, dispatches lifecycle events,
     * and propagates any connection errors to the event bus.
     *
     * @return DatabaseConnection Active database connection instance
     *
     * @throws Throwable Any exception from connection factory or event dispatch
     */
    public function connect() : DatabaseConnection
    {
        $label = $this->config['name'] ?? 'default';
        try {
            $connection = ConnectionFactory::from(config: $this->config);
            $this->eventBus?->dispatch(event: new ConnectionOpened(connectionName: $label));

            return $connection;
        } catch (Throwable $e) {
            $this->eventBus?->dispatch(event: new ConnectionFailed(connectionName: $label, exception: $e));
            throw $e;
        }
    }
}

=== Foundation/Connection/Exceptions/ConnectionException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * General connection error.
 */
class ConnectionException extends DatabaseException
{
    /**
     * Constructor capturing the connection name and failure details.
     *
     * -- intent: provide visibility into which connection configuration failed.
     *
     * @param string         $name     Technical connection identifier
     * @param string         $message  Driver-provided error message
     * @param Throwable|null $previous Original PDO or socket exception
     */
    #[Override]
    public function __construct(
        private readonly string $name,
        string                  $message,
        Throwable|null          $previous = null
    )
    {
        parent::__construct(message: "Connection [{$name}] failed: {$message}", code: 0, previous: $previous);
    }

    /**
     * Retrieve the technical name of the failing connection.
     *
     * -- intent: allow identification of the problematic database node.
     *
     * @return string
     */
    public function getConnectionName() : string
    {
        return $this->name;
    }
}



=== Foundation/Connection/Exceptions/ConnectionFailure.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Throwable;

/**
 * Exception thrown when a database connection attempt fails.
 */
class ConnectionFailure extends DatabaseException
{
    public function __construct(
        public readonly string $name,
        string                 $message = "",
        ?Throwable             $previous = null
    )
    {
        parent::__construct(message: $message, code: 0, previous: $previous);
    }
}



=== Foundation/Connection/Exceptions/PoolLimitReachedException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;

/**
 * Triggered when the database connection pool reaches its maximum configured capacity.
 *
 * -- intent: signal resource exhaustion in high-concurrency environments.
 */
final class PoolLimitReachedException extends DatabaseException
{
    /**
     * Constructor capturing the pool name and configured limit.
     *
     * -- intent: provide clear evidence of resource saturation for scaling decisions.
     *
     * @param string $name  Technical pool identifier
     * @param int    $limit Configured maximum connection count
     */
    #[Override]
    public function __construct(
        private readonly string $name,
        private readonly int    $limit
    )
    {
        parent::__construct(message: "Connection pool [{$name}] reached its limit of {$limit} connections.");
    }

    /**
     * Retrieve the technical name of the saturated pool.
     *
     * -- intent: identify which connection path is blocked.
     *
     * @return string
     */
    public function getPoolName() : string
    {
        return $this->name;
    }

    /**
     * Retrieve the maximum allowed connection count for this pool.
     *
     * -- intent: assist in diagnostic capacity planning.
     *
     * @return int
     */
    public function getLimit() : int
    {
        return $this->limit;
    }
}

=== Foundation/Connection/PdoConnection.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use PDO;
use Throwable;

/**
 * Concrete technician for the native PHP Data Object connection.
 *
 * -- intent: provide a domain-specific wrapper around the standard PDO engine.
 */
final readonly class PdoConnection implements DatabaseConnection
{
    /**
     * Constructor promoting the native driver instance.
     *
     * -- intent: encapsulate the physical driver within the component contract.
     *
     * @param string $name Technical identifier/label of the connection
     * @param PDO    $pdo  Active PHP driver instance
     */
    public function __construct(private string $name, private PDO $pdo) {}

    /**
     * Retrieve the internal PDO instance.
     *
     * -- intent: expose the driver for raw SQL execution.
     *
     * @return PDO
     */
    public function getConnection(): PDO
    {
        return $this->pdo;
    }

    /**
     * Perform a low-level heartbeat check on the connection.
     *
     * -- intent: verify the physical socket or server is still responsive.
     *
     * @return bool
     */
    public function ping(): bool
    {
        try {
            $this->pdo->query(query: "SELECT 1");

            return true;
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Retrieve the logical name/label of the active connection.
     *
     * @return string
     */
    public function getName(): string
    {
        return $this->name;
    }
}

=== Foundation/Connection/ValueObjects/ConnectionConfig.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\ValueObjects;

use SensitiveParameter;

/**
 * Immutable value object representing a database connection's technical configuration.
 *
 * -- intent: centralize and type-hint the varied parameters required to establish a connection.
 * -- design: leverage PHP 8.3 readonly features for strict data integrity.
 */
final readonly class ConnectionConfig
{
    /**
     * Constructor using promoted properties for concise parameter capturing.
     *
     * @param string $driver   Database engine driver (e.g., 'mysql', 'pgsql')
     * @param string $host     Network address of the database host
     * @param string $database Name of the target schema/database
     * @param string $username Security credential (user identifier)
     * @param string $password Security credential (secret token)
     * @param string $charset  Character encoding protocol
     * @param string $name     Logical identifier for the connection within the system
     */
    public function __construct(
        public string                       $driver = 'mysql',
        public string                       $host = '127.0.0.1',
        public string                       $database = '',
        public string                       $username = 'root',
        #[SensitiveParameter] public string $password = '',
        public string                       $charset = 'utf8mb4',
        public string                       $name = 'default',
    ) {}

    /**
     * Static factory for hydrating the config from a raw associative array.
     *
     * @param array $config Key-value map of configuration settings
     *
     * @return self
     */
    public static function from(array $config) : self
    {
        return new self(
            driver  : $config['driver'] ?? 'mysql',
            host    : $config['host'] ?? '127.0.0.1',
            database: $config['database'] ?? '',
            username: $config['username'] ?? 'root',
            password: $config['password'] ?? '',
            charset : $config['charset'] ?? 'utf8mb4',
            name    : $config['name'] ?? 'default'
        );
    }
}

=== Foundation/Connection/ValueObjects/Dsn.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\ValueObjects;

use InvalidArgumentException;

/**
 * Class Dsn
 *
 * -- intent: Represents a complete, immutable DSN (Data Source Name) string used for database connections.
 * -- context: Used by ConnectionFactory and ConnectionManager to safely construct driver-specific DSNs.
 * -- guarantees: Once created, it cannot change; always produces a valid and sanitized DSN string.
 *
 * Example:
 * ```php
 * $dsn = Dsn::for('mysql', 'localhost', 'avax', 'utf8mb4')->toString();
 * // mysql:host=localhost;dbname=avax;charset=utf8mb4
 * ```
 *
 * @package Avax\Database\Connection\ValueObjects
 * @since   1.0.0
 */
final readonly class Dsn
{
    /**
     * -- intent: Internal constructor ensures DSN immutability (Value Object pattern).
     * -- rationale: Prevents direct instantiation; forces creation via named constructor.
     *
     * @param string $dsn Fully formatted DSN string.
     */
    private function __construct(private string $dsn) {}

    /**
     * -- intent: Factory method for building a driver-specific DSN from basic connection parameters.
     * -- guarantees: Returns a valid DSN string for all supported drivers (currently MySQL & SQLite).
     * -- rationale: Keeps DSN generation consistent and free from manual string concatenation.
     *
     * Example:
     * ```php
     * Dsn::for('sqlite', '/tmp/db.sqlite', '', '');
     * Dsn::for('mysql', 'localhost', 'avax', 'utf8mb4');
     * ```
     *
     * @param string $driver   The database driver name (e.g. mysql, sqlite).
     * @param string $host     The database host or file path (for sqlite).
     * @param string $database The database name or file (depending on driver).
     * @param string $charset  The character encoding (e.g. utf8mb4).
     *
     * @return self A new immutable Dsn instance.
     *
     * @throws InvalidArgumentException If the driver is unsupported or parameters are invalid.
     */
    public static function for(
        string $driver,
        string $host,
        string $database,
        string $charset,
    ) : self
    {
        // -- intent: Select DSN format based on driver type
        // -- SECURITY: Prevents injection by strict string formatting (sprintf)
        $dsn = match ($driver) {
            'sqlite' => sprintf('sqlite:%s', $database),
            default  => sprintf('%s:host=%s;dbname=%s;charset=%s', $driver, $host, $database, $charset),
        };

        // -- intent: Return a new immutable DSN instance
        return new self(dsn: $dsn);
    }

    /**
     * -- intent: Retrieve the DSN as a plain string for PDO or ConnectionManager.
     * -- guarantees: Always returns a valid, non-empty DSN.
     *
     * Example:
     * ```php
     * echo $dsn->toString(); // mysql:host=localhost;dbname=avax;charset=utf8mb4
     * ```
     *
     * @return string The final DSN string representation.
     */
    public function toString() : string
    {
        return $this->dsn;
    }
}

=== Foundation/Events/ConnectionFailed.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Throwable;

/**
 * Event signaled when a database connection attempt fails.
 */
final readonly class ConnectionFailed extends Event
{
    #[\Override]
    public function __construct(
        public string    $connectionName,
        public Throwable $exception
    )
    {
        parent::__construct();
    }
}

=== Foundation/Events/ConnectionOpened.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * Event signaled when a new database connection is successfully opened.
 */
final readonly class ConnectionOpened extends Event
{
    public function __construct(public string $connectionName)
    {
        parent::__construct();
    }
}

=== Foundation/Events/Event.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * Base definition for all domain and infrastructure events within the system.
 *
 * -- intent: provide a structured signal for system-wide state changes.
 */
abstract readonly class Event
{
    public readonly float $timestamp;

    public function __construct()
    {
        $this->timestamp = microtime(as_float: true);
    }

    /**
     * Retrieve the identifying name for this event type.
     *
     * -- intent: provide a string-based key for the event bus matching logic.
     *
     * @return string
     */
    public function getName() : string
    {
        return static::class;
    }
}

=== Foundation/Events/EventBus.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Central dispatcher for infrastructure and feature-level events.
 *
 * -- intent: facilitate decoupled communication between various database components.
 */
final class EventBus
{
    // Map of event names to their listeners
    private array $listeners = [];

    public function __construct(private readonly LoggerInterface|null $logger = null) {}

    /**
     * Dispatch an event to all registered listeners matching its type.
     *
     * -- intent: automate the broadcast of system signals to interested subscribers.
     *
     * @param Event $event The event object to propagate
     *
     * @return void
     */
    public function dispatch(Event $event) : void
    {
        $name = $event->getName();

        if (! isset($this->listeners[$name])) {
            return;
        }

        foreach ($this->listeners[$name] as $listener) {
            try {
                $listener($event);
            } catch (Throwable $e) {
                $this->logger?->error(
                    message: "Event listener failed for [{$name}]: " . $e->getMessage(),
                    context: ['exception' => $e]
                );
            }
        }
    }

    /**
     * Automatically register all handlers from a subscriber instance.
     *
     * @param EventSubscriberInterface $subscriber
     *
     * @return void
     */
    public function registerSubscriber(EventSubscriberInterface $subscriber) : void
    {
        foreach ($subscriber->getSubscribedEvents() as $event => $method) {
            $this->subscribe(event: $event, listener: [$subscriber, $method]);
        }
    }

    /**
     * Subscribe a specific callback to a named event type.
     *
     * -- intent: register a handler for specific system notifications.
     *
     * @param string   $event    Event technical name or class
     * @param callable $listener Execution logic for the event
     *
     * @return void
     */
    public function subscribe(string $event, callable $listener) : void
    {
        $this->listeners[$event][] = $listener;
    }
}

=== Foundation/Events/EventSubscriberInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * Defines the contract for external classes that wish to subscribe to multiple events.
 *
 * -- intent: enable organized, class-based handling of multiple distinct events.
 */
interface EventSubscriberInterface
{
    /**
     * Retrieve the mapping of event types to their handling methods in this class.
     *
     * -- intent: declare interest in specific system signals for automated registration.
     *
     * @return array<string, string> Map of event name to method name
     */
    public function getSubscribedEvents() : array;
}

=== Foundation/Events/QueryExecuted.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Override;

/**
 * Event signaled after a database query has been executed.
 *
 * -- intent: provide telemetry data for query performance monitoring and debugging.
 */
final readonly class QueryExecuted extends Event
{
    #[Override]
    public function __construct(
        public string $sql,
        public array  $bindings,
        public float  $timeMs,
        public string $connectionName
    ) {
        parent::__construct();
    }
}

=== Foundation/Events/Subscribers/DatabaseLoggerSubscriber.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events\Subscribers;

use Avax\Database\Events\ConnectionFailed;
use Avax\Database\Events\ConnectionOpened;
use Avax\Database\Events\EventSubscriberInterface;
use Avax\Database\Events\QueryExecuted;
use Psr\Log\LoggerInterface;

/**
 * Event subscriber for logging database operations.
 *
 * -- intent: provide centralized telemetry and debugging for all database activities.
 */
final readonly class DatabaseLoggerSubscriber implements EventSubscriberInterface
{
    /**
     * @param LoggerInterface $logger PSR-3 logger instance (injected via DI)
     */
    public function __construct(private LoggerInterface $logger) {}

    /**
     * Register event handlers for database telemetry.
     *
     * @return array<string, string>
     */
    public function getSubscribedEvents(): array
    {
        return [
            ConnectionOpened::class => 'onConnectionOpened',
            ConnectionFailed::class => 'onConnectionFailed',
            QueryExecuted::class    => 'onQueryExecuted',
        ];
    }

    /**
     * Log successful connection establishment.
     */
    public function onConnectionOpened(ConnectionOpened $event): void
    {
        $this->logger->info(message: "Database connection opened", context: [
            'connection' => $event->connectionName,
            'timestamp'  => $event->timestamp,
        ]);
    }

    /**
     * Log connection failures with full exception details.
     */
    public function onConnectionFailed(ConnectionFailed $event): void
    {
        $this->logger->error(message: "Database connection failed", context: [
            'connection' => $event->connectionName,
            'exception'  => $event->exception,
            'timestamp'  => $event->timestamp,
        ]);
    }

    /**
     * Log executed queries with performance metrics.
     */
    public function onQueryExecuted(QueryExecuted $event): void
    {
        $this->logger->debug(message: "Query executed", context: [
            'connection' => $event->connectionName,
            'sql'        => $event->sql,
            'bindings'   => $event->bindings,
            'time_ms'    => $event->timeMs,
            'timestamp'  => $event->timestamp,
        ]);
    }
}

=== Foundation/Exceptions/DatabaseException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Exceptions;

use RuntimeException;

/**
 * Base exception for all database operations.
 */
abstract class DatabaseException extends RuntimeException implements DatabaseThrowable {}



=== Foundation/Exceptions/DatabaseThrowable.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Exceptions;

use Throwable;

/**
 * Marker interface for all database-related exceptions.
 */
interface DatabaseThrowable extends Throwable {}



=== Foundation/Identity/IdentityMap.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Identity;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Avax\Database\Transaction\Exceptions\TransactionException;
use Throwable;

/**
 * Enterprise-grade technician for tracking record identities and deferring operations.
 *
 * -- intent: implement the Unit of Work pattern to optimize and batch database writes.
 */
final class IdentityMap
{
    // Collection of records retrieved and managed by this map
    private array $map = [];

    // Queue of pending database operations for deferred execution
    private array $deferred = [];

    /**
     * Constructor promoting the transaction manager dependency.
     *
     * -- intent: establish the bridge to the persistence layer for final commits.
     *
     * @param TransactionManagerInterface $transactionManager The active manager for atomic batches
     */
    public function __construct(
        private readonly TransactionManagerInterface $transactionManager,
        private readonly DatabaseConnection          $connection
    ) {}

    /**
     * Schedule a technical SQL operation for deferred execution.
     *
     * -- intent: buffer mutation queries until an explicit flush is requested.
     *
     * @param string $operation Type of operation (INSERT/UPDATE/DELETE)
     * @param string $sql       Dialect-specific SQL string
     * @param array  $bindings  Secure parameter values
     *
     * @return void
     */
    public function schedule(string $operation, string $sql, array $bindings = []) : void
    {
        $this->deferred[] = compact('operation', 'sql', 'bindings');
    }

    /**
     * Fulfill all pending operations within a single atomic batch.
     *
     * -- intent: execute all buffered mutations and clear the internal queue.
     *
     * @return void
     * @throws Throwable If any operation in the batch fails
     */
    public function execute() : void
    {
        if (empty($this->deferred)) {
            return;
        }

        $this->transactionManager->transaction(callback: function () {
            foreach ($this->deferred as $job) {
                $stmt = $this->connection->getConnection()->prepare(query: $job['sql']);
                if (! $stmt->execute(params: $job['bindings'])) {
                    throw new TransactionException(
                        message     : "Failed to execute deferred operation: " . $job['operation'],
                        nestingLevel: 0
                    );
                }
            }
        });

        $this->deferred = [];
    }
}

=== Foundation/Lifecycle/Kernel.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Registry\ModuleRegistry;
use Throwable;

/**
 * System orchestrator responsible for managing the database component lifecycle.
 *
 * -- intent: coordinate the sequential registration and booting of all feature modules.
 */
final class Kernel
{
    /**
     * Constructor promoting core foundation dependencies via PHP 8.3 features.
     *
     * -- intent: link the container and registry for cross-component orchestration.
     *
     * @param Container      $container Central dependency injection vessel
     * @param ModuleRegistry $registry  Authority for module registration and status
     */
    public function __construct(
        private readonly Container      $container,
        private readonly ModuleRegistry $registry
    ) {}

    /**
     * Initiate the component boot sequence for all active modules.
     *
     * -- intent: transform all registered feature metadata into operational services.
     *
     * @return void
     * @throws Throwable If module registration or booting fails
     */
    public function boot() : void
    {
        $modules = Manifest::getModules();

        foreach ($modules as $name => $class) {
            $this->registry->register(name: $name, class: $class, container: $this->container);
        }

        $this->registry->boot();
    }

    /**
     * Execute the graceful shutdown routine for all initialized features.
     *
     * -- intent: ensure all active modules release their resources before system termination.
     *
     * @return void
     */
    public function shutdown() : void
    {
        $this->registry->shutdown();
    }
}

=== Foundation/Lifecycle/LifecycleInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

/**
 * Defines the contract for high-level component lifecycle management.
 *
 * -- intent: ensure all database features follow a predictable registration and boot cycle.
 */
interface LifecycleInterface
{
    /**
     * Register the component and its services into the system container.
     *
     * -- intent: declare service recipes and bindings before the system starts.
     *
     * @return void
     */
    public function register() : void;

    /**
     * Perform bootstrap operations after all system components are ready.
     *
     * -- intent: initialize internal state or dependencies that require a fully-registered container.
     *
     * @return void
     */
    public function boot() : void;

    /**
     * Gracefully terminate the component and release active resources.
     *
     * -- intent: clean up persistent connections, file handles, or caches.
     *
     * @return void
     */
    public function shutdown() : void;
}

=== Foundation/Lifecycle/Manifest.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

use Avax\Migrations\Module;

/**
 * Central discovery point for database feature modules.
 */
final class Manifest
{
    /**
     * Retrieve the map of active feature modules.
     *
     * @return array<string, string>
     */
    public static function getModules() : array
    {
        $potentialModules = [
            \Avax\Database\Transaction\Module::class,
            \Avax\Database\QueryBuilder\Module::class,
            Module::class,
        ];

        $registry = [];
        foreach ($potentialModules as $class) {
            if (class_exists(class: $class) && method_exists(object_or_class: $class, method: 'declare')) {
                $declaration                    = $class::declare();
                $registry[$declaration['name']] = $declaration['class'];
            }
        }

        return $registry;
    }
}

=== Foundation/Query/ColumnIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Pragmatic value object representing a database column with optional alias.
 *
 * -- intent: transport column identification metadata across the builder layers.
 */
final readonly class ColumnIdentifier
{
    /**
     * Constructor promoting immutable properties via PHP 8.3 features.
     *
     * -- intent: ensure data integrity for the column identifier.
     *
     * @param string      $name  Technical column identifier
     * @param string|null $alias Optional domain-specific alias
     */
    public function __construct(
        public string      $name,
        public string|null $alias = null
    ) {}

    /**
     * Convert the identifier into a displayable string format.
     *
     * -- intent: simplify SQL concatenation via stringable interface.
     *
     * @return string
     */
    public function __toString() : string
    {
        if ($this->alias === null) {
            return $this->name;
        }

        // alias
        return "{$this->name} AS {$this->alias}";
    }
}



=== Foundation/Query/Condition.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Pragmatic value object encapsulating a single SQL WHERE constraint.
 *
 * -- intent: transport logical comparison criteria to the SQL grammar engine.
 */
final readonly class Condition
{
    /**
     * Constructor promoting immutable criteria properties via PHP 8.3 features.
     *
     * -- intent: capture the full state of a logical query filter.
     *
     * @param string $column   Technical column identifier
     * @param string $operator Logical comparison operator (=, <, >, etc)
     * @param mixed  $value    Comparison target value
     * @param string $boolean  Logical joiner (AND/OR)
     */
    public function __construct(
        public string $column,
        public string $operator,
        public mixed  $value,
        public string $boolean = 'AND'
    ) {}
}



=== Foundation/Query/PaginationOptions.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Pragmatic value object encapsulating pagination parameters for large datasets.
 *
 * -- intent: provide a structured way to handle record offsets and limits.
 */
final readonly class PaginationOptions
{
    /**
     * Constructor promoting pagination settings via PHP 8.3 features.
     *
     * -- intent: define the current window of the result set.
     *
     * @param int      $page    Current page index (1-based)
     * @param int      $perPage Number of records per resulting page
     * @param int|null $total   Optional total record count for metadata calculation
     */
    public function __construct(
        public int      $page = 1,
        public int      $perPage = 15,
        public int|null $total = null
    ) {}

    /**
     * Calculate the technical offset value for SQL retrieval.
     *
     * -- intent: transform logical page number into physical SQL offset.
     *
     * @return int
     */
    public function getOffset() : int
    {
        return ($this->page - 1) * $this->perPage;
    }
}



=== Foundation/Query/QueryState.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * High-performance state container for builder metadata.
 *
 * -- intent: accumulate all query-building steps before final SQL compilation.
 */
final class QueryState
{
    /**
     * List of technical columns to retrieve.
     */
    public array $columns = ['*'];

    /**
     * Target database table name.
     */
    public string|null $from = null;

    /**
     * Relational join definitions.
     */
    public array $joins = [];

    /**
     * Logical filter constraints (WHERE).
     */
    public array $wheres = [];

    /**
     * Aggregation groups (GROUP BY).
     */
    public array $groups = [];

    /**
     * Aggregate filters (HAVING).
     */
    public array $havings = [];

    /**
     * Sorting rules (ORDER BY).
     */
    public array $orders = [];

    /**
     * Record retrieval limit.
     */
    public int|null $limit = null;

    /**
     * Record retrieval offset.
     */
    public int|null $offset = null;

    /**
     * Data mutation values (INSERT/UPDATE).
     */
    public array $values = [];

    /**
     * Mutation columns (UPSERT).
     */
    public array $updateColumns = [];

    /**
     * Whether to retrieve distinct records.
     */
    public bool $distinct = false;

    /**
     * Internal parameter bindings for PDO.
     */
    private array $bindings = [];

    /**
     * Register a new value for secure parameter binding.
     *
     * -- intent: ensure all user-provided data is handled via PDO placeholders.
     *
     * @param mixed $value Raw input data
     *
     * @return void
     */
    public function addBinding(mixed $value) : void
    {
        $this->bindings[] = $value;
    }

    /**
     * Retrieve the collection of registered bindings.
     *
     * -- intent: provide the executor with sanitized values.
     *
     * @return array
     */
    public function getBindings() : array
    {
        return $this->bindings;
    }

    /**
     * Purge the active binding registry.
     *
     * -- intent: reset parameters for multiple compilation passes.
     *
     * @return void
     */
    public function resetBindings() : void
    {
        $this->bindings = [];
    }
}



=== Foundation/Query/QuotedIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Value object representing a database identifier that has already been quoted.
 *
 * -- intent: optimize compilation by flagging identifiers that bypass the quoting technician.
 */
final readonly class QuotedIdentifier
{
    /**
     * Constructor with promoted technical name via PHP 8.3.
     *
     * -- intent: capture the raw quoted string.
     *
     * @param string $value The already quoted identifier string
     */
    public function __construct(public string $value) {}

    /**
     * Handle direct string conversion for SQL concatenation.
     *
     * -- intent: simplify SQL integration through string casting.
     *
     * @return string
     */
    public function __toString() : string
    {
        return $this->value;
    }
}



=== Foundation/Query/TableIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Pragmatic value object representing a database table with an optional alias.
 *
 * -- intent: transport table identification metadata across the builder layers.
 */
final readonly class TableIdentifier
{
    /**
     * Constructor promoting immutable properties via PHP 8.3 features.
     *
     * -- intent: ensure data integrity for the table identifier.
     *
     * @param string      $name  Technical table identifier
     * @param string|null $alias Optional domain-specific alias (e.g. for joins)
     */
    public function __construct(
        public string      $name,
        public string|null $alias = null
    ) {}

    /**
     * Convert the table identifier into its SQL representation.
     *
     * -- intent: simplify SQL concatenation for table targeting.
     *
     * @return string
     */
    public function __toString() : string
    {
        if ($this->alias === null) {
            return $this->name;
        }

        return "{$this->name} AS {$this->alias}";
    }
}



=== Foundation/Registry/Exceptions/ModuleException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Registry\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * Triggered during failures in the module registration or lifecycle sequence.
 *
 * -- intent: provide specific context for broken feature module initialization.
 */
final class ModuleException extends DatabaseException
{
    /**
     * Constructor capturing the module class and lifecycle stage.
     *
     * -- intent: pinpoint exactly which module and phase failed during boot.
     *
     * @param string         $moduleClass Fully qualified class name of the module
     * @param string         $phase       Registration phase (register/boot/shutdown)
     * @param string         $message     Detailed failure description
     * @param Throwable|null $previous    Underlying trigger
     */
    #[Override]
    public function __construct(
        private readonly string $moduleClass,
        private readonly string $phase,
        string                  $message,
        Throwable|null          $previous = null
    )
    {
        parent::__construct(
            message : "Module [{$moduleClass}] failed during [{$phase}]: {$message}",
            code    : 0,
            previous: $previous
        );
    }

    /**
     * Retrieve the failing module's class name.
     *
     * -- intent: identify the problematic feature component.
     *
     * @return string
     */
    public function getModuleClass() : string
    {
        return $this->moduleClass;
    }

    /**
     * Retrieve the lifecycle phase where the failure occurred.
     *
     * -- intent: help developers understand if the failure was in configuration or execution.
     *
     * @return string
     */
    public function getPhase() : string
    {
        return $this->phase;
    }
}



=== Foundation/Registry/ModuleRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Registry;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\Registry\Exceptions\ModuleException;
use Throwable;

/**
 * Technical authority responsible for managing the registration and status of all modules.
 *
 * -- intent: maintain a central Map of active features and coordinate their lifecycle events.
 */
final class ModuleRegistry
{
    /**
     * Storage for instantiated and registered module objects.
     */
    private array $modules = [];

    /**
     * Tracks which modules have successfully passed the boot sequence.
     */
    private array $booted = [];

    /**
     * Register a new feature module into the internal and system containers.
     *
     * -- intent: instantiate the module and trigger its internal service definitions.
     *
     * @param string    $name      Logical identifier for the feature
     * @param string    $class     Fully qualified module class name
     * @param Container $container The target DI vessel
     *
     * @return void
     * @throws ModuleException If the module class is invalid or missing
     */
    public function register(string $name, string $class, Container $container) : void
    {
        if (! class_exists(class: $class)) {
            throw new ModuleException(moduleClass: $class, phase: 'registration', message: "Module class not found.");
        }

        try {
            $module = new $class(container: $container);

            if (! $module instanceof LifecycleInterface) {
                throw new ModuleException(
                    moduleClass: $class,
                    phase      : 'registration',
                    message    : "Module must implement LifecycleInterface."
                );
            }

            $module->register();
            $this->modules[$name] = $module;
        } catch (Throwable $e) {
            throw new ModuleException(
                moduleClass: $class,
                phase      : 'registration',
                message    : $e->getMessage(),
                previous   : $e
            );
        }
    }

    /**
     * Initiate the boot sequence for all registered and non-booted modules.
     *
     * -- intent: ensure every active feature is fully operational after registration.
     *
     * @return void
     * @throws ModuleException If any module fails to boot
     */
    public function boot() : void
    {
        foreach ($this->modules as $name => $module) {
            if (! isset($this->booted[$name])) {
                try {
                    $module->boot();
                    $this->booted[$name] = true;
                } catch (Throwable $e) {
                    throw new ModuleException(
                        moduleClass: $module::class,
                        phase      : 'boot',
                        message    : $e->getMessage(),
                        previous   : $e
                    );
                }
            }
        }
    }

    /**
     * Execute the graceful shutdown routine for all initialized modules.
     *
     * -- intent: trigger resource cleanup across all active features in the registry.
     *
     * @return void
     * @throws ModuleException If any module fails during shutdown
     */
    public function shutdown() : void
    {
        foreach ($this->modules as $module) {
            try {
                $module->shutdown();
            } catch (Throwable $e) {
                throw new ModuleException(
                    moduleClass: $module::class,
                    phase      : 'shutdown',
                    message    : $e->getMessage(),
                    previous   : $e
                );
            }
        }

        $this->modules = [];
        $this->booted  = [];
    }

    /**
     * Retrieve an active module instance by its technical name.
     *
     * -- intent: provide direct access to specific feature controllers.
     *
     * @param string $name Technical name of the feature
     *
     * @return LifecycleInterface
     * @throws ModuleException If the feature is not found in the registry
     */
    public function getModule(string $name) : LifecycleInterface
    {
        if (! isset($this->modules[$name])) {
            throw new ModuleException(moduleClass: $name, phase: 'retrieval', message: "Module not registered.");
        }

        return $this->modules[$name];
    }
}

=== Foundation/Transaction/Contracts/TransactionManagerInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction\Contracts;

use Throwable;

/**
 * Defines the essential contract for coordinating atomic database transactions.
 *
 * -- intent: provide a standard API for starting, committing, and rolling back operations.
 */
interface TransactionManagerInterface
{
    /**
     * Execute a domain closure within a managed database transaction.
     *
     * -- intent: provide automatic atomicity and rollback for the provided logic.
     *
     * @param callable $callback The unit of work to execute
     *
     * @return mixed
     * @throws Throwable If the operation fails after multiple attempts
     */
    public function transaction(callable $callback) : mixed;

    /**
     * Physically begin a new transaction on the database driver.
     *
     * -- intent: signal the start of a protected sequence of operations.
     *
     * @return void
     */
    public function begin() : void;

    /**
     * Permanently persist all changes made within the current transaction.
     *
     * -- intent: finalize the atomic sequence and commit data to storage.
     *
     * @return void
     */
    public function commit() : void;

    /**
     * Revert all changes made during the active transaction.
     *
     * -- intent: protect data integrity by discarding failed or partial operations.
     *
     * @return void
     */
    public function rollback() : void;
}

=== Foundation/Transaction/Exceptions/TransactionException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * Exception thrown when a transaction-level operation fails.
 */
final class TransactionException extends DatabaseException
{
    /**
     * Constructor capturing the failure context and nesting level.
     *
     * -- intent: store technical details about the failed unit of work.
     *
     * @param string         $message      Technical description of the transaction failure
     * @param int            $nestingLevel The transaction depth when the failure occurred
     * @param Throwable|null $previous     Underlying driver or callback error
     */
    #[Override]
    public function __construct(
        string               $message,
        private readonly int $nestingLevel,
        Throwable|null       $previous = null
    )
    {
        parent::__construct(
            message : "Transaction failed (Level {$nestingLevel}): {$message}",
            code    : 0,
            previous: $previous
        );
    }

    /**
     * Retrieve the transaction nesting depth at the time of failure.
     *
     * -- intent: help diagnose complex nested transaction issues.
     *
     * @return int
     */
    public function getNestingLevel() : int
    {
        return $this->nestingLevel;
    }
}

=== Foundation/Transaction/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;

/**
 * Functional module responsible for the Transaction management feature.
 *
 * -- intent: enable atomic database operations through service registration and orchestration.
 */
final readonly class Module implements LifecycleInterface
{
    /**
     * Constructor promoting the foundation container via PHP 8.3 features.
     *
     * -- intent: link the module to the central dependency injection system.
     *
     * @param Container $container The active DI vessel
     */
    public function __construct(private Container $container) {}

    /**
     * Declare the module metadata for self-registration.
     */
    public static function declare() : array
    {
        return [
            'name'  => 'transaction',
            'class' => self::class
        ];
    }

    /**
     * Register Transaction services into the foundation container.
     *
     * -- intent: define the resolution recipes for atomic operation managers.
     *
     * @return void
     */
    public function register() : void
    {
        $this->container->singleton(abstract: TransactionManagerInterface::class, concrete: static function ($c) {
            return new TransactionRunner(connection: $c->get(id: DatabaseConnection::class));
        });
    }

    /**
     * Perform initialization logic for the transaction feature.
     *
     * -- intent: ensure the feature is ready for use after registration.
     *
     * @return void
     */
    public function boot() : void
    {
        // No additional boot logic required for transactions
    }

    /**
     * Gracefully terminate the transaction feature resources.
     *
     * -- intent: ensure no dangling transactions remain before system shutdown.
     *
     * @return void
     */
    public function shutdown() : void
    {
        // Internal clean-up logic if required
    }
}

=== Foundation/Transaction/TransactionRunner.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Avax\Database\Transaction\Exceptions\TransactionException;
use Throwable;

/**
 * Standard implementation of the transaction manager contract.
 */
class TransactionRunner implements TransactionManagerInterface
{
    /**
     * Tracks the current transaction nesting level.
     */
    private int $transactions = 0;

    /**
     * Initialize transaction runner with database connection.
     *
     * @param DatabaseConnection $connection Authority for database connections
     */
    public function __construct(
        private readonly DatabaseConnection $connection
    ) {}

    /**
     * Orchestrate the execution of a closure within a secured transaction block.
     *
     * -- intent: provide a robust wrapper for safe data mutations with automatic rollback.
     *
     * @param callable $callback Operational logic
     *
     * @return mixed
     * @throws TransactionException If the transaction fails and cannot be recovered
     */
    public function transaction(callable $callback) : mixed
    {
        $this->begin();

        try {
            $result = $callback($this);
            $this->commit();

            return $result;
        } catch (Throwable $e) {
            try {
                $this->rollback();
            } catch (Throwable) {
                // Prevent rollback error from masking the primary exception
            }

            if ($e instanceof TransactionException) {
                throw $e;
            }

            throw new TransactionException(
                message     : "Callback execution failed: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous    : $e
            );
        }
    }

    /**
     * Physically signal the start of a transaction to the database engine.
     *
     * -- intent: increment nesting state and dispatch BEGIN command to the driver.
     *
     * @return void
     * @throws TransactionException If driver fails to begin transaction
     */
    public function begin() : void
    {
        try {
            if ($this->transactions === 0) {
                $this->connection->getConnection()->beginTransaction();
            }

            $this->transactions++;
        } catch (Throwable $e) {
            throw new TransactionException(
                message     : "Failed to begin transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous    : $e
            );
        }
    }

    /**
     * Dispatch a COMMIT signal if the nesting level is at the absolute root.
     *
     * -- intent: finalize the transaction and update the nesting level.
     *
     * @return void
     * @throws TransactionException If driver fails to commit
     */
    public function commit() : void
    {
        try {
            if ($this->transactions === 1) {
                $this->connection->getConnection()->commit();
            }

            $this->transactions = max(0, $this->transactions - 1);
        } catch (Throwable $e) {
            throw new TransactionException(
                message     : "Failed to commit transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous    : $e
            );
        }
    }

    /**
     * Dispatch a ROLLBACK signal and reset the internal transaction state.
     *
     * -- intent: fulfill safe recovery by instructing the driver to discard active changes.
     *
     * @return void
     * @throws TransactionException If driver fails to rollback
     */
    public function rollback() : void
    {
        try {
            if ($this->transactions === 1) {
                $this->connection->getConnection()->rollBack();
            }

            $this->transactions = max(0, $this->transactions - 1);
        } catch (Throwable $e) {
            $this->transactions = 0;
            throw new TransactionException(
                message     : "Failed to rollback transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous    : $e
            );
        }
    }

    /**
     * Create a named savepoint within the current transaction.
     *
     * -- intent: enable partial rollback capability for nested operations.
     *
     * @param string $name Savepoint identifier
     *
     * @return void
     * @throws TransactionException If savepoint creation fails
     */
    public function savepoint(string $name) : void
    {
        $this->connection->getConnection()->exec(statement: "SAVEPOINT {$name}");
    }

    /**
     * Rollback to a previously created savepoint.
     *
     * -- intent: recover from errors within a transaction without full rollback.
     *
     * @param string $name Savepoint identifier
     *
     * @return void
     * @throws TransactionException If rollback to savepoint fails
     */
    public function rollbackTo(string $name) : void
    {
        $this->connection->getConnection()->exec(statement: "ROLLBACK TO {$name}");
    }
}

=== Foundation/Transaction/TransactionScope.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Throwable;

/**
 * Technical value object for managing the lifetime of a specific transaction block.
 *
 * -- intent: implement the Dispose pattern for automatic transaction finalization.
 */
final readonly class TransactionScope
{
    /**
     * Constructor promoting the transaction manager dependency.
     *
     * -- intent: capture the active manager and start a new transaction sequence.
     *
     * @param TransactionManagerInterface $manager The active technician for atomicity
     */
    public function __construct(private TransactionManagerInterface $manager)
    {
        $this->manager->begin();
    }

    /**
     * Destructor ensuring the transaction is closed if not manually committed.
     *
     * -- intent: safeguard data integrity by rolling back dangling transactions.
     */
    public function __destruct()
    {
        try {
            $this->manager->rollback();
        } catch (Throwable) {
            // Suppress secondary failures during destruction
        }
    }

    /**
     * Manually finalize and commit the changes in this scope.
     *
     * -- intent: signal the successful completion of the scoped work.
     *
     * @return void
     */
    public function complete() : void
    {
        $this->manager->commit();
    }
}



=== Migrations/Design/Column/DSL/ColumnDefinition.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Column\DSL;

/**
 * Functional technician for defining a database column's technical properties.
 *
 * -- intent: provide a domain-fluent DSL for structural column design.
 */
class ColumnDefinition
{
    /**
     * Constructor initializing the base technical identifiers via PHP 8.3 features.
     *
     * -- intent: capture the name and technical type of the column.
     *
     * @param string $name       Technical name of the column
     * @param string $type       Database-specific data type
     * @param array  $attributes Collection of column modifiers (nullable, default, etc)
     */
    public function __construct(
        public readonly string $name,
        public readonly string $type,
        public array           $attributes = []
    ) {}

    /**
     * Mark the column as allowing NULL values.
     *
     * -- intent: provide a pragmatic shorthand for the NULL attribute.
     *
     * @param bool $value Whether null is allowed
     *
     * @return $this
     */
    public function nullable(bool $value = true) : self
    {
        $this->attributes['nullable'] = $value;

        return $this;
    }

    /**
     * Define a default value for the column.
     *
     * -- intent: provide a pragmatic shorthand for the DEFAULT attribute.
     *
     * @param mixed $value Fallback data value
     *
     * @return $this
     */
    public function default(mixed $value) : self
    {
        $this->attributes['default'] = $value;

        return $this;
    }

    /**
     * Mark the column as an automatically incrementing primary key.
     *
     * -- intent: provide a domain-specific shorthand for identity columns.
     *
     * @return $this
     */
    public function autoIncrement() : self
    {
        $this->attributes['auto_increment'] = true;

        return $this;
    }

    /**
     * Attach a technical comment to the database column.
     *
     * -- intent: facilitate database self-documentation via column comments.
     *
     * @param string $text Explanatory description
     *
     * @return $this
     */
    public function comment(string $text) : self
    {
        $this->attributes['comment'] = $text;

        return $this;
    }
}

=== Migrations/Design/Column/Renderer/ColumnSQLRenderer.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Column\Renderer;

use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Migrations\Design\Column\DSL\ColumnDefinition;

/**
 * Professional technician for translating column definitions into SQL fragments.
 *
 * -- intent: centralize the transformation logic from DSL attributes to dialect SQL.
 */
final class ColumnSQLRenderer
{
    /**
     * Transform a ColumnDefinition into a cohesive SQL string portion.
     *
     * -- intent: coordinate the rendering of name, type, and all active modifiers.
     *
     * @param ColumnDefinition $column  The design metadata
     * @param GrammarInterface $grammar The dialect technician for wrapping
     *
     * @return string
     */
    public function render(ColumnDefinition $column, GrammarInterface $grammar) : string
    {
        $sql = $grammar->wrap(value: $column->name) . ' ' . $column->type;

        if (isset($column->attributes['nullable']) && $column->attributes['nullable'] === false) {
            $sql .= ' NOT NULL';
        }

        if (isset($column->attributes['auto_increment'])) {
            $sql .= ' AUTO_INCREMENT PRIMARY KEY';
        }

        if (array_key_exists(key: 'default', array: $column->attributes)) {
            $sql .= ' DEFAULT ' . $this->formatDefault(value: $column->attributes['default']);
        }

        return $sql;
    }

    /**
     * Normalize default values for SQL concatenation.
     *
     * -- intent: ensure that data types are appropriately quoted or handled as keywords.
     *
     * @param mixed $value Raw data value
     *
     * @return string
     */
    private function formatDefault(mixed $value) : string
    {
        if (is_string(value: $value)) {
            return "'{$value}'";
        }

        if (is_bool(value: $value)) {
            return $value ? '1' : '0';
        }

        if ($value === null) {
            return 'NULL';
        }

        return (string) $value;
    }
}

=== Migrations/Design/Table/Blueprint.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Table;

use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Migrations\Design\Column\DSL\ColumnDefinition;
use Avax\Migrations\Design\Column\Renderer\ColumnSQLRenderer;

/**
 * Enterprise-grade designer for defining database table structures.
 *
 * -- intent: provide a collection-based DSL for managing multiple column definitions.
 */
final class Blueprint
{
    // Storage for the column design objects
    private array $columns = [];

    /**
     * Constructor promoting the target table name via PHP 8.3 features.
     *
     * -- intent: capture the identifier for the table being designed.
     *
     * @param string $table Technical table name
     */
    public function __construct(
        private readonly string $table
    ) {}

    /**
     * Add a high-performance auto-incrementing primary key ID.
     *
     * -- intent: provide a pragmatic shorthand for the standard 'id' column.
     *
     * @param string $name Technical name, defaults to 'id'
     *
     * @return ColumnDefinition
     */
    public function id(string $name = 'id') : ColumnDefinition
    {
        return $this->addColumn(type: 'BIGINT', name: $name)->autoIncrement();
    }

    /**
     * Internal technician for registering a new column design.
     *
     * -- intent: centralize column object instantiation and storage.
     *
     * @param string $type Technical database type
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    private function addColumn(string $type, string $name) : ColumnDefinition
    {
        $column          = new ColumnDefinition(name: $name, type: $type);
        $this->columns[] = $column;

        return $column;
    }

    /**
     * Add a variable-length string column.
     *
     * -- intent: provide a pragmatic shorthand for VARCHAR columns.
     *
     * @param string $name   Technical name
     * @param int    $length Maximum character capacity
     *
     * @return ColumnDefinition
     */
    public function string(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "VARCHAR({$length})", name: $name);
    }

    /**
     * Add basic created_at and updated_at timestamp columns.
     *
     * -- intent: provide a domain-specific shorthand for audit record-keeping.
     *
     * @return void
     */
    public function timestamps() : void
    {
        $this->addColumn(type: 'TIMESTAMP', name: 'created_at')->nullable();
        $this->addColumn(type: 'TIMESTAMP', name: 'updated_at')->nullable();
    }

    /**
     * Translate the blueprint design into a collection of physical SQL statements.
     *
     * -- intent: coordinate the rendering of all designed columns into a CREATE TABLE command.
     *
     * @param GrammarInterface $grammar The dialect technician for wrapping and syntax
     *
     * @return array<string> List of SQL statements to execute
     */
    public function toSql(GrammarInterface $grammar) : array
    {
        $renderer = new ColumnSQLRenderer();
        $columns  = array_map(
            callback: fn (ColumnDefinition $col) => $renderer->render(column: $col, grammar: $grammar),
            array   : $this->columns
        );

        $sql = "CREATE TABLE " . $grammar->wrap(value: $this->table) . " (";
        $sql .= implode(separator: ', ', array: $columns);
        $sql .= ")";

        return [$sql];
    }
}

=== Migrations/Design/Table/TableDefinition.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Table;

/**
 * Technical value object representing the metadata of a database table.
 *
 * -- intent: transport structural table identifiers across the migration system.
 */
final readonly class TableDefinition
{
    /**
     * Constructor promoting the immutable table name via PHP 8.3 features.
     *
     * -- intent: capture the technical identity of a database table.
     *
     * @param string $name Technical table identifier
     */
    public function __construct(
        public string $name
    ) {}
}

=== Migrations/Exceptions/MigrationException.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * Triggered during failures in the migration runner or structural execution.
 *
 * -- intent: provide specific diagnostic context for broken schema changes.
 */
final class MigrationException extends DatabaseException
{
    /**
     * Constructor capturing the migration class and technical SQL.
     *
     * -- intent: link the failure to the specific migration file and query.
     *
     * @param string         $migrationClass Technical class name of the migration
     * @param string         $message        Detailed failure description
     * @param string|null    $sql            The specific SQL statement that failed
     * @param Throwable|null $previous       Underlying system trigger
     */
    #[Override]
    public function __construct(
        private readonly string      $migrationClass,
        string                       $message,
        private readonly string|null $sql = null,
        Throwable|null               $previous = null
    )
    {
        parent::__construct(message: "Migration [{$migrationClass}] failed: {$message}", code: 0, previous: $previous);
    }

    /**
     * Retrieve the problematic migration's class name.
     *
     * -- intent: identify the broken migration script.
     *
     * @return string
     */
    public function getMigrationClass() : string
    {
        return $this->migrationClass;
    }

    /**
     * Retrieve the SQL statement that caused the structural failure.
     *
     * -- intent: facilitate manual correction of the schema.
     *
     * @return string|null
     */
    public function getSql() : string|null
    {
        return $this->sql;
    }
}



=== Migrations/Migration.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;

/**
 * Technical contract for all database migration implementations.
 *
 * -- intent: define the structural lifecycle (Up/Down) for database changes.
 */
interface Migration
{
    /**
     * Apply the structural database modifications described in the migration.
     *
     * -- intent: advance the database schema to the next version.
     *
     * @param QueryBuilder $builder The active technician for schema manipulation
     *
     * @return void
     */
    public function up(QueryBuilder $builder) : void;

    /**
     * Revert the structural database modifications applied by the 'up' method.
     *
     * -- intent: return the database schema to its previous version.
     *
     * @param QueryBuilder $builder The active technician for schema manipulation
     *
     * @return void
     */
    public function down(QueryBuilder $builder) : void;
}

=== Migrations/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Migrations\Runner\MigrationRunner;
use Avax\Migrations\Services\MigrationRepository;

/**
 * Functional module responsible for the database Migration feature.
 *
 * -- intent: coordinate the registration of migration repositories and runners.
 */
final readonly class Module implements LifecycleInterface
{
    /**
     * Constructor promoting the foundation container via PHP 8.3 features.
     *
     * -- intent: link the module to the central dependency injection system.
     *
     * @param Container $container The active DI vessel
     */
    public function __construct(
        private Container $container
    ) {}

    public static function declare() : array
    {
        return [
            'name'  => 'migrations',
            'class' => self::class
        ];
    }

    /**
     * Register Migration services into the foundation container.
     *
     * -- intent: define the resolution recipes for migration persistence and execution technicians.
     *
     * @return void
     */
    public function register() : void
    {
        $this->container->singleton(abstract: MigrationRepository::class, concrete: function ($c) {
            return new MigrationRepository(builder: $c->get(id: QueryBuilder::class));
        });

        $this->container->singleton(abstract: MigrationRunner::class, concrete: function ($c) {
            return new MigrationRunner(
                repository: $c->get(id: MigrationRepository::class),
                builder   : $c->get(id: QueryBuilder::class)
            );
        });
    }

    /**
     * Perform initialization logic for the migration feature.
     *
     * -- intent: ensure the feature is ready for use after registration.
     *
     * @return void
     */
    public function boot() : void
    {
        // No additional boot logic required for migrations
    }

    /**
     * Gracefully terminate the migration feature resources.
     *
     * -- intent: signal the end of the migration feature availability.
     *
     * @return void
     */
    public function shutdown() : void
    {
        // Shutdown logic if required
    }
}

=== Migrations/Runner/MigrationRunner.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Runner;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Migrations\Exceptions\MigrationException;
use Avax\Migrations\Migration;
use Avax\Migrations\Services\MigrationRepository;
use Throwable;

/**
 * Technical supervisor responsible for the execution lifecycle of migrations.
 *
 * -- intent: coordinate the UP/DOWN operations of migrations and update the system audit trail.
 */
final readonly class MigrationRunner
{
    /**
     * Constructor promoting dependencies via PHP 8.3 features.
     *
     * -- intent: link the runner to the repository and the query builder.
     *
     * @param MigrationRepository $repository The authority for migration status and history
     * @param QueryBuilder        $builder    The technician for physical SQL execution
     */
    public function __construct(
        private MigrationRepository $repository,
        private QueryBuilder        $builder
    ) {}

    /**
     * Advance the database state by running multiple pending migrations.
     *
     * -- intent: identify missing structural changes and apply them in a logical batch.
     *
     * @param array<Migration> $migrations Collection of migration instances
     *
     * @return void
     * @throws MigrationException If any migration in the batch fails
     */
    public function up(array $migrations) : void
    {
        try {
            $ran   = $this->repository->getRan();
            $batch = $this->repository->getNextBatchNumber();

            foreach ($migrations as $migration) {
                $name = $migration::class;

                if (in_array(needle: $name, haystack: $ran)) {
                    continue;
                }

                $this->runMigration(migration: $migration, method: 'up', batch: $batch);
            }
        } catch (Throwable $e) {
            throw new MigrationException(migrationClass: 'Runner', message: $e->getMessage(), previous: $e);
        }
    }

    /**
     * Orchestrate the individual execution of a migration method within a transaction.
     *
     * -- intent: ensure migration logic is applied atomically and recorded in the audit log.
     *
     * @param Migration $migration The target migration instance
     * @param string    $method    The lifecycle method to trigger (up/down)
     * @param int|null  $batch     The batch grouping identifier
     *
     * @return void
     * @throws MigrationException If operation or logging fails
     */
    private function runMigration(Migration $migration, string $method, int|null $batch = null) : void
    {
        try {
            $this->builder->transaction(callback: function () use ($migration, $method, $batch) {
                $migration->{$method}($this->builder);

                if ($method === 'up') {
                    $this->repository->log(name: $migration::class, batch: (int) $batch);
                } else {
                    $this->repository->remove(name: $migration::class);
                }
            });
        } catch (Throwable $e) {
            throw new MigrationException(
                migrationClass: $migration::class,
                message       : "Failed during [{$method}]: " . $e->getMessage(),
                previous      : $e
            );
        }
    }

    /**
     * Revert the database state by rolling back a specific number of batches.
     *
     * -- intent: safely undo structural changes in reverse chronological order.
     *
     * @param array<Migration> $migrations All available migration instances
     * @param int              $steps      Number of batches to revert
     *
     * @return void
     * @throws MigrationException If rollback fails
     */
    public function rollback(array $migrations, int $steps = 1) : void
    {
        try {
            $migrationsByName = [];
            foreach ($migrations as $m) {
                $migrationsByName[$m::class] = $m;
            }

            $records = $this->repository->getLastBatch(steps: $steps);

            foreach ($records as $record) {
                $name = $record['migration'];

                if (isset($migrationsByName[$name])) {
                    $this->runMigration(migration: $migrationsByName[$name], method: 'down');
                }
            }
        } catch (Throwable $e) {
            throw new MigrationException(migrationClass: 'Runner', message: $e->getMessage(), previous: $e);
        }
    }
}

=== Migrations/Services/MigrationRepository.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Services;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Technical authority for the 'migrations' table auditing and record management.
 *
 * -- intent: centralize persistence and retrieval of migration execution history.
 */
final class MigrationRepository
{
    // The technical name of the migration audit table
    private string $table = 'migrations';

    /**
     * Constructor promoting the query builder technician.
     *
     * -- intent: capture the builder for interacting with the audit table.
     *
     * @param QueryBuilder $builder The active SQL orchestrator
     */
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    /**
     * Retrieve the identifying names of all migrations that have already been ran.
     *
     * -- intent: provide a delta-check to prevent duplicate migration execution.
     *
     * @return array<string>
     * @throws Throwable If audit table retrieval fails
     */
    public function getRan() : array
    {
        return array_column(
            array     : $this->builder->from(table: $this->table)->select(columns: 'migration')->get(),
            column_key: 'migration'
        );
    }

    /**
     * Retrieve the execution records for the most recent migration batches.
     *
     * -- intent: support rollback operations by identifying the latest structural changes.
     *
     * @param int $steps Number of prior batches to retrieve
     *
     * @return array
     * @throws Throwable If retrieval fails
     */
    public function getLastBatch(int $steps = 1) : array
    {
        $maxBatch = (int) $this->builder->from(table: $this->table)->max(column: 'batch');
        $minBatch = max(0, $maxBatch - $steps + 1);

        return $this->builder->from(table: $this->table)
            ->where(column: 'batch', operator: '>=', value: $minBatch)
            ->orderBy(column: 'batch', direction: 'DESC')
            ->orderBy(column: 'migration', direction: 'DESC')
            ->get();
    }

    /**
     * Calculate the technical batch identifier for the next sequence of migrations.
     *
     * -- intent: group concurrent migrations under a single logical batch number.
     *
     * @return int
     * @throws Throwable If max calculation fails
     */
    public function getNextBatchNumber() : int
    {
        return (int) $this->builder->from(table: $this->table)->max(column: 'batch') + 1;
    }

    /**
     * Persist an execution record for a successfully ran migration.
     *
     * -- intent: update the audit trail used for future structural state resolution.
     *
     * @param string $name  Technical migration class name
     * @param int    $batch Associated batch identifier
     *
     * @return void
     * @throws Throwable If record persistence fails
     */
    public function log(string $name, int $batch) : void
    {
        $this->builder->from(table: $this->table)->insert(values: [
                                                                      'migration' => $name,
                                                                      'batch'     => $batch
                                                                  ]);
    }

    /**
     * Remove an execution record during a rollback operation.
     *
     * -- intent: synchronize the audit trail with the reverted structural state.
     *
     * @param string $name Technical migration identifier
     *
     * @return void
     * @throws Throwable If record removal fails
     */
    public function remove(string $name) : void
    {
        $this->builder->from(table: $this->table)->where(column: 'migration', value: $name)->delete();
    }

    /**
     * Ensure the internal audit table exists and is technically sound.
     *
     * -- intent: automate the first-time setup of the migration record infrastructure.
     *
     * @return void
     * @throws Throwable If structural creation fails
     */
    public function createRepository() : void
    {
        $this->builder->create(table: $this->table, callback: function ($table) {
            $table->id();
            $table->string(name: 'migration');
            $table->integer(name: 'batch');
        });
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasAdvancedMutations.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Throwable;

/**
 * Trait HasAdvancedMutations
 *
 * -- intent: extend the query builder with complex data modification capabilities like Upsert and Increment.
 */
trait HasAdvancedMutations
{
    /**
     * Perform an "Upsert" operation: insert new records or update existing ones on conflict.
     *
     * -- intent: provide a high-level DSL for atomic mass-insert-or-update logic.
     *
     * @param array        $values   Dataset to insert
     * @param array|string $uniqueBy Columns that define a unique constraint
     * @param array|null   $update   Columns to update if a conflict occurs
     *
     * @return int Number of affected rows
     * @throws Throwable If SQL compilation or execution fails
     */
    public function upsert(array $values, array|string $uniqueBy, array|null $update = null): int
    {
        if (empty($values)) {
            return 0;
        }

        if (! is_array(value: reset(array: $values))) {
            $values = [$values];
        }

        if ($update === null) {
            $update = array_keys(array: reset(array: $values));
        }

        $this->state->values        = $values;
        $this->state->updateColumns = (array) $update;

        $sql = $this->grammar->compileUpsert(
            state: $this->state,
            uniqueBy: (array) $uniqueBy,
            update: $this->state->updateColumns
        );

        return $this->executor->execute(sql: $sql, bindings: $this->state->getBindings())->getAffectedRows();
    }

    /**
     * Increment the value of a specific column by a given amount.
     *
     * -- intent: provide a pragmatic shorthand for atomic numeric increments.
     *
     * @param string         $column Technical column name
     * @param int|float|null $amount Quantity to add
     * @param array          $extra  Additional columns to update simultaneously
     *
     * @return bool
     * @throws Throwable If SQL execution fails
     */
    public function increment(string $column, int|float|null $amount = null, array $extra = []): bool
    {
        $amount  ??= 1;
        $wrapped = $this->grammar->wrap(value: $column);
        $update  = array_merge([$column => $this->raw(value: "{$wrapped} + {$amount}")], $extra);

        return $this->update(values: $update);
    }

    /**
     * Decrement the value of a specific column by a given amount.
     *
     * -- intent: provide a pragmatic shorthand for atomic numeric decrements.
     *
     * @param string         $column Technical column name
     * @param int|float|null $amount Quantity to subtract
     * @param array          $extra  Additional columns to update simultaneously
     *
     * @return bool
     * @throws Throwable If SQL execution fails
     */
    public function decrement(string $column, int|float|null $amount = null, array $extra = []): bool
    {
        $amount  ??= 1;
        $wrapped = $this->grammar->wrap(value: $column);
        $update  = array_merge([$column => $this->raw(value: "{$wrapped} - {$amount}")], $extra);

        return $this->update(values: $update);
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasAggregates.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Throwable;

/**
 * Trait HasAggregates
 *
 * -- intent: extend the query builder with statistical and aggregate function support.
 */
trait HasAggregates
{
    /**
     * Retrieve the total count of records matching the current query state.
     *
     * -- intent: provide a high-level DSL for the SQL COUNT function.
     *
     * @param string $columns Technical column identifier to count
     *
     * @return int
     * @throws Throwable If SQL execution fails
     */
    public function count(string $columns = '*') : int
    {
        return (int) $this->aggregate(function: 'count', columns: [$columns]);
    }

    /**
     * Execute a generic aggregate function and return the scalar result.
     *
     * -- intent: coordinate state modification and execution for aggregate queries.
     *
     * @param string $function Technical function name (COUNT/SUM/etc)
     * @param array  $columns  Target columns
     *
     * @return mixed
     * @throws Throwable If execution fails
     */
    protected function aggregate(string $function, array $columns = ['*']) : mixed
    {
        $this->state->columns = [
            $this->raw(value: "{$function}(" . implode(separator: ', ', array: (array) $columns) . ") as aggregate")
        ];

        $result = $this->get();

        if (empty($result)) {
            return 0;
        }

        return $result[0]['aggregate'] ?? 0;
    }

    /**
     * Retrieve the maximum value for a specific column.
     *
     * -- intent: provide a high-level DSL for the SQL MAX function.
     *
     * @param string $column Target technical column
     *
     * @return mixed
     * @throws Throwable If SQL execution fails
     */
    public function max(string $column) : mixed
    {
        return $this->aggregate(function: 'max', columns: [$column]);
    }

    /**
     * Retrieve the minimum value for a specific column.
     *
     * -- intent: provide a high-level DSL for the SQL MIN function.
     *
     * @param string $column Target technical column
     *
     * @return mixed
     * @throws Throwable If SQL execution fails
     */
    public function min(string $column) : mixed
    {
        return $this->aggregate(function: 'min', columns: [$column]);
    }

    /**
     * Retrieve the average value for a specific column.
     *
     * -- intent: provide a high-level DSL for the SQL AVG function.
     *
     * @param string $column Target technical column
     *
     * @return mixed
     * @throws Throwable If SQL execution fails
     */
    public function avg(string $column) : mixed
    {
        return $this->aggregate(function: 'avg', columns: [$column]);
    }

    /**
     * Retrieve the sum of all values for a specific column.
     *
     * -- intent: provide a high-level DSL for the SQL SUM function.
     *
     * @param string $column Target technical column
     *
     * @return mixed
     * @throws Throwable If SQL execution fails
     */
    public function sum(string $column) : mixed
    {
        return $this->aggregate(function: 'sum', columns: [$column]);
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasConditions.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\Query\Condition;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Closure;
use InvalidArgumentException;

/**
 * Trait HasConditions
 *
 * -- intent: extend the query builder with complex logical filtering capabilities (WHERE clauses).
 */
trait HasConditions
{
    /**
     * Add an "OR WHERE" clause to the query.
     *
     * -- intent: provide a shorthand for alternative logical constraints.
     *
     * @param string|Closure $column   Technical column name
     * @param mixed          $operator Comparison operator
     * @param mixed          $value    Comparison value
     *
     * @return QueryBuilder|HasConditions
     */
    public function orWhere(string|Closure $column, mixed $operator = null, mixed $value = null) : self
    {
        return $this->where(column: $column, operator: $operator, value: $value, boolean: 'OR');
    }

    /**
     * Add a basic where clause to the query.
     *
     * -- intent: provide a human-readable DSL for SQL WHERE constraints.
     *
     * @param string|Closure $column   Technical column name or sub-query closure
     * @param mixed          $operator Comparison operator or value if operator is omitted
     * @param mixed          $value    Target comparison value
     * @param string         $boolean  Logical joiner (AND/OR)
     *
     * @return QueryBuilder|HasConditions
     */
    public function where(
        string|Closure $column,
        mixed          $operator = null,
        mixed          $value = null,
        string         $boolean = 'AND'
    ) : self
    {
        if ($column instanceof Closure) {
            return $this->whereNested(callback: $column, boolean: $boolean);
        }

        if (func_num_args() === 2) {
            $value    = $operator;
            $operator = '=';
        }

        $this->state->wheres[] = new Condition(
            column  : $column,
            operator: (string) $operator,
            value   : $value,
            boolean : $boolean
        );

        if (! in_array(needle: $operator, haystack: ['IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN'])) {
            $this->state->addBinding(value: $value);
        }

        return $this;
    }

    /**
     * Add a composite nested WHERE block to the query.
     *
     * -- intent: provide isolation for complex logical groups (using parentheses).
     *
     * @param Closure $callback Closure receiving a fresh builder for nesting
     * @param string  $boolean  Logical joiner
     *
     * @return QueryBuilder|HasConditions
     */
    protected function whereNested(Closure $callback, string $boolean = 'AND') : self
    {
        $query = new class(
            grammar           : $this->grammar,
            executor          : $this->executor,
            transactionManager: $this->transactionManager,
            identityMap       : $this->identityMap
        ) extends QueryBuilder {};

        $callback($query);

        $this->state->wheres[] = [
            'type'    => 'Nested',
            'query'   => $query,
            'boolean' => $boolean
        ];

        foreach ($query->state->getBindings() as $binding) {
            $this->state->addBinding(value: $binding);
        }

        return $this;
    }

    /**
     * Add an "OR WHERE IN" clause to the query.
     *
     * -- intent: provide shorthand for alternative set participation filters.
     *
     * @param string $column Technical column name
     * @param array  $values Collection of values
     *
     * @return QueryBuilder|HasConditions
     */
    public function orWhereIn(string $column, array $values) : self
    {
        return $this->whereIn(column: $column, values: $values, boolean: 'OR');
    }

    /**
     * Add a "WHERE IN" clause to the query.
     *
     * -- intent: filter records based on a predefined set of values.
     *
     * @param string      $column  Technical column name
     * @param array       $values  Collection of values
     * @param string|null $boolean Logical joiner
     * @param bool        $not     Whether to use NOT IN
     *
     * @return QueryBuilder|HasConditions
     */
    public function whereIn(string $column, array $values, string|null $boolean = null, bool $not = false) : self
    {
        $boolean  ??= 'AND';
        $operator = $not ? 'NOT IN' : 'IN';

        $this->state->wheres[] = new Condition(
            column  : $column,
            operator: $operator,
            value   : $values,
            boolean : $boolean
        );

        foreach ($values as $value) {
            $this->state->addBinding(value: $value);
        }

        return $this;
    }

    /**
     * Add a "WHERE BETWEEN" clause to the query.
     *
     * -- intent: filter records within a numeric or temporal range.
     *
     * @param string      $column  Technical column name
     * @param array       $values  Start and end values
     * @param string|null $boolean Logical joiner
     * @param bool        $not     Whether to use NOT BETWEEN
     *
     * @return QueryBuilder|HasConditions
     */
    public function whereBetween(string $column, array $values, string|null $boolean = null, bool $not = false) : self
    {
        $boolean ??= 'AND';
        if (count(value: $values) !== 2) {
            throw new InvalidArgumentException(message: "BETWEEN requires exactly two values.");
        }

        $operator = $not ? 'NOT BETWEEN' : 'BETWEEN';

        $this->state->wheres[] = new Condition(
            column  : $column,
            operator: $operator,
            value   : $values,
            boolean : $boolean
        );

        $this->state->addBinding(value: $values[0]);
        $this->state->addBinding(value: $values[1]);

        return $this;
    }
}



=== QueryBuilder/Core/Builder/Concerns/HasControlStructures.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Closure;

/**
 * Trait HasControlStructures
 *
 * -- intent: extend the query builder with conditional execution pathways.
 */
trait HasControlStructures
{
    /**
     * Execute a callback if a given condition is falsy.
     *
     * -- intent: provide a pragmatic shorthand for negative conditional building.
     *
     * @param mixed         $condition Falsy value to evaluate
     * @param callable      $callback  Operation to perform if false
     * @param callable|null $default   Alternative operation if true
     *
     * @return QueryBuilder|HasControlStructures
     */
    public function unless(mixed $condition, callable $callback, callable|null $default = null) : self
    {
        return $this->when(condition: ! $condition, callback: $callback, default: $default);
    }

    /**
     * Execute a callback if a given truthy condition is met.
     *
     * -- intent: provide a pragmatic shorthand for conditional query building.
     *
     * @param mixed         $condition Boolean or truthy value to evaluate
     * @param callable      $callback  Operation to perform if true
     * @param callable|null $default   Alternative operation if false
     *
     * @return QueryBuilder|HasControlStructures
     */
    public function when(mixed $condition, callable $callback, callable|null $default = null) : self
    {
        if ($condition) {
            return $callback($this, $condition) ?: $this;
        }

        if ($default !== null) {
            return $default($this, $condition) ?: $this;
        }

        return $this;
    }

    /**
     * Apply a closure directly to the query builder instance.
     *
     * -- intent: allow external logic to participate in the fluent chain.
     *
     * @param Closure $callback Operation to tap into
     *
     * @return QueryBuilder|HasControlStructures
     */
    public function tap(Closure $callback) : self
    {
        $callback($this);

        return $this;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasGroups.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;

/**
 * Trait HasGroups
 *
 * -- intent: extend the query builder with aggregation grouping and filtering support.
 */
trait HasGroups
{
    /**
     * Add a GROUP BY clause to the query.
     *
     * -- intent: aggregate record sets based on one or more technical columns.
     *
     * @param string|array ...$columns Technical column identifiers
     *
     * @return HasGroups|QueryBuilder
     */
    public function groupBy(string|array ...$columns) : self
    {
        foreach ($columns as $column) {
            $this->state->groups = array_merge($this->state->groups, (array) $column);
        }

        return $this;
    }

    /**
     * Add a HAVING clause to the query.
     *
     * -- intent: filter aggregated record groups based on functional criteria.
     *
     * @param string $column   Technical column or aggregate function
     * @param string $operator Comparison operator
     * @param mixed  $value    Comparison target value
     * @param string $boolean  Logical joiner
     *
     * @return HasGroups|QueryBuilder
     */
    public function having(string $column, string $operator, mixed $value, string $boolean = 'AND') : self
    {
        $this->state->havings[] = compact('column', 'operator', 'value', 'boolean');

        $this->state->addBinding(value: $value);

        return $this;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasJoins.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Closure;

/**
 * Trait HasJoins
 *
 * -- intent: extend the query builder with relational join capabilities.
 */
trait HasJoins
{
    /**
     * Add an INNER JOIN clause to the query.
     *
     * -- intent: provide a high-level DSL for standard relational record filtering.
     *
     * @param string         $table    Target database table
     * @param string|Closure $first    Left-hand column identifier
     * @param string|null    $operator Comparison operator
     * @param string|null    $second   Right-hand column identifier
     *
     * @return HasJoins|QueryBuilder
     */
    public function join(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ) : self
    {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'inner');
    }

    /**
     * Internal technician for constructing various join definitions.
     *
     * -- intent: centralize join metadata collection for the grammar engine.
     *
     * @param string         $table    Target table
     * @param string|Closure $first    Comparison source
     * @param string|null    $operator Comparison operator
     * @param string|null    $second   Comparison target
     * @param string         $type     Join significance (inner/left/right/cross)
     *
     * @return HasJoins|QueryBuilder
     */
    protected function addJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null,
        string         $type = 'inner'
    ) : self
    {
        $this->state->joins[] = compact('table', 'first', 'operator', 'second', 'type');

        return $this;
    }

    /**
     * Add a LEFT JOIN clause to the query.
     *
     * -- intent: provide a high-level DSL for inclusive relational record retrieval.
     *
     * @param string         $table    Target database table
     * @param string|Closure $first    Left-hand column identifier
     * @param string|null    $operator Comparison operator
     * @param string|null    $second   Right-hand column identifier
     *
     * @return HasJoins|QueryBuilder
     */
    public function leftJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ) : self
    {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'left');
    }

    /**
     * Add a RIGHT JOIN clause to the query.
     *
     * -- intent: provide a high-level DSL for reverse relational record retrieval.
     *
     * @param string         $table    Target database table
     * @param string|Closure $first    Left-hand column identifier
     * @param string|null    $operator Comparison operator
     * @param string|null    $second   Right-hand column identifier
     *
     * @return HasJoins|QueryBuilder
     */
    public function rightJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ) : self
    {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'right');
    }

    /**
     * Add a CROSS JOIN clause to the query.
     *
     * -- intent: provide a high-level DSL for Cartesian product joins.
     *
     * @param string $table Target database table
     *
     * @return HasJoins|QueryBuilder
     */
    public function crossJoin(string $table) : self
    {
        return $this->addJoin(table: $table, first: '', type: 'cross');
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasOrders.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;

/**
 * Trait HasOrders
 *
 * -- intent: extend the query builder with sorting and ordering capabilities.
 */
trait HasOrders
{
    /**
     * Add a descending ORDER BY clause to the query.
     *
     * -- intent: provide a shorthand for reverse chronological or numeric sorting.
     *
     * @param string $column Technical column name
     *
     * @return HasOrders|QueryBuilder
     */
    public function orderByDesc(string $column) : self
    {
        return $this->orderBy(column: $column, direction: 'DESC');
    }

    /**
     * Add an ORDER BY clause to the query.
     *
     * -- intent: provide a human-readable DSL for sorting record sets.
     *
     * @param string $column    Technical column name
     * @param string $direction Sort orientation (ASC/DESC)
     *
     * @return HasOrders|QueryBuilder
     */
    public function orderBy(string $column, string $direction = 'ASC') : self
    {
        $this->state->orders[] = [
            'column'    => $column,
            'direction' => strtoupper(string: $direction)
        ];

        return $this;
    }

    /**
     * Add a random sorting order to the query.
     *
     * -- intent: provide a pragmatic shorthand for chaotic record retrieval.
     *
     * @return HasOrders|QueryBuilder
     */
    public function inRandomOrder() : self
    {
        $this->state->orders[] = [
            'type'   => 'Raw',
            'sql'    => $this->grammar->compileRandomOrder(),
            'values' => []
        ];

        return $this;
    }

    /**
     * Add a latest (chronological desc) sort order.
     *
     * -- intent: provide a domain-specific shorthand for recent record retrieval.
     *
     * @param string $column Name of the timestamp column
     *
     * @return HasOrders|QueryBuilder
     */
    public function latest(string $column = 'created_at') : self
    {
        return $this->orderBy(column: $column, direction: 'DESC');
    }

    /**
     * Add an oldest (chronological asc) sort order.
     *
     * -- intent: provide a domain-specific shorthand for historic record retrieval.
     *
     * @param string $column Name of the timestamp column
     *
     * @return HasOrders|QueryBuilder
     */
    public function oldest(string $column = 'created_at') : self
    {
        return $this->orderBy(column: $column, direction: 'ASC');
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasSchema.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Migrations\Design\Table\Blueprint;
use Throwable;

/**
 * Trait HasSchema
 *
 * -- intent: bridge the query builder with the migration system for on-the-fly table management.
 */
trait HasSchema
{
    /**
     * Create a new database table and define its structure.
     *
     * -- intent: provide a fluent API for structural table creation within the builder context.
     *
     * @param string   $table    Technical table identifier
     * @param callable $callback Structural design closure
     *
     * @return void
     * @throws Throwable If SQL compilation or execution fails
     */
    public function create(string $table, callable $callback) : void
    {
        $blueprint = new Blueprint(table: $table);
        $callback($blueprint);

        $statements = $blueprint->toSql(grammar: $this->grammar);

        foreach ($statements as $sql) {
            $this->executor->execute(sql: $sql);
        }
    }

    /**
     * Drop a database table if it currently exists.
     *
     * -- intent: provide a safe shorthand for table destruction.
     *
     * @param string $table Technical table name
     *
     * @return void
     * @throws Throwable If SQL execution fails
     */
    public function dropIfExists(string $table) : void
    {
        $sql = $this->grammar->compileDropIfExists(table: $table);
        $this->executor->execute(sql: $sql);
    }

    /**
     * Remove all records from a table and reset auto-increment counters.
     *
     * -- intent: provide an efficient, low-level reset for a specific table.
     *
     * @param string|null $table Optional table name override
     *
     * @return void
     * @throws Throwable If SQL execution fails
     */
    public function truncate(string|null $table = null) : void
    {
        $table = $table ?: $this->state->from;
        $sql   = $this->grammar->compileTruncate(table: $table);
        $this->executor->execute(sql: $sql);
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasSoftDeletes.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Trait HasSoftDeletes
 *
 * -- intent: extend the query builder with automated soft-deletion filtering and management.
 */
trait HasSoftDeletes
{
    /**
     * Whether soft deletion filters should be bypassed.
     */
    protected bool $withTrashed = false;

    /**
     * Filter for specifically retrieving deleted records.
     */
    protected bool $onlyTrashed = false;

    /**
     * Include soft-deleted records in the query results.
     *
     * -- intent: disable the automatic filter for the 'deleted_at' column.
     *
     * @return QueryBuilder|HasSoftDeletes
     */
    public function withTrashed() : self
    {
        $this->withTrashed = true;

        return $this;
    }

    /**
     * Filter results to only include soft-deleted records.
     *
     * -- intent: pivot the logical filter to focus solely on historically removed data.
     *
     * @return QueryBuilder|HasSoftDeletes
     */
    public function onlyTrashed() : self
    {
        $this->onlyTrashed = true;

        return $this;
    }

    /**
     * Restore all soft-deleted records matching the current criteria.
     *
     * -- intent: revert the deletion state by nullifying the 'deleted_at' column.
     *
     * @param string $column The technical deletion indicator column
     *
     * @return bool
     * @throws Throwable If SQL execution fails
     */
    public function restore(string $column = 'deleted_at') : bool
    {
        return $this->update(values: [$column => null]);
    }

    /**
     * Internal technician to apply the appropriate soft-deletion SQL filters.
     *
     * -- intent: automate data visibility constraints based on feature state.
     *
     * @param string $column Technical name of the deletion timestamp
     *
     * @return void
     */
    protected function applySoftDeleteFilter(string $column = 'deleted_at') : void
    {
        if ($this->withTrashed) {
            return;
        }

        if ($this->onlyTrashed) {
            $this->whereNotNull(column: $column);

            return;
        }

        $this->whereNull(column: $column);
    }

    /**
     * Add a WHERE NOT NULL filter to the query.
     *
     * -- intent: ensure that a specific column contains active data.
     *
     * @param string $column  Technical column identifier
     * @param string $boolean Logical joiner
     *
     * @return QueryBuilder|HasSoftDeletes
     */
    public function whereNotNull(string $column, string $boolean = 'AND') : self
    {
        return $this->whereNull(column: $column, boolean: $boolean, not: true);
    }

    /**
     * Add a WHERE NULL filter to the query.
     *
     * -- intent: check for the absence of data in a specific column.
     *
     * @param string      $column  Technical column identifier
     * @param string|null $boolean Logical joiner
     * @param bool        $not     Whether to use IS NOT NULL
     *
     * @return QueryBuilder|HasSoftDeletes
     */
    public function whereNull(string $column, string|null $boolean = null, bool $not = false) : self
    {
        $boolean  ??= 'AND';
        $operator = $not ? 'IS NOT NULL' : 'IS NULL';

        $this->state->wheres[] = [
            'type'     => 'Null',
            'column'   => $column,
            'operator' => $operator,
            'boolean'  => $boolean
        ];

        return $this;
    }
}

=== QueryBuilder/Core/Builder/Concerns/Macroable.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use BadMethodCallException;
use Closure;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;

/**
 * Trait Macroable
 *
 * -- intent: enable runtime extension of the builder through dynamic method registration.
 */
trait Macroable
{
    // Global registry for dynamic builder macros
    protected static array $macros = [];

    /**
     * Register multiple macros at once from a specific mixin class.
     *
     * -- intent: facilitate bulk extension from external provider classes.
     *
     * @param object|string $mixin Target class containing custom methods
     *
     * @return void
     * @throws ReflectionException If class analysis fails
     */
    public static function mixin(object|string $mixin) : void
    {
        $methods = (new ReflectionClass(objectOrClass: $mixin))->getMethods(
            filter: ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED
        );

        foreach ($methods as $method) {
            $method->setAccessible(accessible: true);
            static::macro(name: $method->name, macro: $method->invoke(object: $mixin));
        }
    }

    /**
     * Register a new custom macro (dynamic method).
     *
     * -- intent: provide a way to inject domain-specific helpers into the fluent API.
     *
     * @param string          $name  Method technical name
     * @param callable|object $macro Implementation closure or invokable object
     *
     * @return void
     */
    public static function macro(string $name, callable|object $macro) : void
    {
        static::$macros[$name] = $macro;
    }

    /**
     * Handle dynamic calls to macros or trigger standard failure.
     *
     * -- intent: automate the execution of injected methods via magic interceptor.
     *
     * @param string $method     Target method name
     * @param array  $parameters Call arguments
     *
     * @return mixed
     * @throws BadMethodCallException If method is not found in macros or class
     */
    public function __call(string $method, array $parameters) : mixed
    {
        if (! static::hasMacro(name: $method)) {
            throw new BadMethodCallException(message: "Method [{$method}] does not exist on " . static::class);
        }

        $macro = static::$macros[$method];

        if ($macro instanceof Closure) {
            return call_user_func_array(
                callback: $macro->bindTo(newThis: $this, newscope: static::class),
                args    : $parameters
            );
        }

        return call_user_func_array(callback: $macro, args: $parameters);
    }

    /**
     * Verify if a specific macro name has been registered.
     *
     * -- intent: provide a way to check for feature existence at runtime.
     *
     * @param string $name Method name to check
     *
     * @return bool
     */
    public static function hasMacro(string $name) : bool
    {
        return isset(static::$macros[$name]);
    }
}

=== QueryBuilder/Core/Builder/QueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder;

use Avax\Database\Identity\IdentityMap;
use Avax\Database\Query\QueryState;
use Avax\Database\QueryBuilder\Core\Executor\ExecutorInterface;
use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Database\QueryBuilder\Exceptions\InvalidCriteriaException;
use Avax\Database\QueryBuilder\ValueObjects\Expression;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Avax\Database\Transaction\Exceptions\TransactionException;
use ReflectionClass;
use ReflectionException;
use Throwable;

/**
 * The primary entry point for constructing and executing domain-fluent SQL queries.
 *
 * -- intent: provide a high-level DSL balanced with robust infrastructure coordination.
 */
class QueryBuilder
{
    use Concerns\Macroable;
    use Concerns\HasConditions;
    use Concerns\HasJoins;
    use Concerns\HasOrders;
    use Concerns\HasAggregates;
    use Concerns\HasGroups;
    use Concerns\HasControlStructures;
    use Concerns\HasSoftDeletes;
    use Concerns\HasAdvancedMutations;
    use Concerns\HasSchema;

    /**
     * Current state of the builder's parameters.
     */
    protected readonly QueryState $state;

    /**
     * Flag indicating if execution should be deferred.
     */
    protected bool $isDeferred = false;

    /**
     * Constructor using PHP 8.3 property promotion for core engines.
     *
     * -- intent: initialize the builder with its core engine dependencies and query state.
     *
     * @param GrammarInterface                 $grammar            The compiler for dialect-specific SQL
     * @param ExecutorInterface                $executor           The technician for query execution
     * @param TransactionManagerInterface|null $transactionManager The coordinator for atomicity
     * @param IdentityMap|null                 $identityMap        The vault for deferred operations
     *
     * @throws ReflectionException If class introspection fails
     */
    public function __construct(
        protected readonly GrammarInterface                 $grammar,
        protected readonly ExecutorInterface                $executor,
        protected readonly TransactionManagerInterface|null $transactionManager = null,
        protected IdentityMap|null                          $identityMap = null
    ) {
        $this->state = new QueryState();

        if (property_exists(object_or_class: $this, property: 'tableName')) {
            $ref       = new ReflectionClass(objectOrClass: $this);
            $tableName = $ref->getProperty(name: 'tableName')->getValue(object: $this);

            if (is_string(value: $tableName) && $tableName !== '') {
                $this->state->from = $tableName;
            }
        }
    }

    /**
     * Deep clone the builder to ensure decoupled state branches.
     *
     * -- intent: prevent state leakage between derived query instances.
     *
     * @return void
     */
    public function __clone()
    {
        $this->state = clone $this->state;
    }

    /**
     * Spawn a clean builder instance sharing the same foundational engines.
     *
     * -- intent: create a fresh query context without re-injecting core dependencies manually.
     *
     * @return static
     * @throws ReflectionException
     */
    public function newQuery(): static
    {
        return new static(
            grammar: $this->grammar,
            executor: $this->executor,
            transactionManager: $this->transactionManager,
            identityMap: $this->identityMap
        );
    }

    /**
     * Create a raw SQL expression that will not be escaped or parameterized.
     *
     * -- intent: allow injection of literal SQL fragments for advanced operations.
     *
     * @param string $value The raw SQL fragment
     *
     * @return Expression
     */
    public function raw(string $value): Expression
    {
        return new Expression(value: $value);
    }


    /**
     * Target a specific database table for the query operations.
     *
     * -- intent: set the primary data source for the query.
     *
     * @param string $table The domain table name
     *
     * @return self
     */
    public function from(string $table): self
    {
        $this->state->from = $table;

        return $this;
    }

    /**
     * Define the specific columns to be retrieved.
     *
     * -- intent: restrict the result set to the requested technical identifiers.
     *
     * @param string ...$columns List of column names
     *
     * @return self
     */
    public function select(string ...$columns): self
    {
        $this->state->columns = empty($columns) ? ['*'] : $columns;

        return $this;
    }

    /**
     * Inject raw SQL fragments into the select clause.
     *
     * -- intent: allow bypass of the grammar's column wrapping for complex expressions.
     *
     * @param string ...$expressions Raw SQL expressions
     *
     * @return self
     * @throws InvalidCriteriaException On detected SQL injection attempts
     */
    public function selectRaw(string ...$expressions): self
    {
        foreach ($expressions as $expression) {
            if (str_contains(haystack: $expression, needle: ';') || str_contains(haystack: $expression, needle: '--')) {
                throw new InvalidCriteriaException(
                    method: 'selectRaw',
                    reason: "Raw SELECT expressions must not contain semicolons or SQL comments."
                );
            }
        }

        $this->state->columns = array_merge($this->state->columns ?: [], $expressions);

        return $this;
    }

    /**
     * Enforce unique result sets via the DISTINCT operator.
     *
     * -- intent: filter out duplicate records from the final dataset.
     *
     * @return self
     */
    public function distinct(): self
    {
        $this->state->distinct = true;

        return $this;
    }

    /**
     * Skip a specific number of records at the beginning of the result set.
     *
     * -- intent: coordinate with limit for precise data windowing.
     *
     * @param int $offset Records to bypass
     *
     * @return self
     * @throws InvalidCriteriaException On negative integer inputs
     */
    public function offset(int $offset): self
    {
        if ($offset < 0) {
            throw new InvalidCriteriaException(method: 'offset', reason: "OFFSET must be a non-negative integer.");
        }

        $this->state->offset = $offset;

        return $this;
    }

    /**
     * Enable deferred execution mode (Identity Map / Unit of Work).
     *
     * -- intent: buffer mutation operations for optimized batch processing.
     *
     * @param IdentityMap|null $identityMap Optional specific map to use
     *
     * @return self
     * @throws InvalidCriteriaException If no identity map is available for tracking
     */
    public function deferred(IdentityMap|null $identityMap = null): self
    {
        $this->isDeferred = true;

        if ($identityMap !== null) {
            $this->identityMap = $identityMap;
        }

        if (! $this->identityMap) {
            throw new InvalidCriteriaException(
                method: 'deferred',
                reason: "IdentityMap must be provided to use deferred execution."
            );
        }

        return $this;
    }

    /**
     * Determine if any records matching the current criteria exist.
     *
     * -- intent: execute a minimal existence probe for binary result checking.
     *
     * @return bool
     * @throws Throwable If SQL execution fails
     */
    public function exists(): bool
    {
        $instance = clone $this;
        $sql      = $instance->grammar->compileSelect(state: $instance->limit(limit: 1)->state);
        $result   = $instance->executor->query(sql: $sql, bindings: $instance->state->getBindings());

        return ! empty($result);
    }

    /**
     * Restrict the number of records returned by the query.
     *
     * -- intent: optimize performance and facilitate pagination boundaries.
     *
     * @param int $limit Maximum record count
     *
     * @return self
     * @throws InvalidCriteriaException On negative integer inputs
     */
    public function limit(int $limit): self
    {
        if ($limit < 0) {
            throw new InvalidCriteriaException(method: 'limit', reason: "LIMIT must be a non-negative integer.");
        }

        $this->state->limit = $limit;

        return $this;
    }

    /**
     * Retrieve the first record from the query result set.
     *
     * -- intent: isolate a single record from the results with optional path resolution.
     *
     * @param string|callable|null $key     Target column or processing closure
     * @param mixed                $default Fallback if no result is found
     *
     * @return mixed
     * @throws Throwable If SQL execution fails
     */
    public function first(string|callable|null $key = null, mixed $default = null): mixed
    {
        $instance = clone $this;
        $result   = $instance->limit(limit: 1)->get();

        if (empty($result)) {
            return $default;
        }

        $firstRecord = $result[0];

        if ($key === null) {
            return $firstRecord;
        }

        if (is_callable(value: $key)) {
            return $key($firstRecord) ?? $default;
        }

        if (str_contains(haystack: $key, needle: '.')) {
            $keys  = explode(separator: '.', string: $key);
            $value = $firstRecord;

            foreach ($keys as $segment) {
                if (is_array(value: $value) && array_key_exists(key: $segment, array: $value)) {
                    $value = $value[$segment];
                } else {
                    return $default;
                }
            }

            return $value;
        }

        return $firstRecord[$key] ?? $default;
    }

    /**
     * Fulfill a SELECT query and retrieve all resulting records.
     *
     * -- intent: compile the final SQL and execute the physical data retrieval.
     *
     * @return array<array-key, mixed> Resulting dataset
     * @throws Throwable If SQL syntax or execution fails
     */
    public function get(): array
    {
        if (method_exists(object_or_class: $this, method: 'applySoftDeleteFilter')) {
            $this->applySoftDeleteFilter();
        }

        $sql = $this->grammar->compileSelect(state: $this->state);

        return $this->executor->query(sql: $sql, bindings: $this->state->getBindings());
    }

    /**
     * Execute an INSERT mutation query.
     *
     * -- intent: transform values into a physical data insertion instruction.
     *
     * @param array $values Columns and their corresponding values
     *
     * @return bool
     * @throws Throwable If insertion fails or deferral technician is missing
     */
    public function insert(array $values): bool
    {
        $this->state->values = $values;
        $sql                 = $this->grammar->compileInsert(state: $this->state);

        if ($this->isDeferred) {
            $this->identityMap->schedule(operation: 'INSERT', sql: $sql, bindings: $this->state->getBindings());

            return true;
        }

        return $this->executor->execute(sql: $sql, bindings: $this->state->getBindings())->isSuccessful();
    }

    /**
     * Execute an UPDATE mutation query.
     *
     * -- intent: transform values and criteria into a physical data modification instruction.
     *
     * @param array $values Target assignments
     *
     * @return bool
     * @throws Throwable If update fails
     */
    public function update(array $values): bool
    {
        if (method_exists(object_or_class: $this, method: 'applySoftDeleteFilter')) {
            $this->applySoftDeleteFilter();
        }

        $this->state->values = $values;
        $sql                 = $this->grammar->compileUpdate(state: $this->state);

        if ($this->isDeferred) {
            $this->identityMap->schedule(operation: 'UPDATE', sql: $sql, bindings: $this->state->getBindings());

            return true;
        }

        return $this->executor->execute(sql: $sql, bindings: $this->state->getBindings())->isSuccessful();
    }

    /**
     * Execute a DELETE query against the target table.
     *
     * -- intent: physically or logically remove records based on active criteria.
     *
     * @return bool
     * @throws Throwable If deletion fails
     */
    public function delete(): bool
    {
        if (method_exists(object_or_class: $this, method: 'applySoftDeleteFilter')) {
            $this->applySoftDeleteFilter();
        }

        $sql = $this->grammar->compileDelete(state: $this->state);

        if ($this->isDeferred) {
            $this->identityMap->schedule(operation: 'DELETE', sql: $sql, bindings: $this->state->getBindings());

            return true;
        }

        return $this->executor->execute(sql: $sql, bindings: $this->state->getBindings())->isSuccessful();
    }

    /**
     * Access the raw internal state for advanced structural metadata retrieval.
     *
     * -- intent: provide programmatic access to the accumulated query parameters.
     *
     * @return QueryState
     */
    public function getState(): QueryState
    {
        return $this->state;
    }

    /**
     * Execute a closure within a managed database transaction.
     *
     * -- intent: ensure atomic execution of multiple builder operations with automatic safety.
     *
     * @param callable $callback Operational closure
     *
     * @return mixed
     * @throws TransactionException If no transaction manager is present or execution fails
     * @throws Throwable If the transaction or callback fails
     */
    public function transaction(callable $callback): mixed
    {
        if (! $this->transactionManager) {
            throw new TransactionException(message: "Transaction manager not set in builder.", nestingLevel: 0);
        }

        try {
            return $this->transactionManager->transaction(callback: fn() => $callback($this));
        } catch (Throwable $e) {
            if ($e instanceof TransactionException) {
                throw $e;
            }
            throw new TransactionException(message: $e->getMessage(), nestingLevel: 1, previous: $e);
        }
    }
}

=== QueryBuilder/Core/Executor/ExecutorInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Executor;

use Avax\Database\QueryBuilder\DTO\MutationResult;
use Throwable;

/**
 * Functional contract for the physical execution of database queries.
 *
 * -- intent: decouple the builder's logic from the technicalities of driver-level communication.
 */
interface ExecutorInterface
{
    /**
     * Execute a data retrieval query (SELECT) and return the resulting collection.
     *
     * -- intent: provide a pragmatic entry point for fetching raw datasets.
     *
     * @param string $sql      Technical query dialect
     * @param array  $bindings Secure parameter values
     *
     * @return array<array-key, mixed>
     * @throws Throwable If driver or connection failure occurs
     */
    public function query(string $sql, array $bindings = []): array;

    /**
     * Execute a data mutation query (INSERT/UPDATE/DELETE) and return mutation result.
     *
     * -- intent: provide a pragmatic entry point for structural or data changes.
     *
     * @param string $sql      Technical query dialect
     * @param array  $bindings Secure parameter values
     *
     * @return MutationResult Encapsulates success status and affected row count
     * @throws Throwable If driver or connection failure occurs
     */
    public function execute(string $sql, array $bindings = []): MutationResult;

    /**
     * Retrieve the identifying technical name of the underlying database driver.
     *
     * -- intent: allow components to adapt behavior based on the active storage engine.
     *
     * @return string
     */
    public function getDriverName(): string;
}

=== QueryBuilder/Core/Executor/PDOExecutor.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Executor;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\QueryBuilder\DTO\MutationResult;
use Avax\Database\QueryBuilder\Exceptions\QueryException;
use PDO;
use Throwable;

/**
 * Practical technician for executing queries via the native PHP Data Object driver.
 *
 * -- intent: provide a secure and reliable implementation of the executor contract using PDO.
 */
final readonly class PDOExecutor implements ExecutorInterface
{
    /**
     * @param DatabaseConnection $connection The technician for connection resolution
     */
    public function __construct(private DatabaseConnection $connection) {}

    /**
     * Fulfill a retrieval query while maintaining secure parameter binding.
     *
     * -- intent: execute SELECT statements and deliver normalized result arrays.
     *
     * @param string $sql      Technical SQL string
     * @param array  $bindings Sanitized values for placeholding
     *
     * @return array<array-key, mixed>
     * @throws QueryException If the SQL is invalid or execution fails
     */
    public function query(string $sql, array $bindings = []): array
    {
        try {
            $statement = $this->getPdo()->prepare(query: $sql);
            $statement->execute(params: $bindings);

            return $statement->fetchAll();
        } catch (Throwable $e) {
            throw new QueryException(
                message: "Query execution failed: " . $e->getMessage(),
                sql: $sql,
                bindings: $bindings,
                previous: $e
            );
        }
    }

    /**
     * Resolve the active PDO instance from the connection technician.
     *
     * -- intent: lazily retrieve the physical driver for query fulfillment.
     *
     * @return PDO
     */
    private function getPdo(): PDO
    {
        return $this->connection->getConnection();
    }

    /**
     * Fulfill a mutation query and return the mutation result.
     *
     * -- intent: execute write operations (INSERT/UPDATE/DELETE) with atomicity support.
     *
     * @param string $sql      Technical SQL string
     * @param array  $bindings Sanitized values for placeholding
     *
     * @return MutationResult Encapsulates success status and affected row count
     * @throws QueryException If mutation fails
     */
    public function execute(string $sql, array $bindings = []): MutationResult
    {
        try {
            $statement = $this->getPdo()->prepare(query: $sql);
            $statement->execute(params: $bindings);

            return MutationResult::success(count: $statement->rowCount());
        } catch (Throwable $e) {
            throw new QueryException(
                message: "Execution failed: " . $e->getMessage(),
                sql: $sql,
                bindings: $bindings,
                previous: $e
            );
        }
    }

    /**
     * Determine the active driver name from the physical PDO instance.
     *
     * -- intent: facilitate dialect-aware logic in grammar and builder layers.
     *
     * @return string
     */
    public function getDriverName(): string
    {
        return $this->getPdo()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);
    }
}

=== QueryBuilder/Core/Grammar/BaseGrammar.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\QueryState;
use Avax\Database\QueryBuilder\ValueObjects\Expression;

/**
 * Base implementation of SQL compilation logic shared across most RDBMS dialects.
 *
 * -- intent: provide a foundation for building standardized SQL strings from query metadata.
 */
abstract class BaseGrammar implements GrammarInterface
{
    /**
     * Compile the components of a SELECT statement into a cohesive string.
     *
     * -- intent: coordinate the sequential compilation of columns, source, joins, and filters.
     *
     * @param QueryState $state Current builder parameters
     *
     * @return string
     */
    public function compileSelect(QueryState $state): string
    {
        $components = [
            'select' => $this->compileColumns(state: $state),
            'from'   => $this->compileFrom(state: $state),
            'joins'  => $this->compileJoins(state: $state),
            'wheres' => $this->compileWheres(state: $state),
            'groups' => $this->compileGroups(state: $state),
            'orders' => $this->compileOrders(state: $state),
            'limit'  => $this->compileLimit(state: $state),
            'offset' => $this->compileOffset(state: $state),
        ];

        return implode(separator: ' ', array: array_filter(array: $components));
    }

    /**
     * Compile the column list for the retrieval query.
     *
     * -- intent: transform technical column names into a comma-separated and wrapped SQL list.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileColumns(QueryState $state): string
    {
        $select  = $state->distinct ? 'SELECT DISTINCT ' : 'SELECT ';
        $columns = array_map(callback: fn($c) => $this->wrap(value: $c), array: $state->columns);

        return $select . implode(separator: ', ', array: $columns);
    }

    /**
     * Ensure a database identifier is properly escaped according to standard SQL.
     *
     * -- intent: provide generic wrapping logic to be overridden by specific dialects.
     *
     * @param mixed $value Technical name or Expression
     *
     * @return string
     */
    public function wrap(mixed $value): string
    {
        // If it's an Expression, return raw value
        if ($value instanceof Expression) {
            return $value->getValue();
        }

        $value = (string) $value;

        // Don't wrap wildcards or function calls
        if ($value === '*' || str_contains(haystack: $value, needle: '(')) {
            return $value;
        }

        // Handle table.column notation
        if (str_contains(haystack: $value, needle: '.')) {
            return implode(separator: '.', array: array_map(callback: fn($segment) => $this->wrapSegment($segment), array: explode(separator: '.', string: $value)));
        }

        return $this->wrapSegment($value);
    }

    /**
     * Wrap a single identifier segment.
     *
     * @param string $segment
     *
     * @return string
     */
    protected function wrapSegment(string $segment): string
    {
        if ($segment === '*') {
            return $segment;
        }

        return '"' . str_replace(search: '"', replace: '""', subject: $segment) . '"';
    }

    /**
     * Compile the source table for the query.
     *
     * -- intent: transform the internal table identifier into a wrapped SQL fragment.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileFrom(QueryState $state): string
    {
        if ($state->from) {
            return 'FROM ' . $this->wrap(value: $state->from);
        }

        return '';
    }

    /**
     * Compile all JOIN clauses into SQL fragments.
     *
     * -- intent: transform join metadata into proper SQL JOIN syntax.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileJoins(QueryState $state): string
    {
        if (empty($state->joins)) {
            return '';
        }

        $sql = [];

        foreach ($state->joins as $join) {
            $type = strtoupper($join['type']);
            $table = $this->wrap($join['table']);

            // CROSS JOIN doesn't need ON clause
            if ($join['type'] === 'cross') {
                $sql[] = "{$type} JOIN {$table}";
                continue;
            }

            $first = $this->wrap($join['first']);
            $operator = $join['operator'] ?? '=';
            $second = $this->wrap($join['second']);

            $sql[] = "{$type} JOIN {$table} ON {$first} {$operator} {$second}";
        }

        return implode(' ', $sql);
    }

    /**
     * Compile all logical filters (WHERE clauses) into a single SQL clause.
     *
     * -- intent: provide a structured transformation of Condition objects into SQL criteria.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileWheres(QueryState $state): string
    {
        if (empty($state->wheres)) {
            return '';
        }

        $sql = [];
        foreach ($state->wheres as $i => $where) {
            $prefix = $i === 0 ? 'WHERE ' : $where->boolean . ' ';
            $sql[]  = $prefix . $this->wrap(value: $where->column) . " {$where->operator} ?";
        }

        return implode(separator: ' ', array: $sql);
    }

    /**
     * Compile GROUP BY clauses into SQL.
     *
     * -- intent: transform grouping metadata into proper SQL GROUP BY syntax.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileGroups(QueryState $state): string
    {
        if (empty($state->groups)) {
            return '';
        }

        $columns = array_map(fn($column) => $this->wrap($column), $state->groups);

        return 'GROUP BY ' . implode(', ', $columns);
    }

    /**
     * Compile ORDER BY clauses into SQL.
     *
     * -- intent: transform sorting metadata into proper SQL ORDER BY syntax.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileOrders(QueryState $state): string
    {
        if (empty($state->orders)) {
            return '';
        }

        $orders = [];
        foreach ($state->orders as $order) {
            $column = $this->wrap($order['column']);
            $direction = strtoupper($order['direction'] ?? 'ASC');
            $orders[] = "{$column} {$direction}";
        }

        return 'ORDER BY ' . implode(', ', $orders);
    }

    /**
     * Compile the LIMIT clause for result set restriction.
     *
     * -- intent: transform the limit metadata into standard SQL LIMIT syntax.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileLimit(QueryState $state): string
    {
        if ($state->limit) {
            return "LIMIT {$state->limit}";
        }

        return '';
    }

    /**
     * Compile the OFFSET clause for result set pagination.
     *
     * -- intent: transform the offset metadata into standard SQL OFFSET syntax.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    protected function compileOffset(QueryState $state): string
    {
        if ($state->offset) {
            return "OFFSET {$state->offset}";
        }

        return '';
    }

    /**
     * Compile an INSERT statement based on the provided state values.
     *
     * -- intent: transform a simple data map into a valid SQL insertion command.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    public function compileInsert(QueryState $state): string
    {
        $table   = $this->wrap(value: $state->from);
        $columns = implode(
            separator: ', ',
            array: array_map(
                callback: fn($c) => $this->wrap(value: $c),
                array: array_keys(array: $state->values)
            )
        );
        $values  = implode(
            separator: ', ',
            array: array_fill(
                start_index: 0,
                count: count(value: $state->values),
                value: '?'
            )
        );

        foreach ($state->values as $value) {
            $state->addBinding(value: $value);
        }

        return "INSERT INTO {$table} ({$columns}) VALUES ({$values})";
    }

    /**
     * Compile an UPDATE statement based on the provided state values and filters.
     *
     * -- intent: transform mutation data and criteria into a valid SQL modification command.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    public function compileUpdate(QueryState $state): string
    {
        $table = $this->wrap(value: $state->from);

        $sets = [];
        foreach ($state->values as $column => $value) {
            $sets[] = $this->wrap(value: $column) . ' = ?';
            $state->addBinding(value: $value);
        }

        $setClause = 'SET ' . implode(separator: ', ', array: $sets);
        $wheres = $this->compileWheres(state: $state);

        return trim(string: "UPDATE {$table} {$setClause} {$wheres}");
    }

    /**
     * Compile a DELETE statement based on the provided filter state.
     *
     * -- intent: transform query criteria into a destructive SQL command.
     *
     * @param QueryState $state Target state
     *
     * @return string
     */
    public function compileDelete(QueryState $state): string
    {
        $table  = $this->wrap(value: $state->from);
        $wheres = $this->compileWheres(state: $state);

        return trim(string: "DELETE FROM {$table} {$wheres}");
    }
}

=== QueryBuilder/Core/Grammar/GrammarInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\QueryState;

/**
 * Functional contract for translating query builder state into dialect-specific SQL.
 *
 * -- intent: decouple the logical representation of a query from its physical SQL dialect.
 */
interface GrammarInterface
{
    /**
     * Compile a full SELECT statement from the provided query state.
     *
     * -- intent: transform the metadata container into a valid SQL retrieval string.
     *
     * @param QueryState $state Current builder parameters
     *
     * @return string
     */
    public function compileSelect(QueryState $state): string;

    /**
     * Compile a technical INSERT statement.
     *
     * -- intent: transform the mutation state into a valid SQL insertion string.
     *
     * @param QueryState $state Current builder parameters
     *
     * @return string
     */
    public function compileInsert(QueryState $state): string;

    /**
     * Compile a technical UPDATE statement.
     *
     * -- intent: transform the mutation state and filters into a valid SQL modification string.
     *
     * @param QueryState $state Current builder parameters
     *
     * @return string
     */
    public function compileUpdate(QueryState $state): string;

    /**
     * Compile a technical DELETE statement.
     *
     * -- intent: transform the query criteria into a valid SQL removal string.
     *
     * @param QueryState $state Current builder parameters
     *
     * @return string
     */
    public function compileDelete(QueryState $state): string;

    /**
     * Securely wrap a database identifier (table or column) or Expression.
     *
     * -- intent: protect against reserved keyword conflicts and SQL injection risks.
     *
     * @param mixed $value Technical name or Expression object
     *
     * @return string
     */
    public function wrap(mixed $value): string;
}

=== QueryBuilder/Core/Grammar/MySQLGrammar.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\QueryState;
use Override;

/**
 * Specialized technician for compiling SQL according to the MySQL/MariaDB dialect.
 *
 * -- intent: override base grammar logic for MySQL-specific syntax (Backticks, Upsert, etc).
 */
final class MySQLGrammar extends BaseGrammar
{
    /**
     * Compile an UPSERT (INSERT ... ON DUPLICATE KEY UPDATE) statement.
     *
     * -- intent: leverage MySQL's specific atomicity logic for conditional data mutations.
     *
     * @param QueryState $state    Target metadata
     * @param array      $uniqueBy Unused in MySQL implementation as it relies on schema keys
     * @param array      $update   Columns to refresh on conflict
     *
     * @return string
     */
    public function compileUpsert(QueryState $state, array $uniqueBy, array $update) : string
    {
        $sql = $this->compileInsert(state: $state);
        $sql .= " ON DUPLICATE KEY UPDATE ";

        $updates = [];
        foreach ($update as $column) {
            $updates[] = $this->wrap(value: $column) . " = VALUES(" . $this->wrap(value: $column) . ")";
        }

        return $sql . implode(separator: ', ', array: $updates);
    }

    /**
     * Securely wrap a database identifier using MySQL's backtick convention.
     *
     * -- intent: provide dialect-safe escaping for tables and columns in MySQL.
     *
     * @param string $value Technical name
     *
     * @return string
     */
    #[Override]
    public function wrap(string $value) : string
    {
        if ($value === '*' || str_contains(haystack: $value, needle: '(')) {
            return $value;
        }

        return '`' . str_replace(search: '`', replace: '``', subject: $value) . '`';
    }

    /**
     * Generate the MySQL-specific random ordering expression.
     *
     * -- intent: provide a pragmatic shorthand for the RAND() function.
     *
     * @return string
     */
    public function compileRandomOrder() : string
    {
        return 'RAND()';
    }

    /**
     * Compile a MySQL TRUNCATE statement to purge a table.
     *
     * -- intent: provide a high-performance command for record resets in MySQL.
     *
     * @param string $table Target table
     *
     * @return string
     */
    public function compileTruncate(string $table) : string
    {
        return 'TRUNCATE TABLE ' . $this->wrap(value: $table);
    }

    /**
     * Compile a MySQL DROP TABLE IF EXISTS statement.
     *
     * -- intent: provide a safe structural modification command for MySQL.
     *
     * @param string $table Target table
     *
     * @return string
     */
    public function compileDropIfExists(string $table) : string
    {
        return 'DROP TABLE IF EXISTS ' . $this->wrap(value: $table);
    }
}



=== QueryBuilder/DTO/MutationResult.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\DTO;

/**
 * Immutable value object representing the result of a database mutation operation.
 *
 * -- intent: provide both success status and affected row count for INSERT/UPDATE/DELETE operations.
 * -- design: enables flexible return type handling while maintaining type safety.
 */
final readonly class MutationResult
{
    /**
     * @param int $affectedRows Number of rows affected by the mutation
     */
    public function __construct(public int $affectedRows) {}

    /**
     * Check if the mutation was successful (at least one row affected).
     *
     * @return bool
     */
    public function isSuccessful(): bool
    {
        return $this->affectedRows > 0;
    }

    /**
     * Get the number of affected rows.
     *
     * @return int
     */
    public function getAffectedRows(): int
    {
        return $this->affectedRows;
    }

    /**
     * Static factory for creating a successful result.
     *
     * @param int $count Number of affected rows
     *
     * @return self
     */
    public static function success(int $count): self
    {
        return new self(affectedRows: $count);
    }

    /**
     * Static factory for creating a failed result (no rows affected).
     *
     * @return self
     */
    public static function none(): self
    {
        return new self(affectedRows: 0);
    }
}

=== QueryBuilder/Enums/Operator.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Enums;

/**
 * Domain-fluent enumeration of supported SQL comparison operators.
 *
 * -- intent: provide a type-safe way to reference logical comparison strings.
 */
enum Operator: string
{
    case EQUAL         = '=';
    case NOT_EQUAL     = '!=';
    case GREATER_THAN  = '>';
    case LESS_THAN     = '<';
    case GREATER_EQUAL = '>=';
    case LESS_EQUAL    = '<=';
    case LIKE          = 'LIKE';
    case NOT_LIKE      = 'NOT LIKE';
    case IN            = 'IN';
    case NOT_IN        = 'NOT IN';
}

=== QueryBuilder/Enums/QueryBuilderEnum.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Enums;

/**
 * Technical base class for all enumerations used within the QueryBuilder domain.
 *
 * -- intent: centralize common enum-specific utility methods.
 */
abstract class QueryBuilderEnum
{
    /**
     * Retrieve all defined values for the enumeration.
     *
     * -- intent: provide a programmatic way to list all valid enum cases.
     *
     * @return array
     */
    abstract public static function values() : array;
}

=== QueryBuilder/Exceptions/InvalidCriteriaException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;

/**
 * Triggered when the query builder receives malformed or dangerous criteria.
 *
 * -- intent: prevent SQL injection and logical errors at the DSL level.
 */
final class InvalidCriteriaException extends DatabaseException
{
    /**
     * Constructor capturing the problematic method and reason.
     *
     * -- intent: provide specific feedback on which builder method was misused.
     *
     * @param string $method Technical name of the builder method
     * @param string $reason Human-readable explanation of why the input is invalid
     */
    #[Override]
    public function __construct(
        private readonly string $method,
        string                  $reason
    )
    {
        parent::__construct(message: "Invalid criteria in [{$method}]: {$reason}");
    }

    /**
     * Retrieve the name of the method where the error originated.
     *
     * -- intent: pinpoint the logical source of the usage error.
     *
     * @return string
     */
    public function getMethod() : string
    {
        return $this->method;
    }
}



=== QueryBuilder/Exceptions/QueryException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * Specialized exception for failures occurring during SQL compilation or execution.
 *
 * -- intent: provide diagnostic context including the failing SQL and its parameter bindings.
 */
class QueryException extends DatabaseException
{
    /**
     * Constructor promoting diagnostic properties via PHP 8.3 features.
     *
     * -- intent: capture the full state of the failure for debugging and logging.
     *
     * @param string         $message  Technical failure description
     * @param string         $sql      The dialect-specific SQL string that failed
     * @param array          $bindings Secure parameter values used in the query
     * @param Throwable|null $previous The underlying driver exception
     */
    #[Override]
    public function __construct(
        string                  $message,
        private readonly string $sql,
        private readonly array  $bindings = [],
        Throwable|null          $previous = null
    )
    {
        parent::__construct(message: $message, code: 0, previous: $previous);
    }

    /**
     * Retrieve the failing SQL statement.
     *
     * -- intent: expose the problematic query for technical analysis.
     *
     * @return string
     */
    public function getSql() : string
    {
        return $this->sql;
    }

    /**
     * Retrieve the parameter bindings used with the failing statement.
     *
     * -- intent: expose the provided data values for debugging.
     *
     * @return array
     */
    public function getBindings() : array
    {
        return $this->bindings;
    }
}



=== QueryBuilder/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Identity\IdentityMap;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Database\QueryBuilder\Core\Executor\PDOExecutor;
use Avax\Database\QueryBuilder\Core\Grammar\MySQLGrammar;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;

/**
 * Functional module responsible for the domain-fluent QueryBuilder feature.
 *
 * -- intent: coordinate the registration of SQL grammars, executors, and builder recipes.
 */
final class Module implements LifecycleInterface
{
    /**
     * Constructor promoting the foundation container via PHP 8.3 features.
     *
     * -- intent: link the module to the central dependency injection system.
     *
     * @param Container $container The active DI vessel
     */
    public function __construct(
        private readonly Container $container
    ) {}

    public static function declare() : array
    {
        return [
            'name'  => 'queryBuilder',
            'class' => self::class
        ];
    }

    /**
     * Register QueryBuilder services into the foundation container.
     *
     * -- intent: define the resolution recipes for compilers, executors, and the builder.
     *
     * @return void
     */
    public function register() : void
    {
        $this->container->singleton(abstract: QueryBuilder::class, concrete: function ($c) {
            return new QueryBuilder(
                grammar           : new MySQLGrammar(),
                executor          : new PDOExecutor(connection: $c->get(id: DatabaseConnection::class)),
                transactionManager: $c->get(id: TransactionManagerInterface::class),
                identityMap       : $c->get(id: IdentityMap::class)
            );
        });
    }

    /**
     * Perform initialization logic for the query builder feature.
     *
     * -- intent: ensure the feature is ready for use after registration.
     *
     * @return void
     */
    public function boot() : void
    {
        // No additional boot logic required for query builder
    }

    /**
     * Gracefully terminate the query builder feature resources.
     *
     * -- intent: signal the end of the query builder's availability.
     *
     * @return void
     */
    public function shutdown() : void
    {
        // Shutdown logic if required
    }
}

=== QueryBuilder/ValueObjects/Expression.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\ValueObjects;

use Stringable;

/**
 * Represents a raw SQL expression that should not be escaped or parameterized.
 *
 * -- intent: allow developers to inject literal SQL fragments for advanced operations.
 * -- design: immutable value object implementing Stringable for seamless integration.
 */
final readonly class Expression implements Stringable
{
    /**
     * @param string $value The raw SQL fragment
     */
    public function __construct(public string $value) {}

    /**
     * Retrieve the raw SQL expression as a string.
     *
     * @return string
     */
    public function __toString(): string
    {
        return $this->value;
    }

    /**
     * Get the raw SQL value.
     *
     * @return string
     */
    public function getValue(): string
    {
        return $this->value;
    }
}

=== tests/Connection/ConnectionPoolTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Connection;

use Avax\Database\Connection\ConnectionPool;
use Avax\Tests\TestCase;
use Psr\Log\NullLogger;

class ConnectionPoolTest extends TestCase
{
    public function testConnectionPoolInitialization() : void
    {
        $pool = new ConnectionPool(
            ['connections' => ['mysql' => ['driver' => 'mysql']]],
            new NullLogger()
        );

        $this->assertInstanceOf(ConnectionPool::class, $pool);
    }

    public function testPruneStaleConnections() : void
    {
        $pool = new ConnectionPool([], new NullLogger());

        // This is a unit test, so we can't easily test real connections
        // but we can verify the method exists and runs.
        $pool->pruneStaleConnections();
        $this->assertTrue(true);
    }
}



=== tests/Core/KernelTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Core;

use Avax\Database\Core\Container;
use Avax\Database\Core\EventBus;
use Avax\Database\Core\Registry;
use Avax\Database\Kernel;
use Avax\Tests\TestCase;

class KernelTest extends TestCase
{
    public function testKernelIsSingleton() : void
    {
        $instance1 = Kernel::getInstance();
        $instance2 = Kernel::getInstance();

        $this->assertSame($instance1, $instance2);
    }

    public function testKernelResolvesCoreServices() : void
    {
        $container = $this->kernel->getContainer();

        $this->assertInstanceOf(Container::class, $container->resolve('container'));
        $this->assertInstanceOf(Registry::class, $container->resolve('registry'));
        $this->assertInstanceOf(EventBus::class, $container->resolve('events'));
    }

    public function testKernelIsBootstrapped() : void
    {
        $container = $this->kernel->getContainer();

        $this->assertTrue($container->has('config'));
        $this->assertEquals('sqlite', $container->resolve('config')->get('database.default'));
    }
}

=== tests/Migration/MigrationTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Migration;

use Avax\Database\Modules\Migration\Blueprint;
use Avax\Database\Modules\Migration\TableRenderer;
use Avax\Tests\TestCase;

class MigrationTest extends TestCase
{
    public function testBlueprintGeneratesColumns() : void
    {
        $blueprint = new Blueprint('users');
        $blueprint->id();
        $blueprint->string('email');
        $blueprint->timestamps();

        $this->assertCount(4, $blueprint->getColumns());
    }

    public function testTableRendererGeneratesSQL() : void
    {
        $blueprint = new Blueprint('users');
        $blueprint->id();
        $blueprint->string('name');

        $sql = TableRenderer::renderCreate($blueprint);

        $this->assertStringContainsString('CREATE TABLE `users`', $sql);
        $this->assertStringContainsString('`id`', $sql);
        $this->assertStringContainsString('`name`', $sql);
    }
}

=== tests/QueryBuilder/BuilderTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Query;

use Avax\Database\Database;
use Avax\Database\Modules\Query\Builder\QueryBuilder;
use Avax\Database\Modules\Query\Query;
use Avax\Tests\TestCase;
use Override;
use Throwable;

class BuilderTest extends TestCase
{
    public function testBasicSelect() : void
    {
        $results = Query::table('users')->select('id', 'name')->get();

        $this->assertCount(1, $results);
        $this->assertEquals('John Doe', $results[0]['name']);
    }

    public function testWhereClauses() : void
    {
        $builder = Query::table('users')->where('id', 1)->orWhere('email', 'test@example.com');

        $this->assertInstanceOf(QueryBuilder::class, $builder);
    }

    public function testJoins() : void
    {
        $builder = Query::table('users')
            ->join('posts', 'users.id', '=', 'posts.user_id')
            ->select('users.name', 'posts.title');

        $this->assertInstanceOf(QueryBuilder::class, $builder);
    }

    public function testAggregates() : void
    {
        $count = Query::table('users')->count();

        $this->assertSame(1, $count);
    }

    /**
     * @throws Throwable
     */
    #[Override]
    protected function setUp() : void
    {
        parent::setUp();

        // Create the users table for testing
        Database::schema()->create('users', function ($table) {
            $table->id();
            $table->string('name');
            $table->string('email');
            $table->timestamps();
        });

        // Seed some data
        Database::table('users')->insert(['name' => 'John Doe', 'email' => 'john@example.com']);
    }
}

=== tests/TestCase.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests;

use Avax\Database\Kernel;
use PHPUnit\Framework\TestCase as BaseTestCase;

abstract class TestCase extends BaseTestCase
{
    protected Kernel $kernel;

    protected function setUp() : void
    {
        parent::setUp();

        $this->kernel = Kernel::getInstance();
        $this->kernel->bootstrap([
                                     'database' => [
                                         'default'     => 'sqlite',
                                         'connections' => [
                                             'sqlite' => [
                                                 'driver'   => 'sqlite',
                                                 'database' => ':memory:',
                                                 'prefix'   => '',
                                             ]
                                         ]
                                     ]
                                 ]);
    }

    protected function tearDown() : void
    {
        $this->kernel->shutdown();
        parent::tearDown();
    }
}

