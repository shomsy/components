=== Connection/ConnectionPool.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Connection;

use Exception;
use Gemini\Database\Connection\Contracts\ConnectionPoolInterface;
use PDO;
use Psr\Log\LoggerInterface;
use RuntimeException;

/**
 * Class ConnectionPool
 *
 * Manages a pool of PDO connections to improve efficiency and reuse within an application.
 * Implements the ConnectionPoolInterface to allow for consistent connection handling.
 *
 * Features:
 * - Supports named database connections (`mysql`, `pgsql`, `sqlite`, `sqlsrv`).
 * - Automatically initializes and pools connections.
 * - Efficiently reuses available connections.
 * - Ensures that connections are alive before reuse.
 * - Implements exception handling and logging.
 */
class ConnectionPool implements ConnectionPoolInterface
{
    /** @var array<string, PDO> Active connections stored by name. */
    private array $connections = [];

    /** @var array<string, array> Configuration settings for all connections. */
    private array           $config;

    private LoggerInterface $logger;

    private int             $maxConnections;

    /**
     * ConnectionPool constructor.
     *
     * @param array           $config         Database configuration array.
     * @param LoggerInterface $logger         Logger for handling errors and connection issues.
     * @param int             $maxConnections Maximum number of connections allowed per database.
     */
    public function __construct(
        array           $config,
        LoggerInterface $logger,
        int             $maxConnections = 5
    ) {
        $this->config         = $config['connections'] ?? [];
        $this->logger         = $logger;
        $this->maxConnections = $maxConnections;
    }

    /**
     * Retrieves an available database connection by name.
     *
     * @param string|null $connectionName The database connection to retrieve.
     *
     * @return PDO The active PDO connection.
     *
     * @throws RuntimeException If the requested connection is not configured.
     */
    public function getConnection(string|null $connectionName = null) : PDO
    {
        $connectionName ??= config(key: 'database.default', default: 'mysql');

        if (! isset($this->config[$connectionName])) {
            throw new RuntimeException(message: "Database connection '{$connectionName}' is not configured.");
        }

        if (isset($this->connections[$connectionName])
            && $this->isConnectionAvailable(pdo: $this->connections[$connectionName])
        ) {
            return $this->connections[$connectionName];
        }

        if (count($this->connections) < $this->maxConnections) {
            return $this->initializeConnection(connectionName: $connectionName);
        }

        throw new RuntimeException(message: "Connection pool limit reached for '{$connectionName}'.");
    }

    /**
     * Checks if the given PDO connection is still available and functional.
     *
     * @param PDO $pdo The PDO connection instance to check.
     *
     * @return bool Returns true if the connection is valid, false otherwise.
     */
    private function isConnectionAvailable(PDO $pdo) : bool
    {
        try {
            return $pdo->query(query: 'SELECT 1') !== false;
        } catch (Exception) {
            return false;
        }
    }

    /**
     * Initializes a new database connection.
     *
     * @param string $connectionName The name of the database connection.
     *
     * @return PDO The newly created PDO connection.
     *
     * @throws RuntimeException If connection fails.
     */
    private function initializeConnection(string $connectionName) : PDO
    {
        try {
            $config = $this->config[$connectionName];

            $pdo = new PDO(
                dsn     : $config['connection'],
                username: $config['username'] ?? null,
                password: $config['password'] ?? null,
                options : $config['options'] ?? []
            );

            $pdo->setAttribute(attribute: PDO::ATTR_ERRMODE, value: PDO::ERRMODE_EXCEPTION);
            $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

            $this->connections[$connectionName] = $pdo;

            $this->logger->info(message: "Successfully connected to '{$connectionName}' database.");

            return $pdo;
        } catch (Exception $e) {
            $this->logger->error(message: "Failed to connect to '{$connectionName}': {$e->getMessage()}");
            throw new RuntimeException(message: "Database connection failed: {$e->getMessage()}", previous: $e);
        }
    }

    /**
     * Releases a connection back into the pool.
     *
     * @param PDO $pdo The PDO connection to release.
     */
    public function releaseConnection(PDO $pdo) : void
    {
        foreach ($this->connections as $name => $connection) {
            if ($connection === $pdo) {
                $this->logger->info(message: "Releasing connection for '{$name}' back to the pool.");

                return;
            }
        }

        $this->logger->warning(message: 'Attempted to release an unknown connection.');
    }
}
=== Connection/Contracts/ConnectionPoolInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Connection\Contracts;

use PDO;

interface ConnectionPoolInterface
{
    /**
     * Retrieves a database connection by name.
     *
     * @param string|null $connectionName The name of the database connection.
     *
     * @return PDO The active PDO connection.
     */
    public function getConnection(string|null $connectionName = null) : PDO;

    /**
     * Releases a connection back to the pool.
     *
     * @param PDO $pdo The PDO connection instance.
     */
    public function releaseConnection(PDO $pdo) : void;
}

=== DatabaseConnection.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database;

use Gemini\Database\Connection\Contracts\ConnectionPoolInterface;
use PDO;
use Psr\Log\LoggerInterface;
use RuntimeException;
use Throwable;

/**
 * **DatabaseConnection**
 *
 * Manages secure and optimized database connections using a connection pool.
 *
 * âœ… **Key Features**
 * - Connection Pooling for optimal performance.
 * - Secure Connection Handling (Prevents leaks).
 * - Enterprise-Grade Logging & Error Handling.
 * - Enforces `PDO::ATTR_EMULATE_PREPARES = false` to prevent SQL Injection.
 * - Read/Write Connection Support.
 *
 * ðŸ† **Best Practices Implemented**
 * - **SRP (Single Responsibility Principle)** â†’ Only manages database connections.
 * - **DIP (Dependency Inversion Principle)** â†’ Uses an interface for loose coupling.
 * - **Fail-Fast Principle** â†’ Throws exceptions immediately on failures.
 * - **Security Best Practices** â†’ Prevents SQL Injection, connection leaks, and enforces strict error handling.
 *
 * Usage:
 * ```
 * $databaseConnection = new DatabaseConnection($connectionPool, $logger);
 * $pdo = $databaseConnection->getConnection('mysql');
 * $databaseConnection->releaseConnection($pdo);
 * ```
 */
readonly class DatabaseConnection
{
    /**
     * Initializes the database connection manager.
     *
     * @param ConnectionPoolInterface $connectionPool The connection pool instance.
     * @param LoggerInterface         $logger         The logger for structured logging.
     */
    public function __construct(
        private ConnectionPoolInterface $connectionPool,
        private LoggerInterface         $logger
    ) {}

    /**
     * Releases a database connection back into the pool.
     *
     * âœ… **Ensures Proper Resource Management**
     * - Avoids connection leaks by returning the connection to the pool.
     * - Logs successful release operations.
     *
     * @param PDO $pdo The connection to release.
     */
    public function releaseConnection(PDO $pdo) : void
    {
        $this->connectionPool->releaseConnection(pdo: $pdo);
        $this->logger->info(message: "Database connection successfully released.");
    }

    /**
     * Checks if the database connection is alive.
     *
     * âœ… **Fail-Fast Design**
     * - Executes a lightweight `SELECT 1` query to test the connection.
     * - Logs failures for monitoring.
     *
     * @param string|null $connectionName Optional connection name.
     *
     * @return bool `true` if the connection is active, `false` otherwise.
     */
    public function testConnection(string|null $connectionName = null) : bool
    {
        try {
            $pdo = $this->getConnection(connectionName: $connectionName);
            $pdo->query(query: 'SELECT 1');

            return true;
        } catch (Throwable $exception) {
            $this->logger->warning(
                message: "Database connection test failed.",
                context: [
                             'connection' => $connectionName,
                             'error'      => $exception->getMessage(),
                         ]
            );

            return false;
        }
    }

    /**
     * Retrieves a secure database connection from the pool.
     *
     * âœ… **Security Enhancements**
     * - Enforces `PDO::ATTR_EMULATE_PREPARES = false` to prevent SQL Injection.
     * - Ensures only valid connection names are used.
     *
     * @param string|null $connectionName Optional connection name (default: primary connection).
     *
     * @return PDO A secure, pooled database connection.
     *
     * @throws RuntimeException If the connection cannot be established.
     */
    public function getConnection(string|null $connectionName = null) : PDO
    {
        try {
            // Retrieve a database connection from the connection pool.
            // The variable `$connectionName` specifies the name of the database connection to use.
            $pdo = $this->connectionPool->getConnection(connectionName: $connectionName);
            // âœ… Security Hardening â€“ Ensure emulated prepares are disabled to prevent SQL Injection.
            $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

            return $pdo;
        } catch (Throwable $exception) {
            $this->logger->error(
                message: "Database connection error: " . $exception->getMessage(),
                context: [
                             'connection' => $connectionName,
                             'trace'      => $exception->getTraceAsString(),
                         ]
            );

            throw new RuntimeException(message: "Failed to establish a secure database connection.");
        }
    }
}

=== Migration/Design/Column/Builder/ColumnAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Builder;

use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Represents an immutable value object for column metadata in database migrations.
 *
 * This class encapsulates database column attributes in a strongly-typed, immutable
 * structure, providing a clean interface for accessing column properties. It serves
 * as a read-only facade over the underlying ColumnAttributesDTO data.
 *
 * @property string                     $name
 * @property ColumnType                 $type
 * @property int|null                   $length
 * @property int|null                   $precision
 * @property int|null                   $scale
 * @property bool|null                  $nullable
 * @property bool|null                  $unsigned
 * @property bool|null                  $autoIncrement
 * @property bool|null                  $primary
 * @property bool|null                  $unique
 * @property string|int|float|bool|null $default
 * @property array<string>|null         $enum
 * @property string|null                $generated
 * @property string|null                $after
 * @property bool|null                  $useCurrent
 * @property bool|null                  $useCurrentOnUpdate
 * @property string|null                $alias
 * @property string|null                $comment
 * @property array<string, mixed>       $foreign
 * @property array<string, mixed>       $columns
 *
 * @final     This class is not designed for inheritance
 * @immutable This class represents an immutable value object
 * @pattern   Value Object - Encapsulates column attributes in an immutable structure
 */
final class ColumnAttributes
{
    /**
     * Stores the internal attribute collection extracted from the DTO.
     *
     * The properties array maintains a key-value mapping of all column attributes,
     * providing O(1) access time for attribute lookups while maintaining
     * encapsulation of the underlying data structure.
     *
     * @var array<string, mixed> Key-value pairs of column attributes
     */
    private array $properties;

    /**
     * Constructs a new immutable ColumnAttributes instance.
     *
     * Uses constructor property promotion for concise initialization
     * while maintaining clean code principles through explicit type declarations
     * and validation at instantiation.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column metadata
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $fromDto          = $this->dto;
        $this->properties = get_object_vars($fromDto);
    }

    /**
     * Creates a minimal column definition with essential attributes.
     *
     * Factory method implementing the named parameters pattern for improved
     * readability and maintainability. Provides a convenient way to create
     * basic column definitions without full DTO instantiation.
     *
     * @param string     $name The logical identifier for the column
     * @param ColumnType $type The SQL data type specification
     *
     * @return self New instance with minimal column configuration
     * @throws \ReflectionException When DTO instantiation fails
     */
    public static function make(
        string     $name,
        ColumnType $type
    ) : self {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Provides dynamic access to column attributes via property syntax.
     *
     * Implements magic getter following clean code principles by providing
     * clear error messages and type-safe access to internal properties.
     *
     * @param string $name The attribute name to retrieve
     *
     * @return mixed The value of the requested attribute
     * @throws RuntimeException When accessing undefined attributes
     */
    public function __get(string $name) : mixed
    {
        if (! array_key_exists($name, $this->properties)) {
            throw new RuntimeException(
                message: sprintf('Column attribute "%s" does not exist.', $name)
            );
        }

        return $this->properties[$name];
    }

    /**
     * Supports PHP's isset() and empty() operations on attributes.
     *
     * Provides a clean interface for attribute existence checking while
     * maintaining encapsulation of internal property storage.
     *
     * @param string $name The attribute name to check
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function __isset(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Explicitly verifies the existence of a column attribute.
     *
     * Provides a more semantic alternative to isset() for attribute checking,
     * following clean code principles with clear method naming.
     *
     * @param string $name The attribute name to verify
     *
     * @return bool True if the attribute exists, false otherwise
     */
    public function has(string $name) : bool
    {
        return array_key_exists($name, $this->properties);
    }

    /**
     * Retrieves an attribute value with optional default fallback.
     *
     * Implements null coalescing operator for safe attribute access,
     * following defensive programming practices.
     *
     * @param string     $name    The attribute name to retrieve
     * @param mixed|null $default The fallback value if attribute doesn't exist
     *
     * @return mixed The attribute value or default
     */
    public function get(string $name, mixed $default = null) : mixed
    {
        return $this->properties[$name] ?? $default;
    }

    /**
     * Exports all column attributes as an associative array.
     *
     * Provides a clean interface for serialization while maintaining
     * immutability of the internal property collection.
     *
     * @return array<string, mixed> Complete map of column attributes
     */
    public function toArray() : array
    {
        return $this->properties;
    }
}

=== Migration/Design/Column/Column.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLDefaults;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use RuntimeException;

/**
 * Factory and macro layer for fluent column construction.
 *
 * Delegates schema building to ColumnDefinition while also exposing
 * DDD-safe shortcuts like `id()`, `timestamps()`, etc.
 *
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final readonly class Column
{
    use ColumnDSLDefaults;

    /**
     * Creates a ColumnDefinition via a DSL method call
     *
     * This method dynamically interprets the method name (e.g., `string`, `decimal`)
     * and maps it to an enum `ColumnType`, while applying appropriate DSL parameters.
     *
     * DSL-idiomatic:
     * - $table->string('name', 255)
     * - $table->decimal('price', 10, 2)
     * - $table->enum('type', ['free', 'paid'])
     *
     * @param string            $method    The column type method (e.g., 'string', 'decimal')
     * @param array<int, mixed> $arguments DSL arguments passed (name, length/precision/etc.)
     *
     * @return ColumnDefinition Returns a fully constructed column schema node
     *
     * @throws RuntimeException If the first argument (column name) is missing or invalid
     * @throws \ReflectionException
     */
    public function create(string $method, array $arguments) : ColumnDefinition
    {
        /**
         * Destructure the DSL arguments for clarity and DSL alignment.
         *
         * - $name: Column name (required)
         * - $size: Size, length, precision (optional)
         * - $details: Enum options or scale (optional)
         */
        [$name, $size, $details] = array_pad($arguments, 3, null);

        // Defensive: Fail early if column name is not provided
        if (empty($name) || ! is_string($name)) {
            throw new RuntimeException(message: "Missing or invalid column name for method: '{$method}'");
        }

        // Normalize method to ColumnType Enum (via alias support)
        $type = ColumnType::map(input: $method);

        // Dynamically collect any additional DSL parameters
        $attributes = match ($type) {
            ColumnType::VARCHAR,
            ColumnType::CHAR  => ['length' => $size ?? 255],

            ColumnType::DECIMAL,
            ColumnType::DOUBLE,
            ColumnType::FLOAT => [
                'precision' => $size ?? 10,
                'scale'     => $details ?? 2,
            ],

            ColumnType::ENUM,
            ColumnType::SET   => ['enum' => is_array($size) ? $size : []],

            default           => []
        };

        // Wrap all attributes in a strict, validated DTO
        $dto = new ColumnAttributesDTO(
            data: array_merge(
                      ['name' => $name, 'type' => $type],
                      $attributes
                  )
        );

        // Create immutable column node using named constructor
        return ColumnDefinition::make(
            name: $dto->name,
            type: $dto->type
        );
    }

}
=== Migration/Design/Column/DSL/ColumnDefinition.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLKeyConstraints;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLSemantics;
use Gemini\Database\Migration\Design\Column\DSL\FluentModifiers\ColumnDSLTypeAttributes;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use InvalidArgumentException;

/**
 * Represents a fluent interface for defining database column schemas.
 *
 * This value object encapsulates the definition of a database column using a Domain-Specific Language (DSL)
 * approach. It implements the Builder pattern through a fluent interface, allowing for expressive
 * and type-safe column definitions.
 *
 * @package   Gemini\Database\Migration\Design\Column\DSL
 * @final     This class is not intended for extension
 * @immutable This class represents an immutable value object
 *
 *
 * ```php
 * $column = ColumnDefinition::make('user_id', ColumnType::INTEGER)
 *     ->unsigned()
 *     ->notNull()
 *     ->primary();
 * ```
 */
final class ColumnDefinition
{
    use ColumnDSLSemantics;
    use ColumnDSLKeyConstraints;
    use ColumnDSLTypeAttributes;

    /**
     * Encapsulates the internal state of the column definition.
     *
     * This property maintains the complete state of the column definition
     * through a dedicated value object, ensuring immutability and encapsulation
     * of the column attributes.
     *
     * @var ColumnAttributes
     */
    private ColumnAttributes $builder;

    /**
     * Initializes a new column definition instance.
     *
     * Constructs the column definition from a validated DTO containing
     * the essential column attributes. Uses constructor promotion for
     * clean and efficient initialization.
     *
     * @param ColumnAttributesDTO $dto Validated data transfer object containing column attributes
     */
    public function __construct(private readonly ColumnAttributesDTO $dto)
    {
        $this->builder = new ColumnAttributes(dto: $dto);
    }

    /**
     * Creates a new column definition using a fluent interface.
     *
     * Factory method implementing the Named Constructor pattern to provide
     * a more expressive way of creating column definitions.
     *
     * @param string     $name The logical name of the column
     * @param ColumnType $type The SQL data type for the column
     *
     * @return self New column definition instance
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public static function make(string $name, ColumnType $type) : self
    {
        return new self(
            dto: new ColumnAttributesDTO(
                     data: [
                               'name' => $name,
                               'type' => $type,
                           ]
                 )
        );
    }

    /**
     * Renders the column definition as an SQL string.
     *
     * Delegates the actual rendering to a dedicated renderer class,
     * following the Single Responsibility Principle.
     *
     * @return string The complete SQL column definition
     */
    public function __toString() : string
    {
        return ColumnSQLRenderer::render(column: $this->getBuilder());
    }

    /**
     * Retrieves the internal column attributes builder.
     *
     * Provides access to the underlying value object containing
     * the complete column definition state.
     *
     * @return ColumnAttributes The immutable column attributes value object
     */
    public function getBuilder() : ColumnAttributes
    {
        return $this->builder;
    }

    /**
     * Gets the logical name of the column.
     *
     * Provides direct access to the column's identifier without
     * exposing the internal builder implementation.
     *
     * @return string The column's identifier
     */
    public function columnName() : string
    {
        return $this->builder->name;
    }

    /**
     * Modifies the column definition by adding or updating column specifications.
     *
     * This method implements the immutable modification pattern, creating a new
     * instance with updated column specifications while preserving the original
     * definition. It follows the immutability principle essential for maintaining
     * a predictable state in domain-driven design.
     *
     * @param array<string, mixed> $columns New column specifications to be applied
     *
     * @return self New instance with updated column specifications
     * @throws \ReflectionException When reflection fails during DTO construction
     */

    public function columns(array $columns) : self
    {
        if (empty($columns)) {
            throw new InvalidArgumentException(message: 'Column names array cannot be empty.');
        }

        $this->validateColumnNames($columns);

        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Validates the integrity of column names in a database schema definition.
     *
     * This method ensures that the provided column names meet the following criteria:
     * - Must be provided as a sequential array (list)
     * - Each element must be a non-empty string
     *
     * Part of the database schema validation layer that maintains data structure integrity.
     *
     * @param array<int, string> $columnNames Sequential array of column identifiers
     *
     * @throws InvalidArgumentException When validation fails due to invalid format or content
     */
    private function validateColumnNames(array $columnNames) : void
    {
        // Validate that the array is a sequential list and all elements are strings
        if (! array_is_list($columnNames)
            || array_filter($columnNames, static fn(mixed $column) : bool => ! is_string($column))
        ) {
            throw new InvalidArgumentException(
                message: 'All column names must be non-empty strings.'
            );
        }
    }
}
=== Migration/Design/Column/DSL/FluentModifiers/ColumnDSLDefaults.php ===
<?php

declare(strict_types=1);

/**
 * Domain-Specific Language (DSL) for Database Schema Design.
 *
 * This namespace encapsulates the column definition DSL components,
 * providing a fluent interface for database schema manipulation.
 */

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Domain-Specific Column Definition Defaults Trait.
 *
 * Provides a collection of standardized column definitions following Domain-Driven Design principles.
 * This trait encapsulates common database schema patterns, offering a semantic layer
 * above raw SQL definitions to express business domain concepts.
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 * @since   1.0.0
 */
trait ColumnDSLDefaults
{
    /**
     * Defines a standardized auto-incrementing primary key identifier.
     *
     * Implements the Identity Field pattern using a BIGINT type to ensure
     * sufficient capacity for large datasets. This follows the ubiquitous
     * language principle of DDD by providing a clear, domain-focused identifier.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function id() : ColumnDefinition
    {
        // Create a primary key column with auto-increment capability
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::BIGINT
        )
            ->primary()
            ->autoIncrement();
    }

    /**
     * Establishes temporal tracking for entity lifecycle events.
     *
     * Implements the Audit Trail pattern through timestamp columns that automatically
     * track entity creation and modification times. This supports both auditing
     * requirements and temporal queries within the domain.
     *
     * @return array{ColumnDefinition, ColumnDefinition} An array containing created_at and updated_at columns
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function timestamps() : array
    {
        // Define creation timestamp column
        $createdAt = ColumnDefinition::make(
            name: 'created_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Define update timestamp column
        $updatedAt = ColumnDefinition::make(
            name: 'updated_at',
            type: ColumnType::TIMESTAMP
        )->nullable();

        // Return both columns as a tuple
        return [
            $createdAt,
            $updatedAt,
        ];
    }

    /**
     * Implements the Soft Delete pattern for logical record deletion.
     *
     * Creates a nullable timestamp column that enables logical deletion without
     * a physical record removal, supporting data recovery and maintaining referential integrity.
     * This pattern is essential for maintaining audit trails and implementing undo operations.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function softDeletes() : ColumnDefinition
    {
        // Create a nullable timestamp column for soft deletes
        return ColumnDefinition::make(
            name: 'deleted_at',
            type: ColumnType::TIMESTAMP
        )->nullable();
    }

    /**
     * Establishes a UUID-based primary key for distributed systems.
     *
     * Implements a distributed-friendly primary key strategy using UUIDs,
     * enabling reliable unique identification across distributed systems
     * without central coordination. This pattern supports horizontal scaling
     * and microservices architecture.
     *
     * @return ColumnDefinition A fluent interface for column configuration
     * @throws \ReflectionException When reflection fails during object instantiation
     */
    public function uuidPrimary() : ColumnDefinition
    {
        // Create a UUID-based primary key column
        return ColumnDefinition::make(
            name: 'id',
            type: ColumnType::UUID
        )->primary();
    }

    /**
     * @throws \ReflectionException
     */
    public function char(string $name, int $length = 255) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::CHAR)
            ->length(length: $length);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function longText(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::LONGTEXT);
    }

    /**
     * @throws \ReflectionException
     */
    public function tinyInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::TINYINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function mediumInteger(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::MEDIUMINT);
    }

    /**
     * @throws \ReflectionException
     */
    public function ipAddress(string $name = 'ip_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 45);
    }

    /**
     * @throws \ReflectionException
     */
    public function macAddress(string $name = 'mac_address') : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VARCHAR)
            ->length(length: 17);
    }

    /**
     * @throws \ReflectionException
     */
    public function vector(string $name, int $dimensions = 1536) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::VECTOR)
            ->length(length: $dimensions);
    }

    /**
     * @throws \ReflectionException
     */
    public function geography(string $name) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::GEOGRAPHY);
    }
}
=== Migration/Design/Column/DSL/FluentModifiers/ColumnDSLKeyConstraints.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Enums\ReferentialAction;

/**
 * Trait ColumnDSLKeyConstraints
 *
 * Provides fluent methods for defining column-level constraints.
 * Applies strict immutability via DTO-based state mutation.
 */
trait ColumnDSLKeyConstraints
{
    /**
     * Shortcut for setting column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function pk() : ColumnDefinition
    {
        return $this->primary();
    }

    /**
     * Marks the column as PRIMARY KEY
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function primary() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['primary' => true]);
    }

    /**
     * Shortcut for setting AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function inc() : ColumnDefinition
    {
        return $this->autoIncrement();
    }

    /**
     * Marks column as AUTO_INCREMENT
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function autoIncrement() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['autoIncrement' => true]);
    }

    /**
     * Defines a FOREIGN KEY constraint
     *
     * @param string $references Referenced column
     * @param string $onTable    Target table
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function foreignKey(string $references, string $onTable) : ColumnDefinition
    {
        return $this->withModifiedAttributes(
            [
                'type'    => ColumnType::FOREIGN_KEY,
                'foreign' => [
                    'references' => $references,
                    'on'         => $onTable,
                ],
            ]
        );
    }

    /**
     * Sets ON DELETE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onDelete(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onDelete' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Sets ON UPDATE behavior for foreign key
     *
     * @param ReferentialAction $action Referential action enum
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function onUpdate(ReferentialAction $action) : ColumnDefinition
    {
        $foreign = $this->getBuilder()->foreign ?? [];

        return $this->withModifiedAttributes(
            [
                'foreign' => array_merge($foreign, [
                    'onUpdate' => $action->value,
                ]),
            ]
        );
    }

    /**
     * Defines INDEX constraint
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::INDEX)
            ->columns($columns);
    }

    /**
     * Defines UNIQUE constraint
     *
     * @param string        $name    Constraint name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::UNIQUE)
            ->columns($columns);
    }

    /**
     * Defines FULLTEXT index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::FULLTEXT)
            ->columns($columns);
    }

    /**
     * Defines SPATIAL index
     *
     * @param string        $name    Index name
     * @param array<string> $columns Affected columns
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatial(string $name, array $columns) : ColumnDefinition
    {
        return ColumnDefinition::make(name: $name, type: ColumnType::SPATIAL)
            ->columns($columns);
    }
}

=== Migration/Design/Column/DSL/FluentModifiers/ColumnDSLSemantics.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use InvalidArgumentException;

/**
 * Trait ColumnDSLSemantics
 *
 * Domain-Specific Language (DSL) fluent modifiers for expressive schema definitions.
 *
 * Each method adheres to value object principles by avoiding direct mutation.
 * Instead, modifications are applied via a `withModifiedAttributes()` builder contract,
 * ensuring immutability and enabling composability of modifiers.
 *
 * @see     ColumnDefinition
 * @see     ColumnDefinition::withModifiedAttributes()
 *
 * @package Gemini\Database\Migration\Design\Column\DSL\FluentModifiers
 */
trait ColumnDSLSemantics
{
    /**
     * Defines an ENUM type column with a fixed set of string values.
     *
     * @param array<int, string> $values Acceptable string values for ENUM constraint
     *
     * @return ColumnDefinition New column instance with ENUM type
     *
     * @throws InvalidArgumentException When the $values array is empty
     * @throws \ReflectionException
     */
    public function enum(array $values) : ColumnDefinition
    {
        if (empty($values)) {
            throw new InvalidArgumentException(message: "Enum values cannot be empty.");
        }

        return $this->withModifiedAttributes(
            [
                'type' => ColumnType::ENUM,
                'enum' => $values,
            ]
        );
    }

    /**
     * Contract: Fluent modifier mutation through immutability contract.
     *
     * @param array<string, mixed> $attributes New values to apply to builder state
     *
     * @return ColumnDefinition Mutated copy with applied attributes
     */
    abstract protected function withModifiedAttributes(array $attributes) : ColumnDefinition;

    /**
     * Defines a STORED generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated and persisted
     *
     * @return ColumnDefinition New column with stored generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function storedAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) STORED"]);
    }

    /**
     * Defines a VIRTUAL generated column from a SQL expression.
     *
     * @param string $expression SQL expression evaluated on read
     *
     * @return ColumnDefinition New column with virtual generated behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function virtualAs(string $expression) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['generated' => "AS ({$expression}) VIRTUAL"]);
    }

    /**
     * Specifies the placement of the column relative to another column.
     *
     * @param string $column Name of the reference column
     *
     * @return ColumnDefinition Column with `AFTER` clause applied
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function after(string $column) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['after' => $column]);
    }

    /**
     * Sets the default value to CURRENT_TIMESTAMP for temporal columns.
     *
     * @return ColumnDefinition Column with default timestamp behavior
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrent() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrent' => true]);
    }

    /**
     * Enables ON UPDATE CURRENT_TIMESTAMP behavior for automatic updates.
     *
     * @return ColumnDefinition Column with auto-update timestamp logic
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function useCurrentOnUpdate() : ColumnDefinition
    {
        return $this->withModifiedAttributes(['useCurrentOnUpdate' => true]);
    }

    /**
     * Sets the compound index column list for multi-column indexes.
     *
     * @param array<int, string> $columns Array of column names to index together
     *
     * @return ColumnDefinition Column with compound index config
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function columns(array $columns) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['columns' => $columns]);
    }

    /**
     * Assigns an alias to the column for use in views or generated columns.
     *
     * @param string $name Alias identifier
     *
     * @return ColumnDefinition Column with alias assigned
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function alias(string $name) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['alias' => $name]);
    }

    /**
     * Attaches a comment to the column definition for metadata purposes.
     *
     * @param string $text SQL comment text
     *
     * @return ColumnDefinition Column with comment metadata
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function comment(string $text) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['comment' => $text]);
    }

    /**
     * Sets a default value to be applied during insert operations.
     *
     * @param string|int|float|bool|null $value Default value to apply
     *
     * @return ColumnDefinition Column with default constraint
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function default(string|int|float|bool|null $value) : ColumnDefinition
    {
        return $this->withModifiedAttributes(['default' => $value]);
    }
}

=== Migration/Design/Column/DSL/FluentModifiers/ColumnDSLTypeAttributes.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DSL\FluentModifiers;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\DTO\ColumnAttributesDTO;
use InvalidArgumentException;
use ReflectionException;

/**
 * Provides a fluent interface for column-type-specific attribute modifications.
 *
 * This trait encapsulates the type-specific modifiers for database column definitions,
 * implementing an immutable fluent interface pattern. It handles common column attributes
 * such as length, precision, scale, nullability, and unsigned specifications.
 *
 * @internal This trait is intended for internal use within the column definition system
 * @api      Exposes fluent interface methods for column type modifications
 *
 * @since    1.0.0
 */
trait ColumnDSLTypeAttributes
{
    /**
     * Defines the maximum length for character-based column types.
     *
     * Immutably creates a new column definition with the specified length attribute.
     * Commonly used for VARCHAR and CHAR column types.
     *
     * @param int<1, max> $length The maximum length of the column content
     *
     * @return ColumnDefinition A new immutable instance with the length attribute
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function length(int $length) : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['length' => $length]);
    }

    /**
     * Creates a new column definition with modified attributes.
     *
     * Internal helper method implementing the immutable modification pattern.
     * Clones the current state and applies new modifications to create a fresh instance.
     *
     * @param array<string, mixed> $modifiers Key-value pairs of attributes to modify
     *
     * @return ColumnDefinition A new immutable instance with applied modifications
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    protected function withModifiedAttributes(array $modifiers) : ColumnDefinition
    {
        // Extract current state as array
        $data = $this->getBuilder()->toArray();

        // Apply new modifications
        foreach ($modifiers as $key => $value) {
            $data[$key] = $value;
        }

        // Create a new immutable instance
        return new ColumnDefinition(dto: new ColumnAttributesDTO(data: $data));
    }

    /**
     * Configures precision and scale for decimal number columns.
     *
     * Creates a new column definition with specified numeric precision attributes.
     * Ensures proper relationship between precision and scale values.
     *
     * @param positive-int $precision Total number of significant digits
     * @param positive-int $scale     Number of digits after decimal point
     *
     * @return ColumnDefinition A new immutable instance with precision settings
     * @throws ReflectionException If reflection fails during DTO instantiation
     * @throws InvalidArgumentException If precision is less than scale
     */
    public function decimal(int $precision, int $scale) : ColumnDefinition
    {
        if ($precision < $scale) {
            throw new InvalidArgumentException(
                message: 'Precision must be greater than or equal to scale.'
            );
        }

        return $this->withModifiedAttributes(
            modifiers: [
                           'precision' => $precision,
                           'scale'     => $scale,
                       ]
        );
    }

    /**
     * Marks a numeric column as unsigned.
     *
     * Creates a new column definition with the unsigned flag set.
     * Applicable only to numeric column types.
     *
     * @return ColumnDefinition A new immutable instance marked as unsigned
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function unsigned() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['unsigned' => true]);
    }

    /**
     * Marks a column as nullable.
     *
     * Creates a new column definition that allows NULL values.
     * This is a schema-level nullability setting.
     *
     * @return ColumnDefinition A new immutable instance marked as nullable
     * @throws ReflectionException If reflection fails during DTO instantiation
     */
    public function nullable() : ColumnDefinition
    {
        return $this->withModifiedAttributes(modifiers: ['nullable' => true]);
    }

    /**
     * Sets the precision (total number of digits) for numeric data types.
     *
     * This method follows the immutable modification pattern, creating a new instance
     * with the specified precision while preserving the original column definition.
     * Particularly useful for decimal, numeric, and floating-point data types.
     *
     * @param int $precision The total number of digits the column can store
     *
     * @return ColumnDefinition New immutable instance with updated precision
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function precision(int $precision) : ColumnDefinition
    {
        // Create new immutable instance with updated precision attribute
        return $this->withModifiedAttributes(['precision' => $precision]);
    }

    /**
     * Sets the scale (number of decimal places) for numeric data types.
     *
     * This method implements the immutable modification pattern, creating a new instance
     * with the specified scale while maintaining immutability. Essential for decimal
     * and numeric data types where decimal precision is required.
     *
     * @param int $scale The number of digits after the decimal point
     *
     * @return ColumnDefinition New immutable instance with updated scale
     * @throws \ReflectionException When reflection fails during DTO construction
     */
    public function scale(int $scale) : ColumnDefinition
    {
        // Create a new immutable instance with updated scale attribute
        return $this->withModifiedAttributes(['scale' => $scale]);
    }

}
=== Migration/Design/Column/DTO/ColumnAttributesDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\DTO;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Enum;
use Gemini\DataHandling\Validation\Attributes\Rules\Filled;

/**
 * Data Transfer Object representing database column attributes within the migration context.
 *
 * This immutable value object encapsulates the complete set of attributes that define
 * a database column's structure and behavior. It provides a type-safe way to transfer
 * column definitions between different layers of the application.
 *
 * @template-extends AbstractDTO<ColumnAttributesDTO>
 * @final
 */
final class ColumnAttributesDTO extends AbstractDTO
{
    /**
     * @var string The column identifier in the database schema
     */
    #[Filled]
    public string $name;

    /**
     * @var ColumnType The SQL data type of the column
     */
    #[Enum(ColumnType::class)]
    public ColumnType $type;

    /**
     * @var int|null The maximum length for string-based column types
     */
    public int|null $length = null;

    /**
     * @var int|null The total number of digits for numeric column types
     */
    public int|null $precision = null;

    /**
     * @var int|null The number of digits after the decimal point for numeric types
     */
    public int|null $scale = null;

    /**
     * @var bool|null Indicates if the column can contain NULL values
     */
    public bool|null $nullable = false;

    /**
     * @var bool|null Specifies if numeric column should be unsigned
     */
    public bool|null $unsigned = false;

    /**
     * @var bool|null Determines if column value should auto-increment
     */
    public bool|null $autoIncrement = false;

    /**
     * @var bool|null Indicates if column is part of primary key
     */
    public bool|null $primary = false;

    /**
     * @var bool|null Specifies if column values must be unique
     */
    public bool|null $unique = false;

    /**
     * @var string|int|float|bool|null Default value for the column
     */
    public string|int|float|bool|null $default = null;

    /**
     * @var array<string>|null Possible values for ENUM type columns
     */
    public array|null $enum = null;

    /**
     * @var string|null Expression for generated columns
     */
    public string|null $generated = null;

    /**
     * @var string|null Column name after which this column should be placed
     */
    public string|null $after = null;

    /**
     * @var bool|null Use current timestamp for temporal columns
     */
    public bool|null $useCurrent = false;

    /**
     * @var bool|null Update temporal columns on record modification
     */
    public bool|null $useCurrentOnUpdate = false;

    /**
     * @var string|null Alternative name for the column
     */
    public string|null $alias = null;

    /**
     * @var string|null Documentation or description for the column
     */
    public string|null $comment = null;

    /**
     * @var array<string, mixed> Foreign key relationship configuration
     */
    public array $foreign = [];

    /**
     * @var array<string, mixed> Nested column definitions for complex types
     */
    public array $columns = [];
}
=== Migration/Design/Column/Enums/ColumnType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Enum representing standardized SQL column types.
 *
 * Provides type-safe mapping to SQL-compatible type strings.
 * Improves reliability and prevents typos in column definitions.
 */
enum ColumnType: string
{
    /**
     * Uses the SupportsCaseMappedEnum trait to enable case-insensitive enum value mapping with alias support.
     *
     * This trait provides functionality for mapping string inputs to enum cases in a case-insensitive manner,
     * with support for custom aliases. It's particularly useful in Domain-Driven Design (DDD) when working
     * with value objects and enums that need flexible input handling.
     *
     * @template-implements SupportsCaseMappedEnum<static>
     *
     * @see   BackedEnum For backed enum compatibility
     * @since 8.3.0
     */
    use SupportsCaseMappedEnum;

    /**
     * Standard 4-byte integer type supporting values from -2^31 to 2^31-1
     */
    case INT = 'INT';

    /**
     * Represents an INTEGER column type in the database schema.
     *
     * This type is used for storing whole numbers without decimal points.
     * Typically used for primary keys, foreign keys, and numerical data that
     * doesn't require decimal precision.
     *
     * @var string
     * @since 1.0.0
     * @immutable
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::isNumeric()
     * @see   \Gemini\Database\Migration\Design\Column\Enums\ColumnType::requiresLength()
     */
    case INTEGER = 'INTEGER';

    /**
     * Large 8-byte integer type supporting values from -2^63 to 2^63-1
     */
    case BIGINT = 'BIGINT';

    /**
     * Small 2-byte integer type supporting values from -32,768 to 32,767
     */
    case SMALLINT = 'SMALLINT';

    /**
     * Medium 3-byte integer type supporting values from -8,388,608 to 8,388,607
     */
    case MEDIUMINT = 'MEDIUMINT';

    /**
     * Tiny 1-byte integer type supporting values from -128 to 127
     */
    case TINYINT = 'TINYINT';

    /**
     * Fixed-point decimal number with configurable precision and scale
     */
    case DECIMAL = 'DECIMAL';

    /**
     * Single-precision floating-point number (4 bytes)
     */
    case FLOAT = 'FLOAT';

    /**
     * Double-precision floating-point number (8 bytes)
     */
    case DOUBLE = 'DOUBLE';

    /**
     * Variable-length string type with a maximum length specification
     */
    case VARCHAR = 'VARCHAR';

    /**
     * Fixed-length string type, padded with spaces to specified length
     */
    case CHAR = 'CHAR';

    /**
     * Variable-length text type with a maximum size of 65,535 bytes
     */
    case TEXT = 'TEXT';

    /**
     * Variable-length text type with maximum size of 4GB
     */
    case LONGTEXT = 'LONGTEXT';

    /**
     * Variable-length text type with maximum size of 16MB
     */
    case MEDIUMTEXT = 'MEDIUMTEXT';

    /**
     * Variable-length text type with maximum size of 255 bytes
     */
    case TINYTEXT = 'TINYTEXT';

    /**
     * Date type storing year, month, and day
     */
    case DATE = 'DATE';

    /**
     * Date and time type with microsecond precision
     */
    case DATETIME = 'DATETIME';

    /**
     * Timestamp type for tracking record modifications
     */
    case TIMESTAMP = 'TIMESTAMP';

    /**
     * Time type storing hours, minutes, seconds
     */
    case TIME = 'TIME';

    /**
     * Year type storing values from 1901 to 2155
     */
    case YEAR = 'YEAR';

    /**
     * JSON document type with validation and indexing capabilities
     */
    case JSON = 'JSON';

    /**
     * Binary JSON type optimized for indexing and querying
     */
    case JSONB = 'JSONB';

    /**
     * Binary large object type for storing binary data
     */
    case BLOB = 'BLOB';

    /**
     * Enumerated type with predefined set of valid values
     */
    case ENUM = 'ENUM';

    /**
     * Set type allowing multiple values from predefined options
     */
    case SET = 'SET';

    /**
     * Vector type for AI/ML applications and similarity searches
     */
    case VECTOR = 'VECTOR';

    /**
     * Geographic spatial data type for location-based features
     */
    case GEOGRAPHY = 'GEOGRAPHY';

    /**
     * UUID type for globally unique identifiers (36 chars)
     */
    case UUID = 'UUID';

    /**
     * ULID type for sortable unique identifiers (26 chars)
     */
    case ULID = 'ULID';

    /**
     * Boolean type typically implemented as TINYINT(1)
     */
    case BOOLEAN = 'BOOLEAN';

    /**
     * Foreign key constraint type for referential integrity
     */
    case FOREIGN_KEY = 'FOREIGN KEY';

    /**
     * Standard index type for query optimization
     */
    case INDEX = 'INDEX';

    /**
     * Unique constraint index type ensuring value uniqueness
     */
    case UNIQUE = 'UNIQUE';

    /**
     * Full-text search index type for text search optimization
     */
    case FULLTEXT = 'FULLTEXT';

    /**
     * Spatial index type for geographic data queries
     */
    case SPATIAL = 'SPATIAL';

    /**
     * Resolves a ColumnType enum from a DSL method name.
     *
     * @param string $method The DSL method name (e.g., 'string', 'text', 'uuid')
     *
     * @return self The corresponding ColumnType enum
     *
     * @throws \InvalidArgumentException If the method is not recognized
     */
    public static function fromDslMethod(string $method) : self
    {
        return self::map(input: $method);
    }


    /**
     * Returns a mapping of DSL (Domain-Specific Language) column type aliases to their corresponding database types.
     * This method establishes a unified type system across the domain model and persistence layer.
     *
     * @return array<string, string> Associative array mapping DSL type aliases to concrete database column types
     */
    public static function dslAliases() : array
    {
        // String-based column type mappings
        return [
            // Standard string variations for flexible text storage
            'string'     => self::VARCHAR,    // Variable-length character string, default choice for text
            'varchar'    => self::VARCHAR,    // Alternative notation for VARCHAR type
            'char'       => self::CHAR,       // Fixed-length character string

            // Text storage variations with different capacity limits
            'text'       => self::TEXT,       // Standard text type for larger string storage
            'longText'   => self::LONGTEXT,   // Maximum capacity text storage
            'mediumText' => self::MEDIUMTEXT, // Medium capacity text storage
            'tinyText'   => self::TINYTEXT,   // Minimal capacity text storage

            // Unique identifier types
            'uuid'       => self::UUID,       // Universally Unique Identifier (128-bit)
            'ulid'       => self::ULID,       // Universally Unique Lexicographically Sortable Identifier

            // JSON data types
            'json'       => self::JSON,       // Standard JSON storage type
            'jsonb'      => self::JSONB,      // Binary JSON storage (PostgreSQL specific)

            // Integer-based numeric types
            'int'        => self::INTEGER,    // Standard integer type
            'integer'    => self::INTEGER,    // Alternative notation for INTEGER
            'bigint'     => self::BIGINT,     // Large-range integer type
            'smallint'   => self::SMALLINT,   // Small-range integer type
            'tinyint'    => self::TINYINT,    // Minimal-range integer type

            // Decimal number types
            'decimal'    => self::DECIMAL,    // Exact decimal number type
            'float'      => self::FLOAT,      // Floating-point number type
            'double'     => self::DOUBLE,     // Double precision floating-point type

            // Boolean type aliases
            'boolean'    => self::BOOLEAN,    // Standard boolean type
            'bool'       => self::BOOLEAN,    // Alternative notation for BOOLEAN

            // Date and time types
            'date'       => self::DATE,       // Date storage without time
            'datetime'   => self::DATETIME,   // Combined date and time storage
            'timestamp'  => self::TIMESTAMP,  // Timestamp with timezone awareness
            'time'       => self::TIME,       // Time storage without date
            'year'       => self::YEAR,       // Year storage only

            'foreign'     => self::FOREIGN_KEY,
            'foreignKey'  => self::FOREIGN_KEY,
            'foreign_key' => self::FOREIGN_KEY,
            'foreign key' => self::FOREIGN_KEY,
        ];
    }

    /**
     * Returns only the raw SQL type string for this column, without metadata.
     *
     * Useful for quick compatibility checks, logging, or fallback rendering.
     *
     * Delegates to toSqlTypeDefinition() and extracts the base SQL type.
     *
     * @return string SQL-compatible column type name (e.g., "CHAR", "TINYINT")
     */
    public function toSqlType() : string
    {
        return $this->toSqlTypeDefinition()->type;
    }

    /**
     * Returns the physical SQL type representation for the current ColumnType,
     * including fixed-length or precision information when relevant.
     *
     * This is critical for type-safe schema generation (e.g. CHAR(36) for UUID).
     *
     * @return SqlTypeDefinition Full SQL type contract with constraints
     */
    public function toSqlTypeDefinition() : SqlTypeDefinition
    {
        return match ($this) {
            self::UUID    => new SqlTypeDefinition(type: 'CHAR', length: 36),
            self::ULID    => new SqlTypeDefinition(type: 'CHAR', length: 26),
            self::BOOLEAN => new SqlTypeDefinition(type: 'TINYINT', length: 1),
            self::VARCHAR => new SqlTypeDefinition(type: 'VARCHAR', length: 255),
            self::CHAR    => new SqlTypeDefinition(type: 'CHAR', length: 255),
            self::DECIMAL => new SqlTypeDefinition(type: 'DECIMAL', precision: 10, scale: 2),
            self::FLOAT,
            self::DOUBLE  => new SqlTypeDefinition(type: $this->value, precision: 10, scale: 2),
            default       => new SqlTypeDefinition(type: $this->value),
        };
    }

    /**
     * Determines whether the current column type represents an index type.
     *
     * @return bool True if the type is an index type, false otherwise
     */
    public function isIndex() : bool
    {
        return match ($this) {
            self::INDEX,
            self::UNIQUE,
            self::FULLTEXT,
            self::SPATIAL => true,
            default       => false,
        };
    }

    /**
     * Determines whether the column type requires a length specification.
     *
     * @return bool True if length is required, false otherwise
     */
    public function requiresLength() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::UUID,
            self::ULID,
            self::VECTOR => true,
            default      => false,
        };
    }

    /**
     * Determines if the column type supports precision and scale parameters.
     *
     * @return bool True if precision/scale are supported, false otherwise
     */
    public function supportsPrecision() : bool
    {
        return match ($this) {
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Indicates whether the column type is temporal (timestamp/datetime/etc).
     *
     * @return bool
     */
    public function isTemporal() : bool
    {
        return match ($this) {
            self::TIMESTAMP,
            self::DATETIME,
            self::DATE,
            self::TIME,
            self::YEAR => true,
            default    => false,
        };
    }

    /**
     * Determines if the type is string-compatible.
     *
     * @return bool
     */
    public function isString() : bool
    {
        return match ($this) {
            self::VARCHAR,
            self::CHAR,
            self::TEXT,
            self::LONGTEXT,
            self::MEDIUMTEXT,
            self::TINYTEXT,
            self::UUID,
            self::ULID => true,
            default    => false,
        };
    }

    /**
     * Returns the default length for types that require it.
     *
     * @return int|null Default length or null
     */
    public function defaultLength() : int|null
    {
        return match ($this) {
            self::UUID    => 36,
            self::ULID    => 26,
            self::CHAR,
            self::VARCHAR => 255,
            self::VECTOR  => 1536,
            default       => null,
        };
    }

    /**
     * Determines if the type is numeric.
     *
     * @return bool True if numeric
     */
    public function isNumeric() : bool
    {
        return match ($this) {
            self::INT,
            self::BIGINT,
            self::SMALLINT,
            self::MEDIUMINT,
            self::TINYINT,
            self::DECIMAL,
            self::FLOAT,
            self::DOUBLE => true,
            default      => false,
        };
    }

    /**
     * Retrieves the primary DSL method alias for the current schema type.
     *
     * This method returns the first (most preferred) method name from the available
     * DSL method aliases. It's particularly useful in fluent schema definitions
     * where a consistent primary method name is required.
     *
     * @return string The primary DSL method alias for the current schema type
     * @see   preferredDslMethods() For the complete list of available DSL method aliases
     * @since 8.3
     */
    public function getPreferredAlias() : string
    {
        // Retrieve the first (primary) DSL method alias from the available methods
        return $this->preferredDslMethods()[0];
    }

    /**
     * Reverse map to prefer DSL-friendly names (e.g. use `string()` instead of `varchar()`).
     * Returns an array of preferred DSL (Domain Specific Language) method names for the current field type.
     *
     * This method maps enumeration cases to their corresponding fluent schema builder methods,
     * facilitating a more expressive and domain-driven database schema definition.
     *
     * @return array<int, string> Array of method names available for this field type
     * @throws never
     * @api
     * @since 1.0.0
     */
    public function preferredDslMethods() : array
    {
        // Match expression provides exhaustive type mapping for schema builder methods
        return match ($this) {
            // Maps VARCHAR type to both 'string' and 'varchar' method names for flexibility
            self::VARCHAR     => ['string', 'varchar'],

            // Boolean type supports both full and short method names
            self::BOOLEAN     => ['boolean', 'bool'],

            // Integer type supports both full and short method names
            self::INTEGER     => ['integer', 'int'],

            // Text type maps to the 'text' schema builder method
            self::TEXT        => ['text'],

            // LongText type maps to the camelCase 'longText' method
            self::LONGTEXT    => ['longText'],

            // Char type maps directly to the 'char' method
            self::CHAR        => ['char'],

            // Enum type maps to the 'enum' schema builder method
            self::ENUM        => ['enum'],

            self::FOREIGN_KEY => ['foreign', 'foreignKey', 'foreign_key'],


            // Fallback for any undefined types, converts enum case name to lowercase
            default           => [strtolower($this->name)],
        };
    }
}

=== Migration/Design/Column/Enums/ReferentialAction.php ===
<?php

/**
 * ReferentialAction Enum for Database Foreign Key Constraints
 *
 * This enum defines the possible actions that can be taken when a referenced
 * record is deleted or updated in a foreign key relationship.
 *
 * @package Gemini\Database\Migration\Table\Column
 * @since   1.0.0
 * @immutable
 */
declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

enum ReferentialAction: string
{
    /**
     * Automatically delete or update related records when the referenced record is deleted/updated
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Set the foreign key column value to NULL when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Prevent deletion/update of referenced record if it has related records
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Similar to RESTRICT, prevents changes that would violate referential integrity
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Set the foreign key column to its default value when the referenced record is deleted/updated
     *
     * @var string
     */
    case SET_DEFAULT = 'SET DEFAULT';
}
=== Migration/Design/Column/Enums/SqlTypeDefinition.php ===
<?php

/**
 * Strict type declaration for enhanced type safety and better performance.
 */
declare(strict_types=1);

/**
 * Namespace declaration following PSR-4 autoloading standards.
 * Contains value objects related to SQL column type definitions in the migration context.
 */

namespace Gemini\Database\Migration\Design\Column\Enums;

/**
 * Represents an immutable Value Object encapsulating SQL column type definition parameters.
 *
 * This class follows Domain-Driven Design principles by representing a concept from
 * the ubiquitous language of database schema design. It is marked as final to prevent
 * inheritance and ensure immutability through the readonly modifier.
 *
 * @package Gemini\Database\Migration\Design\Column\Enums
 * @final
 * @readonly
 */
final readonly class SqlTypeDefinition
{
    /**
     * Constructs a new SQL type definition with its associated parameters.
     *
     * Uses constructor property promotion for concise and expressive initialization
     * of the value object's properties.
     *
     * @param string   $type      The SQL data type identifier (e.g., 'VARCHAR', 'DECIMAL')
     * @param int|null $length    Optional length parameter for types that support it (e.g., VARCHAR(255))
     * @param int|null $precision Optional precision for numeric types (total number of significant digits)
     * @param int|null $scale     Optional scale for numeric types (number of digits after decimal point)
     */
    public function __construct(
        public string   $type,
        public int|null $length = null,
        public int|null $precision = null,
        public int|null $scale = null,
    ) {}
}
=== Migration/Design/Column/Enums/SupportsCaseMappedEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Enums;

use BackedEnum;
use LogicException;
use ValueError;

/**
 * A trait that provides sophisticated case-mapped enum support with DSL capabilities.
 *
 * This trait enhances backed enums with case-insensitive mapping functionality,
 * supporting both direct enum value/name matching and custom DSL aliases.
 *
 * @template T of BackedEnum
 *
 * @author AI Assistant <ai@example.com>
 * @since  1.0.0
 */
trait SupportsCaseMappedEnum
{
    /**
     * Error message for empty or whitespace-only input validation.
     *
     * @var string Constant representing the error message for empty input scenarios
     */
    private const string ERROR_EMPTY_INPUT = "Enum mapping input cannot be empty or whitespace.";

    /**
     * Error message template for invalid alias mapping scenarios.
     *
     * @var string Constant representing the error message for invalid alias configurations
     */
    private const string ERROR_INVALID_ALIAS = 'Invalid alias mapping for "%s". Expected instance of %s, got %s.';

    /**
     * Error message template for unmatched enum cases.
     *
     * @var string Constant representing the error message when no matching enum case is found
     */
    private const string ERROR_NO_MATCH = 'No matching enum case found for "%s". Valid inputs: [%s]';

    /**
     * Determines if the provided input string can be mapped to an enum case.
     *
     * @param string $input The input string to validate for mapping possibility
     *
     * @return bool True if mapping is possible, false otherwise
     */
    public static function canMap(string $input) : bool
    {
        return static::tryMap(input: $input) !== null;
    }

    /**
     * Attempts to map the input string to an enum case, returning null on failure.
     *
     * @param string $input The input string to attempt mapping
     *
     * @return static|null The mapped enum case or null if mapping fails
     */
    public static function tryMap(string $input) : static|null
    {
        try {
            return static::map(input: $input);
        } catch (ValueError) {
            return null;
        }
    }

    /**
     * Maps the input string to an enum case or throws an exception on failure.
     *
     * @param string $input The input string to map to an enum case
     *
     * @return static The successfully mapped enum case
     * @throws ValueError When mapping fails or input is invalid
     */
    public static function map(string $input) : static
    {
        // Validate input for emptiness
        if (trim($input) === '') {
            throw new ValueError(message: self::ERROR_EMPTY_INPUT);
        }

        // Normalize input for case-insensitive comparison
        $normalized = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $input)); // camelCase â†’ snake_case â†’ lower

        // Attempt to find a match through various strategies
        $matchedCase = self::findMatchInAliases($normalized)
                       ?? self::findMatchByValue($normalized)
                          ?? self::findMatchByName($normalized);

        if ($matchedCase !== null) {
            return $matchedCase;
        }

        // No match found, throw a detailed exception
        throw new ValueError(
            message: sprintf(
                         self::ERROR_NO_MATCH,
                         $input,
                         self::getValidInputsString($normalized)
                     )
        );
    }

    /**
     * Attempts to find a matching enum case through configured aliases.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     * @throws LogicException When alias mapping is invalid
     */
    private static function findMatchInAliases(string $normalized) : static|null
    {
        // Check if DSL aliases are supported
        if (! method_exists(static::class, 'dslAliases')) {
            return null;
        }

        $aliases = static::dslAliases();

        // Check if normalized input exists in aliases
        if (! array_key_exists($normalized, $aliases)) {
            return null;
        }

        $aliasTarget = $aliases[$normalized];

        // Validate alias target type
        if (! ($aliasTarget instanceof static)) {
            throw new LogicException(
                message: sprintf(
                             self::ERROR_INVALID_ALIAS,
                             $normalized,
                             static::class,
                             get_debug_type($aliasTarget)
                         )
            );
        }

        return $aliasTarget;
    }

    /**
     * Provides DSL aliases for enum cases. Override this method to define custom mappings.
     *
     * @return array<string, static> Array of alias => enum case mappings
     */
    protected static function dslAliases() : array
    {
        return [];
    }

    /**
     * Attempts to find a matching enum case by its value.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByValue(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->value) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Attempts to find a matching enum case by its name.
     *
     * @param string $normalized The normalized input string
     *
     * @return static|null The matched enum case or null if no match found
     */
    private static function findMatchByName(string $normalized) : static|null
    {
        foreach (static::cases() as $case) {
            if (strtolower($case->name) === $normalized) {
                return $case;
            }
        }

        return null;
    }

    /**
     * Generates a string of all valid input values for error messaging.
     *
     * @param string $normalized The normalized input string (unused but kept for consistency)
     *
     * @return string Comma-separated list of valid inputs
     */
    protected static function getValidInputsString(string $normalized) : string
    {
        $cases   = static::cases();
        $aliases = method_exists(static::class, 'dslAliases') ? static::dslAliases() : [];

        $valid = array_merge(
            array_keys($aliases),
            array_map(static fn($c) => strtolower($c->value), $cases),
            array_map(static fn($c) => strtolower($c->name), $cases)
        );

        return implode(', ', array_unique($valid));
    }
}
=== Migration/Design/Column/Renderer/ColumnDSLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;

/**
 * Renders column definitions into Gemini migration DSL format.
 *
 * This final class is responsible for converting column attributes into
 * syntactically correct Laravel migration method chains. It follows DDD principles
 * by encapsulating all column DSL rendering logic in a dedicated service.
 *
 * @final
 */
final class ColumnDSLRenderer
{
    /**
     * Formats column attributes into a Laravel migration DSL string.
     *
     * This method transforms the domain model (ColumnAttributes) into a valid
     * Laravel migration method chain, handling type-specific formatting,
     * modifiers, and defaults according to Laravel's schema builder syntax.
     *
     * @param ColumnAttributes $column The column attributes to format
     *
     * @return string The formatted Laravel migration DSL statement
     */
    public function format(ColumnAttributes $column) : string
    {
        // Retrieves the preferred Domain-Specific Language (DSL) method mapping for the column type.
        $type = $column->type->getPreferredAlias();

        // Prepare base arguments starting with the column name
        $args = [$column->name];

        // Add length parameter for string-based column types
        if ($column->type->requiresLength() && $column->length !== null) {
            $args[] = $column->length;
        }

        // Add precision and scale for numeric types
        if ($column->type->supportsPrecision()) {
            $args[] = $column->precision ?? 10; // Default precision if isn't specified
            $args[] = $column->scale ?? 2;      // Default scale if isn't specified
        }

        // Construct the base column definition
        $dsl = sprintf(
            '$table->%s(%s)',
            $type,
            implode(', ', array_map(static fn($a) => var_export($a, true), $args))
        );

        // Define available column modifiers with their corresponding method names
        $modifiers = [
            'nullable'           => 'nullable',
            'unsigned'           => 'unsigned',
            'autoIncrement'      => 'autoIncrement',
            'primary'            => 'primary',
            'unique'             => 'unique',
            'useCurrent'         => 'useCurrent',
            'useCurrentOnUpdate' => 'useCurrentOnUpdate',
        ];

        // Apply modifiers if their corresponding attributes are true
        foreach ($modifiers as $attr => $method) {
            if ($column->{$attr} === true) {
                $dsl .= "->{$method}()";
            }
        }

        // Add default value if specified
        if ($column->default !== null) {
            $escaped = is_string($column->default) ? "'{$column->default}'" : var_export($column->default, true);
            $dsl     .= "->default({$escaped})";
        }

        // Terminate the statement with semicolon
        return $dsl . ';';
    }
}
=== Migration/Design/Column/Renderer/ColumnSQLRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Column\Renderer;

use Gemini\Database\Migration\Design\Column\Builder\ColumnAttributes;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

final class ColumnSQLRenderer
{
    /**
     * Static entrypoint for rendering a column definition.
     *
     * @param ColumnAttributes $column The column to render
     *
     * @return string SQL representation of the column
     */
    public static function render(ColumnAttributes $column) : string
    {
        return (new self())->format($column);
    }

    public function format(ColumnAttributes $column) : string
    {
        return match (true) {
            $column->type === ColumnType::FOREIGN_KEY => $this->buildForeignKey($column),
            $column->type->isIndex()                  => $this->buildIndex($column),
            default                                   => $this->buildColumn($column),
        };
    }

    private function buildForeignKey(ColumnAttributes $c) : string
    {
        $sql = sprintf(
            'FOREIGN KEY (`%s`) REFERENCES `%s`(`%s`)',
            $c->name,
            $c->foreign['on'] ?? 'unknown_table',
            $c->foreign['references'] ?? 'id'
        );

        if (! empty($c->foreign['onDelete'])) {
            $sql .= ' ON DELETE ' . $c->foreign['onDelete'];
        }

        if (! empty($c->foreign['onUpdate'])) {
            $sql .= ' ON UPDATE ' . $c->foreign['onUpdate'];
        }

        return $sql;
    }

    private function buildIndex(ColumnAttributes $c) : string
    {
        return strtoupper($c->type->toSqlType()) . " `{$c->name}` (" . implode(', ', $c->columns) . ")";
    }

    private function buildColumn(ColumnAttributes $c) : string
    {
        $sql = "`{$c->name}` " . $this->typeDeclaration($c);

        $sql .= $c->unsigned ? ' UNSIGNED' : '';
        $sql .= $c->nullable ? ' NULL' : ' NOT NULL';
        $sql .= $this->defaultClause($c);
        $sql .= $c->autoIncrement ? ' AUTO_INCREMENT' : '';
        $sql .= $c->unique ? ' UNIQUE' : '';
        $sql .= $c->primary ? ' PRIMARY KEY' : '';
        $sql .= $c->generated ? " {$c->generated}" : '';
        $sql .= $c->after ? " AFTER `{$c->after}`" : '';
        $sql .= $c->alias !== null ? " AS `{$c->alias}`" : '';

        return trim($sql);
    }

    private function typeDeclaration(ColumnAttributes $c) : string
    {
        if ($c->type === ColumnType::ENUM && $c->enum !== null) {
            $quoted = array_map(static fn(string $v) : string => "'{$v}'", $c->enum);

            return 'ENUM(' . implode(', ', $quoted) . ')';
        }

        return match (true) {
            $c->type === ColumnType::DECIMAL                  =>
                "DECIMAL(" . ($c->precision ?? 8) . ", " . ($c->scale ?? 2) . ")",
            $c->type->requiresLength() && $c->length !== null =>
                $c->type->toSqlType() . "({$c->length})",
            default                                           => $c->type->toSqlType(),
        };
    }

    private function defaultClause(ColumnAttributes $c) : string
    {
        if ($c->default !== null) {
            $escaped = match (true) {
                is_string($c->default) => "'{$c->default}'",
                $c->default === true   => '1',
                $c->default === false  => '0',
                default                => $c->default
            };

            return " DEFAULT {$escaped}";
        }

        if ($c->useCurrent) {
            return ' DEFAULT CURRENT_TIMESTAMP';
        }

        return '';
    }
}

=== Migration/Design/Mapper/FieldToDslMapperInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;

/**
 * Defines the contract for mapping field data transfer objects to database schema DSL.
 *
 * This interface is part of the database migration domain and implements the Strategy pattern,
 * allowing for flexible field-to-DSL mapping strategies. It serves as a crucial component
 * in translating field definitions into concrete database schema specifications.
 *
 * Key responsibilities:
 * - Translates FieldDTO objects into table schema modifications
 * - Ensures consistent field mapping across different database platforms
 * - Maintains single responsibility principle for field transformation logic
 *
 * @package Gemini\Database\Migration\Design\Mapper
 * @since   8.3.0
 */
interface FieldToDslMapperInterface
{
    /**
     * Applies the field mapping strategy to transform a FieldDTO into table schema modifications.
     *
     * This method implements the core mapping logic, taking a table instance and field DTO
     * as input and applying the necessary schema modifications through the table's DSL.
     *
     * @param Table    $table The target table to apply the field mapping to
     * @param FieldDTO $field The field data transfer object containing the field definition
     *
     * @return void
     *
     * @throws \InvalidArgumentException If the field definition is invalid
     * @throws \RuntimeException If the mapping operation fails
     */
    public function apply(Table $table, FieldDTO $field) : void;
}
=== Migration/Design/Mapper/FluentFieldToDslMapper.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Mapper;

use Gemini\Database\Migration\Design\Column\Enums\ColumnType;
use Gemini\Database\Migration\Design\Column\Enums\ReferentialAction;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;
use Throwable;

/**
 * Maps database field specifications to fluent DSL expressions in the schema builder.
 *
 * This mapper translates abstract field definitions (FieldDTO) into concrete database schema
 * declarations using a fluent interface. It encapsulates the complexity of mapping various
 * field types, their modifiers, and foreign key relationships.
 *
 * @final   This class is not designed for extension as per Interface Segregation Principle
 *
 * @package Gemini\Database\Migration\Design\Mapper
 * @version 1.0.0
 * @since   8.3
 */
final class FluentFieldToDslMapper implements FieldToDslMapperInterface
{
    /**
     * Transforms a field specification into its corresponding database schema representation.
     *
     * This method serves as the primary entry point for field-to-schema mapping operations.
     * It orchestrates the process of:
     * 1. Type resolution and column creation
     * 2. Foreign key relationship configuration (if applicable)
     * 3. Column modifier application
     *
     * @param Table    $table The schema builder table instance to modify
     * @param FieldDTO $field The field specification to transform
     *
     * @throws RuntimeException When column creation fails or invalid specifications are provided
     */
    public function apply(Table $table, FieldDTO $field) : void
    {
        try {
            // Map the field type to a concrete ColumnType enum
            $typeEnum = ColumnType::map(input: $field->type->value);

            // Create the base column definition
            $column = $this->createColumn(table: $table, typeEnum: $typeEnum, field: $field);

            // Apply foreign key specific configurations if applicable
            if ($typeEnum === ColumnType::FOREIGN_KEY) {
                $column = $this->applyForeignKeyActions(column: $column, field: $field);
            }

            // Apply any additional modifiers to the column
            $this->applyModifiers(
                table     : $table,
                column    : $column,
                modifiers : $field->attributes ?? [],
                typeMethod: strtolower($typeEnum->name)
            );
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : sprintf("Column creation failed for method '%s': %s", $field->type->value, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Creates a column instance based on the specified type and field configuration.
     *
     * @param Table      $table    The table blueprint instance
     * @param ColumnType $typeEnum The enumerated column type
     * @param FieldDTO   $field    The field specification
     *
     * @return object The created column instance
     */
    private function createColumn(Table $table, ColumnType $typeEnum, FieldDTO $field) : object
    {
        $args = $this->resolveColumnArguments(typeEnum: $typeEnum, field: $field);

        return $typeEnum === ColumnType::FOREIGN_KEY
            ? $table->foreignKey(...$args)
            : $table->{strtolower($typeEnum->name)}(...$args);
    }

    /**
     * Resolves constructor arguments for column creation based on type and field specification.
     *
     * Maps different column types to their required constructor arguments, handling default values
     * and mandatory parameters for each type.
     *
     * @param ColumnType $typeEnum The type of column being created
     * @param FieldDTO   $field    The field specification containing the parameters
     *
     * @return array<int, mixed> Resolved constructor arguments
     *
     * @throws RuntimeException When required foreign key parameters are missing
     * @noinspection PhpFeatureEnvyLocalInspection
     */
    private function resolveColumnArguments(ColumnType $typeEnum, FieldDTO $field) : array
    {
        return match ($typeEnum) {
            ColumnType::VARCHAR, ColumnType::CHAR                      => [
                $field->name,
                $field->length ?? 255,
            ],
            ColumnType::DECIMAL, ColumnType::FLOAT, ColumnType::DOUBLE => [
                $field->name,
                ...$this->hasPrecisionScale($field)
                    ? [$field->total, $field->places]
                    : throw new RuntimeException(
                        sprintf(
                            "Invalid precision/scale for '%s': total=%s, places=%s",
                            $field->name,
                            var_export($field->total, true),
                            var_export($field->places, true)
                        )
                    ),
            ],

            ColumnType::ENUM, ColumnType::SET                          => [
                $field->name,
                $field->enum ?? [],
            ],
            ColumnType::FOREIGN_KEY                                    => [
                $field->columns[0] ?? throw new RuntimeException(message: "Missing local column name for foreign key."),
                $field->references ?? throw new RuntimeException(message: "Missing 'references' for foreign key."),
                $field->on ?? throw new RuntimeException(message: "Missing 'on' (referenced table) for foreign key."),
            ],
            default                                                    => [$field->name],
        };
    }

    /**
     * Validates numeric precision and scale parameters for decimal-type columns.
     *
     * Ensures that the precision (total digits) and scale (decimal places) are valid
     * and logically consistent.
     *
     * @param FieldDTO $field The field specification to validate
     *
     * @return bool True if the precision/scale combination is valid
     */
    private function hasPrecisionScale(FieldDTO $field) : bool
    {
        return is_int($field->total)
               && is_int($field->places)
               && $field->total >= $field->places;
    }

    /**
     * Configures referential actions for foreign key constraints.
     *
     * @param object   $column The foreign key column instance
     * @param FieldDTO $field  The field specification containing referential actions
     *
     * @return object The modified column instance
     */
    private function applyForeignKeyActions(object $column, FieldDTO $field) : object
    {
        if (is_string($field->onDelete)) {
            $column = $column->onDelete(
                ReferentialAction::tryFrom(value: strtoupper(trim($field->onDelete)))
            );
        }

        if (is_string($field->onUpdate)) {
            $column = $column->onUpdate(
                ReferentialAction::tryFrom(value: strtoupper(trim($field->onUpdate)))
            );
        }

        return $column;
    }

    /**
     * Applies a sequence of modifiers to a column definition.
     *
     * Validates and applies each modifier in sequence, ensuring the modifier exists
     * for the given column type.
     *
     * @param Table  $table      The table blueprint instance
     * @param object $column     The column instance to modify
     * @param array  $modifiers  List of modifiers to apply
     * @param string $typeMethod The column type method name
     *
     * @throws RuntimeException When an invalid modifier is specified
     */
    private function applyModifiers(Table $table, object $column, array $modifiers, string $typeMethod) : void
    {
        foreach ($modifiers as $modifier) {
            if (! method_exists($column, $modifier)) {
                throw new RuntimeException(
                    message: sprintf(
                                 "Column modifier '%s' is not available on column type '%s'.",
                                 $modifier,
                                 $typeMethod
                             )
                );
            }
            $column = $column->{$modifier}();
            $table->replaceColumn(column: $column);
        }
    }
}
=== Migration/Design/Table/Alter/AlterTable.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Closure;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddForeignKeyDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\AddIndexDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\RenameColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use InvalidArgumentException;
use ReflectionException;
use RuntimeException;

/**
 * Provides a fluent Domain-Specific Language (DSL) for database table alterations.
 *
 * This value object encapsulates the complete specification for altering database tables,
 * following Domain-Driven Design principles. It provides an immutable, type-safe interface
 * for defining structural changes to database tables.
 *
 * Example usage:
 * ```
 * $alter = AlterTable::for('users')
 *     ->addColumn('email', 'string')
 *     ->modifyColumn('status', fn(Column $column) => $column->enum(['active', 'inactive']))
 *     ->dropColumn('deprecated_field');
 * ```
 *
 * @final This class is not intended for inheritance
 */
final class AlterTable
{
    /**
     * Represents an immutable collection of atomic table alteration operations.
     *
     * This property maintains the ordered sequence of modifications that will be
     * applied to the database table. The order is significant as certain operations
     * may have dependencies on previous alterations.
     *
     * Operations are executed in FIFO (First-In-First-Out) order, ensuring
     * predictable schema modification behavior.
     *
     * @var list<AlterOperation> $operations A strictly typed list of atomic table modifications
     *                                       where each operation represents a single schema change
     */
    private array $operations = [];

    /**
     * Initializes a new immutable table alteration specification.
     *
     * @param string $tableName The canonical name of the database table to be altered
     *                          Must be a valid identifier according to database naming conventions
     *
     * @throws InvalidArgumentException If the table name is empty or contains invalid characters
     */
    private function __construct(private readonly string $tableName) {}

    /**
     * Creates a new table alteration specification following the named constructor pattern.
     * This factory method provides a more expressive and semantic way to initiate table alterations.
     *
     * @param string $tableName The identifier of the table to alter
     *
     * @return self A new immutable instance of TableAlteration
     *
     * @throws InvalidArgumentException If table name validation fails
     *
     * @api
     */
    public static function for(string $tableName) : self
    {
        return new self(tableName: $tableName);
    }

    /**
     * Adds a new column to the table with specified characteristics.
     *
     * @param string               $name   The identifier for the new column
     * @param string               $type   The SQL data type for the column
     * @param array<string, mixed> $params Additional column attributes
     *
     * @throws \ReflectionException
     * @throws \ReflectionException
     */
    public function addColumn(string $name, string $type, array $params = []) : self
    {
        $definition = $this->createColumnDefinition(
            method   : 'create',
            arguments: [$name, ...$params]
        );

        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Factory method for creating column definitions with specific configurations.
     *
     * @param string $method    The method name representing the column operation
     * @param array  $arguments Configuration parameters for the column
     *
     * @throws ReflectionException
     */
    private function createColumnDefinition(string $method, array $arguments) : ColumnDefinition
    {
        return (new Column())->create(method: $method, arguments: $arguments);
    }

    /**
     * Modifies an existing column's definition using a callback.
     *
     * @param string                            $name                     The identifier of the column to modify
     * @param Closure(Column): ColumnDefinition $columnDefinitionCallback Configuration callback
     *
     * @throws RuntimeException When callback returns an invalid definition
     */
    public function modifyColumn(string $name, Closure $columnDefinitionCallback) : self
    {
        $column     = new Column();
        $definition = $columnDefinitionCallback($column);

        if (! $definition instanceof ColumnDefinition) {
            throw new RuntimeException(
                message: 'Column definition callback must return a ColumnDefinition instance'
            );
        }

        $this->operations[] = new AlterOperation(
            type      : AlterType::MODIFY_COLUMN,
            target    : $name,
            definition: $definition
        );

        return $this;
    }

    /**
     * Renames an existing column in the table.
     *
     * This method creates a rename operation for an existing column while maintaining
     * referential integrity and schema consistency.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     *
     * @return self Fluent interface for method chaining
     *
     */
    public function renameColumn(string $from, string $to) : self
    {
        $this->operations[] = new AlterOperation(
            type      : AlterType::RENAME_COLUMN,
            target    : $from,
            definition: new RenameColumnDefinition(from: $from, to: $to)
        );

        return $this;
    }


    /**
     * Removes a column from the table structure.
     *
     * This operation permanently removes the specified column and its data.
     * It Should be used with caution as it's irreversible in production.
     *
     * @param string $column The name of the column to be dropped
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When column definition cannot be created
     */
    public function dropColumn(string $column) : self
    {
        // Create a column definition for the drop operation
        $definition = $this->createColumnDefinition(method: 'drop', arguments: [$column]);

        // Register the drop column operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_COLUMN,
            target    : $column,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes an index from the table.
     *
     * Handles the removal of an existing index while ensuring
     * database performance implications are considered.
     *
     * @param string $indexName The name of the index to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When index definition cannot be created
     */
    public function dropIndex(string $indexName) : self
    {
        // Create a column definition for the drop index operation
        $definition = $this->createColumnDefinition(method: 'dropIndex', arguments: [$indexName]);

        // Register the drop index operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_INDEX,
            target    : $indexName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Removes a foreign key constraint from the table.
     *
     * This operation removes the referential integrity constraint while
     * maintaining the underlying column and its data.
     *
     * @param string $foreignKeyName The name of the foreign key constraint to be removed
     *
     * @return self Fluent interface for method chaining
     *
     * @throws \ReflectionException When a foreign key definition cannot be created
     */
    public function dropForeign(string $foreignKeyName) : self
    {
        // Create a column definition for the drop foreign key operation
        $definition = $this->createColumnDefinition(method: 'dropForeign', arguments: [$foreignKeyName]);

        // Register the drop foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::DROP_FOREIGN,
            target    : $foreignKeyName,
            definition: $definition
        );

        return $this;
    }

    /**
     * Adds a new index definition to the table alteration operations queue.
     *
     * This method follows Domain-Driven Design principles by encapsulating index
     * creation logic within the aggregate root's context. It ensures type safety
     * through strict parameter typing and immutable operation queuing.
     *
     * @param string                    $name    The unique identifier for the index within the table's scope
     * @param array<int|string, string> $columns List of column names to be included in the index
     * @param string                    $type    The index type specification (defaults to 'INDEX')
     *                                           Supported values: 'INDEX', 'UNIQUE', 'FULLTEXT', 'SPATIAL'
     *
     * @return self Returns the current instance for method chaining (fluent interface)
     *
     * @throws InvalidArgumentException When invalid index type is provided
     */
    public function addIndex(
        string $name,
        array  $columns,
        string $type = 'INDEX'
    ) : self {
        // Append new alter operation to the operations collection using constructor promotion
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_INDEX,        // Specifies the operation type as index addition
            target    : $name,                     // Sets the index name as the operation target
            definition: new AddIndexDefinition( // Creates immutable index definition
                            name   : $name,                   // Index identifier
                            columns: $columns,             // Columns to be indexed
                            type   : $type                    // Index type specification
                        )
        );

        // Return self for method chaining capability
        return $this;
    }

    /**
     * Retrieves the immutable table identifier from the migration context.
     *
     * This method provides access to the protected table name property, maintaining
     * encapsulation while exposing the necessary information for SQL generation.
     * Following Domain-Driven Design principles, it represents a crucial part of
     * the domain model's identity.
     *
     * @return string The fully qualified, immutable table identifier
     *
     * @throws never This method guarantees no exceptions will be thrown
     *
     * @api       This method is part of the public API contract
     * @since     1.0.0
     * @immutable This method always returns the same value for the same instance
     */
    public function getTable() : string
    {
        // Return the immutable table identifier stored during object construction
        return $this->tableName;
    }

    /**
     * Retrieves the collection of pending alter operations.
     *
     * @return list<AlterOperation> Ordered a sequence of table modifications
     */
    public function getOperations() : array
    {
        return $this->operations;
    }

    /**
     * Adds a foreign key constraint to establish referential integrity between tables.
     *
     * This domain operation ensures data consistency by creating a relationship between
     * the current table and a referenced table. It supports customizable referential
     * actions for maintaining data integrity during updates and deletions.
     *
     * @param string      $name       The identifier for the foreign key constraint
     * @param array       $columns    Local columns participating in the relationship
     * @param string      $refTable   The referenced table name
     * @param array       $refColumns Referenced columns in the target table
     * @param string|null $onDelete   Action to take when a referenced record is deleted
     * @param string|null $onUpdate   Action to take when a referenced record is updated
     *
     * @return self Fluent interface for method chaining
     *
     * @throws InvalidArgumentException When constraint parameters are invalid
     */
    public function addForeignKey(
        string      $name,       // Constraint identifier
        array       $columns,    // Source columns in the current table
        string      $refTable,   // Referenced table name
        array       $refColumns, // Target columns in the referenced table
        string|null $onDelete = null, // Optional deletion behavior
        string|null $onUpdate = null  // Optional update behavior
    ) : self
    {
        // Register a new foreign key operation in the migration sequence
        $this->operations[] = new AlterOperation(
            type      : AlterType::ADD_FOREIGN,      // Specify an operation type as a foreign key addition
            target    : $name,                       // Set the constraint name as the target
            definition: new AddForeignKeyDefinition( // Define the foreign key specifics
                            name             : $name,
                            columns          : $columns,
                            referencedTable  : $refTable,
                            referencedColumns: $refColumns,
                            onDelete         : $onDelete,
                            onUpdate         : $onUpdate
                        )
        );

        return $this; // Enable method chaining
    }
}
=== Migration/Design/Table/Alter/AlterTableRenderer.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use Gemini\Database\Migration\Design\Table\Alter\DTO\AlterOperation;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;
use RuntimeException;

/**
 * Class AlterTableRenderer
 *
 * Renders valid SQL ALTER TABLE statements from structured DSL operations.
 * Encapsulates the rendering logic for each supported operation, delegating
 * to the proper rendering strategies or SQL renderers depending on a definition type.
 *
 * @final
 */
final class AlterTableRenderer
{
    /**
     * Renders an ALTER TABLE SQL statement from a structured table alteration specification.
     *
     * This service method transforms a domain-specific AlterTable object into a valid SQL ALTER TABLE
     * statement. It ensures proper SQL syntax and escaping while maintaining database schema integrity.
     *
     * @param AlterTable $alter The domain model representing table alterations
     *
     * @return string The fully formed SQL ALTER TABLE statement
     * @throws RuntimeException When attempting to render an empty alteration set
     *
     * @example
     * $SQL = SQLRenderer::render(
     *     AlterTable::for('users')->addColumn('email', 'VARCHAR(255)')
     * );
     */
    public static function render(AlterTable $alter) : string
    {
        // Retrieve the collection of atomic table operations from the alteration specification
        $operations = $alter->getOperations();

        // Validate that at least one operation has been defined
        if (empty($operations)) {
            throw new RuntimeException(
                message: "No ALTER TABLE operations defined for table '{$alter->getTable()}'."
            );
        }

        // Transform each operation into its corresponding SQL representation
        $segments = [];
        foreach ($operations as $operation) {
            $segments[] = self::renderOperation(operation: $operation);
        }

        // Compose the final ALTER TABLE statement with a proper table name escaping
        return sprintf(
            'ALTER TABLE `%s` %s;',
            $alter->getTable(),
            implode(', ', $segments)
        );
    }

    /**
     * Renders a single database alteration operation into its SQL representation.
     *
     * This method implements the Strategy pattern by mapping AlterType enum values
     * to their corresponding SQL syntax. It ensures type-safety through PHP 8.3's
     * enhanced type system and match expressions.
     *
     * @param AlterOperation $operation The alteration operation value object
     *
     * @return string                  The SQL fragment representing the operation
     * @throws RuntimeException        When encountering unsupported operation types
     */
    private static function renderOperation(AlterOperation $operation) : string
    {
        // Use match expression for type-safe operation mapping
        return match ($operation->type) {
            // Handle column addition with proper SQL syntax
            AlterType::ADD_COLUMN    => sprintf(
                'ADD COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column modification maintaining schema consistency
            AlterType::MODIFY_COLUMN => sprintf(
                'MODIFY COLUMN %s',
                self::renderDefinition(operation: $operation)
            ),

            // Handle column renaming with a proper identifier escaping
            AlterType::RENAME_COLUMN => sprintf(
                'RENAME COLUMN `%s` TO `%s`',
                $operation->target,
                self::assertColumnRenameTarget(operation: $operation)
            ),

            // Handle column removal with a proper identifier escaping
            AlterType::DROP_COLUMN   => sprintf(
                'DROP COLUMN `%s`',
                $operation->target
            ),

            // Handle index removal with a proper identifier escaping
            AlterType::DROP_INDEX    => sprintf(
                'DROP INDEX `%s`',
                $operation->target
            ),

            // Handle foreign key constraint removal
            AlterType::DROP_FOREIGN  => sprintf(
                'DROP FOREIGN KEY `%s`',
                $operation->target
            ),

            // Handle index and foreign key additions through definition renderer
            AlterType::ADD_INDEX,
            AlterType::ADD_FOREIGN   => self::renderDefinition(operation: $operation),

            // Handle unsupported operations with a descriptive exception
            default                  => throw new RuntimeException(
                message: "Unsupported ALTER operation type: {$operation->type->value}"
            ),
        };
    }

    /**
     * Renders an SQL definition from an AlterOperation using polymorphic behavior.
     *
     * This method implements the Strategy pattern by dynamically selecting the appropriate
     * rendering approach based on the definition type. It handles both direct column
     * definitions and SQL-renderable objects through a uniform interface.
     *
     * @param AlterOperation $operation The operation containing the definition to render
     *
     * @return string                   The SQL-safe string representation
     * @throws RuntimeException         When definition is missing or unsupported
     */
    private static function renderDefinition(AlterOperation $operation) : string
    {
        // Extract definition from operation for validation and processing
        $definition = $operation->definition;

        // Ensure definition exists before attempting to render
        if ($definition === null) {
            throw new RuntimeException(
                message: "Definition missing for operation type: {$operation->type->value}"
            );
        }

        // Handle ColumnDefinition using a dedicated renderer for complex column structures
        if ($definition instanceof ColumnDefinition) {
            return ColumnSQLRenderer::render(column: $definition->getBuilder());
        }

        // Process objects implementing SQL rendering capabilities through toSql() method
        if (method_exists($definition, 'toSql')) {
            return $definition->toSql();
        }

        // Throw exception for unsupported definition types
        throw new RuntimeException(
            message: sprintf(
                         'Cannot render alter operation [%s]: definition is not renderable.',
                         $operation->type->value
                     )
        );
    }

    /**
     * Validates and extracts the target column name for a rename operation.
     *
     * This method ensures type safety and semantic correctness of column rename operations
     * by validating that the provided operation contains a valid ColumnDefinition.
     * Following Domain-Driven Design principles, it enforces invariants at the domain boundary.
     *
     * @param AlterOperation $operation The alter operation containing the rename definition
     *
     * @return string The validated target column name
     * @throws RuntimeException When the operation definition is not a valid ColumnDefinition
     */
    private static function assertColumnRenameTarget(AlterOperation $operation) : string
    {
        // Extract the definition from the operation for validation
        $definition = $operation->definition;

        // Ensure type safety through runtime assertion of the definition type
        if (! ($definition instanceof ColumnDefinition)) {
            throw new RuntimeException(
                message: "Invalid rename operation definition â€“ expected ColumnDefinition."
            );
        }

        // Extract and return the validated target column name
        return $definition->columnName();
    }
}

=== Migration/Design/Table/Alter/Definitions/AddForeignKeyDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a foreign key creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create foreign key constraints. It follows immutable design principles
 * to ensure consistency during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddForeignKeyDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the AddForeignKeyDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name              The name of the foreign key constraint
     * @param array<string> $columns           The local columns participating in the foreign key
     * @param string        $referencedTable   The referenced table name
     * @param array<string> $referencedColumns The columns in the referenced table
     * @param string|null   $onDelete          The ON DELETE behavior (CASCADE, SET NULL, etc.)
     * @param string|null   $onUpdate          The ON UPDATE behavior (CASCADE, SET NULL, etc.)
     */
    public function __construct(
        public string      $name,
        public array       $columns,
        public string      $referencedTable,
        public array       $referencedColumns,
        public string|null $onDelete = null,
        public string|null $onUpdate = null
    ) {}

    /**
     * Generates the SQL statement for the foreign key creation operation.
     *
     * Produces a standardized SQL ADD CONSTRAINT statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in table and column names.
     *
     * @return string The complete SQL statement for creating the foreign key constraint
     */
    public function toSql() : string
    {
        // Transform column names arrays into properly escaped column identifiers
        $columns = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->columns));
        $refs    = implode(', ', array_map(static fn(string $col) : string => "`{$col}`", $this->referencedColumns));

        // Construct the base foreign key constraint SQL
        $sql = "ADD CONSTRAINT `{$this->name}` FOREIGN KEY ({$columns}) REFERENCES `{$this->referencedTable}` ({$refs})";

        // Append ON DELETE clause if specified
        if ($this->onDelete) {
            $sql .= " ON DELETE {$this->onDelete}";
        }

        // Append ON UPDATE clause if specified
        if ($this->onUpdate) {
            $sql .= " ON UPDATE {$this->onUpdate}";
        }

        return $sql;
    }
}
=== Migration/Design/Table/Alter/Definitions/AddIndexDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents an index creation operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to create various types of database indexes (standard, unique, fulltext).
 * It follows immutable design principles to ensure consistency during
 * the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class AddIndexDefinition extends AlterColumnDefinition
{
    /**
     * Valid index types supported by this definition.
     *
     * @var array<string>
     */
    private const array VALID_INDEX_TYPES = ['INDEX', 'UNIQUE', 'FULLTEXT'];

    /**
     * Initializes a new instance of the AddIndexDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string        $name    The name of the index to be created
     * @param array<string> $columns The columns to be included in the index
     * @param string        $type    The type of index (INDEX, UNIQUE, FULLTEXT)
     */
    public function __construct(
        public string $name,
        public array  $columns,
        public string $type = 'INDEX'
    ) {
        assert(
            in_array($type, self::VALID_INDEX_TYPES, true),
            sprintf('Invalid index type. Must be one of: %s', implode(', ', self::VALID_INDEX_TYPES))
        );
    }

    /**
     * Generates the SQL statement for the index creation operation.
     *
     * Produces a standardized SQL CREATE INDEX statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column and index names.
     *
     * @return string The complete SQL statement for creating the index
     */
    public function toSql() : string
    {
        // Transform column names array into properly escaped column identifiers
        $columns = implode(
            ', ',
            array_map(
                static fn(string $col) : string => "`{$col}`",
                $this->columns
            )
        );

        // Construct the final SQL statement using the defined format
        return sprintf(
            '%s `%s` (%s)',
            strtoupper($this->type),
            $this->name,
            $columns
        );
    }
}
=== Migration/Design/Table/Alter/Definitions/Base/AlterColumnDefinition.php ===
<?php

/**
 * Provides base functionality for SQL column alteration definitions.
 *
 * This abstract class serves as a foundation for implementing various column
 * alteration strategies in database migrations, following the Domain-Driven Design
 * pattern and Single Responsibility Principle.
 *
 * @category Database
 * @package  Gemini\Database\Migration\Design\Table\Alter\Definitions\Base
 * @author   Development Team
 * @version  1.0.0
 * @since    1.0.0
 */
declare(strict_types=1);

/**
 * Base abstract class representing a column alteration definition.
 *
 * This class serves as a blueprint for defining SQL representation of
 * a column alteration in a database migration. It provides an abstract
 * method that subclasses must implement to define specific
 * SQL generation logic for altering database table columns.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions\Base;

abstract readonly class AlterColumnDefinition
{
    /**
     * Converts the column alteration definition to its SQL representation.
     *
     * This method must be implemented by concrete classes to provide specific SQL
     * generation logic for different types of column alterations.
     *
     * @return string The SQL statement representing the column alteration
     *
     * @throws \RuntimeException When SQL generation fails
     */
    abstract public function toSql() : string;
}
=== Migration/Design/Table/Alter/Definitions/RenameColumnDefinition.php ===
<?php

/**
 * Declares strict type checking for this file, ensuring type safety.
 */
declare(strict_types=1);

/**
 * Namespace for database migration design components focused on table alterations.
 */

namespace Gemini\Database\Migration\Design\Table\Alter\Definitions;

use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;

/**
 * Represents a column renaming operation in the database migration context.
 *
 * This value object encapsulates the logic for generating SQL statements
 * to rename database columns. It's immutable by design to ensure data integrity
 * during the migration process.
 *
 * @final    This class is not intended for inheritance
 * @readonly Ensures immutability of the object after construction
 */
final readonly class RenameColumnDefinition extends AlterColumnDefinition
{
    /**
     * Initializes a new instance of the RenameColumnDefinition value object.
     *
     * Uses constructor property promotion for concise and clean initialization
     * of the immutable properties.
     *
     * @param string $from The current name of the column to be renamed
     * @param string $to   The new name for the column
     */
    public function __construct(
        public string $from,
        public string $to
    ) {}

    /**
     * Generates the SQL statement for the column renaming operation.
     *
     * Produces a standardized SQL RENAME COLUMN statement with proper escaping
     * using backticks to prevent SQL injection and handle special characters
     * in column names.
     *
     * @return string The complete SQL statement for renaming the column
     */
    public function toSql() : string
    {
        return sprintf('RENAME COLUMN `%s` TO `%s`', $this->from, $this->to);
    }
}
=== Migration/Design/Table/Alter/DTO/AlterOperation.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\DTO;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Definitions\Base\AlterColumnDefinition;
use Gemini\Database\Migration\Design\Table\Alter\Enums\AlterType;

/**
 * Represents an immutable value object for table alteration operations.
 *
 * This DTO encapsulates the essential information needed to perform
 * structural modifications to database tables, ensuring type safety
 * and immutability in the domain model.
 *
 * @final    Prevents extension to maintain invariants
 * @readonly Ensures immutability of the value object
 */
final readonly class AlterOperation
{
    /**
     * Constructs a new AlterOperation instance using constructor promotion.
     *
     * Encapsulates the complete state required for a table alteration
     * operation through immutable properties, following DDD value object patterns.
     *
     * @param AlterType                                   $type                                                                                                       The
     *                                                                                                                                                                perform
     * @param string                                      $target                                                                                                     The
     *                                                                                                                                                                identifier
     * @param ColumnDefinition|AlterColumnDefinition|null $definition                                                                                                 The
     *                                                                                                                                                                specification
     */
    public function __construct(
        public AlterType                                   $type,
        public string                                      $target,
        public ColumnDefinition|AlterColumnDefinition|null $definition = null
    ) {}
}
=== Migration/Design/Table/Alter/Enums/AlterType.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Alter\Enums;

/**
 * Enum AlterType
 *
 * Defines all supported ALTER TABLE operation types.
 * Used in conjunction with AlterOperation to describe mutations to a table schema.
 *
 * @immutable
 * @psalm-immutable
 */
enum AlterType: string
{
    /**
     * Adds a new column to a table.
     *
     * Example: ALTER TABLE users ADD COLUMN age INT;
     */
    case ADD_COLUMN = 'ADD_COLUMN';

    /**
     * Modifies an existing column.
     *
     * Example: ALTER TABLE users MODIFY COLUMN name VARCHAR(255) NOT NULL;
     */
    case MODIFY_COLUMN = 'MODIFY_COLUMN';

    /**
     * Renames a column.
     *
     * Example: ALTER TABLE users RENAME COLUMN old_name TO new_name;
     */
    case RENAME_COLUMN = 'RENAME_COLUMN';

    /**
     * Drops a column.
     *
     * Example: ALTER TABLE users DROP COLUMN deprecated_field;
     */
    case DROP_COLUMN = 'DROP_COLUMN';

    /**
     * Drops an index.
     *
     * Example: ALTER TABLE users DROP INDEX idx_email;
     */
    case DROP_INDEX = 'DROP_INDEX';

    /**
     * Drops a foreign key constraint.
     *
     * Example: ALTER TABLE orders DROP FOREIGN KEY fk_user_id;
     */
    case DROP_FOREIGN = 'DROP_FOREIGN';

    /**
     * Represents an operation to add a new index to a table.
     *
     * This operation allows the creation of different types of indexes (regular INDEX,
     * UNIQUE, FULLTEXT, SPATIAL) to optimize query performance and enforce data integrity.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE users ADD INDEX idx_email (email);
     *     ALTER TABLE users ADD UNIQUE INDEX idx_username (username);
     */
    case ADD_INDEX = 'ADD_INDEX';

    /**
     * Represents an operation to add a new foreign key constraint to a table.
     *
     * This operation establishes referential integrity between tables by creating
     * a foreign key relationship with configurable ON DELETE and ON UPDATE behaviors.
     *
     * @api
     * @since 1.0.0
     * @example
     *     ALTER TABLE orders
     *     ADD CONSTRAINT fk_user_id
     *     FOREIGN KEY (user_id)
     *     REFERENCES users(id)
     *     ON DELETE CASCADE
     *     ON UPDATE CASCADE;
     */
    case ADD_FOREIGN = 'ADD_FOREIGN';
}

=== Migration/Design/Table/Enum/FieldModifierEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enumeration: FieldModifierEnum
 *
 * This enum provides a type-safe way to define and manage field modifiers
 * used in database migrations for the Gemini system.
 * Each enumerated case represents a specific modifier,
 * ensuring maintainability and reducing duplication across the codebase.
 *
 * Following Domain-Driven Design (DDD), it encapsulates behavior related
 * to its enumeration, ensuring that valid operations are directly associated
 * with the definition itself.
 */
enum FieldModifierEnum: string
{
    /**
     * Represents the "nullable" field modifier.
     *
     * This modifier allows the associated database column to accept NULL values.
     *
     * @var string
     */
    case NULLABLE = 'nullable';

    /**
     * Represents the "unique" field modifier.
     *
     * This modifier ensures that all values in the associated database column
     * are unique and no duplicates are allowed.
     *
     * @var string
     */
    case UNIQUE = 'unique';

    /**
     * Represents the "primary" field modifier.
     *
     * This modifier signifies that the database column serves as a primary key,
     * which uniquely identifies each row in the table.
     *
     * @var string
     */
    case PRIMARY = 'primary';

    /**
     * Represents the "index" field modifier.
     *
     * This modifier designates the creation of an index for the associated column
     * to improve query performance.
     *
     * @var string
     */
    case INDEX = 'index';

    /**
     * Check if the provided value is a valid case for this enum.
     *
     * This method ensures that the given value matches one of the enum's predefined
     * cases, improving type safety and reducing unexpected errors during runtime.
     *
     * @param string $value The value to validate against the enum cases.
     *
     * @return bool Returns `true` if the value exists in the enum, otherwise `false`.
     */
    public static function isValid(string $value) : bool
    {
        // Validate if the provided value exists within the enum's list of values using strict comparison.
        return in_array($value, self::values(), true);
    }

    /**
     * Retrieve all string values of the enum cases.
     *
     * This method provides a centralized way to access the raw underlying values
     * of the defined enum cases. This is particularly useful when the raw values
     * need to be passed to external systems or stored in a database.
     *
     * @return array<int, string> An indexed array of the string values of all cases.
     */
    public static function values() : array
    {
        // Use PHP 8.1+ `cases()` method to get all enum cases and extract their `value` property.
        return array_column(self::cases(), 'value');
    }

    /**
     * Safely attempts to retrieve an enum instance from a given value. If the value is null
     * or invalid, it returns null instead of throwing an error.
     *
     * This method wraps around PHP's built-in `tryFrom()` to provide a safe and null-tolerant
     * implementation that prevents exceptions when handling dynamic inputs.
     *
     * @param string|null $value The value to convert to an enum instance, or `null`.
     *
     * @return self|null Returns the enum instance for the corresponding value, or `null` if the value is invalid.
     */
    public static function fromOrNull(string|null $value) : self|null
    {
        // Ensure type-safety by checking if the input is a string before attempting conversion.
        return is_string($value) ? self::tryFrom($value) : null;
    }
}
=== Migration/Design/Table/Enum/FieldTypeEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum FieldTypeEnum
 *
 * This enum serves as a representation of valid Gemini-compatible column types.
 * It ensures type safety and provides a centralized definition for managing
 * the various database field types used in migrations in a Domain-Driven Design (DDD) context.
 */
enum FieldTypeEnum: string // Enum declaration with an underlying string type, ensuring type-safety for the enum values.
{
    /**
     * Represents a variable-length string column in the database.
     * Suitable for shorter text or character data, defined by Gemini's `string` type.
     *
     * @var string
     */
    case STRING = 'string';

    /**
     * Represents an integer column in the database.
     * Suitable for whole numbers, defined as `integer` in Gemini migrations.
     *
     * @var string
     */
    case INTEGER = 'integer';

    /**
     * Represents a big integer column in the database.
     * Useful for storing larger whole numbers, as defined by Gemini's `bigInteger` type.
     *
     * @var string
     */
    case BIGINT = 'bigInteger';

    /**
     * Represents a boolean column in the database.
     * Used to store true/false values, as defined by Gemini's `boolean` type.
     *
     * @var string
     */
    case BOOLEAN = 'boolean';

    /**
     * Represents a decimal column in the database.
     * Suitable for storing precise numeric values with defined precision and scale.
     *
     * @var string
     */
    case DECIMAL = 'decimal';

    /**
     * Represents a float column in the database.
     * Useful for storing approximate numeric values with floating-point precision.
     *
     * @var string
     */
    case FLOAT = 'float';

    /**
     * Represents an enum column in the database.
     * Allows for a fixed set of predefined string values, common for constrained fields.
     *
     * @var string
     */
    case ENUM = 'enum';

    /**
     * Represents a text column in the database.
     * Suitable for storing large textual content, as defined by Gemini's `text` type.
     *
     * @var string
     */
    case TEXT = 'text';

    /**
     * Represents a timestamp column in the database.
     * Typically used for storing date and time information with precision.
     *
     * @var string
     */
    case TIMESTAMP = 'timestamp';

    /**
     * Represents a universally unique identifier (UUID) column in the database.
     * Useful for storing UUIDs for globally unique identification purposes.
     *
     * @var string
     */
    case UUID = 'uuid';

    /**
     * Represents a foreign key column in the database.
     * Primarily used for establishing relationships between tables in a relational database.
     *
     * @var string
     */
    case FOREIGN = 'foreign';

    /**
     * Represents an indexed column in the database.
     * Commonly used for columns that require quick lookups or unique constraints.
     *
     * @var string
     */
    case INDEX = 'index';

    /**
     * Represents a full-text search index column in the database.
     * Typically used for performing full-text search operations on textual data within Gemini.
     *
     * @var string
     */
    case FULLTEXT = 'fulltext';


    /**
     * Returns a list of all enum values.
     *
     * This method provides a centralized way to retrieve the values of all the cases defined in the enum.
     * It utilizes PHP 8.1+ `cases()` enumeration feature to dynamically return the `value` property
     * of each case, ensuring type-safety and simplicity when needing the raw string representations of the cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Uses array_column to extract the 'value' property of each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Migration/Design/Table/Enum/ForeignActionEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Enum;

/**
 * Enum ForeignActionEnum
 *
 * This enum represents possible actions to be taken on foreign key constraints
 * when certain events occur in the referenced table, such as row deletions or updates.
 *
 * In the context of database migrations, this enum simplifies handling of foreign key behaviors
 * by providing a strongly typed definition for actions like cascade, restrict, or no action.
 * It enhances type-safety, readability, and ensures centralized management of foreign key options.
 *
 * Designed using PHP 8.1+ enums, this class leverages modern features for expressive and reliable
 * definition of constants.
 */
enum ForeignActionEnum: string // Enum declaration with 'string' type to ensure type safety for the defined cases.
{
    /**
     * Indicates cascading behavior for foreign keys.
     * When the referenced row is updated or deleted, the change cascades to the dependent rows.
     *
     * Example: If a parent record is removed, all associated child records are also removed.
     *
     * @var string
     */
    case CASCADE = 'CASCADE';

    /**
     * Indicates behavior to set foreign key columns to NULL.
     * When the referenced row is deleted, dependent foreign key columns in related rows are set to NULL.
     *
     * Example: If a parent record is deleted, the foreign key in child records will be nullified.
     *
     * @var string
     */
    case SET_NULL = 'SET NULL';

    /**
     * Restricts changes to the referenced row.
     * Prevents any changes (such as deletion) to a parent row when there are dependencies on it.
     *
     * Example: Trying to delete a parent record with dependent child records will raise an error.
     *
     * @var string
     */
    case RESTRICT = 'RESTRICT';

    /**
     * Indicates no action should be taken on foreign key constraints.
     * It simply allows the database to raise an error if the integrity rules are violated.
     *
     * Example: If a parent record is targeted for deletion but a child record exists, the operation fails.
     *
     * @var string
     */
    case NO_ACTION = 'NO ACTION';

    /**
     * Retrieves an array of all values defined by the enum cases.
     *
     * This method provides a centralized, type-safe way to access the raw string values
     * of all enum cases. It is useful when generating lists of possible options for migrations
     * or when working with foreign key actions dynamically.
     *
     * Uses PHP's built-in `cases()` method, introduced in PHP 8.1+, to retrieve the values of all cases.
     *
     * @return array<int, string> An indexed array containing the string values of all enum cases.
     */
    public static function values() : array
    {
        // Leverages `array_column` to extract the 'value' property from each enum case.
        return array_column(self::cases(), 'value');
    }
}
=== Migration/Design/Table/Table.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table;

use BadMethodCallException;
use Gemini\Database\Migration\Design\Column\Column;
use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Table\Traits\FieldMappingTrait;
use Gemini\Database\Migration\Design\Table\Traits\IndexDefinitionsTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderDslTrait;
use Gemini\Database\Migration\Design\Table\Traits\TableRenderSqlTrait;
use RuntimeException;

/**
 * @internal Auto-generated from ColumnType enum
 * @method ColumnDefinition bigInteger(string $name)
 * @method ColumnDefinition binary(string $name)
 * @method ColumnDefinition boolean(string $name)
 * @method ColumnDefinition char(string $name, int $length = 255)
 * @method ColumnDefinition date(string $name)
 * @method ColumnDefinition dateTime(string $name)
 * @method ColumnDefinition decimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition double(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition enum(string $name, array $allowed)
 * @method ColumnDefinition float(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition foreignId(string $name)
 * @method ColumnDefinition foreignKey(string $name)
 * @method ColumnDefinition integer(string $name)
 * @method ColumnDefinition json(string $name)
 * @method ColumnDefinition jsonb(string $name)
 * @method ColumnDefinition longText(string $name)
 * @method ColumnDefinition mediumInteger(string $name)
 * @method ColumnDefinition mediumText(string $name)
 * @method ColumnDefinition morphs(string $name)
 * @method ColumnDefinition nullableMorphs(string $name)
 * @method ColumnDefinition nullableTimestamps(string $name)
 * @method ColumnDefinition set(string $name, array $allowed)
 * @method ColumnDefinition smallInteger(string $name)
 * @method ColumnDefinition string(string $name, int $length = 255)
 * @method ColumnDefinition text(string $name)
 * @method ColumnDefinition time(string $name)
 * @method ColumnDefinition timestamp(string $name)
 * @method ColumnDefinition tinyInteger(string $name)
 * @method ColumnDefinition tinyText(string $name)
 * @method ColumnDefinition unsignedBigInteger(string $name)
 * @method ColumnDefinition unsignedDecimal(string $name, int $precision = 10, int $scale = 2)
 * @method ColumnDefinition unsignedInteger(string $name)
 * @method ColumnDefinition unsignedMediumInteger(string $name)
 * @method ColumnDefinition unsignedSmallInteger(string $name)
 * @method ColumnDefinition unsignedTinyInteger(string $name)
 * @method ColumnDefinition uuid(string $name)
 * @method ColumnDefinition year(string $name)
 * @method void timestamps() Adds created_at and updated_at columns
 * @method void softDeletes() Adds deleted_at column for soft deletes
 * @method void rememberToken() Adds remember_token column for auth tokens
 */
final class Table
{
    /**
     * Import the IndexDefinitionsTrait which provides robust database index management capabilities.
     *
     * This trait encapsulates the domain logic for defining and managing various types of database indexes:
     * - Standard indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     * - Composite indexes (COMPOSITE)
     *
     * @see   \IndexDefinitionsTrait For complete index management functionality
     * @since 8.3.0
     */
    use IndexDefinitionsTrait;

    /**
     * Imports TableRenderSqlTrait, which provides SQL generation capabilities for table definitions.
     *
     * This trait is responsible for converting table definitions into valid SQL CREATE TABLE statements.
     * It works in conjunction with column definitions and rendering logic to produce
     * properly formatted SQL strings.
     *
     * @see TableRenderSqlTrait::toSql() For the main SQL generation method
     * @see ColumnSQLRenderer For the column-specific SQL rendering
     *
     * @api
     */
    use TableRenderSqlTrait;

    /**
     * Incorporates table rendering capabilities via Domain-Specific Language (DSL).
     *
     * This trait provides DSL generation functionality for database table definitions,
     * enabling fluent and declarative table schema specifications. It transforms
     * column definitions into a standardized DSL format suitable for database migrations.
     *
     * @see     ColumnDSLRenderer For the underlying DSL formatting logic
     * @see     ColumnAttributes For the column attribute specifications
     *
     * @author  Your Name <your.email@domain.com>
     * @package Database\Schema
     * @version 1.0.0
     */
    use TableRenderDslTrait;

    /**
     * Imports the FieldMappingTrait which provides essential field mapping capabilities for database schema
     * definitions.
     *
     * This trait encapsulates domain logic for mapping FieldDTO objects to table schema DSL,
     * implementing a flexible and extensible field mapping strategy pattern.
     *
     * Key responsibilities:
     * - Manages field-to-DSL mapper injection
     * - Provides fluent interface for field application
     * - Handles both single and batch field mapping operations
     *
     * @see   FieldToDslMapperInterface For the mapping strategy contract
     * @see   FieldDTO For the field data transfer object structure
     *
     * @since 8.3.0
     * @api
     */
    use FieldMappingTrait;

    /**
     * Collection of column definitions indexed by column name.
     *
     * Maintains the ordered set of columns that define the table structure,
     * ensuring column name uniqueness through associative array keys.
     *
     * @var array<string, ColumnDefinition>
     */
    private array $columns = [];

    /**
     * Constructs a new Table instance with the specified name.
     *
     * Uses constructor promotion for lean initialization of the immutable name property.
     */
    private function __construct(private readonly string $name) {}

    /**
     * Dynamic column type handler implementing the Schema DSL.
     *
     * Provides a fluent interface for column definition by delegating to the Column factory.
     * Method name becomes the column type, the first argument is expected to be the column name.
     *
     * @param string            $method    The column types to create
     * @param array<int, mixed> $arguments The column definition arguments
     *
     * @return ColumnDefinition              The created column definition
     * @throws BadMethodCallException        When a column type is invalid
     * @throws RuntimeException|\ReflectionException             When column creation fails
     */
    public function __call(string $method, array $arguments) : ColumnDefinition
    {
        $column = (new Column())->create(
            method   : $method,
            arguments: $arguments
        );

        return $this->addColumn(column: $column);
    }

    /**
     * Named constructor implementing the factory pattern for Table creation.
     *
     * Provides a semantic way to instantiate new Table objects while encapsulating
     * construction details.
     *
     * @param string $name The logical name of the table
     *
     * @return self       The constructed Table instance
     */
    public static function create(string $name) : self
    {
        return new self(name: $name);
    }

    /**
     * Adds a column definition to the table schema.
     *
     * Maintains the column collection while supporting method chaining for the fluent interface.
     *
     * @param ColumnDefinition $column The column definition to add
     *
     * @return ColumnDefinition        The added column definition
     */
    public function addColumn(ColumnDefinition $column) : ColumnDefinition
    {
        $this->columns[$column->columnName()] = $column;

        return $column;
    }

    /**
     * Replaces or adds a column definition in the schema.
     *
     * This method ensures atomic column replacement within the schema definition,
     * maintaining schema consistency and integrity. It follows the Single
     * Responsibility Principle by focusing solely on column replacement logic.
     *
     * @param ColumnDefinition $column The column definition to replace or add
     *
     * @return void
     * @throws RuntimeException When attempting to replace with an invalid column
     */
    public function replaceColumn(ColumnDefinition $column) : void
    {
        // Extract the column name from the definition for validation and indexing
        $name = $column->columnName();

        // Ensure column name validity to maintain schema integrity
        if (! $name) {
            throw new RuntimeException(
                message: "Column name must not be empty for replacement."
            );
        }

        // Perform atomic column replacement in the schema definition
        $this->columns[$name] = $column;
    }

    /**
     * Retrieves the table name.
     *
     * Value object accessor for the immutable table name property.
     *
     * @return string The logical table name
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * Retrieves all column definitions.
     *
     * Provides read-only access to the complete collection of column definitions.
     *
     * @return array<string, ColumnDefinition> Column definitions indexed by name
     */
    public function getColumns() : array
    {
        return $this->columns;
    }

    /**
     * Retrieves all defined table indexes.
     *
     * This method provides access to the collection of indexes that have been
     * defined for the current table schema.
     * The indexes can include various types such as:
     * - Regular indexes (INDEX)
     * - Unique indexes (UNIQUE)
     * - Fulltext indexes (FULLTEXT)
     * - Spatial indexes (SPATIAL)
     *
     * @return array<string, ColumnDefinition> Array of index definitions keyed by index name
     *
     * @since 1.0.0
     * @api
     */
    public function getIndexes() : array
    {
        // Return the protected collection of index definitions
        return $this->indexes;
    }
}
=== Migration/Design/Table/Traits/FieldMappingTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use RuntimeException;

/**
 * Provides field mapping capabilities for database schema definitions.
 *
 * This trait implements the Strategy pattern to enable dynamic field-to-DSL mapping
 * in database table definitions. It serves as a bridge between FieldDTO objects
 * and the table's DSL methods.
 *
 * Key Features:
 * - Implements a Strategy pattern for flexible field mapping
 * - Supports both single and batch field operations
 * - Provides fluent interface for method chaining
 * - Maintains loose coupling through dependency injection
 *
 * @template T of object
 * @author YourName <your@email.com>
 * @since  8.3.0
 */
trait FieldMappingTrait
{
    /**
     * Field-to-DSL mapper implementation.
     *
     * Responsible for transforming FieldDTO objects into table column definitions
     * using the fluent DSL. Implements the Strategy pattern to allow runtime
     * mapping behavior modification.
     *
     * @var FieldToDslMapperInterface|null
     */
    private FieldToDslMapperInterface|null $mapper = null;

    /**
     * Configures the field mapping strategy.
     *
     * Injects the mapper implementation that will be used for converting FieldDTO
     * objects into table column definitions via the fluent DSL.
     *
     * @param FieldToDslMapperInterface $mapper The field mapping strategy to use
     *
     * @return T The trait using instance for method chaining
     */
    public function useMapper(FieldToDslMapperInterface $mapper) : self
    {
        $this->mapper = $mapper;

        return $this;
    }

    /**
     * Applies multiple field definitions to the table schema.
     *
     * Batch processes an array of FieldDTO objects, applying each one to the table
     * schema using the configured mapper.
     *
     * @param array<int, FieldDTO> $fields Collection of field definitions to apply
     *
     * @return T The trait using instance for method chaining
     */
    public function applyMany(array $fields) : self
    {
        foreach ($fields as $field) {
            $this->apply(field: $field);
        }

        return $this;
    }

    /**
     * Applies a single field definition to the table schema.
     *
     * Delegates the field-to-column mapping to the injected mapper strategy,
     * enforcing the requirement for a configured mapper.
     *
     * @param FieldDTO $field The field definition to apply
     *
     * @return T The trait using instance for method chaining
     * @throws RuntimeException When no mapper has been configured
     */
    public function apply(FieldDTO $field) : self
    {
        if (! $this->mapper) {
            throw new RuntimeException(message: 'No FieldToDslMapperInterface injected into Table.');
        }

        $this->mapper->apply(table: $this, field: $field);

        return $this;
    }
}
=== Migration/Design/Table/Traits/IndexDefinitionsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\DSL\ColumnDefinition;
use Gemini\Database\Migration\Design\Column\Enums\ColumnType;

/**
 * Trait IndexDefinitionsTrait
 *
 * Provides fluent DSL methods for defining table-level indexes.
 */
trait IndexDefinitionsTrait
{
    /**
     * @var array<string, ColumnDefinition> Indexes keyed by index name
     */
    protected array $indexes = [];

    /**
     * Adds a general-purpose INDEX.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function index(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::INDEX, columns: $columns, indexName: $indexName);
    }

    /**
     * Internal helper to create and register an index ColumnDefinition.
     *
     * @param ColumnType                $type
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    private function addIndex(ColumnType $type, string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        $cols = (array) $columns;
        $name = $indexName ?? strtolower($type->value) . '_' . implode('_', $cols);

        $definition = ColumnDefinition::make(name: $name, type: $type)
            ->columns($cols);

        $this->indexes[$name] = $definition;

        return $definition;
    }

    /**
     * Adds a FULLTEXT index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function fullText(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::FULLTEXT, columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a SPATIAL index.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function spatialIndex(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::SPATIAL, columns: $columns, indexName: $indexName);
    }

    /**
     * Alias for unique composite keys.
     *
     * @param array<int, string> $columns
     * @param string|null        $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function uniqueComposite(array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->unique(columns: $columns, indexName: $indexName);
    }

    /**
     * Adds a UNIQUE index with optional composite support.
     *
     * @param string|array<int, string> $columns
     * @param string|null               $indexName
     *
     * @return ColumnDefinition
     * @throws \ReflectionException
     */
    public function unique(string|array $columns, string|null $indexName = null) : ColumnDefinition
    {
        return $this->addIndex(type: ColumnType::UNIQUE, columns: $columns, indexName: $indexName);
    }
}

=== Migration/Design/Table/Traits/SpatialColumnsTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\ColumnBuilder;

trait SpatialColumnsTrait
{
    public function geometry(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRY', name: $name);
    }

    public function point(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POINT', name: $name);
    }

    public function lineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'LINESTRING', name: $name);
    }

    public function polygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'POLYGON', name: $name);
    }

    public function multiPoint(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOINT', name: $name);
    }

    public function multiLineString(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTILINESTRING', name: $name);
    }

    public function multiPolygon(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'MULTIPOLYGON', name: $name);
    }

    public function geometryCollection(string $name) : ColumnBuilder
    {
        return $this->addColumn(type: 'GEOMETRYCOLLECTION', name: $name);
    }
}
=== Migration/Design/Table/Traits/TablePropertiesTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

/**
 * Trait TablePropertiesTrait
 *
 * Provides methods for defining table-level properties such as storage engine, character set, collation, and comments.
 * These properties allow for fine-grained control over database table configurations, ensuring optimal performance and
 * compatibility.
 *
 * Supported properties:
 * - Storage engine (e.g., InnoDB, MyISAM)
 * - Character set (e.g., utf8, utf8mb4)
 * - Collation (e.g., utf8_general_ci, utf8mb4_unicode_ci)
 * - Table-level comments for documentation and indexing purposes
 *
 * Usage Example:
 * ```
 * $blueprint->engine('InnoDB');
 * $blueprint->charset('utf8mb4');
 * $blueprint->collation('utf8mb4_unicode_ci');
 * $blueprint->comment('User table storing authentication details');
 * ```
 *
 * @package Gemini\Database\Migration\Table\Traits
 */
trait TablePropertiesTrait
{
    /**
     * Sets the storage engine for the table.
     *
     * @param string $engine The storage engine (e.g., 'InnoDB', 'MyISAM').
     *
     * @return \Gemini\Database\Migration\Design\Table\Table|\Gemini\Database\Migration\Design\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->engine('InnoDB');
     * ```
     */
    public function engine(string $engine) : self
    {
        $this->tableEngine = $engine;

        return $this;
    }

    /**
     * Sets the character set for the table.
     *
     * @param string $charset The character set (e.g., 'utf8mb4', 'utf8').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->charset('utf8mb4');
     * ```
     */
    public function charset(string $charset) : self
    {
        $this->charset = $charset;

        return $this;
    }

    /**
     * Sets the collation for the table.
     *
     * @param string $collation The collation (e.g., 'utf8mb4_unicode_ci', 'utf8_general_ci').
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->collation('utf8mb4_unicode_ci');
     * ```
     */
    public function collation(string $collation) : self
    {
        $this->collation = $collation;

        return $this;
    }

    /**
     * Sets a comment for the table.
     *
     * @param string $text The comment text.
     *
     * @return \Gemini\Database\Migration\Design\Table\Traits\TablePropertiesTrait Usage
     *                                                                                                                     Example:
     *
     * Usage Example:
     * ```
     * $blueprint->comment('Stores user authentication data');
     * ```
     */
    public function comment(string $text) : self
    {
        $this->tableComment = addslashes($text);

        return $this;
    }
}

=== Migration/Design/Table/Traits/TableRenderDslTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnDSLRenderer;

/**
 * Trait TableRenderDslTrait
 *
 * Provides Domain-Specific Language (DSL) rendering capabilities for database table definitions.
 * Implement the Single Responsibility Principle by focusing solely on DSL generation logic.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 *
 * @since   1.0.0
 */
trait TableRenderDslTrait
{
    /**
     * Converts the table definition into a DSL representation.
     *
     * Transforms the internal column collection into a formatted DSL string using
     * the ColumnDSLRenderer. Follows the Command Query Separation principle by
     * performing a pure transformation operation.
     *
     * @return string The generated DSL representation of the table structure
     */
    public function toDsl() : string
    {
        // Initialize collection for DSL line storage
        $lines = [];

        // Transform each column definition into its DSL representation
        foreach ($this->getColumns() as $column) {
            // Delegate rendering responsibility to a specialized renderer
            $lines[] = (new ColumnDSLRenderer())->format(column: $column->getBuilder());
        }

        // Join DSL lines with proper indentation
        return implode(
            separator: PHP_EOL . '            ',
            array    : $lines
        );
    }
}
=== Migration/Design/Table/Traits/TableRenderSqlTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Design\Table\Traits;

use Gemini\Database\Migration\Design\Column\Renderer\ColumnSQLRenderer;
use RuntimeException;

/**
 * Trait TableRenderSqlTrait
 *
 * Provides SQL rendering capabilities for table definitions in the database migration context.
 * Implements Domain-Driven Design principles for table schema representation.
 *
 * @package Gemini\Database\Migration\Design\Table\Traits
 */
trait TableRenderSqlTrait
{
    /**
     * Generates the SQL CREATE TABLE statement for the current table definition.
     *
     * Transforms the abstract table representation into a valid SQL statement,
     * handling both simple and nested column definitions. Ensures proper SQL
     * formatting with indentation and newlines for improved readability.
     *
     * @return string Complete SQL CREATE TABLE statement
     * @throws RuntimeException When no columns are defined for the table
     */
    public function toSql() : string
    {
        // Retrieve all column definitions from the table schema
        $columns = $this->getColumns();

        // Validate that the table has at least one column defined
        if (empty($columns)) {
            throw new RuntimeException(
                message: sprintf('No columns defined for table [%s]', $this->getName())
            );
        }

        // Initialize collection for SQL column definitions
        $lines = [];

        // Process each column definition, handling both single and nested columns
        foreach ($columns as $col) {
            if (is_array($col)) {
                // Handle nested column definitions (e.g., for compound indexes)
                foreach ($col as $nested) {
                    $lines[] = ColumnSQLRenderer::render(column: $nested->getBuilder());
                }
            } else {
                // Process single column definition
                $lines[] = ColumnSQLRenderer::render(column: $col->getBuilder());
            }
        }

        // Construct the complete CREATE TABLE statement with proper formatting
        $sql = sprintf(
            "CREATE TABLE `%s` (\n    %s\n)",
            $this->getName(),
            implode(",\n    ", $lines)
        );

        // Append semicolon to complete the SQL statement
        return $sql . ';';
    }
}
=== Migration/Runner/CliInput.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

class CliInput
{
    public function __construct(private readonly array $rawArguments) {}

    /**
     * Check if a specific key exists in the arguments.
     */
    public function has(string $key) : bool
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get the value of a specific key.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        foreach ($this->rawArguments as $rawArgument) {
            if (str_starts_with((string) $rawArgument, '--' . $key)) {
                [$k, $value] = explode('=', (string) $rawArgument, 2) + [1 => $default];

                return $value;
            }
        }

        return $default;
    }

    /**
     * Retrieve a raw argument by index.
     */
    public function getRawArgument(int $index) : string|null
    {
        return $this->rawArguments[$index] ?? null;
    }

    /**
     * Get all remaining arguments (after the command).
     */
    public function getRemainingArguments() : array
    {
        return array_slice($this->rawArguments, 2);
    }
}

=== Migration/Runner/Commands/Commands.php ===
<?php

declare(strict_types=1);

/**
 * Represents a container for database migration commands.
 */

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The Commands class is responsible for managing and organizing available commands
 * within the application.
 *
 * It initializes and retrieves a collection of commands during instantiation.
 */
class Commands
{
    private Arrhae $commands;

    public function __construct()
    {
        $this->commands = $this->getCommands();
    }

    private function getCommands() : Arrhae
    {
        return Arrhae::make(
            items: [
                       //'install'          => new InstallCommand(),
                       'create:migration' => new MigrationGenerator(),
                   ]
        );
    }
}
=== Migration/Runner/Commands/Defined/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Defined;

/**
 * Class Migration
 *
 * This class defines a set of migration commands and their corresponding aliases.
 * It helps in standardizing the command names for various migration operations.
 */
class Migration
{
    /**
     * Get the list of migration commands and their aliases.
     *
     * This method returns an associative array mapping custom command names to
     * their actual migration command counterparts. The intent is to provide a
     * simpler and more standardized way to refer to common migration operations.
     *
     * @return array<string, string> Returns an associative array of command aliases.
     */
    public static function definedCommandAliases() : array
    {
        return [
            'migrate:up'       => 'migrate',
            'migrate:down'     => 'migrate:rollback',
            'migrate:reapply'  => 'migrate:refresh',
            'migrate:clean'    => 'migrate:fresh',
            'create:migration' => 'make:migration',
        ];
    }
}
=== Migration/Runner/Commands/InstallCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\MigrationException;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\SchemaBuilder;
use Psr\Log\LoggerInterface;
use RuntimeException;
use Throwable;

use function readline;
use function strtolower;
use function trim;

/**
 * InstallCommand handles the initial application setup.
 *
 * This final class is made readonly to ensure immutability after instantiation,
 * which enhances reliability and predictability in its behavior.
 */
final readonly class InstallCommand implements CommandInterface
{
    /**
     * The name of the migrations table used to track migrations.
     */
    private const string MIGRATIONS_TABLE = 'migrations';

    /**
     * Constructor for InstallCommand.
     *
     * @param SchemaBuilder                $schemaBuilder       Builder for database schemas.
     * @param LoggerInterface              $logger              Logger instance for logging events.
     * @param MigrationRepositoryInterface $migrationRepository Repository for handling migration records.
     */
    public function __construct(
        private SchemaBuilder                $schemaBuilder,
        private LoggerInterface              $logger,
        private MigrationRepositoryInterface $migrationRepository
    ) {}

    /**
     * Executes the command to set up the initial database and migrations.
     *
     * @param array $arguments Key-value array of arguments for the command.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in the process fails.
     */
    public function execute(array $arguments = []) : void
    {
        $database = $this->getDatabaseName(arguments: $arguments);
        $this->prepareDatabase(database: $database);
        $this->ensureMigrationsTableSetup();
        $this->recordSelfAsFirstMigration();
    }

    /**
     * Retrieves the database name from arguments or environment variables.
     *
     * Throws an exception if the database name is not found.
     *
     * @param array $arguments The command-line arguments passed to the script.
     *
     * @return string The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database name is not provided.
     */
    private function getDatabaseName(array $arguments) : string
    {
        $database = $arguments['database'] ?? env(key: 'DB_NAME') ?? null;
        if (! $database) {
            $this->logAndThrowMigrationException(message: 'Database name is required but was not provided.');
        }

        $this->logger->info(message: 'Preparing installation for database: ' . $database);

        return $database;
    }

    /**
     * Logs an error message and throws a MigrationException.
     *
     * This ensures that each failure point provides a consistent error handling strategy.
     *
     * @param string          $message  The error message to log and throw.
     * @param \Throwable|null $previous The previous exception for chaining, if any.
     *
     * @throws MigrationException Always thrown after logging the error.
     */
    private function logAndThrowMigrationException(string $message, Throwable|null $previous = null) : never
    {
        $this->logger->error(message: $message);
        throw new MigrationException(message: $message, previous: $previous);
    }

    /**
     * Prepares the database for the installation.
     *
     * Checks the database connection and ensures the existence of the database.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if any step in preparation fails.
     */
    private function prepareDatabase(string $database) : void
    {
        $this->checkDatabaseConnection(database: $database);
        $this->ensureDatabaseExists(database: $database);
    }

    /**
     * Checks if the connection to the database is healthy.
     *
     * Throws an exception if the connection is not healthy, to ensure database operations are safe to proceed.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if the database connection is unhealthy.
     */
    private function checkDatabaseConnection(string $database) : void
    {
        if (! $this->schemaBuilder->isConnectionHealthy(database: $database)) {
            $this->logAndThrowMigrationException(
                message: sprintf("Failed to establish a healthy connection to the database '%s'.", $database)
            );
        }
    }

    /**
     * Ensures that the database exists, creating it if it does not.
     *
     * Logs and provides feedback to the user accordingly.
     *
     * @param string $database The name of the database.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the database fails.
     */
    private function ensureDatabaseExists(string $database) : void
    {
        if (! $this->schemaBuilder->databaseExists(database: $database)) {
            $this->logger->info(message: sprintf("Database '%s' does not exist. Creating database...", $database));
            $this->schemaBuilder->createDatabase(database: $database);
            echo "Database '" . $database . "' created successfully.\n";
        } else {
            echo "Database '" . $database . "' already exists.\n";
        }
    }

    /**
     * Ensures the migrations table is set up correctly.
     *
     * This method handles the creation or recreation of the migrations table, providing feedback and
     * handling exceptions to maintain consistency in the setup process.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if setting up the migrations table fails.
     */
    private function ensureMigrationsTableSetup() : void
    {
        try {
            if (! $this->schemaBuilder->tableExists(table: self::MIGRATIONS_TABLE)) {
                $this->createMigrationsTable();
            } else {
                $this->promptRecreateMigrationsTable();
            }

            echo "Migration install completed.\n";
        } catch (RuntimeException $runtimeException) {
            $this->logAndThrowMigrationException(
                message : "Failed to set up migrations table: " . $runtimeException->getMessage(),
                previous: $runtimeException
            );
        }
    }

    /**
     * Creates the migrations table with the necessary columns.
     *
     * The table structure is defined within a callback to ensure consistent setup.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if creating the migrations table fails.
     */
    private function createMigrationsTable() : void
    {
        try {
            $this->schemaBuilder->create(table: self::MIGRATIONS_TABLE, callback: static function ($table) : void {
                $table->id();
                $table->string('migration');
                $table->string('executable');
                $table->integer('batch');
                $table->timestamp('executed_at')->useCurrent();
            });
            $this->logger->info(message: 'Migrations table created successfully.');
            echo "Migrations table created successfully.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to create migrations table: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Prompts the user to recreate the migration table if it already exists.
     *
     * Provides options to drop and recreate the table or to skip this step.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if user opts to recreate and the operation
     *                                                                  fails.
     */
    private function promptRecreateMigrationsTable() : void
    {
        $choice = strtolower(
            trim(readline("The 'migrations' table already exists. Do you want to recreate it? [yes/no]: "))
        );
        if (in_array($choice, ['yes', 'y'], true)) {
            $this->schemaBuilder->drop(table: self::MIGRATIONS_TABLE);
            $this->logger->info(message: 'Old migrations table dropped.');
            echo "Old 'migrations' table dropped.\n";
            $this->createMigrationsTable();
        } else {
            echo "Skipped creating the 'migrations' table.\n";
        }
    }

    /**
     * Records this InstallCommand as the first migration in the migrations table.
     *
     * This method ensures that InstallCommand is logged as the first entry,
     * establishing the provenance of the migration system installation.
     *
     * @throws \Gemini\Database\Migration\Runner\MigrationException if saving the record fails.
     */
    private function recordSelfAsFirstMigration() : void
    {
        try {
            $this->migrationRepository->save(
                migration : 'CreateMigrationsTable',
                executable: self::class,
                batch     : 1
            );
            $this->logger->info(message: 'Recorded InstallCommand as the first migration.');
            echo "Recorded InstallCommand as the first migration.\n";
        } catch (Throwable $throwable) {
            $this->logAndThrowMigrationException(
                message : "Failed to record the InstallCommand migration: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}
=== Migration/Runner/Commands/MakeMigrationCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\{Repository\RepositoryGenerator};
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\DTO\DtoGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityGenerator;
use Gemini\Database\Migration\Runner\Generators\Entity\EntityQueryBuilderGenerator;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\Database\Migration\Runner\Generators\Service\ServiceGenerator;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MakeMigrationCommand
 *
 * This class manages the creation of migrations and optionally generates
 * related components like Entity, DTO, Repository, etc.
 */
final readonly class MakeMigrationCommand implements CommandInterface
{
    private const string        ERROR_MISSING_ARGUMENTS = "Migration name and table name are required.";

    private const        string ERROR_INVALID_FIELDS    = "Invalid fields format. Expected format: 'name:type:attr1,attr2'.";

    public function __construct(
        private MigrationGenerator          $migrationGenerator,
        private EntityGenerator             $entityGenerator,
        private EntityQueryBuilderGenerator $entityQueryBuilderGenerator,
        private DtoGenerator                $dtoGenerator,
        private RepositoryGenerator         $repositoryGenerator,
        private ServiceGenerator            $serviceGenerator,
        private MigrationStateManager       $migrationStateManager,
        private LoggerInterface             $logger
    ) {}

    /**
     * Executes the MakeMigration command.
     *
     * @param array $arguments Command-line arguments.
     */
    public function execute(array $arguments) : void
    {
        try {
            $input = new Arrhae($arguments);

            // Check for presence
            if (! $input->has(key: 'name') || ! $input->has(key: 'table')) {
                $this->reportError(message: self::ERROR_MISSING_ARGUMENTS);

                return;
            }

            $name  = $input->get(key: 'name');
            $table = $input->get(key: 'table');

            $fieldsInput = $input->get(key: 'fields', default: '');
            $fields      = $this->extractFields(fieldsInput: $fieldsInput);

            $this->generateMigration(name: $name, table: $table, fields: $fields);

            if ($input->get(key: 'entity', default: false)) {
                $this->generateEntity(name: $table, fields: $fields);
            }
            if ($input->get(key: 'entity-qb', default: false)) {
                $this->generateQueryBuilder(name: $table, table: $table, fields: $fields);
            }
            if ($input->get(key: 'dto', default: false)) {
                $this->generateDto(name: $table, fields: $fields);
            }
            if ($input->get(key: 'repository', default: false)) {
                $this->generateRepository(name: $table, fields: $fields);
            }
            if ($input->get(key: 'service', default: false)) {
                $this->generateService(name: $table);
            }
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    /**
     * Reports an error to the logger and echoes it.
     *
     * @param string $message The error message.
     */
    private function reportError(string $message) : void
    {
        $this->logger->error(message: $message);
        echo "Error: " . $message . "\n";
    }

    private function extractFields(string $fieldsInput) : array
    {
        // Wrap the fields into an Arrhae instance
        return (new Arrhae(items: explode(',', $fieldsInput)))
            ->filter(callback: fn($field) => ! empty($field)) // Filter out empty fields
            ->map(callback: function ($field) {
                $parts = explode(':', $field);
                if (count($parts) < 2) {
                    throw new InvalidArgumentException(message: self::ERROR_INVALID_FIELDS);
                }

                $name       = $parts[0];
                $type       = $parts[1];
                $attributes = array_slice($parts, 2);

                return $this->parseField(name: $name, type: $type, attributes: $attributes);
            })
            ->toArray(); // Convert back to a standard array
    }

    private function parseField(string $name, string $type, array $attributes) : array
    {
        // Wrap attributes in Arrhae for simplified handling
        return (new Arrhae(items: $attributes))
            ->reduce(
                callback: fn($fieldData, $attribute) => match (true) {
                    str_contains($attribute, 'default:') => array_merge(
                        $fieldData,
                        [
                            'default' => str_replace(
                                'default:',
                                '',
                                $attribute
                            ),
                        ]
                    ),
                    $attribute === 'unique'              => array_merge($fieldData, ['unique' => true]),
                    $attribute === 'nullable'            => array_merge($fieldData, ['nullable' => true]),
                    default                              => $fieldData
                },
                initial : ['name' => $name, 'type' => $type]
            );
    }

    private function generateMigration(string $name, string $table, array $fields) : void
    {
        try {
            $this->migrationGenerator->writeMigrationFile(name: $name, table: $table, fields: $fields);
            $this->migrationStateManager->migrate(availableMigrations: [$name]);
        } catch (Throwable $e) {
            $this->handleException(e: $e);
        }
    }

    private function handleException(Throwable $e) : void
    {
        $errorMessage = sprintf(
            'Error: %s in %s on line %d',
            $e->getMessage(),
            $e->getFile(),
            $e->getLine()
        );
        $this->logger->error(message: $errorMessage);
        echo $errorMessage . "\n";
    }

    private function generateEntity(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('Entity %s created successfully.', $name)
        );
    }

    private function executeSafely(callable $operation, string $successMessage) : void
    {
        try {
            $operation();
            $this->logger->info(message: $successMessage);
            echo $successMessage . "\n";
        } catch (Throwable $throwable) {
            $this->handleException(e: $throwable);
        }
    }

    private function generateQueryBuilder(string $name, string $table, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->entityQueryBuilderGenerator->create(
                name  : $name,
                table : $table,
                fields: $fields
            ),
            successMessage: sprintf('Entity QueryBuilder %s created successfully.', $name)
        );
    }

    private function generateDto(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->dtoGenerator->create(tableName: $name, fields: $fields),
            successMessage: sprintf('DTO %s created successfully.', $name)
        );
    }

    private function generateRepository(string $name, array $fields) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->repositoryGenerator->create(
                tableName: $name,
                entity   : $name,
                fields   : $fields
            ),
            successMessage: sprintf('Repository %s created successfully.', $name)
        );
    }

    private function generateService(string $name) : void
    {
        $this->executeSafely(
            operation     : fn() => $this->serviceGenerator->create(name: $name),
            successMessage: sprintf('Service %s created successfully.', $name)
        );
    }
}

=== Migration/Runner/Commands/Middlewares/LoggingMiddleware.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;

/**
 * Middleware for logging command execution.
 *
 * This middleware logs the execution of migration commands, both at the start and at the
 * completion of the command's execution. It helps to track command activities, useful for
 * debugging and auditing purposes.
 */
class LoggingMiddleware
{
    /**
     * Handles the command execution with logging.
     *
     * Logs the start and end of command execution, providing insights into command activities.
     *
     * @param array    $input                                               The input parameters for the command.
     * @param callable $next                                                The next middleware or the actual command
     *                                                                      execution.
     *
     */
    public function handle(CommandInterface $command, array $input, callable $next) : void
    {
        // Log the start of the command execution.
        logger(message: 'Executing command: ' . $command::class, context: $input, level: 'debug');

        // Proceed to the next middleware or actual command execution.
        $next();

        // Log the end of the command execution.
        logger(message: 'Command execution finished: ' . $command::class, context: [], level: 'debug');
    }
}
=== Migration/Runner/Commands/Middlewares/MiddlewareStack.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands\Middlewares;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * A stack of middleware functions to be executed as a pipeline.
 *
 * - Extends Arrhae to manage the internal collection of middleware functions.
 * - Allows pushing middleware functions onto the stack.
 * - Executes the middleware functions in sequence, passing control to the `next` middleware.
 */
class MiddlewareStack extends Arrhae
{
    /**
     * Adds a middleware callable to the stack.
     *
     * This method allows chaining by returning the instance.
     *
     * @param callable $middleware The middleware to add.
     *
     * @return self The instance itself for method chaining.
     */
    public function push(callable $middleware) : self
    {
        $this->add($middleware);

        return $this;
    }

    /**
     * Executes the command by passing it through the middleware stack.
     *
     * - The method applies each middleware function to the command.
     * - Ensures that the `next` callable is eventually called.
     *
     * @param CommandInterface $command   The command to execute.
     * @param array            $arguments The arguments for the command.
     * @param callable         $next      The next middleware callable.
     */
    public function execute(
        CommandInterface $command,
        array            $arguments,
        callable         $next
    ) : void {
        // Middleware logic here, last middleware will eventually call $next()
        $next();
    }
}
=== Migration/Runner/Commands/MigrateCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\Migration\Runner\Service\MigrationStateManager;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * MigrateCommand
 *
 * A final immutable class responsible for executing the migration process.
 * Implements CommandInterface to standardize command execution.
 *
 * The class is marked as readonly to enforce immutability ensuring
 * that its state cannot be altered after instantiation, adding robustness
 * and thread-safety.
 */
final readonly class MigrateCommand implements CommandInterface
{
    /**
     * MigrateCommand constructor.
     *
     * @param MigrationStateManager        $migrationStateManager Service to manage the state of migrations.
     * @param MigrationRepositoryInterface $migrationRepository   Repository to fetch available migrations.
     * @param LoggerInterface              $logger                Logger for recording operational events.
     */
    public function __construct(
        private MigrationStateManager        $migrationStateManager,
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface              $logger
    ) {}

    /**
     * Executes the migration process.
     *
     * This method orchestrates the entire migration process, logging important steps
     * and handling exceptions to ensure smooth operation.
     *
     * @param array $arguments CLI arguments or configuration parameters.
     *
     * @throws MigrationException If the migration process encounters an error.
     */
    public function execute(array $arguments = []) : void
    {
        try {
            $this->logger->info(message: 'Starting migration process.');
            echo "Starting migration process...\n";

            $availableMigrations = $this->fetchAvailableMigrations();
            $this->migrationStateManager->migrate(availableMigrations: $availableMigrations);

            $this->logger->info(message: 'Migration process completed successfully.');
            echo "Migration process completed successfully.\n";
        } catch (MigrationException $migrationException) {
            // Handle known migration-specific errors.
            $this->handleError(migrationException: $migrationException);
        } catch (Throwable $throwable) {
            // Handle unexpected errors that do not fall under MigrationException.
            $this->handleUnexpectedError(throwable: $throwable);
        }
    }

    /**
     * Fetches available migrations directly from the database.
     *
     * This encapsulates the retrieval logic from the repository, ensuring a single responsibility
     * and making it easy to modify data fetching strategy if required.
     *
     * @return array List of fully qualified migration class names.
     */
    private function fetchAvailableMigrations() : array
    {
        $migrations          = $this->migrationRepository->getAll();
        $availableMigrations = array_column($migrations, 'executable');

        $this->logger->info(message: 'Fetched available migrations.', context: ['migrations' => $availableMigrations]);

        return $availableMigrations;
    }

    /**
     * Handles migration-specific errors gracefully.
     *
     * This function centralizes error handling for migration exceptions, ensuring consistent
     * logging and error reporting which makes debugging easier.
     *
     * @param MigrationException $migrationException Exception to handle.
     */
    private function handleError(MigrationException $migrationException) : void
    {
        $this->logger->error(
            message: 'Migration process failed.',
            context: ['error' => $migrationException->getMessage()]
        );

        echo sprintf('Migration process failed: %s%s', $migrationException->getMessage(), PHP_EOL);
    }

    /**
     * Handles unexpected errors gracefully.
     *
     * Centralizes the handling of unknown or unexpected errors, ensuring that critical failures
     * are logged and reported consistently, making it easier to track issues.
     *
     * @param Throwable $throwable Exception to handle.
     */
    private function handleUnexpectedError(Throwable $throwable) : void
    {
        $this->logger->critical(
            message: 'An unexpected error occurred during the migration process.',
            context: ['error' => $throwable->getMessage()]
        );

        echo sprintf('Unexpected error: %s%s', $throwable->getMessage(), PHP_EOL);
    }
}
=== Migration/Runner/Commands/MigrateFreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateFreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Running fresh migrations...\n";
            $this->logger->info("Fresh migrations executed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error running fresh migrations: ' . $throwable->getMessage());
        }
    }
}
=== Migration/Runner/Commands/MigrateRefreshCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRefreshCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Refreshing migrations...\n";
            $this->logger->info("Migrations refreshed successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error refreshing migrations: ' . $throwable->getMessage());
        }
    }
}
=== Migration/Runner/Commands/MigrateRollbackCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;
use Throwable;

final readonly class MigrateRollbackCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        try {
            echo "Rolling back migrations...\n";
            $this->logger->info("Migrations rolled back successfully.");
        } catch (Throwable $throwable) {
            $this->logger->error('Error rolling back migrations: ' . $throwable->getMessage());
        }
    }
}
=== Migration/Runner/Commands/MigrateStatusCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Psr\Log\LoggerInterface;

final readonly class MigrateStatusCommand implements CommandInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function execute(array $arguments) : void
    {
        echo "Migration status:\n";
        echo "[âœ“] Migration_001\n";
        echo "[âœ“] Migration_002\n";
        $this->logger->info("Migration status retrieved successfully.");
    }
}
=== Migration/Runner/Commands/ValidateStubsCommand.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Commands;

use Gemini\Database\Migration\Runner\Generators\CommandInterface;
use Gemini\Database\Migration\Runner\Generators\StubResolver;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * ValidateStubsCommand Class
 *
 * Validates the existence and readability of stub files in the specified directory.
 */
readonly class ValidateStubsCommand implements CommandInterface
{
    public function __construct(
        private StubResolver    $stubResolver,
        private LoggerInterface $logger
    ) {}

    /**
     * Executes the stub validation command.
     *
     * @param array $arguments List of stub file names to validate.
     */
    public function execute(array $arguments) : void
    {
        if ($arguments === []) {
            $this->logger->error(message: "No stub files provided for validation.");
            echo "Error: No stub files provided for validation.\n";

            return;
        }

        foreach ($arguments as $argument) {
            try {
                // Attempt to read the stub file
                $this->stubResolver->read(stubName: $argument);

                // Log and output success message
                $this->logger->info(message: sprintf('Stub "%s" is valid.', $argument));
                echo sprintf("Stub \"%s\" is valid.\n", $argument);
            } catch (Throwable $e) {
                // Log and output error message
                $this->logger->error(
                    message: sprintf(
                                 'Stub "%s" validation failed: %s',
                                 $argument,
                                 $e->getMessage()
                             )
                );
                echo sprintf(
                    "Error: Stub \"%s\" validation failed: %s\n",
                    $argument,
                    $e->getMessage()
                );
            }
        }
    }
}

=== Migration/Runner/Console/CLI.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Console;

use Exception;
use Gemini\Database\Migration\Runner\Generators\Migration\MigrationGenerator;
use Gemini\DataHandling\ArrayHandling\Arrhae;

/**
 * The CLI class handles command-line interactions for database migrations.
 * It utilizes the Arrhae collection class for managing commands and arguments,
 * providing enhanced flexibility and powerful data manipulation capabilities.
 *
 * Example Usage:
 * php gemini create:migration --name=CreateUsersTable
 */
class CLI
{
    /**
     * @var Arrhae The collection of available commands.
     */
    private Arrhae $commands;

    /**
     * CLI constructor.
     *
     * Initializes the commands collection using the Arrhae::make() factory method.
     */
    public function __construct()
    {
        // Initialize the command collection with Arrhae
        $this->commands = Arrhae::make(
            items: [
                       'make:migration' => new MigrationGenerator(),
                   ]
        );
    }

    /**
     * Executes the CLI command based on provided arguments.
     *
     * @param array $argv Command-line arguments.
     *
     * @return void
     */
    public function run(array $argv) : void
    {
        // Wrap the $argv array into an Arrhae collection for enhanced manipulation
        $args = Arrhae::make(items: $argv);

        // Check if at least one command is provided
        if ($args->count() < 2) {
            $this->displayUsage();
            exit(1);
        }

        // Retrieve the command name (second argument)
        $commandName = $args->get(key: 1);

        // Format the arguments using the Arrhae-based method
        $arguments = $this->formatArguments(args: $args->slice(offset: 2));

        // Check if the command exists in the collection
        if (! $this->commands->has(key: $commandName)) {
            echo "Command not found: {$commandName}\n";
            $this->suggestSimilarCommands(commandName: $commandName);
            exit(1);
        }

        // Retrieve the command instance
        $command = $this->commands->get(key: $commandName);

        // Ensure the command is executable
        if (! method_exists($command, 'execute')) {
            echo "Command '{$commandName}' is not executable.\n";
            exit(1);
        }

        // Execute the command with the formatted arguments
        try {
            $command->execute($arguments->toArray());
        } catch (Exception $e) {
            echo "Error executing command '{$commandName}': " . $e->getMessage() . "\n";
            exit(1);
        }
    }

    /**
     * Displays the usage instructions for the CLI.
     *
     * @return void
     */
    private function displayUsage() : void
    {
        echo "Usage: php gemini <command> [options]\n";
        echo "Available Commands:\n";
        echo $this->commands->keys()->map(static fn($command) => "  - {$command}")->implode("\n") . "\n";
    }

    /**
     * Formats command-line arguments into a structured Arrhae collection.
     *
     * This method parses arguments to handle both flag-style (e.g., --key=value)
     * and positional arguments, assigning the first positional argument to 'name'.
     *
     * @param Arrhae $args Raw command-line arguments (excluding script name and command name).
     *
     * @return Arrhae Formatted arguments as an Arrhae collection.
     */
    private function formatArguments(Arrhae $args) : Arrhae
    {
        // Use Arrhae's filtering and mapping capabilities to parse arguments
        return $args
            ->filter(callback: static fn($arg, $key) => is_string($arg) && $key !== 0) // Exclude script name
            ->mapWithKeys(callback: static function ($arg) {
                if (str_starts_with($arg, '--')) {
                    // Parse --key=value arguments
                    $keyValue = substr($arg, 2);
                    $parts    = explode('=', $keyValue, 2);

                    $key = $parts[0];
                    $value = $parts[1] ?? true; // Assign true if no value is provided

                    return [$key => $value];
                } elseif (! str_starts_with($arg, '--') && ! isset($arg)) {
                    // Assign the first positional argument to 'name'
                    return ['name' => $arg];
                }

                return [];
            })
            // Ensure 'name' is set if a positional argument exists
            ->when(
                condition: $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'))->count() > 0,
                callback : function ($collection) use ($args) {
                    $positionalArgs = $args->filter(callback: fn($arg) => ! str_starts_with($arg, '--'));

                    return $collection->set('name', $positionalArgs->first());
                }
            );
    }

    /**
     * Suggests similar commands if the provided command is not found.
     *
     * @param string $commandName The command name that was not found.
     *
     * @return void
     */
    private function suggestSimilarCommands(string $commandName) : void
    {
        // Wrap the keys into an Arrhae instance to use fuzzyMatch
        $similarCommands = Arrhae::make(items: $this->commands->keys())
            ->fuzzyMatch(query: $commandName, threshold: 60)
            ->toArray();

        if (! empty($similarCommands)) {
            echo "Did you mean:\n";
            echo Arrhae::make(items: $similarCommands)
                     ->map(callback: fn($cmd) => "  - {$cmd}")
                     ->implode("\n") . "\n";
        }
    }
}

=== Migration/Runner/DTO/FieldDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\Database\Migration\Design\Table\Enum\FieldTypeEnum;
use Gemini\Database\Migration\Design\Table\Enum\ForeignActionEnum;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationArrayRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldAttributesRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationFieldTypeRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationForeignActionRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationIntegerRule;
use Gemini\DataHandling\Validation\Attributes\Rules\MigrationStringRule;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;
use InvalidArgumentException;

final class FieldDTO extends AbstractDTO
{
    #[Required]
    #[Trimmed]
    #[StringType]
    public string                 $name;

    #[MigrationFieldTypeRule]
    public FieldTypeEnum|null     $type       = null;

    #[MigrationIntegerRule]
    public int|null               $length     = null;

    #[MigrationIntegerRule]
    public int|null               $total      = null;

    #[MigrationIntegerRule]
    public int|null               $places     = null;

    #[MigrationArrayRule]
    public array|null             $values     = null;

    public mixed                  $default    = null;

    #[MigrationFieldAttributesRule]
    public array|null             $attributes = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $comment    = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $references = null;

    #[MigrationStringRule]
    #[Trimmed]
    public string|null            $on         = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onDelete   = null;

    #[MigrationForeignActionRule]
    public ForeignActionEnum|null $onUpdate   = null;

    #[ArrayType]
    public array|null             $columns    = null;

    public function __construct(array|object $data)
    {
        $data = (array) $data;

        if (isset($data['name'], $data['type'])) {
            parent::__construct(data: $data);

            return;
        }

        $fieldName  = array_key_first($data);
        $definition = (array) ($data[$fieldName] ?? []);

        if (! isset($definition['type'])) {
            throw new InvalidArgumentException("Missing required 'type' key for field '{$fieldName}'");
        }

        $definition['name'] = $fieldName;
        parent::__construct(data: $definition);
    }
}

=== Migration/Runner/DTO/MigrationDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\DTOObjectOf;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;
use Gemini\DataHandling\Validation\Attributes\Rules\Trimmed;

/**
 * Data Transfer Object (DTO) for handling migration creation requests.
 *
 * This class acts as an intermediate structure for carrying data between
 * different layers/domain boundaries. It validates input data and ensures all
 * necessary properties conform to their expected types or constraints.
 *
 * Each property of the DTO is initialized and validated through the parent
 * `AbstractDTO` class's constructor.
 *
 * @package Application\DTO
 */
class MigrationDTO extends AbstractDTO
{
    /**
     * The name of the migration class (in PascalCase format).
     *
     * - This represents the high-level name of the migration and is expected to follow coding standards.
     * - This property is subject to trimming and validation rules for string-based input.
     *
     * Example:
     * ```
     * $migrationDTO->name = 'CreateUsersTable';
     * ```
     *
     * @var string Represents the name of the migration class.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be of type string.
    #[Required]
    public string $name;

    /**
     * The name of the database table being targeted or created by the migration.
     *
     * - This represents the physical table name in the database schema.
     * - It undergoes trimming and validation (must be a non-empty string).
     *
     * Example:
     * ```
     * $migrationDTO->table = 'users';
     * ```
     *
     * @var string Represents the target database table for the migration.
     */
    #[Trimmed]   // Ensures the value is trimmed before assignment.
    #[StringType] // Validates that the value must be a non-empty string.
    #[Required]
    public string $table;

    /**
     * The schema property representing a complex structure for validation.
     *
     * @var SchemaDTO A data transfer object containing structured schema information.
     */
    #[Required]
    #[DTOObjectOf(SchemaDTO::class)]
    public SchemaDTO $schema;

    public function __construct(array $data = [])
    {
        parent::__construct($data);
    }
}
=== Migration/Runner/DTO/MigrationRecordDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\Integer;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * DTO representing a single migration record.
 *
 * Used to transfer structured migration metadata (name, SQL, batch, time).
 */
final class MigrationRecordDTO extends AbstractDTO
{
    #[Required(message: 'Migration name is required.')]
    #[StringType(message: 'Migration must be a string.')]
    public string $migration;

    #[Required(message: 'Executable is required.')]
    #[StringType(message: 'Executable must be a string.')]
    public string $executable;

    #[Required(message: 'Batch ID is required.')]
    #[Integer(message: 'Batch must be an integer.')]
    public int    $batch;

    #[Required(message: 'Execution time is required.')]
    #[StringType(message: 'Execution time must be a valid datetime string.')]
    public string $executed_at;
}

=== Migration/Runner/DTO/SchemaDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\DTO;

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object (DTO) representing a database schema.
 *
 * Primary purpose:
 * - Facilitates the consistent and strongly typed representation of schema-related data throughout the system.
 * - Encapsulates and validates an array of fields, where each field is defined by an instance of `FieldDTO`.
 *
 * Leveraging DDD Practices:
 * - Serves as a Boundary Data Design for interaction between application layers.
 * - Ensures domain consistency by enforcing attribute-based validations (e.g., `#[Required]`, `#[ArrayType]`).
 *
 * @package Application\DTO
 */
class SchemaDTO extends AbstractDTO
{
    /**
     * A list of field definitions forming a database schema.
     *
     * - Represents the core building blocks of a database schema (e.g., columns, field attributes).
     * - Each field within the array is strongly typed as `FieldDTO`, ensuring schema integrity.
     *
     * Validation Requirements:
     * - **Required:** `fields` must be present and cannot be `null`.
     * - **ArrayType:** It must be an array of well-formed `FieldDTO` instances.
     *
     * @var \Gemini\Database\Migration\Runner\DTO\FieldDTO[] $fields
     *
     */
    #[Required]
    #[ArrayType]
    public array $fields;
}
=== Migration/Runner/Entity/Migration.php ===
<?php

declare(strict_types=1);

/**
 * Class Migration
 *
 * This class represents a Migration entity in the domain layer. It encapsulates:
 * - The name of the migration.
 * - The date and time when the migration was executed.
 *
 * Responsibilities:
 * - Store and provide access to migration-related data.
 * - Offer additional utilities for validation and serialization.
 *
 * Adheres to:
 * - Single Responsibility Principle (SRP): Only holds migration-specific data and logic.
 * - Immutability: The properties are set at construction and cannot be changed afterward.
 */

namespace Gemini\Database\Migration\Runner\Entity;

use DateTimeImmutable;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use JsonSerializable;

/**
 * The Migration class represents a database migration.
 * It stores the migration's name and the date/time of its execution.
 *
 * Features:
 * - Provides methods to retrieve migration details.
 * - Implements validation for robust handling of migration data.
 * - Supports JSON serialization for external APIs or storage.
 */
class Migration implements JsonSerializable
{
    /**
     * Constructor for the Migration class.
     *
     * @param string            $migrationName The name of the migration (must be non-empty).
     * @param DateTimeImmutable $executedAt    The date and time the migration was executed.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    public function __construct(
        protected string            $migrationName,
        protected DateTimeImmutable $executedAt,
        protected QueryBuilder      $queryBuilder
    ) {
        $this->validateMigrationName(migrationName: $migrationName);
    }

    /**
     * Validates the migration name.
     *
     * @param string $migrationName The name of the migration.
     *
     * @throws \InvalidArgumentException If the migration name is empty or invalid.
     */
    private function validateMigrationName(string $migrationName) : void
    {
        if (trim($migrationName) === '') {
            throw new InvalidArgumentException(message: 'Migration name cannot be empty.');
        }

        if (strlen($migrationName) > 255) {
            throw new InvalidArgumentException(message: 'Migration name cannot exceed 255 characters.');
        }
    }

    /**
     * Creates a Migration instance from an array of data.
     *
     * @param array $data An associative array containing 'migration_name' and 'executed_at' keys.
     *
     * @return static A new Migration instance created from the provided data.
     * @throws \InvalidArgumentException If required, data is missing or invalid.
     */
    public static function fromArray(array $data) : self
    {
        if (! isset($data['migration_name'], $data['executed_at'])) {
            throw new InvalidArgumentException(message: 'Missing required keys: "migration_name" and "executed_at".');
        }

        $executedAt = DateTimeImmutable::createFromFormat('Y-m-d H:i:s', $data['executed_at']);
        if ($executedAt === false) {
            throw new InvalidArgumentException(
                message: 'Invalid date format for "executed_at". Expected "Y-m-d H:i:s".'
            );
        }

//        return new self(
//            migrationName: $data['migration_name'],
//            executedAt   : $executedAt,
//            queryBuilder : $this->queryBuilder
//        );
    }

    /**
     * Alias for `getMigrationName`, used for compatibility with other systems.
     *
     * @return string The name of the migration.
     */
    public function getName() : string
    {
        return $this->getMigrationName();
    }

    /**
     * Retrieves the name of the migration.
     *
     * @return string The name of the migration.
     */
    public function getMigrationName() : string
    {
        return $this->migrationName;
    }

    /**
     * Gets the date and time when the migration was executed.
     *
     * @return DateTimeImmutable The datetime representing when the migration was executed.
     */
    public function getExecutedAt() : DateTimeImmutable
    {
        return $this->executedAt;
    }

    /**
     * Prepares the migration instance for JSON serialization.
     *
     * @return array The migration data ready for JSON encoding.
     */
    public function jsonSerialize() : array
    {
        return $this->toArray();
    }

    /**
     * Converts the migration instance to an associative array.
     *
     * @return array The migration data as an associative array.
     */
    public function toArray() : array
    {
        return [
            'migration_name' => $this->migrationName,
            'executed_at'    => $this->executedAt->format(format: 'Y-m-d H:i:s'),
        ];
    }
}

=== Migration/Runner/Enum/MigrationStatus.php ===
<?php

/**
 * Migration Status Value Object
 *
 * This file is part of the Gemini Database Migration System.
 *
 * @copyright Gemini Team 2024
 */

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Enum;

/**
 * MigrationStatus Value Object represents the lifecycle states of a database migration.
 *
 * This immutable enum encapsulates all possible states a migration can transition through
 * during its lifecycle, ensuring type safety and domain integrity. Each state represents
 * a distinct phase in the migration process, making the domain model explicit and enforcing
 * business rules through type constraints.
 *
 * @api
 * @final
 * @since   1.0.0
 * @package Gemini\Database\Migration
 */
enum MigrationStatus: string
{
    /**
     * Represents a migration that is scheduled but not yet executed.
     * This is the initial state of any new migration.
     */
    case Pending = 'pending';

    /**
     * Represents a migration that has been successfully applied to the database.
     * Transitions from Pending state after successful execution.
     */
    case Executed = 'executed';

    /**
     * Represents a migration that has been reversed to its previous state.
     * Only migrations in Executed state can transition to RolledBack.
     */
    case RolledBack = 'rolled_back';

    /**
     * Represents a migration that encountered an error during execution or rollback.
     * Can transition from any state when an operation fails.
     */
    case Failed = 'failed';

    /**
     * Determines if the migration can be executed.
     *
     * @return bool True if the migration is in a state where it can be executed
     */
    public function canBeExecuted() : bool
    {
        return $this === self::Pending || $this === self::RolledBack;
    }

    /**
     * Determines if the migration can be rolled back.
     *
     * @return bool True if the migration is in a state where it can be rolled back
     */
    public function canBeRolledBack() : bool
    {
        return $this === self::Executed;
    }
}
=== Migration/Runner/Exception/MigrationException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Exception;

use RuntimeException;
use Throwable;

/**
 * MigrationException
 *
 * Represents errors that occur during the migration process.
 * Extends RuntimeException to provide context-specific information for migration failures.
 */
class MigrationException extends RuntimeException
{
    /**
     * Constructor for the MigrationException.
     *
     * @param string         $message  The error message describing the issue.
     * @param int            $code     An optional error code for categorizing the error.
     * @param Throwable|null $previous Optional previous exception for chained exceptions.
     */
    public function __construct(string $message, int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Provides a string representation of the exception for debugging purposes.
     *
     * @return string A detailed message including the exception class and message.
     */
    public function __toString() : string
    {
        return sprintf(
            "[%s]: %s in %s on line %d\nStack trace:\n%s",
            static::class,
            $this->getMessage(),
            $this->getFile(),
            $this->getLine(),
            $this->getTraceAsString()
        );
    }
}

=== Migration/Runner/Execution/MigrationExecutionServiceInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

/**
 * Interface MigrationExecutionServiceInterface
 *
 * Defines high-level operations for applying, rolling back,
 * and previewing schema migrations in a transactional and declarative manner.
 */
interface MigrationExecutionServiceInterface
{
    /**
     * Executes all pending migrations in order.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function executeUp() : void;

    /**
     * Rolls back the most recent batch of migrations.
     *
     * @return void
     *
     * @throws \Throwable
     */
    public function rollbackBatch() : void;

    /**
     * Simulates execution and returns SQL preview.
     *
     * @return array<string>
     */
    public function pretend() : array;
}

=== Migration/Runner/Execution/MigrationExecutionService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Execution;

use Gemini\Database\Migration\Runner\Migration;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Concrete implementation for executing migration logic.
 */
final readonly class MigrationExecutionService implements MigrationExecutionServiceInterface
{
    public function __construct(private LoggerInterface $logger) {}

    /**
     * @throws \Throwable
     */
    public function runUp(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration UP: " . $migration::class);
            $migration->executeUp();
            $this->logger->info(message: "Migration UP completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration UP failed: " . $e->getMessage());
            throw $e;
        }
    }

    /**
     * @throws \Throwable
     */
    public function runDown(Migration $migration) : void
    {
        try {
            $this->logger->info(message: "Executing migration DOWN: " . $migration::class);
            $migration->executeDown();
            $this->logger->info(message: "Migration DOWN completed: " . $migration::class);
        } catch (Throwable $e) {
            $this->logger->error(message: "Migration DOWN failed: " . $e->getMessage());
            throw $e;
        }
    }
}

=== Migration/Runner/Generators/AbstractGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Gemini\Config\Architecture\DDD\AppPath;
use Gemini\Facade\Facades\Storage;
use RuntimeException;

/**
 * AbstractGenerator
 *
 * Provides reusable foundational logic for migration file generation.
 * Adheres to Clean Architecture and modern DSL philosophy.
 */
abstract class AbstractGenerator
{
    /**
     * Retrieves the contents of a stub file used as a template.
     *
     * @param string $stubName The name of the stub file to retrieve (e.g., 'create.stub').
     *
     * @return string The contents of the stub.
     * @throws RuntimeException If the stub file is missing.
     */
    protected function getStub(string $stubName) : string
    {
        $stubPath = $this->resolveStubPath(stubName: $stubName);

        if (! Storage::exists($stubPath)) {
            throw new RuntimeException(message: sprintf('Stub "%s" not found at path: %s', $stubName, $stubPath));
        }

        return Storage::read($stubPath);
    }

    /**
     * Resolves the absolute path to the specified stub file.
     *
     * @param string $stubName The filename of the stub.
     *
     * @return string The resolved absolute path.
     */
    private function resolveStubPath(string $stubName) : string
    {
        return AppPath::STUBS_PATH->get() . $stubName;
    }

    /**
     * Replaces all placeholders in a stub string with provided values.
     *
     * @param string                $stub         The original stub content.
     * @param array<string, string> $placeholders Array of placeholders and replacement values.
     *
     * @return string The updated stub content.
     */
    protected function replacePlaceholders(string $stub, array $placeholders) : string
    {
        foreach ($placeholders as $placeholder => $value) {
            $stub = str_replace(sprintf('{{%s}}', $placeholder), $value, $stub);
        }

        return $stub;
    }

    /**
     * Writes content to a file and applies secure permissions.
     *
     * @param string $path    The absolute file path.
     * @param string $content The content to write to disk.
     *
     * @throws RuntimeException On write or permission failure.
     */
    protected function writeToFile(string $path, string $content) : void
    {
        $directory = dirname($path);

        // Create a directory if it doesn't exist
        if (! Storage::exists($directory)) {
            Storage::createDirectory($directory);
        }

        // Throws if writing to a file fails
        if (! Storage::write($path, $content)) {
            throw new RuntimeException(message: 'Failed to write file at path: ' . $path);
        }

        $permissions = config(key: 'app.filePermissions', default: 0666);

        if (! Storage::setPermissions($path, $permissions)) {
            throw new RuntimeException(message: 'Failed to set permissions for file: ' . $path);
        }

        $this->setFileOwnership($path);
    }

    /**
     * Ensures the file has appropriate ownership metadata for local development.
     *
     * @param string $path Absolute path of the file.
     */
    private function setFileOwnership(string $path) : void
    {
        if (PHP_OS_FAMILY === 'Linux' || PHP_OS_FAMILY === 'Darwin') {
            $uid = getmyuid() ?: getenv('UID') ?: 1000;
            $gid = getmygid() ?: getenv('GID') ?: 1000;

            shell_exec(sprintf('chown %d:%d %s', $uid, $gid, escapeshellarg($path)));
        }
    }

    /**
     * Resolves the appropriate filesystem path for a given namespace.
     *
     * @param string $namespace The target namespace.
     * @param string $name      The base class name (without extension).
     *
     * @return string Fully qualified file path.
     * @throws RuntimeException If no config path is found for the namespace.
     */
    protected function resolvePath(string $namespace, string $name) : string
    {
        $type = array_keys(config(key: 'app.namespaces'), $namespace, true)[0] ?? null;
        $path = config(key: 'app.paths.' . $type);

        if (! $path) {
            throw new RuntimeException(
                message: sprintf('Path for %s is not defined in app.php configuration.', $namespace)
            );
        }

        return rtrim(base_path(), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . rtrim((string) $path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR
               . ($name . '.php');
    }
}
=== Migration/Runner/Generators/Code/BlueprintCodeGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Code;

use Gemini\Database\Migration\Design\Table\Table;
use RuntimeException;

/**
 * Class BlueprintCodeGenerator
 *
 * Responsible for converting an instance of the Table class into
 * syntactically valid PHP schema definition statements (e.g. `$table->string('name')...`).
 *
 * This class is used during migration stub rendering to inject generated code
 * for table schema directly from the domain blueprint object.
 *
 * @package Gemini\Database\Migration\Generators\Code
 */
final readonly class BlueprintCodeGenerator
{
    /**
     * Indentation used for formatting output.
     *
     * @var string
     */
    private const string INDENT = '            ';

    /**
     * Generates formatted PHP code lines from the given Table object.
     *
     * @param Table $blueprint The domain object containing table column definitions.
     *
     * @return string Fully formatted PHP schema definition lines suitable for migration stub.
     *
     * @throws RuntimeException If blueprint contains invalid structures or unsupported definitions.
     */
    public function generate(Table $blueprint) : string
    {
        // Retrieve all raw column definitions from the Table instance.
        $columns = $blueprint->getRawColumnDefinitions();

        // Check for an empty schema and return a placeholder comment if needed.
        if (empty($columns)) {
            return self::INDENT . '// No schema defined in Table.';
        }

        // Map each raw SQL/DSL definition into a properly indented PHP statement.
        $lines = array_map(
            static fn(string $line) : string => self::INDENT . '$table->addColumn(' . var_export($line, true) . ');',
            $columns
        );

        // Join all formatted lines into a single block.
        return implode(PHP_EOL, $lines);
    }
}

=== Migration/Runner/Generators/CommandInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

/**
 * Interface CommandInterface
 *
 * Describes a blueprint for CLI commands in the Gemini framework.
 * Any CLI command in the Gemini system should implement this interface to ensure consistency.
 */
interface CommandInterface
{
    /**
     * Executes the command with provided arguments.
     *
     * The method signature enforces strict typing by using `array` for arguments and
     * `void` for the return type, which aligns with the goals of type safety and clarity.
     *
     * @param array $arguments Arguments passed to the command.
     *
     * Important to note:
     * - The method does not return anything (`void`), reflecting that CLI commands typically
     *   produce their outcome directly via output or side effects (like writing to a file).
     * - This interface ensures any implementing class will provide its own specific logic
     *   for executing commands, maintaining a standard method signature for execution.
     */
    public function execute(array $arguments) : void;
}
=== Migration/Runner/Generators/Controller/ControllerGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Controller;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * ControllerGenerator Class
 *
 * This final class is responsible for generating RESTful controllers based on a given name.
 * It inherits from AbstractGenerator, ensuring reusable code for common generator functionalities.
 */
final class ControllerGenerator extends AbstractGenerator
{
    /**
     * Creates a RESTful controller class file.
     *
     * @param string $name The name of the controller to be generated.
     *
     * This method constructs a namespace and path for controller files using
     * configuration variables. If these configurations are missing, it throws an exception.
     * The class name is generated, and a stub file is loaded and customized with placeholders.
     * Finally, the customized stub is written to the appropriate file path.
     *
     * @throws RuntimeException If the namespace or path configuration is missing, or if file operations fail.
     */
    public function create(string $name) : void
    {
        // Retrieve the namespace and path for controllers from the configuration
        $namespace = config(key: 'app.namespaces.Controllers');
        $path      = config(key: 'app.paths.Controllers');

        // Ensure both namespace and path are configured
        if ($namespace === null || $path === null) {
            throw new RuntimeException(message: 'Controllers namespace or path is not configured.');
        }

        // Generate the class name for the controller
        $className = $this->generateMigrationClassName(tableName: $name, type: 'controller');

        // Load the controller stub and replace placeholders
        $stub = $this->getStub(stubName: 'controller.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'ControllerName' => $className,
            'namespace'      => $namespace,
        ]);

        // Resolve the file path for the new controller and write the customized stub content
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Migration/Runner/Generators/DTO/DtoGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\DTO;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Class DtoGenerator
 *
 * A final class responsible for generating DTO (Data Transfer Object)
 * classes based on a given table name and its fields.
 *
 * @package Gemini\Database\Migration\Generators
 */
final class DtoGenerator extends AbstractGenerator
{
    /**
     * Generate and create a DTO class file based on provided table name and fields.
     *
     * @param string $tableName The name of the table to generate the DTO for.
     * @param array  $fields    An associative array of fields where 'type' and 'name' are defined.
     *
     * @throws RuntimeException If DTO paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Retrieve DTO namespace and path from configuration
        $namespace = config(key: 'app.namespaces.DTO');
        $path      = config(key: 'app.paths.DTO');

        // Ensure namespace and path are configured
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'DTO paths or namespaces are not configured correctly.');
        }

        // Generate the class name using the AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'dto');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'dto.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'DTOName'    => $className,
            'Namespace'  => $namespace,
            'Properties' => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate formatted properties for the DTO class.
     *
     * @param array $fields An array of fields with 'type' and 'name'.
     *
     * @return string Formatted properties as strings.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    public %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types.
     *
     * @param string $type The database type (e.g., 'string', 'int').
     *
     * @return string The corresponding PHP type (e.g., 'string', 'int') or 'mixed' if not mapped.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Migration/Runner/Generators/Entity/EntityGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Final class for generating entity classes based on table schema.
 * Extends the AbstractGenerator for reusing the generator logic.
 */
final class EntityGenerator extends AbstractGenerator
{
    /**
     * Create an entity class file for the given table and fields.
     *
     * @param string $tableName The name of the table.
     * @param array  $fields    The fields' definitions of the table.
     *
     * @throws RuntimeException If paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, array $fields) : void
    {
        // Load namespace and path from configuration.
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');

        // If a namespace or path is not configured, throw an exception.
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method.
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'  => $className,
            'Namespace'   => $namespace,
            'Properties'  => $this->generateProperties(fields: $fields),
            'Constructor' => $this->generateConstructor(fields: $fields),
            'Methods'     => $this->generateMethods(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate class properties for the given fields.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Convert database field types to corresponding PHP types.
     *
     * @param string $type The database field type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }

    /**
     * Generate constructor method for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated constructor.
     */
    private function generateConstructor(array $fields) : string
    {
        // Arguments for the constructor.
        $args = implode(
            ', ',
            array_map(
                fn($field) : string => sprintf(
                    '%s|null $%s = null',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );

        // Property assignments in the constructor.
        $assignments = implode(
            PHP_EOL,
            array_map(
                fn($field) : string => sprintf('        $this->%s = $%s;', $field['name'], $field['name']),
                $fields
            )
        );

        return <<<PHP
            public function __construct({$args})
            {
                {$assignments}
            }
            PHP;
    }

    /**
     * Generate getter and setter methods for the entity class.
     *
     * @param array $fields The fields' definitions of the table.
     *
     * @return string A string containing the generated methods.
     */
    private function generateMethods(array $fields) : string
    {
        $methods = array_map(function (array $field) : string {
            // Generating getter method.
            $getter = <<<PHP
                public function get{$this->camelCase(name: $field['name'])}(): ?{$this->mapType(type: $field['type'])}
                {
                    return \$this->{$field['name']};
                }
                PHP;

            // Generating setter method.
            $setter = <<<PHP
                                                            public function set{$this->camelCase(
                    name: $field['name']
                )}({$this->mapType(
                    type: $field['type']
                )} \${$field['name']}): self
                                                            {
                                                                \$this->{$field['name']} = \${$field['name']};
                                                                return \$this;
                                                            }
                PHP;

            return "{$getter}\n\n{$setter}";
        }, $fields);

        return implode(PHP_EOL, $methods);
    }

    /**
     * Convert snake_case to CamelCase.
     *
     * @param string $name The string in snake_case.
     *
     * @return string The string converted to CamelCase.
     */
    private function camelCase(string $name) : string
    {
        return ucfirst(
            str_replace(
                ' ',
                '',
                ucwords(
                    str_replace('_', ' ', $name)
                )
            )
        );
    }
}
=== Migration/Runner/Generators/Entity/EntityQueryBuilderGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Entity;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * EntityQueryBuilderGenerator Class
 *
 * Generates PHP entity classes with integrated query builder functionality.
 * Designed to automate generation of entity classes with standard CRUD operations.
 */
final class EntityQueryBuilderGenerator extends AbstractGenerator
{
    /**
     * Create a new entity class with integrated query builder methods.
     *
     * @param string $name   The name of the entity class to create.
     * @param string $table  The name of the database table associated with the entity.
     * @param array  $fields The fields to include in the entity class.
     *
     * @throws RuntimeException if necessary configuration is missing.
     */
    public function create(string $name, string $table, array $fields) : void
    {
        $namespace = config(key: 'app.namespaces.Entity');
        $path      = config(key: 'app.paths.Entity');
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Entity paths or namespaces are not configured correctly.');
        }

        // Generate class name based on the table and entity type.
        $className = $this->generateMigrationClassName(tableName: $table, type: 'entity');

        // Load and replace placeholders in the stub.
        $stub = $this->getStub(stubName: 'entity-querybuilder.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'EntityName'   => $className,
            'TableName'    => $table,
            'Namespace'    => $namespace,
            'QueryMethods' => $this->generateQueryMethods(),
            'Properties'   => $this->generateProperties(fields: $fields),
        ]);

        // Resolve the destination path and write the file.
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate standard query methods for the entity.
     *
     * @return string The PHP code for query methods.
     *
     * Methods include common CRUD operations to make entity management straightforward.
     */
    private function generateQueryMethods() : string
    {
        return <<<PHP
            public function find(int \$id): ?self
            {
                \$result = \$this->where('id', '=', \$id)->first();
                return \$result ? (new static())->fillFromArray(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->get();
                return array_map(fn(array \$data) => (new static())->fillFromArray(\$data), \$results);
            }
            
            public function save(): bool
            {
                \$data = get_object_vars(\$this);
                if (!empty(\$data['id'])) {
                    return \$this->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->insertGetId(\$data);
                if (\$id) {
                    \$this->id = \$id;
                    return true;
                }
            
                return false;
            }
            
            public function delete(): bool
            {
                if (empty(\$this->id)) {
                    throw new \RuntimeException('Cannot delete an unsaved entity.');
                }
                return \$this->where('id', '=', \$this->id)->delete();
            }
            
            public function fillFromArray(array \$data): self
            {
                foreach (\$data as \$key => \$value) {
                    if (property_exists(\$this, \$key)) {
                        \$this->{\$key} = \$value;
                    }
                }
                return \$this;
            }
            PHP;
    }

    /**
     * Generate properties for the entity class based on given fields.
     *
     * @param array $fields The fields to include in the entity class.
     *
     * @return string The PHP code for entity properties.
     */
    private function generateProperties(array $fields) : string
    {
        return implode(
            PHP_EOL,
            array_map(
                fn(array $field) : string => sprintf(
                    '    protected %s $%s;',
                    $this->mapType(type: $field['type']),
                    $field['name']
                ),
                $fields
            )
        );
    }

    /**
     * Map database types to PHP types for entity properties.
     *
     * @param string $type The database type.
     *
     * @return string The corresponding PHP type.
     */
    private function mapType(string $type) : string
    {
        return match ($type) {
            'string', 'text'             => 'string',
            'int', 'integer', 'bigint'   => 'int',
            'float', 'double', 'decimal' => 'float',
            'bool', 'boolean'            => 'bool',
            default                      => 'mixed',
        };
    }
}
=== Migration/Runner/Generators/Migration/MigrationGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Migration;

use DateTimeImmutable;
use Gemini\Database\Migration\Design\Mapper\FieldToDslMapperInterface;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\DTO\FieldDTO;
use Gemini\Database\Migration\Runner\DTO\MigrationDTO;
use Gemini\Database\Migration\Runner\Enum\MigrationStatus;
use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;
use Gemini\Database\Migration\Runner\Manifest\ManifestStoreInterface;
use RuntimeException;

/**
 * Generates migration classes using Gemini's Domain-Specific Language (DSL).
 *
 * This generator is responsible for transforming structured migration metadata (DTOs)
 * into concrete PHP migration classes. It implements a robust templating system
 * to ensure consistent and maintainable migration file generation.
 *
 * @final    This class is final to prevent inheritance and maintain encapsulation
 * @package  Gemini\Database\Migration\Runner\Generators\Migration
 * @since    8.3.0
 */
final class MigrationGenerator extends AbstractGenerator
{
    /**
     * Template file name used for generating migration classes.
     *
     * This constant defines the stub file that serves as a template for all
     * generated migration classes.
     *
     * @var string
     */
    private const string MIGRATION_STUB = 'anonymous-migration.stub';

    /**
     * Constructs a new instance of the migration generator.
     *
     * This constructor implements the Constructor Promotion pattern (PHP 8.0+) for a cleaner,
     * more maintainable dependency injection. It follows Domain-Driven Design principles
     * by accepting a mapper strategy that encapsulates the field-to-DSL mapping logic.
     *
     * @param FieldToDslMapperInterface $mapper Strategy pattern implementation responsible for
     *                                          mapping field definitions to DSL representations
     *
     * @throws \InvalidArgumentException If the mapper implementation is invalid
     *
     * @since 8.3.0
     */
    public function __construct(
        private readonly FieldToDslMapperInterface $mapper,
        private readonly ManifestStoreInterface    $manifestStore,
    ) {}

    /**
     * Orchestrates the creation of a new database migration file.
     *
     * This method serves as the primary entry point for migration generation,
     * implementing the Command pattern through DTO-based input. It delegates the
     * actual file writing to specialized private methods, maintaining separation
     * of concerns.
     *
     * @param MigrationDTO $dto Data Transfer Object containing migration specifications
     *                          including name, table, and schema information
     *
     * @return void
     * @throws \ReflectionException
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */

    public function generateMigration(MigrationDTO $dto) : void
    {
        // Step 1: Generate migration file and obtain its full path
        $filePath = $this->writeMigrationFile(
            fileName: $dto->name,
            table   : $dto->table,
            fields  : $dto->schema->fields
        );

        // Step 2: Build Manifest Entry DTO
        $manifestEntryDTO = new CreateManifestEntryDTO(
            [
                'migration'      => $dto->name,
                'file'           => basename($filePath),
                'status'         => MigrationStatus::Pending->value,
                'hash'           => hash_file('sha256', $filePath),
                'batch'          => null,
                'executed_at'    => null,
                'rolled_back_at' => null,
                'tenant_id'      => null,
                'tags'           => [],
                'logs'           => [],
                'created_at'     => new DateTimeImmutable(),
            ]
        );

        // Step 3: Store manifest entry
        $this->manifestStore->createEntry($manifestEntryDTO);

        // Step 4: Provide user feedback
        echo "ðŸ› ï¸ Migration '{$dto->name}' and manifest entry created successfully.\n";
    }


    /**
     * Handles the core migration file generation process.
     *
     * This method orchestrates the complete workflow of creating a new database migration file:
     * 1. Validates and retrieves configuration settings
     * 2. Generates the necessary file naming parts
     * 3. Prepares content placeholders
     * 4. Generates and writes the final migration file
     *
     * @param string     $fileName The base name for the migration class (PascalCase)
     * @param string     $table    The target database table name
     * @param FieldDTO[] $fields   Collection of field specifications for table schema
     *
     */
    private function writeMigrationFile(
        string $fileName,
        string $table,
        array  $fields
    ) : string {
        // Retrieve critical configuration settings for migration generation
        $namespace = config(key: 'app.namespaces.Migrations');
        $path      = config(key: 'app.paths.Migrations');

        // Validate configuration presence to ensure proper setup
        if (! ($namespace && $path)) {
            throw new RuntimeException(
                message: "Migration paths or namespaces are misconfigured."
            );
        }

        // Generate timestamp for unique migration file naming
        $timestamp = $this->generateTimestamp();

        // Transform file name into appropriate formats for different uses
        $className = ucfirst($fileName);
        $snakeName = $this->toSnakeCase(string: $fileName);

        // Prepare template placeholders with migration-specific values
        $placeholders = [
            'MigrationName' => $className,
            'Namespace'     => $namespace,
            'TableName'     => $table,
            'Fields'        => $this->generateMigrationTableFields(fields: $fields),
        ];

        // Generate migration content by applying placeholders to the template
        $stubContent = $this->replacePlaceholders(
            stub        : $this->getStub(stubName: self::MIGRATION_STUB),
            placeholders: $placeholders
        );

        // Construct the final file path for the migration
        $finalPath = $this->resolvePath(
            namespace: $namespace,
            name     : "{$timestamp}_{$snakeName}"
        );

        // Write the migration file to the filesystem
        $this->writeToFile(
            path   : $finalPath,
            content: $stubContent
        );

        // Store the generated file name important for manifest entry
        return $finalPath;
    }

    /**
     * Generates a UTC-based timestamp for migration naming.
     *
     * Creates a standardized timestamp format used in migration file names
     * to ensure proper ordering and uniqueness.
     *
     * @return string Formatted timestamp (YmdHis)
     */
    private function generateTimestamp() : string
    {
        return (new DateTimeImmutable())->format(format: 'YmdHis');
    }

    /**
     * Converts PascalCase/camelCase strings to snake_case.
     *
     * Implements a robust string transformation algorithm that handles:
     * - PascalCase to snake_case
     * - camelCase to snake_case
     * - Special character replacement
     *
     * @param string $string The input string to convert
     *
     * @return string The snake_case representation
     */
    private function toSnakeCase(string $string) : string
    {
        $string = preg_replace('/([a-z])([A-Z])/', '$1_$2', $string);
        $string = preg_replace('/[^a-zA-Z0-9]/', '_', $string);

        return strtolower(trim((string) $string, '_'));
    }

    /**
     * Generates the migration table DSL lines using the Table DSL Renderer.
     *
     * Uses a temporary Table blueprint to apply FieldDTO definitions via the fieldMapper,
     * and renders them as `$table->...` PHP migration code lines suitable for stub injection.
     *
     * @param array<int, FieldDTO> $fields Validated list of field DTOs
     *
     * @return string DSL-compatible PHP migration body
     *
     * @throws RuntimeException When the field collection is empty or rendering fails
     */
    private function generateMigrationTableFields(array $fields) : string
    {
        // Create blueprint with injected mapper (injected earlier in MigrationGenerator)
        $table = Table::create(name: 'temporary')
            ->useMapper($this->mapper)
            ->applyMany($fields);

        // Render DSL output
        return $table->toDsl();
    }

}
=== Migration/Runner/Generators/Repository/RepositoryGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Repository;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * RepositoryGenerator Class
 *
 * This class is responsible for generating repository classes with predefined methods for database operations.
 * It extends from AbstractGenerator and leverages its methods to handle stubs and file writing.
 */
final class RepositoryGenerator extends AbstractGenerator
{
    /**
     * Create a repository class for a given table and entity.
     *
     * @param string $tableName The name of the database table.
     * @param string $entity    The name of the entity class.
     * @param array  $fields    Additional fields used in repository methods. (Default: empty array).
     *
     * @throws RuntimeException If repository paths or namespaces are not configured correctly.
     */
    public function create(string $tableName, string $entity, array $fields = []) : void
    {
        $namespace = config(key: 'app.namespaces.Repositories');
        $path      = config(key: 'app.paths.Repositories');

        // Ensure namespace and path configuration exists
        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Repository paths or namespaces are not configured correctly.');
        }

        // Generate class name using AbstractGenerator's method
        $className = $this->generateMigrationClassName(tableName: $tableName, type: 'repository');

        // Load and replace placeholders in the stub
        $stub = $this->getStub(stubName: 'repository.stub');
        $stub = $this->replacePlaceholders(stub: $stub, placeholders: [
            'RepositoryName' => $className,
            'Namespace'      => $namespace,
            'EntityName'     => $entity,
            'Methods'        => $this->generateMethods(entity: $entity),
        ]);

        // Determine the destination path and write the file
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);
        $this->writeToFile(path: $destinationPath, content: $stub);
    }

    /**
     * Generate method stubs for the repository class.
     *
     * @param string $entity The name of the entity class.
     *
     * @return string The generated methods as a string.
     */
    private function generateMethods(string $entity) : string
    {
        return <<<PHP
            public function find(int \$id): ?{$entity}
            {
                \$result = \$this->queryBuilder()->where('id', '=', \$id)->first();
                return \$result ? new {$entity}(\$result) : null;
            }
            
            public function findAll(): array
            {
                \$results = \$this->queryBuilder()->get();
                return array_map(fn(\$data) => new {$entity}(\$data), \$results);
            }
            
            public function save({$entity} \$entity): bool
            {
                \$data = get_object_vars(\$entity);
            
                if (!empty(\$data['id'])) {
                    return \$this->queryBuilder()->where('id', '=', \$data['id'])->update(\$data);
                }
            
                \$id = \$this->queryBuilder()->insertGetId(\$data);
                if (\$id) {
                    \$entity->setId(\$id);
                    return true;
                }
            
                return false;
            }
            
            public function delete(int \$id): bool
            {
                return \$this->queryBuilder()->where('id', '=', \$id)->delete();
            }
            PHP;
    }
}
=== Migration/Runner/Generators/Service/ServiceGenerator.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators\Service;

use Gemini\Database\Migration\Runner\Generators\AbstractGenerator;
use RuntimeException;

/**
 * Service Generator
 *
 * This generator creates service classes with basic scaffolding.
 * It extends AbstractGenerator to leverage shared utilities for file generation.
 */
final class ServiceGenerator extends AbstractGenerator
{
    /**
     * Creates a new service class.
     *
     * This method uses a stub file as a template, replaces placeholders
     * with actual values, and writes the generated content to a destination path.
     *
     * @param string $name The name of the service class to be generated.
     */
    public function create(string $name) : void
    {
        // Load the namespace and path from configuration
        // Rationale: Allow configuration to dictate the location and structure of generated files
        $namespace = config(key: 'app.namespaces.Services');
        $path      = config(key: 'app.paths.Services');

        if (! $namespace || ! $path) {
            throw new RuntimeException(message: 'Service namespace or path is not configured correctly.');
        }

        // Generate the class name using AbstractGenerator's method
        // Intent: Create standardized class names based on provided table name
        $className = $this->generateMigrationClassName(tableName: $name, type: 'service');

        // Load the service stub file
        // Rationale: Use a template to maintain consistent structure across generated service classes
        $stub = $this->getStub(stubName: 'service.stub');

        // Replace placeholders in the stub
        // Intent: Dynamically insert the class name and namespace into the template
        $stub = $this->replacePlaceholders(
            stub:         $stub,
            placeholders: [
                              'ServiceName' => $className,
                              'Namespace'   => $namespace,
                          ]
        );

        // Resolve the file path
        // Rationale: Ensure the new class is placed in the correct directory based on namespace
        $destinationPath = $this->resolvePath(namespace: $namespace, name: $className);

        // Write the generated content to the file
        // Rationale: Finalize the service class creation by writing the populated template to the file system
        $this->writeToFile(path: $destinationPath, content: $stub);
    }
}
=== Migration/Runner/Generators/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Generators;

use Exception;
use Psr\Log\LoggerInterface;

/**
 * StubResolver Class
 *
 * This class is responsible for handling the location, validation, and reading of stub files
 * used in code generation. It ensures that the directory containing stub files exists and is readable,
 * and it supports reading specific stub files for use in other applications.
 */
readonly class StubResolver
{
    /**
     * @param string          $stubDirectory The directory where stub files are stored.
     * @param LoggerInterface $logger        The logger instance for logging errors and information.
     *
     * @throws Exception If the stub directory is invalid upon instantiation.
     */
    public function __construct(
        private string          $stubDirectory,
        private LoggerInterface $logger
    ) {
        $this->validateStubDirectory();
    }

    /**
     * Validates that the stub directory exists and is readable.
     *
     * Throws an exception if the directory does not exist or is not readable, and logs a critical error.
     * This check is crucial for ensuring that later file operations do not fail due to
     * an invalid directory path.
     *
     * @throws Exception If the stub directory is invalid.
     */
    private function validateStubDirectory() : void
    {
        if (! is_dir($this->stubDirectory) || ! is_readable($this->stubDirectory)) {
            // Log the critical issue that the directory is invalid.
            $this->logger->critical(
                sprintf('Invalid stub directory: "%s".', $this->stubDirectory)
            );

            throw new Exception(
                sprintf(
                    'Stub directory "%s" does not exist or is not readable.',
                    $this->stubDirectory
                )
            );
        }
    }

    /**
     * Reads the contents of a stub file.
     *
     * This method resolves the full path of the stub file and attempts to read its contents.
     * If reading fails, it logs an error and throws an exception.
     * Successfully read content is logged for auditing purposes.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The content of the stub file.
     * @throws Exception If the stub file cannot be read.
     */
    public function read(string $stubName) : string
    {
        // Resolve a full path for the specified stub file.
        $stubPath = $this->resolve($stubName);

        $content = file_get_contents($stubPath);
        if ($content === false) {
            // Log the error if reading the file fails.
            $this->logger->error(
                sprintf('Failed to read content of stub file: "%s" at "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Failed to read stub file: "%s".', $stubName));
        }

        // Log successful read for future reference.
        $this->logger->info(
            sprintf('Successfully read stub file: "%s" from path: "%s".', $stubName, $stubPath)
        );

        return $content;
    }

    /**
     * Resolves the full path of a stub file.
     *
     * This method constructs the full path to the stub file within the stub directory.
     * It checks for the file's existence and readability, logging warnings and throwing exceptions as necessary.
     *
     * @param string $stubName The name of the stub file.
     *
     * @return string The resolved path of the stub file.
     * @throws Exception If the stub file does not exist or is unreadable.
     */
    public function resolve(string $stubName) : string
    {
        $stubPath = rtrim($this->stubDirectory, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $stubName;

        // Check that the file exists and is readable before progressing.
        if (! file_exists($stubPath) || ! is_readable($stubPath)) {
            // Log a warning if the file is missing or not accessible.
            $this->logger->warning(
                sprintf('Stub file "%s" not found or unreadable at path: "%s".', $stubName, $stubPath)
            );

            throw new Exception(sprintf('Stub file "%s" not found or unreadable.', $stubName));
        }

        return $stubPath;
    }
}
=== Migration/Runner/Manifest/DTO/CreateManifestEntryDTO.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest\DTO;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;

/**
 * Data Transfer Object for creating a Manifest Entry.
 *
 * Provides validated, casted, and serializable structure for manifest metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest\DTO
 *
 * @final
 */
final class CreateManifestEntryDTO extends AbstractDTO
{
    /**
     * Logical migration name (e.g., CreateProductsTable).
     */
    #[Required]
    public string $migration;

    /**
     * Physical file name (e.g., 20250428120300_create_products_table.php).
     */
    #[Required]
    public string $file;

    /**
     * Migration execution status (pending, executed, rolled_back, failed).
     */
    #[Required]
    public string $status;

    /**
     * SHA-256 hash of the migration file.
     */
    #[Required]
    public string $hash;

    /**
     * Optional batch ID assigned during migration execution.
     */
    public string|null $batch = null;

    /**
     * UTC ISO8601 timestamp of execution completion.
     */
    public string|null $executed_at = null;

    /**
     * UTC ISO8601 timestamp if migration was rolled back.
     */
    public string|null $rolled_back_at = null;

    /**
     * Optional tenant identifier for multi-tenant schemas.
     */
    public string|null $tenant_id = null;

    /**
     * Categorization tags for grouping migrations.
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs attached to the migration.
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Manifest creation timestamp.
     */
    #[Required]
    public DateTimeImmutable $created_at;
}

=== Migration/Runner/Manifest/ManifestDBInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

/**
 * Represents the persistence contract for migration manifest entries.
 *
 * This interface defines the repository contract for managing migration manifest records
 * in a persistence store. It follows the Repository Pattern from DDD and ensures
 * a consistent way to handle migration metadata across different storage implementations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestDBInterface
{
    /**
     * Persists a new migration manifest entry to the storage.
     *
     * This method is responsible for creating a new record in the persistence layer.
     * It encapsulates the storage-specific implementation details while maintaining
     * a consistent interface for manifest entry creation.
     *
     * @param array<string, mixed> $data The manifest entry data to persist
     *
     * @return array<string, mixed> The persisted manifest entry with any storage-generated metadata
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When provided data is invalid
     * @throws \SleekDB\Exceptions\JsonException When JSON serialization fails
     * @throws \SleekDB\Exceptions\IdNotAllowedException When ID field conflicts occur
     */
    public function insert(array $data) : array;

    /**
     * Retrieves manifest entries matching specified criteria.
     *
     * Implements specification pattern for flexible querying of manifest entries.
     * Supports complex query conditions while abstracting storage-specific query syntax.
     *
     * @param array<int, array<string|array>> $conditions Query specifications for filtering entries
     *
     * @return array<int, array<string, mixed>> Collection of manifest entries matching the conditions
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When query conditions are invalid
     */
    public function find(array $conditions) : array;

    /**
     * Retrieves all manifest entries from the storage.
     *
     * Provides a way to access the complete migration history. Use with caution
     * in large datasets as it may impact performance.
     *
     * @return array<int, array<string, mixed>> Complete collection of manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage read operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When internal query fails
     */
    public function findAll() : array;

    /**
     * Updates existing manifest entries matching the specified criteria.
     *
     * Supports atomic updates of manifest entries based on matching conditions.
     * Implements bulk update capability for efficient batch processing.
     *
     * @param array<int, array<string|array>> $conditions Specifications for identifying entries to update
     * @param array<string, mixed>            $newData    Updated data to apply to matching entries
     *
     * @throws \SleekDB\Exceptions\IOException When storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When conditions or data are invalid
     */
    public function update(array $conditions, array $newData) : void;
}
=== Migration/Runner/Manifest/ManifestDB.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Concrete implementation of ManifestDBInterface using SleekDB.
 *
 * @final
 */
final class ManifestDB implements ManifestDBInterface
{
    /**
     * The underlying SleekDB store instance.
     *
     * @var Store
     */
    private Store $store;

    /**
     * ManifestDB constructor.
     *
     * @param string $storagePath Path where a manifest database is located.
     *
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function __construct(string $storagePath)
    {
        $this->store = new Store(
            storeName    : 'migrations',
            databasePath : $storagePath,
            configuration: ['timeout' => false]
        );
    }


    /**
     * Insert a new manifest record.
     *
     * @param array<string, mixed> $data
     *
     * @return array<string, mixed>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function insert(array $data) : array
    {
        return $this->store->insert($data);
    }

    /**
     * Find manifest records matching given conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function find(array $conditions) : array
    {
        return $this->store->findBy($conditions);
    }

    /**
     * Retrieve all manifest records.
     *
     * @return array<int, array<string, mixed>>
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function findAll() : array
    {
        return $this->store->findAll();
    }

    /**
     * Update manifest records matching conditions.
     *
     * @param array<int, array<string, mixed>> $conditions
     * @param array<string, mixed>             $newData
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function update(array $conditions, array $newData) : void
    {
        $this->store
            ->createQueryBuilder()
            ->where($conditions)
            ->getQuery()
            ->update($newData);
    }
}

=== Migration/Runner/Manifest/ManifestStoreInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Defines the contract for managing migration manifest entries in the application.
 *
 * This service interface abstracts the business operations for migration manifest management,
 * providing a clean boundary between the domain logic and persistence layer. It follows
 * the Service Pattern from DDD to encapsulate complex migration tracking operations.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 */
interface ManifestStoreInterface
{
    /**
     * Creates a new migration manifest entry in the store.
     *
     * Processes and validates the migration entry data through a DTO before persistence.
     * Ensures data integrity and consistent state transitions for new migrations.
     *
     * @param CreateManifestEntryDTO $dto Value object containing validated migration entry data
     *
     * @throws \SleekDB\Exceptions\IOException When a storage operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When entry data is invalid
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void;

    /**
     * Retrieves all migration manifest entries from the store.
     *
     * Provides a complete view of the migration history for audit and management purposes.
     * Results are ordered by creation timestamp to maintain execution sequence.
     *
     * @return array<int, array<string, mixed>> Collection of all migration manifest entries
     *
     * @throws \SleekDB\Exceptions\IOException When retrieval operation fails
     */
    public function fetchAll() : array;

    /**
     * Retrieves all pending migrations that haven't been executed.
     *
     * Identifies migrations that need to be processed in the next migration run.
     * Filters entries based on execution status and ordering constraints.
     *
     * @return array<int, array<string, mixed>> Collection of pending migration entries
     *
     * @throws \SleekDB\Exceptions\IOException When the query operation fails
     */
    public function findPending() : array;

    /**
     * Performs rollback operations for migrations in a specific batch.
     *
     * Manages the state transition of migrations during a rollback process.
     * Updates manifest entries to reflect rollback status and timing.
     *
     * @param string $batch Identifier for the batch of migrations to rollback
     *
     * @throws \SleekDB\Exceptions\IOException When the rollback operation fails
     * @throws \SleekDB\Exceptions\InvalidArgumentException When batch identifier is invalid
     */
    public function rollbackBatch(string $batch) : void;

    /**
     * Locates a specific migration entry by its unique name.
     *
     * Provides direct access to individual migration metadata for verification
     * and state management purposes.
     *
     * @param string $migrationName Unique identifier/name of the migration
     *
     * @return array<string, mixed>|null Migration entry if found, null otherwise
     *
     * @throws \SleekDB\Exceptions\IOException When lookup operation fails
     */
    public function findByMigrationName(string $migrationName) : array|null;
}
=== Migration/Runner/Manifest/ManifestStore.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Manifest\DTO\CreateManifestEntryDTO;

/**
 * Service that manages manifest operations.
 */
final readonly class ManifestStore implements ManifestStoreInterface
{
    public function __construct(private ManifestDBInterface $db) {}

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\JsonException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \ReflectionException
     */
    public function createEntry(CreateManifestEntryDTO $dto) : void
    {
        $this->db->insert($dto->toArray());
    }

    /**
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     */
    public function fetchAll() : array
    {
        return $this->db->findAll();
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findPending() : array
    {
        return $this->db->find(
            [
                ['status', '=', 'pending'],
            ]
        );
    }

    public function rollbackBatch(string $batch) : void
    {
        $this->db->update(
            [['batch', '=', $batch]],
            ['status' => 'rolled_back', 'rolled_back_at' => (new DateTimeImmutable())->format(DATE_ATOM)]
        );
    }

    /**
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\IOException
     */
    public function findByMigrationName(string $migrationName) : array|null
    {
        $found = $this->db->find(
            [
                ['migration', '=', $migrationName],
            ]
        );

        return $found[0] ?? null;
    }
}
=== Migration/Runner/Manifest/MigrationManifestEntry.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use DateTimeImmutable;
use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Gemini\DataHandling\Validation\Attributes\Rules\ArrayType;
use Gemini\DataHandling\Validation\Attributes\Rules\DateFormat;
use Gemini\DataHandling\Validation\Attributes\Rules\Required;
use Gemini\DataHandling\Validation\Attributes\Rules\StringType;

/**
 * Represents an immutable manifest entry for database migrations within the system.
 *
 * This Value Object encapsulates all metadata related to a single database migration,
 * including its execution status, timing information, and associated metadata. It follows
 * the immutability principle to ensure data consistency throughout the migration process.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 * @final   This class is immutable and must not be extended to maintain invariants
 */
final class MigrationManifestEntry extends AbstractDTO
{
    /**
     * The unique identifier/name of the migration.
     *
     * @var string Represents the unique name used to identify this migration
     */
    #[Required]
    #[StringType]
    public string $migrationName;

    /**
     * The physical file name containing the migration code.
     *
     * @var string The actual filename on the filesystem containing migration logic
     */
    #[Required]
    #[StringType]
    public string $fileName;

    /**
     * Current status of the migration (e.g., 'pending', 'executed', 'failed').
     *
     * @var string Indicates the current state of migration execution
     */
    #[Required]
    #[StringType]
    public string $status;

    /**
     * Cryptographic hash of the migration content for integrity verification.
     *
     * @var string SHA-256 hash (or similar) of the migration file content
     */
    #[Required]
    #[StringType]
    public string $hash;

    /**
     * Optional batch identifier grouping related migrations.
     *
     * @var string|null Identifier for grouping migrations in execution batches
     */
    public string|null $batch = null;

    /**
     * Timestamp when the migration was successfully executed.
     *
     * @var string|null ISO-8601 formatted datetime string of execution
     */
    public string|null $executedAt = null;

    /**
     * Timestamp when the migration was rolled back.
     *
     * @var string|null ISO-8601 formatted datetime string of rollback
     */
    public string|null $rolledBackAt = null;

    /**
     * Optional tenant identifier for multi-tenant environments.
     *
     * @var string|null Unique identifier of the tenant this migration applies to
     */
    public string|null $tenantId = null;

    /**
     * Collection of tags for migration categorization and filtering.
     *
     * @var array<string> List of tags associated with this migration
     */
    #[ArrayType]
    public array $tags = [];

    /**
     * Execution logs and debug information.
     *
     * @var array<string, mixed> Collection of log entries related to migration execution
     */
    #[ArrayType]
    public array $logs = [];

    /**
     * Timestamp when this manifest entry was created.
     *
     * @var DateTimeImmutable Immutable datetime representing creation timestamp
     */
    #[Required]
    #[DateFormat('Y-m-d H:i:s')]
    public DateTimeImmutable $createdAt;
}
=== Migration/Runner/Manifest/MigrationManifestService.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Manifest;

use SleekDB\Store;

/**
 * Service for managing the Migration Manifest entries.
 *
 * Handles creation, retrieval, updating, and validation of migration metadata.
 *
 * @package Gemini\Database\Migration\Runner\Manifest
 *
 * @final   This class is immutable and must not be extended.
 */
final class MigrationManifestService
{
    /**
     * SleekDB Store instance for Manifest storage.
     *
     * @var Store
     */
    private Store $store;

    /**
     * Constructor.
     *
     * Initializes the SleekDB Store directly.
     *
     * @param string $manifestPath Absolute path to the manifest storage directory.
     *
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\InvalidConfigurationException
     */
    public function __construct(string $manifestPath)
    {
        $this->store = new Store(
            storeName    : 'manifest',
            databasePath : $manifestPath,
            configuration: ['auto_cache' => true]
        );
    }

    /**
     * Creates a new Manifest entry.
     *
     * @param MigrationManifestEntry $entry Data Transfer Object representing the migration manifest.
     *
     * @return void
     * @throws \SleekDB\Exceptions\IOException
     * @throws \SleekDB\Exceptions\IdNotAllowedException
     * @throws \SleekDB\Exceptions\InvalidArgumentException
     * @throws \SleekDB\Exceptions\JsonException
     */
    public function createEntry(MigrationManifestEntry $entry) : void
    {
        $this->store->insert(
            [
                'migration'      => $entry->migrationName,
                'file'           => $entry->fileName,
                'status'         => $entry->status,
                'hash'           => $entry->hash,
                'batch'          => $entry->batch,
                'executed_at'    => $entry->executedAt,
                'rolled_back_at' => $entry->rolledBackAt,
                'tenant_id'      => $entry->tenantId,
                'tags'           => $entry->tags,
                'logs'           => $entry->logs,
                'created_at'     => $entry->createdAt->format(DATE_ATOM),
            ]
        );
    }

    /**
     * Retrieves all Manifest entries.
     *
     * @return array<int, array<string, mixed>> List of all migration manifest entries.
     */
    public function all() : array
    {
        return $this->store->fetch();
    }

    /**
     * Finds a specific migration entry by its migration name.
     *
     * @param string $migrationName Logical name of the migration.
     *
     * @return array<string, mixed>|null The matching manifest entry or null if not found.
     */
    public function find(string $migrationName) : array|null
    {
        $result = $this->store
            ->where('migration', '=', $migrationName)
            ->fetch();

        return $result[0] ?? null;
    }
}

=== Migration/Runner/MigrationException.php ===
<?php

declare(strict_types=1);

/**
 * Class MigrationException
 *
 * Exceptions class to handle migration-specific errors within the Gemini database migration context.
 *
 * This class extends the base Exceptions class to provide custom error handling for
 * database migrations, encapsulating the message, error code, and the previous exception.
 *
 * Example usage:
 * <code>
 * throw new MigrationException("Migration failed due to XYZ reason");
 * </code>
 *
 * @package Gemini\Database\Migration
 */

namespace Gemini\Database\Migration\Runner;

use Exception;
use Throwable;

/**
 * MigrationException is a custom exception that is thrown during migration operations.
 *
 * The MigrationException class extends the base Exceptions class and provides additional contextual
 * information specifically related to database migration errors. This exception should be used
 * to indicate issues encountered during the process of migrating database schemas or related data.
 *
 * Usage example:
 * throw new MigrationException("Migration failed due to XYZ reason.");
 *
 * @package Gemini\Database\Migration
 */
class MigrationException extends Exception
{
    /**
     * Constructs a new MigrationException.
     *
     * @param string          $message  The Exceptions message to throw.
     * @param int             $code     The Exceptions code.
     * @param \Throwable|null $previous The previous throwable used for the exception chaining.
     */
    public function __construct(
        string         $message = '',
        int            $code = 0,
        Throwable|null $previous = null,
    ) {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }
}

=== Migration/Runner/Migration.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Service\MigrationExecution;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Abstract Migration Base Class
 *
 * Provides the foundation for creating database migrations in the Gemini framework.
 * Supports transactional, auditable, API-driven migration execution with up/down lifecycle.
 */
abstract readonly class Migration
{
    /**
     * Message template for successful operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_SUCCESS = 'Successfully executed: %s';

    /**
     * Message template for failed operation logging.
     *
     * @var string
     */
    protected const string LOG_OPERATION_FAILURE = 'Failed to execute: %s. Error: %s';

    /**
     * Message template for exception escalation during migration.
     *
     * @var string
     */
    protected const string MIGRATION_ERROR = 'Migration error during: %s. Details: %s';

    /**
     * Dependency for schema creation and modification.
     *
     * @var SchemaBuilder
     */
    protected SchemaBuilder $schemaBuilder;

    /**
     * Action for managing migration registration and persistence.
     *
     * @var MigrationExecution
     */
    protected MigrationExecution $migrationService;

    /**
     * Optional logger for structured output.
     *
     * @var LoggerInterface|null
     */
    protected LoggerInterface|null $logger;

    /**
     * Constructs the Migration base.
     *
     * @param SchemaBuilder        $schemaBuilder    DSL engine for table/column mutation.
     * @param MigrationExecution   $migrationService Action to persist execution records.
     * @param LoggerInterface|null $logger           Optional logger.
     */
    public function __construct(
        SchemaBuilder        $schemaBuilder,
        MigrationExecution   $migrationService,
        LoggerInterface|null $logger = null
    ) {
        $this->schemaBuilder    = $schemaBuilder;
        $this->migrationService = $migrationService;
        $this->logger           = $logger;
    }

    /**
     * Executes the "up" migration lifecycle.
     *
     * @throws MigrationException
     * @throws \Throwable
     */
    final public function executeUp() : void
    {
        $name  = $this->getMigrationName();
        $batch = $this->migrationService->getLatestBatch() + 1;

        $this->logInfo(message: sprintf("ðŸ”¼ Starting migration '%s' (up)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->up(),
                description: sprintf("Applying migration '%s'", $name)
            );

            $this->migrationService->save(
                migration : $name,
                executable: 'up()',
                batch     : $batch
            );

            $this->logInfo(message: sprintf("ðŸ§± Migration '%s' completed successfully (up).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Migration '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Resolves the class-based migration name.
     *
     * @return string
     */
    private function getMigrationName() : string
    {
        return static::class;
    }

    /**
     * Logs a message if logger is available.
     *
     * @param string $message
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Wraps any logic in try/catch, logs success/failure, escalates errors.
     *
     * @param callable $operation
     * @param string   $description
     *
     * @throws MigrationException
     */
    private function executeSafely(callable $operation, string $description) : void
    {
        // Begin a try block to handle potential errors during operation execution.
        try {
            // Execute the passed operation.
            // Any exception thrown here will be caught by the catch block below.
            $operation();

            $this->logInfo(message: sprintf(self::LOG_OPERATION_SUCCESS, $description));
        } catch (Throwable $e) {
            $this->logError(message: sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Log the failure of the operation with the error message for debugging or auditing purposes.
            $this->logError(sprintf(self::LOG_OPERATION_FAILURE, $description, $e->getMessage()));

            // Throw a MigrationException to escalate the issue while providing context for the failure.
            throw new MigrationException(
                message : sprintf(self::MIGRATION_ERROR, $description, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Logs an error if logger is available.
     *
     * @param string $message
     */
    private function logError(string $message) : void
    {
        $this->logger?->error(message: $message);
    }

    /**
     * Abstract method to be implemented by concrete migrations.
     *
     * @return void
     */
    abstract protected function up() : void;

    /**
     * Executes the "down" rollback lifecycle.
     *
     * @throws MigrationException
     */
    final public function executeDown() : void
    {
        $name = $this->getMigrationName();

        $this->logInfo(message: sprintf("ðŸ”½ Starting migration '%s' (down)...", $name));

        try {
            $this->executeSafely(
                operation  : fn() => $this->down(),
                description: sprintf("Reverting migration '%s'", $name)
            );

            $this->migrationService->delete(migration: $name);

            $this->logInfo(message: sprintf("ðŸ—‘ï¸ Migration '%s' completed successfully (down).", $name));
        } catch (Throwable $e) {
            throw new MigrationException(
                message : sprintf("Rollback for '%s' failed: %s", $name, $e->getMessage()),
                previous: $e
            );
        }
    }

    /**
     * Abstract method for rollback.
     *
     * @return void
     */
    abstract protected function down() : void;
}

=== Migration/Runner/Repository/MigrationRepositoryInterface.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Repository;

/**
 * Interface MigrationRepositoryInterface
 *
 * Defines a contract for managing database migrations.
 * This interface abstracts migration management to ensure consistent migration operations across different
 * implementations.
 */
interface MigrationRepositoryInterface
{
    /**
     * Registers a migration with specified details into the database.
     *
     * @param string $migration  The name or identifier of the migration.
     * @param string $executable The class- or identifier-responsible for executing the migration.
     * @param int    $batch      The batch number that groups this migration with others.
     *
     * The `save` method is crucial for keeping a record of applied migrations
     * along with their batch number to allow rollback or re-execution of specific batches.
     */
    public function save(string $migration, string $executable, int $batch) : void;

    /**
     * Removes a specific migration entry from the database.
     *
     * @param string $migration The name or identifier of the migration to be deleted.
     *
     * Use `delete` to remove the record of a migration, especially if it was applied
     * erroneously or if it needs to be reapplied from scratch.
     */
    public function delete(string $migration) : void;

    /**
     * Checks if a certain migration is recorded in the database.
     *
     * @param string $migration The name or identifier of the migration.
     *
     * @return bool Returns true if the migration exists, otherwise false.
     *
     * The `has` method helps to verify if a migration has already been applied
     * to avoid duplicate application of the same migration.
     */
    public function has(string $migration) : bool;

    /**
     * Retrieves all migration records that have been executed.
     *
     * @return array An array containing details of all executed migrations.
     *
     * The `getAll` method provides a comprehensive list of all migrations that
     * have been executed, useful for audits and tracking the history of migrations.
     */
    public function getAll() : array;

    /**
     * Fetches migrations belonging to a specific batch.
     *
     * @param int $batch The batch number to filter migrations by.
     *
     * @return array An array of migrations under the given batch.
     *
     * The `getMigrationsByBatch` method is useful for operations that need to
     * target specific groups of migrations, such as rolling back a single batch.
     */
    public function getMigrationsByBatch(int $batch) : array;

    /**
     * Gets the highest batch number currently in use.
     *
     * @return int The highest batch number.
     *
     * The `getLatestBatch` method is essential for determining the most recent
     * group of migrations that were applied, often used to target the latest set
     * of migrations for rollbacks.
     */
    public function getLatestBatch() : int;

    /**
     * Removes all migration records, effectively resetting the migration state.
     *
     * Using `dropAllMigrations` prepares the system for a fresh start of migrations,
     * useful in scenarios where the entire migration history needs to be cleared.
     */
    public function dropAllMigrations() : void;

    /**
     * Returns all unexpected (pending) migrations from the database.
     *
     * @return array<int, array<string, mixed>>
     */
    public function allPending() : array;

    /**
     * Deletes all migrations associated with a given batch ID.
     *
     * @param int $batch The batch number to delete.
     */
    public function removeByBatch(int $batch) : void;

    /**
     * Retrieves all migrations for a specific batch in reverse order.
     *
     * @param int $batch The batch to search.
     *
     * @return array<int, array<string, mixed>>
     */
    public function findByBatch(int $batch) : array;

}
=== Migration/Runner/SchemaBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner;

use Closure;
use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\QueryBuilder;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * SchemaBuilder
 *
 * Infrastructure facade for declaratively managing database schema via Domain-Specific Language (DSL).
 *
 * This class is responsible for all Data Definition Language (DDL) operations related to schema evolution,
 * such as table creation, deletion, renaming, and connectivity checks. It wraps these operations in
 * transaction-safe boundaries and provides centralized logging, exception normalization, and
 * semantic mapping from domain-oriented blueprints to raw SQL statements.
 *
 * It uses:
 * - QueryBuilder for driver-agnostic query execution
 * - Table DSL for semantic schema construction
 * - LoggerInterface for audit logging and observability
 *
 * It provides:
 * - Transactional safety for destructive operations
 * - Health check APIs for deployment probes
 * - Domain-safe exception boundaries for orchestration code
 *
 * This class belongs to the Infrastructure Layer of a Clean Architecture system,
 * and is intentionally readonly and immutable for safety in concurrent and async environments.
 *
 * @package Gemini\Database\Migration\Runner
 * @readonly
 * @final
 */
final readonly class SchemaBuilder
{
    /**
     * Constructor for initializing the QueryBuilder and LoggerInterface dependencies.
     *
     * @param QueryBuilder    $queryBuilder An instance of QueryBuilder to handle database queries.
     * @param LoggerInterface $logger       An instance of LoggerInterface for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private QueryBuilder    $queryBuilder,
        private LoggerInterface $logger
    ) {}

    /**
     * Determines whether a physical table exists in the active database schema.
     *
     * This check queries the `information_schema.tables` system view using the current
     * database context. It ensures compatibility with multi-tenant schemas and provides
     * fault-tolerant behavior on driver-level errors.
     *
     * @param non-empty-string $table The fully qualified table name to inspect
     *
     * @return bool True if the table exists, false otherwise
     * @throws \Random\RandomException
     */
    public function tableExists(string $table) : bool
    {
        // âœ… Guard against empty table names (domain invariant)
        if (trim($table) === '') {
            return false;
        }

        try {
            return $this->queryBuilder
                ->table(tableName: 'information_schema.tables')
                ->where(column: 'table_schema', value: $this->queryBuilder->raw(sql: 'DATABASE()'))
                ->where(column: 'table_name', value: $table)
                ->exists();
        } catch (QueryBuilderException $e) {
            // âŒ Defensive: driver-level failures shouldn't propagate upward
            $this->logger->error(
                message: 'Failed to verify table existence.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: $e->getMessage(), type: 'warning');

            return false;
        }
    }

    /**
     * Handles message output formatting based on the execution context (CLI or API/HTTP).
     *
     * This method implements the Single Responsibility Principle by managing output
     * formatting and delivery based on the application's runtime environment.
     *
     * @param string $message The message content to be output
     * @param string $type    The message type for color coding (success|warning|error|info)
     *
     * @return string|null Returns null for CLI context (direct output) or string for HTTP context
     */
    public function output(string $message, string $type = 'info') : string|null
    {
        // Determine if we're running in a CLI environment
        if (php_sapi_name() === 'cli') {
            // Define ANSI color codes for different message types in CLI
            $color = match ($type) {
                'success' => "\033[32m", // Green signifies successful operations
                'warning' => "\033[33m", // Yellow indicates warnings or cautions
                'error'   => "\033[31m", // Red represents errors or failures
                default   => "\033[0m",  // Default color for informational messages
            };

            // Output the colored message with reset code and line ending
            echo $color . $message . "\033[0m" . PHP_EOL;

            // CLI context doesn't need return value as output is immediate
            return '';
        }

        // For HTTP/API context, return the raw message
        return $message;
    }

    /**
     * Creates a new database table using a fluent Domain-Specific Language (DSL) schema definition.
     *
     * This method allows declarative schema construction by accepting a user-defined DSL callback.
     * Internally, it ensures atomic DDL execution via transactional encapsulation and logs all operations.
     *
     * @param non-empty-string $table    The name of the table to be created
     * @param Closure          $callback Closure defining the table schema using the fluent DSL
     *
     */
    public function create(string $table, Closure $callback) : bool
    {
        // âœ… Defensive: enforce a table name contract
        if (trim($table) === '') {
            $this->logger->warning(
                message: 'Table name is empty.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table name is empty.', type: 'warning');

            return false;
        }

        try {
            // âœ… Construct new Table schema blueprint using domain factory
            $blueprint = Table::create(name: $table);

            // âœ… Delegate table schema definition to user via DSL callback
            $callback($blueprint);

            // âœ… Generate SQL from blueprint (idempotent)
            $sql = $blueprint->toSql();

            // âœ… Execute SQL within transactional boundary (atomic DDL)
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->raw(sql: $sql)->execute()
            );

            // âœ… Structured operation logging for auditability
            $this->logger->info(
                message: 'Table successfully created.',
                context: ['table' => $table, 'query' => $sql]
            );

            return true;
        } catch (Throwable $e) {
            // âŒ Translate all low-level driver/query exceptions into a domain exception
            $this->logger->error(
                message: 'Failed to create table.',
                context: ['table' => $table, 'exception' => $e::class, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Failed to create table.', type: 'error');

            return false;
        }
    }

    /**
     * Drops the specified table if it exists, using transactional guarantees.
     *
     * This operation is destructive and irreversible. It wraps the `DROP TABLE`
     * execution in a transactional context to ensure rollback capability on failure.
     * Logging is performed for observability, and domain-specific exception wrapping
     * ensures consistent error boundaries.
     *
     * @param non-empty-string $table The name of the table to drop
     *
     * @throws MigrationException On failure to drop the table
     */
    public function drop(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Drop failed: empty table name.', context: ['table' => $table]);

            $this->output(message: 'Drop failed: empty table name.', type: 'warning');

            return false;
        }

        try {
            // ðŸ’¥ Atomic drop with rollback support
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder
                    ->table(tableName: $table)
                    ->drop()
            );

            // ðŸ“˜ Successful audit trail
            $this->logger->info(
                message: 'Table dropped successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table dropped successfully.');

            return true;
        } catch (Throwable $e) {
            // ðŸš¨ Surface clean domain-level failure
            $this->logger->error(
                message: 'Failed to drop table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to drop table.', type: 'error');

            return false;
        }
    }

    /**
     * Renames a table within the database schema using transactional guarantees.
     *
     * This method encapsulates the renaming of a table from its current name to a new name.
     * The operation is executed within a transaction, ensuring rollback on failure.
     * Logs are emitted to track structural changes for audit purposes.
     *
     * @param non-empty-string $oldName The current name of the table
     * @param non-empty-string $newName The desired new name for the table
     *
     * @throws MigrationException When renaming fails due to invalid names or query execution errors
     */
    public function rename(string $oldName, string $newName) : bool
    {
        if (trim($oldName) === '' || trim($newName) === '') {
            $this->logger->warning(
                message: 'Cannot rename table: source or destination name is empty.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Cannot rename table: source or destination name is empty.', type: 'warning');

            return false;
        }

        try {
            // ðŸ›¡ Perform rename in transaction for rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->renameTable(
                    oldName: $oldName,
                    newName: $newName
                )
            );

            // ðŸ“‹ Log structural schema change
            $this->logger->info(
                message: 'Table renamed successfully.',
                context: [
                             'old_name' => $oldName,
                             'new_name' => $newName,
                         ]
            );

            $this->output(message: 'Table renamed successfully.');

            return true;
        } catch (Throwable $e) {
            // ðŸ§± Wrap lower-level failure in domain-safe exception
            $this->logger->warning(
                message: "Failed to rename table '{$oldName}' to '{$newName}'",
                context: [
                             'old_name'  => $oldName,
                             'new_name'  => $newName,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to rename table.', type: 'warning');

            return false;
        }
    }

    /**
     * Truncates a table, removing all data while retaining schema structure.
     *
     * This operation deletes all records from the given table without logging individual row deletions.
     * It is faster than a DELETE operation and suitable for resetting state in non-production contexts.
     * The operation is performed transactionally and wrapped in domain-safe exception boundaries.
     *
     * @param non-empty-string $table The name of the table to truncate
     *
     * @throws MigrationException If truncation fails due to SQL or driver issues
     */
    public function truncate(string $table) : bool
    {
        if (trim($table) === '') {
            $this->logger->warning(message: 'Cannot truncate table: table name is empty.');
            $this->output(message: 'Cannot truncate table: table name is empty.', type: 'warning');

            return false;
        }

        try {
            // ðŸš¨ Run inside a transaction to ensure rollback safety
            $this->queryBuilder->transaction(
                operations: fn() => $this->queryBuilder->table(tableName: $table)->truncate()
            );

            // ðŸ“¢ Log action for observability and audit trail
            $this->logger->info(
                message: 'Table truncated successfully.',
                context: ['table' => $table]
            );

            $this->output(message: 'Table truncated successfully.');

            return true;
        } catch (Throwable $e) {
            // ðŸ§± Encapsulate and elevate to domain-level failure
            $this->logger->error(
                message: 'Failed to truncate table.',
                context: [
                             'table'     => $table,
                             'exception' => $e::class,
                             'message'   => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to truncate table.', type: 'error');

            return false;
        }
    }

    /**
     * Checks whether a given database exists in the current RDBMS instance.
     *
     * Queries the `information_schema.SCHEMATA` view to determine if the specified
     * database schema is present. This method is essential for conditional migrations,
     * onboarding flows, or database provisioning orchestration.
     *
     * @param non-empty-string $database The name of the database schema to check
     *
     * @return bool True if the schema exists, false otherwise
     * @throws \Random\RandomException
     */
    public function databaseExists(string $database) : bool
    {
        // ðŸ§± Defensive contract enforcement
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to check database existence with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database existence: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // ðŸ“¦ Query the information schema for the presence of the schema name
            return $this->queryBuilder
                ->table(tableName: 'information_schema.SCHEMATA')
                ->where(column: 'SCHEMA_NAME', value: $database)
                ->exists();
        } catch (QueryBuilderException $e) {
            // ðŸªµ Log error for observability and diagnostics
            $this->logger->error(
                message: 'Failed to check database existence.',
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to check database existence.', type: 'error');

            return false;
        }
    }

    /**
     * Creates a new database schema if it does not already exist.
     *
     * This method is typically used during bootstrap, provisioning, or deployment flows.
     * It ensures explicit schema creation with high observability and proper fault isolation.
     *
     * @param non-empty-string $database The name of the schema to be created
     *
     * @throws MigrationException If database creation fails
     */
    public function createDatabase(string $database) : bool
    {
        // ðŸ§± Domain precondition: avoid invalid names
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Attempted to create database with empty name.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot create database: database name is empty.');

            return false;
        }

        try {
            // ðŸ›  Execute database creation command via query builder abstraction
            $this->queryBuilder->createDatabase(database: $database);

            // ðŸ§¾ Log the successful creation event for observability
            $this->logger->info(
                message: 'Database schema successfully created.',
                context: ['database' => $database]
            );

            $this->output(message: 'Database schema successfully created.');

            return true;
        } catch (Throwable $e) {
            // ðŸ”¥ Wrap infrastructure failure in domain-specific exception
            $this->logger->warning(
                message: "Failed to create database '{$database}'",
                context: [
                             'database'  => $database,
                             'exception' => $e::class,
                             'error'     => $e->getMessage(),
                         ]
            );

            $this->output(message: 'Failed to create database.', type: 'error');

            return false;
        }
    }

    /**
     * Verifies database connectivity by attempting to select the given schema.
     *
     * This check is used for liveness/readiness probes, orchestration health checks,
     * and resilience features that depend on connection status with minimal overhead.
     *
     * @param non-empty-string $database The name of the database schema to check connectivity for
     *
     * @return bool True if the connection is healthy, false otherwise
     * @throws \Random\RandomException
     */
    public function isConnectionHealthy(string $database) : bool
    {
        // ðŸ§± Guard clause: avoid checking unnamed schemas
        if (trim($database) === '') {
            $this->logger->warning(
                message: 'Health check failed â€” database name was empty.',
                context: ['database' => $database]
            );

            $this->output(message: 'Cannot check database connectivity: database name is empty.', type: 'warning');

            return false;
        }

        try {
            // ðŸ§ª Attempt to switch to target schema
            $this->queryBuilder->useDatabase(database: $database);

            // âœ… If successful, consider the connection healthy
            $this->output(message: 'Database connectivity check successful.');

            return true;
        } catch (QueryBuilderException $e) {
            // âŒ Connection or database switch failed â€” log failure
            $this->logger->error(
                message: 'Database connectivity check failed.',
                context: ['database' => $database, 'error' => $e->getMessage()]
            );

            $this->output(message: 'Database connectivity check failed.', type: 'error');

            return false;
        }
    }
}

=== Migration/Runner/Service/MigrationExecution.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use DateTimeImmutable;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Class MigrationExecution
 *
 * Provides CRUD operations for database migrations with transactional safety and structured logging.
 * Uses a QueryBuilder abstraction to manage migration records efficiently.
 */
class MigrationExecution implements MigrationRepositoryInterface
{
    /**
     * The default table name used for storing migration data.
     */
    private const string TABLE_MIGRATIONS = 'migrations';

    /**
     * The default date and time format used for formatting and parsing dates.
     */
    private const string DATE_FORMAT = 'Y-m-d H:i:s';

    /**
     * Constructor to initialize the class with required dependencies.
     *
     * @param QueryBuilder         $queryBuilder The query builder instance for database interactions.
     * @param LoggerInterface|null $logger       Optional logger instance for logging purposes.
     *
     * @return void
     */
    public function __construct(
        private readonly QueryBuilder    $queryBuilder,
        private readonly LoggerInterface $logger
    ) {}

    /**
     * Persists a new migration record into the database.
     *
     * @param string $migration  Name of the migration file or class.
     * @param string $executable Raw SQL or migration command executed.
     * @param int    $batch      Batch number that this migration belongs to.
     *
     * @throws InvalidArgumentException When the input is invalid.
     * @throws Throwable When the insert operation fails.
     */
    public function save(string $migration, string $executable, int $batch) : void
    {
        // Validate that both the migration name and executable are not empty.
        if (empty($migration) || empty($executable)) {
            throw new InvalidArgumentException(message: "Migration name and executable cannot be empty.");
        }

        // Validate that the batch ID is greater than 0.
        if ($batch < 1) {
            throw new InvalidArgumentException(message: "Batch ID must be greater than 0.");
        }

        // Generate the current timestamp in the defined DATE_FORMAT ('Y-m-d H:i:s').
        $timestamp = (new DateTimeImmutable())->format(format: self::DATE_FORMAT);

        // Save the migration record using a database transaction to ensure atomicity.
        $this->queryBuilder->transaction(operations: function () use ($migration, $executable, $batch, $timestamp) {
            // Specify the target database table and insert the migration data.
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS) // Set the target table to 'migrations'.
                ->insert(
                    parameters: [
                                    'migration'   => $migration,    // Name of the migration file or class.
                                    'executable'  => $executable,  // The executed SQL or migration command.
                                    'batch'       => $batch,       // Grouping number for the migration (batch).
                                    'executed_at' => $timestamp,   // Timestamp of when the migration was saved.
                                ]
                )
                ->flush(); // Commit the database operation immediately.
        });

        // Log an informational message about the saved migration if a logger is available.
        $this->logger->info(message: "Saved migration '{$migration}' in batch {$batch}.");
    }

    /**
     * Checks whether a given migration exists in the database.
     *
     * @param string $migration Name of the migration to check.
     *
     * @return bool True if migration exists, false otherwise.
     *
     * @throws Throwable If the query fails.
     */
    public function has(string $migration) : bool
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'migration', value: $migration)
            ->exists();
    }

    /**
     * Retrieves all migration records.
     *
     * @return array List of all migrations in associative array format.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getAll() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select('migration', 'executable', 'batch', 'executed_at')
            ->get()
            ->toArray();
    }

    /**
     * Retrieves all migrations associated with a specific batch.
     *
     * @param int $batch The batch number to filter migrations.
     *
     * @return array Migrations belonging to the given batch.
     *
     * @throws Throwable If retrieval fails.
     */
    public function getMigrationsByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->get()
            ->toArray();
    }

    /**
     * Fetches the most recent batch number from the migrations table.
     *
     * @return int Latest batch number, or 0 if no migrations exist.
     *
     * @throws Throwable If the query fails.
     */
    public function getLatestBatch() : int
    {
        $result = $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->select(columns: 'MAX(batch) AS batch')
            ->get()
            ->first(key: 'batch');

        return $result !== null ? (int) $result : 0;
    }

    /**
     * Removes all migration records using the built-in truncate method.
     *
     * @throws Throwable If the truncate operation fails.
     */
    public function dropAllMigrations() : void
    {
        $this->queryBuilder->transaction(operations: function () {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->truncate()
                ->flush();
        });

        $this->logger->info(message: "Dropped all migration records.");
    }

    /**
     * Returns all pending migrations (executed_at is NULL).
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function allPending() : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->whereNull(column: 'executed_at')
            ->orderBy(column: 'id', direction: 'asc')
            ->get()
            ->toArray();
    }

    /**
     * Deletes all migrations in the given batch.
     *
     * @param int $batch
     *
     * @throws \Exception
     */
    public function removeByBatch(int $batch) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($batch) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'batch', value: $batch)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "ðŸ—‘ Removed all migrations in batch {$batch}.");
    }

    /**
     * Removes a specific migration record from the database.
     *
     * @param string $migration Name of the migration to delete.
     *
     * @throws Throwable If deletion fails.
     */
    public function delete(string $migration) : void
    {
        $this->queryBuilder->transaction(operations: function () use ($migration) {
            $this->queryBuilder
                ->table(tableName: self::TABLE_MIGRATIONS)
                ->where(column: 'migration', value: $migration)
                ->delete()
                ->flush();
        });

        $this->logger->info(message: "Deleted migration '{$migration}'.");
    }

    /**
     * Finds all migrations for a specific batch in reverse order (for rollback).
     *
     * @param int $batch
     *
     * @return array<int, array<string, mixed>>
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Random\RandomException
     */
    public function findByBatch(int $batch) : array
    {
        return $this->queryBuilder
            ->table(tableName: self::TABLE_MIGRATIONS)
            ->where(column: 'batch', value: $batch)
            ->orderBy(column: 'id', direction: 'desc')
            ->get()
            ->toArray();
    }

}

=== Migration/Runner/Service/MigrationStateManager.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Service;

use Gemini\Database\Migration\Runner\Exception\MigrationException;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Repository\MigrationRepositoryInterface;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Manages the lifecycle of migrations, including execution, rollback, refresh, and fresh operations.
 */
final readonly class MigrationStateManager
{
    public function __construct(
        private MigrationRepositoryInterface $migrationRepository,
        private LoggerInterface|null         $logger = null
    ) {}

    /**
     * Refresh migrations by rolling back all and reapplying them.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If the refresh process fails.
     */
    public function refresh(array $availableMigrations) : void
    {
        try {
            $this->rollbackAll();
            $this->migrate(availableMigrations: $availableMigrations);
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to refresh migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback all migrations batch by batch.
     *
     * @throws MigrationException If rolling back migrations fails.
     */
    public function rollbackAll() : void
    {
        try {
            while ($batch = $this->migrationRepository->getLatestBatch()) {
                $this->rollbackBatch(batch: $batch);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : 'Failed to rollback all migrations: ' . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a specific batch of migrations.
     *
     * @param int $batch Batch ID to rollback.
     *
     * @throws MigrationException If rolling back the batch fails.
     */
    public function rollbackBatch(int $batch) : void
    {
        try {
            foreach ($this->migrationRepository->getMigrationsByBatch(batch: $batch) as $migration) {
                $this->rollbackMigration(migration: $migration['migration']);
                $this->migrationRepository->delete(migration: $migration['migration']);
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to rollback batch " . $batch . ": " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Rollback a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If rolling back the migration fails.
     */
    private function rollbackMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: sprintf("Migration class '%s' not found.", $fullNamespace));
            }

            $instance = app($fullNamespace);
            if (! $instance instanceof Migration) {
                throw new MigrationException(
                    message: sprintf("Migration '%s' must extend the base Migration class.", $fullNamespace)
                );
            }

            $instance->executeDown();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : sprintf("Failed to rollback migration '%s': %s", $migration, $throwable->getMessage()),
                previous: $throwable
            );
        }
    }

    /**
     * Resolves the full namespace of the migration class.
     *
     * @param string $className The migration class name.
     *
     * @return string Fully qualified namespace of the class.
     */
    private function resolveFullNamespace(string $className) : string
    {
        $availableNamespaces = config(key: 'app.namespaces.Migrations', default: []);

        $fullNamespace = rtrim((string) $availableNamespaces, '\\') . '\\' . ltrim($className, '\\');
        if (class_exists($fullNamespace)) {
            $this->logInfo('Resolved migration namespace: ' . $fullNamespace);

            return $fullNamespace;
        }

        throw new MigrationException(message: sprintf("Unable to resolve namespace for class: '%s'.", $className));
    }

    /**
     * Log an informational message.
     *
     * @param string $message The message to log.
     */
    private function logInfo(string $message) : void
    {
        $this->logger?->info(message: $message);
    }

    /**
     * Migrate all pending migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @throws MigrationException If applying migrations fails.
     */
    public function migrate(array $availableMigrations) : void
    {
        try {
            $pending = $this->getPendingMigrations(availableMigrations: $availableMigrations);

            if ($pending === []) {
                $this->logInfo(message: "No migrations to execute.");

                return;
            }

            $batchId = $this->migrationRepository->getLatestBatch() + 1;

            foreach ($pending as $migration) {
                $this->runMigration(migration: $migration);
                $this->migrationRepository->save(
                    migration : $migration,
                    executable: $this->resolveFullNamespace($migration),
                    batch     : $batchId
                );
            }
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to execute migrations: " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }

    /**
     * Get pending migrations by comparing available with executed migrations.
     *
     * @param array $availableMigrations List of available migration classes.
     *
     * @return array List of pending migrations.
     */
    private function getPendingMigrations(array $availableMigrations) : array
    {
        $executed = array_column($this->migrationRepository->getAll(), 'migration');

        return array_diff($availableMigrations, $executed);
    }

    /**
     * Run a single migration.
     *
     * @param string $migration The migration class name.
     *
     * @throws MigrationException If applying the migration fails.
     */
    private function runMigration(string $migration) : void
    {
        try {
            $fullNamespace = $this->resolveFullNamespace($migration);

            if (! class_exists($fullNamespace)) {
                throw new MigrationException(message: "Migration class '" . $fullNamespace . "' not found.");
            }

            $instance = app($fullNamespace);

            if (! $instance instanceof Migration) {
                $this->logInfo(message: "Skipping non-migration class '" . $fullNamespace . "'.");

                return;
            }

            $instance->executeUp();
        } catch (Throwable $throwable) {
            throw new MigrationException(
                message : "Failed to run migration '" . $migration . "': " . $throwable->getMessage(),
                previous: $throwable
            );
        }
    }
}

=== Migration/Runner/Stubs/anonymous-migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Anonymous database migration.
 *
 * This migration is responsible for applying and rolling back schema changes
 * within the database context, using an immutable, declarative approach.
 *
 * @package {{Namespace}}
 * @readonly Guarantees immutability of the migration object
 * @version 1.0.0
 * @since PHP 8.3
 */
return new readonly class extends Migration
{
    /**
     * Perform the forward (up) migration.
     *
     * This method creates the database structure using the SchemaBuilder DSL,
     * applying all field definitions provided during migration generation.
     *
     * @return void
     *
     * @throws MigrationException If the schema creation process encounters an error
     */
    protected function up(): void
    {
        // Create a new database table dynamically defined during migration generation
        $this->schemaBuilder->create(
            table: '{{TableName}}',
            callback: function (Table $table): void {
                // Apply dynamically generated field definitions
                {{Fields}}

                // Add default created_at and updated_at timestamp columns
                $table->timestamps();
            }
        );

        // Output success message after schema creation
        $this->schemaBuilder->output(message: "ðŸ—ï¸ Migration executed: Table '{{TableName}}' created successfully.");
    }

    /**
     * Perform the rollback (down) migration.
     *
     * This method drops the previously created database table, reverting
     * the schema to its prior state before this migration execution.
     *
     * @return void
     *
     * @throws MigrationException If the schema rollback process encounters an error
     */
    protected function down(): void
    {
        // Drop the database table associated with this migration
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Output success message after table deletion
        $this->schemaBuilder->output(message: "ðŸ—‘ï¸ Migration rollback executed: Table '{{TableName}}' dropped successfully.");
    }
};

=== Migration/Runner/Stubs/controller.stub ===
<?php

declare(strict_types=1);

namespace {{namespace}};

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * {{ControllerName}} Controller
 *
 * RESTful Controller for managing resources.
 */
class {{ControllerName}}
{
    /**
     * Display a listing of the resource.
     *
     * @return ResponseInterface
     */
    public function index(): ResponseInterface
    {
        // Fetch all resources (dummy example data)
        $data = [
            ['id' => 1, 'name' => 'Resource 1'],
            ['id' => 2, 'name' => 'Resource 2'],
        ];

        // Return Blade view with data
        return view('resources.index', compact('data'));
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return ResponseInterface
     */
    public function create(): ResponseInterface
    {
        // Return Blade view for the create form
        return view('resources.create');
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param ServerRequestInterface $request
     * @return ResponseInterface
     */
    public function store(ServerRequestInterface $request): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Store the resource (dummy logic)
        // Example: Save to database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource created successfully.');
    }

    /**
     * Display the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function show(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view with resource data
        return view('resources.show', compact('resource'));
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function edit(int $id): ResponseInterface
    {
        // Fetch the resource (dummy example data)
        $resource = ['id' => $id, 'name' => 'Resource ' . $id];

        // Return Blade view for the edit form
        return view('resources.edit', compact('resource'));
    }

    /**
     * Update the specified resource in storage.
     *
     * @param ServerRequestInterface $request
     * @param int $id
     * @return ResponseInterface
     */
    public function update(ServerRequestInterface $request, int $id): ResponseInterface
    {
        $data = $request->getParsedBody();

        // Update the resource (dummy logic)
        // Example: Update in database

        // Redirect to show page with success message
        return response(302, ['Location' => route('resources.show', ['id' => $id])])
            ->withHeader('X-Message', 'Resource updated successfully.');
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param int $id
     * @return ResponseInterface
     */
    public function destroy(int $id): ResponseInterface
    {
        // Delete the resource (dummy logic)
        // Example: Remove from database

        // Redirect to index with success message
        return response(302, ['Location' => route('resources.index')])
            ->withHeader('X-Message', 'Resource deleted successfully.');
    }
}

=== Migration/Runner/Stubs/dto.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\DataHandling\ObjectHandling\DTO\AbstractDTO;

/**
 * Data Transfer Object for {{DTOName}}.
 */
final class {{DTOName}} extends AbstractDTO
{
{{Properties}}

}

=== Migration/Runner/Stubs/entity-querybuilder.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;

/**
 * Entity class with QueryBuilder integration for {{EntityName}}.
 */
class {{EntityName}} extends QueryBuilder
{
    /**
     * Table name associated with the entity.
     */
    protected string $tableName = '{{TableName}}';

{{QueryMethods}}
}

=== Migration/Runner/Stubs/entity.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

/**
 * Entity class for {{EntityName}}.
 */
class {{EntityName}}
{
{{Properties}}

    {{Constructor}}

{{Methods}}
}

=== Migration/Runner/Stubs/migration.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\Migration\Design\Table\Table;
use Gemini\Database\Migration\Runner\Migration;
use Gemini\Database\Migration\Runner\Exception\MigrationException;

/**
 * Database Migration Implementation for {{TableName}} Entity.
 *
 * This class represents a concrete database migration strategy implementing the schema
 * modifications for the {{TableName}} bounded context. It follows immutable design
 * principles and provides declarative schema definitions.
 *
 * @package {{Namespace}}
 * @final This class is not designed for inheritance
 * @readonly Ensures immutability of the migration definition
 * @version 1.0.0
 * @since PHP 8.3
 *
 * @template-implements Migration
 */
final readonly class {{MigrationName}} extends Migration
{
    /**
     * Executes the forward migration operation.
     *
     * Implements the schema creation logic using a fluent DSL pattern.
     * Creates the {{TableName}} table with defined columns and constraints.
     *
     * @return void
     * @throws MigrationException When schema creation fails
     *
     * @api
     */
    protected function up(): void
    {
        // Instantiate schema creation using fluent builder pattern
        $this->schemaBuilder->create(
            table: '{{TableName}}', // Named argument for better code clarity
            callback: function (Table $table): void {
                {{Fields}}

                // Adds standardized timestamp columns for entity lifecycle tracking
                $table->timestamps();
            }
        );

        // Provide feedback for migration execution monitoring
        $this->schemaBuilder->output("ðŸ—ï¸ Table '{{TableName}}' created successfully.");
    }

    /**
     * Executes the rollback migration operation.
     *
     * Implements the schema rollback logic by removing the {{TableName}} table
     * and all its associated constraints and indexes.
     *
     * @return void
     * @throws MigrationException When schema rollback fails
     *
     * @api
     */
    protected function down(): void
    {
        // Execute table removal using schema builder
        $this->schemaBuilder->drop(table: '{{TableName}}');

        // Provide feedback for rollback execution monitoring
       $this->schemaBuilder->output("ðŸ—‘ï¸ Table '{{TableName}}' dropped successfully.");
    }
}

=== Migration/Runner/Stubs/repository.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Gemini\Database\QueryBuilder\QueryBuilder;
use {{EntityNamespace}}\{{EntityName}};

/**
 * Repository for {{RepositoryName}}.
 */
final class {{RepositoryName}}
{
    public function __construct(private QueryBuilder $queryBuilder) {}

    public function find(int $id): ?{{EntityName}}
    {
        $result = $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->first();

        return $result ? $this->mapToEntity($result) : null;
    }

    public function save({{EntityName}} $entity): int
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->insertGetId($entity->toArray());
    }

    public function update(int $id, {{EntityName}} $entity): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->update($entity->toArray());
    }

    public function delete(int $id): bool
    {
        return $this->queryBuilder
            ->table('{{TableName}}')
            ->where('id', '=', $id)
            ->delete();
    }

    private function mapToEntity(array $data): {{EntityName}}
    {
        return new {{EntityName}}($data);
    }
}

=== Migration/Runner/Stubs/service.stub ===
<?php

declare(strict_types=1);

namespace {{Namespace}};

use Psr\Log\LoggerInterface;

/**
 * Service for {{ServiceName}}.
 */
final class {{ServiceName}}
{
    public function __construct(private LoggerInterface $logger) {}

    public function execute(array $input): array
    {
        $this->logger->info("Executing service logic for {{ServiceName}}.", ['input' => $input]);

        try {
            return $this->processLogic($input);
        } catch (\Throwable $exception) {
            $this->logger->error("Execution failed for {{ServiceName}}.", ['error' => $exception->getMessage()]);
            throw new \RuntimeException("Failed to execute service logic.", 0, $exception);
        }
    }

    private function processLogic(array $input): array
    {
        return ['status' => 'success', 'processed_data' => $input];
    }
}

=== Migration/Runner/Stubs/StubResolver.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\Migration\Runner\Stubs;

use Gemini\Gemini;
use RuntimeException;

/**
 * Resolves and loads stub files for generators.
 */
final readonly class StubResolver
{
    /**
     * Path to stub files in the framework for migrations.
     */
    private string $defaultStubPath;

    public function __construct()
    {
        // Use the Gemini enum to dynamically resolve the default stub path.
        $this->defaultStubPath = Gemini::MIGRATIONS->resolve() . 'stubs/';
    }

    /**
     * Resolves a stub file by its name.
     *
     * @param string $stubName Name of the stub file.
     *
     * @return string Content of the stub file.
     */
    public function resolve(string $stubName) : string
    {
        $filePath = $this->defaultStubPath . $stubName;

        if (! file_exists($filePath)) {
            throw new RuntimeException(message: 'Stub file not found: ' . $filePath);
        }

        return file_get_contents($filePath);
    }
}

=== QueryBuilder/BaseQueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Gemini\Database\DatabaseConnection;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\Traits\BaseQueryBuilderTrait;
use InvalidArgumentException;
use PDO;
use Psr\Log\LoggerInterface;

/**
 * **BaseQueryBuilder**
 *
 * A **robust and extendable** base class for query builders, handling:
 * - ðŸ”Œ **Database connection management**
 * - ðŸ— **Unit of Work for transactional operations**
 * - ðŸ“Œ **Table name handling**
 * - â™» **Reusable query logic for child classes**
 *
 * ### **Key Features**
 * - âœ… Centralized database connection logic.
 * - âœ… Ensures consistency across different query builders.
 * - âœ… Provides a **foundation** for extending advanced query-building capabilities.
 *
 * ðŸ— **Design Principles:**
 * - **Separation of Concerns (SoC)** â†’ Keeps query execution separate from the logic that builds queries.
 * - **Extensibility** â†’ Child classes (e.g., `QueryBuilder`) can extend this for additional functionality.
 * - **Reusability** â†’ Common logic (transactions, caching, joins, etc.) lives here.
 *
 * ðŸš€ **Usage Example:**
 * ```
 * class QueryBuilder extends BaseQueryBuilder
 * {
 *     // Custom query logic specific to QueryBuilder
 * }
 * ```
 */
abstract class BaseQueryBuilder
{
    use BaseQueryBuilderTrait;

    /**
     * The table name for the query.
     */
    protected string|null $tableName = null;

    /**
     * Initializes the query builder with a database connection, unit of work, and logger.
     */
    public function __construct(
        public readonly DatabaseConnection $databaseConnection,
        public readonly UnitOfWork         $unitOfWork,
        public readonly LoggerInterface    $logger
    ) {}

    /**
     * Retrieves the table name for the query.
     *
     * @throws QueryBuilderException If the table name is not set.
     */
    public function getTableName() : string
    {
        return $this->tableName ?? throw new QueryBuilderException(message: 'Table name is not set.');
    }

    /**
     * Sets the table name for the query.
     *
     * @throws QueryBuilderException If the table name is empty or invalid.
     */
    public function table(string $tableName) : static
    {
        // Trim any leading or trailing whitespace from the `$tableName` value.
        $tableName = trim($tableName);

        // Validate the table name format (OWASP Recommendation âœ…)
        if ($tableName === '' || ! preg_match('/^[a-zA-Z0-9_]+(?:\.[a-zA-Z0-9_]+)?$/', $tableName)) {
            throw new QueryBuilderException(message: 'Invalid table name format.');
        }

        $this->tableName = $tableName;

        return $this;
    }

    /**
     * Quotes a table or column name safely.
     *
     * The provided code first checks if the identifier (`$name`) is already wrapped with the given quoting character
     * (`$quoteChar`) at both the start and end; if so, the identifier is returned as-is. If not, it sanitizes the
     * identifier by stripping away characters that are not letters, digits, underscores, dollar signs, dots, or
     * Unicode characters in the allowed range, ensuring only valid characters remain. If the sanitized result is
     * empty, it throws an exception indicating the identifier is invalid or empty. Finally, it returns the sanitized
     * identifier wrapped with the specified quoting character, ensuring the identifier is securely escaped for use,
     * such as in SQL queries.
     */
    protected function quoteIdentifier(string $name) : string
    {
        // Validate the column name to ensure it contains only safe characters (a-z, A-Z, 0-9, _).
        $this->validateColumnName(name: $name);

        // Retrieve the database driver's name (e.g., mysql, pgsql, sqlite) from the active connection.
        $driver = $this->getConnection()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);

        // Determine the proper quoting characters based on the database driver.
        $quoteChars = match ($driver) {
            // PostgreSQL and SQLite use double quotes for identifiers.
            'pgsql', 'sqlite' => ['"', '"'],
            // MySQL uses backticks for identifiers.
            'mysql'           => ['`', '`'],
            // SQL Server uses square brackets for identifiers.
            'sqlsrv'          => ['[', ']'],
            // Default fallback to double quotes if the driver is unknown.
            default           => ['"', '"'],
        };

        // Destructure the opening and closing quote characters from the determined array.
        [$openQuote, $closeQuote] = $quoteChars;

        // Split the column name by dots (.) to handle cases like schema.table or table.column.
        $parts = explode('.', $name);

        // Quote and sanitize each part of the split name (e.g., schema or table names).
        $quotedParts = array_map(static function ($part) use ($openQuote, $closeQuote) {
            // If the part is already properly quoted with the correct opening and closing quotes, leave it unchanged.
            if (
                str_starts_with($part, $openQuote)
                && str_ends_with($part, $closeQuote)
            ) {
                return $part;
            }

            // Sanitize the part, allowing only alphanumeric characters, underscores, and multibyte characters.
            $sanitized = preg_replace('/[^a-zA-Z0-9_$\x80-\xFF]/u', '', $part);
            // Validate that the sanitized part is not empty after cleaning.
            if (empty($sanitized)) {
                throw new InvalidArgumentException(message: "Invalid identifier segment: '$part'");
            }

            // Return the properly quoted and sanitized identifier part.
            return $openQuote . $sanitized . $closeQuote;
        }, $parts);

        // Combine the quoted and sanitized parts back into a single string separated by dots (schema.table format).
        return implode('.', $quotedParts);
    }

    /**
     * Validates a column name to prevent SQL injection.
     */
    protected function validateColumnName(string $name) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $name)) {
            throw new InvalidArgumentException(message: "Invalid column name: {$name}");
        }
    }

    /**
     * Retrieves the active database connection.
     */
    public function getConnection() : PDO
    {
        return $this->databaseConnection->getConnection();
    }
}

=== QueryBuilder/Enums/QueryBuilderEnum.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Enums;

/**
 * Enumeration of query builder types and supported database drivers.
 *
 * Technical Description:
 * - Defines constants for different types of query operations.
 * - Includes supported database drivers.
 * - Provides utility methods for validation and retrieval of all available types.
 *
 * Business Description:
 * - Ensures consistency in query type definitions across the application.
 * - Prevents errors by validating query types and database drivers.
 */
enum QueryBuilderEnum: string
{
    /** Query Types */
    case QUERY_TYPE_SELECT         = 'SELECT';

    case QUERY_TYPE_INSERT         = 'INSERT';

    case QUERY_TYPE_UPDATE         = 'UPDATE';

    case QUERY_TYPE_DELETE         = 'DELETE';

    case QUERY_TYPE_UPSERT         = 'UPSERT';

    case QUERY_TYPE_SOFT_DELETE    = 'SOFT DELETE';

    case QUERY_TYPE_RESTORE        = 'RESTORE';

    case QUERY_TYPE_TRUNCATE       = 'TRUNCATE';

    case QUERY_TYPE_CASCADE_DELETE = 'CASCADE DELETE';

    case QUERY_TYPE_DELETE_JOIN    = 'DELETE JOIN';

    /** Database Drivers */
    case DRIVER_MYSQL  = 'mysql';

    case DRIVER_PGSQL  = 'pgsql';

    case DRIVER_SQLITE = 'sqlite';

    case DRIVER_MSSQL  = 'sqlsrv';

    case DRIVER_ORACLE = 'oci';

    /**
     * Checks if the provided string is a valid query type.
     *
     * @param string $queryType The query type to validate.
     *
     * @return bool Returns true if the provided query type is valid; otherwise, false.
     */
    public static function isValidQueryType(string $queryType) : bool
    {
        return in_array(strtoupper($queryType), self::queryTypes(), true);
    }

    /**
     * Returns all possible query types as an array of strings.
     *
     * @return array An array containing all query types as strings.
     */
    public static function queryTypes() : array
    {
        return [
            self::QUERY_TYPE_SELECT->value,
            self::QUERY_TYPE_INSERT->value,
            self::QUERY_TYPE_UPDATE->value,
            self::QUERY_TYPE_DELETE->value,
            self::QUERY_TYPE_UPSERT->value,
            self::QUERY_TYPE_SOFT_DELETE->value,
            self::QUERY_TYPE_RESTORE->value,
            self::QUERY_TYPE_TRUNCATE->value,
            self::QUERY_TYPE_CASCADE_DELETE->value,
            self::QUERY_TYPE_DELETE_JOIN->value,
        ];
    }

    /**
     * Checks if the provided string is a valid database driver.
     *
     * @param string $driver The database driver to validate.
     *
     * @return bool Returns true if the provided driver is valid; otherwise, false.
     */
    public static function isValidDriver(string $driver) : bool
    {
        return in_array(strtolower($driver), self::drivers(), true);
    }

    /**
     * Returns all possible database drivers as an array of strings.
     *
     * @return array An array containing all supported database drivers.
     */
    public static function drivers() : array
    {
        return [
            self::DRIVER_MYSQL->value,
            self::DRIVER_PGSQL->value,
            self::DRIVER_SQLITE->value,
            self::DRIVER_MSSQL->value,
            self::DRIVER_ORACLE->value,
        ];
    }
}

=== QueryBuilder/Exception/QueryBuilderException.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Exception;

use Exception;
use Throwable;

class QueryBuilderException extends Exception
{
    public function __construct(
        string         $message = "",
        int            $code = 500,
        Throwable|null $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }
}
=== QueryBuilder/QueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\Traits\InsertUpdateTrait;
use Gemini\Database\QueryBuilder\Traits\JoinClauseBuilderTrait;
use Gemini\Database\QueryBuilder\Traits\OrderByAndGroupByBuilderTrait;
use Gemini\Database\QueryBuilder\Traits\SelectQueryTrait;
use Gemini\Database\QueryBuilder\Traits\SoftDeleteAndDeleteTrait;
use Gemini\Database\QueryBuilder\Traits\WhereTrait;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use PDO;
use PDOException;
use PDOStatement;

/**
 * **QueryBuilder**
 *
 * A **robust and flexible SQL query builder** providing a fluent interface for constructing
 * and executing SQL queries dynamically.
 *
 * âœ… **Key Features**
 * - **Fluent API** â†’ Allows chaining of query methods.
 * - **Fully Prepared Queries** â†’ Prevents SQL injection.
 * - **Supports Transactions** â†’ Uses **Unit of Work**.
 * - **Advanced Query Optimization** â†’ Caching, indexing recommendations.
 * - **Comprehensive SQL Support** â†’ SELECT, INSERT, UPDATE, DELETE, JOINs, WHERE, GROUP BY, ORDER BY, etc.
 *
 * ðŸš€ **Usage Example**
 * ```
 * $users = $queryBuilder->table('users')
 *     ->where('status', 'active')
 *     ->orderBy('created_at', 'DESC')
 *     ->limit(10)
 *     ->get();
 * ```
 */
class QueryBuilder extends BaseQueryBuilder
{
    use SelectQueryTrait;
    use InsertUpdateTrait;
    use SoftDeleteAndDeleteTrait;
    use WhereTrait;
    use JoinClauseBuilderTrait;
    use OrderByAndGroupByBuilderTrait;

    /**
     * Sets the LIMIT value for the SELECT query.
     *
     * @param int $limit Maximum number of rows to retrieve.
     *
     * @return static
     *
     * @throws QueryBuilderException
     */
    public function limit(int $limit) : static
    {
        if ($limit < 0) {
            throw new QueryBuilderException(message: 'Limit must be a non-negative integer.');
        }

        $this->limit = $limit;

        return $this;
    }

    /**
     * Sets the OFFSET value for the SELECT query.
     *
     * @param int $offset Number of rows to skip.
     *
     * @return static
     *
     * @throws QueryBuilderException
     */
    public function offset(int $offset) : static
    {
        if ($offset < 0) {
            throw new QueryBuilderException(message: 'Offset must be a non-negative integer.');
        }

        $this->offset = $offset;

        return $this;
    }

    /**
     * Registers a query for **deferred execution** using Unit of Work.
     *
     * âœ… **Best Practices**
     * - **Batch Queries** â†’ Reduces database calls.
     * - **Ensures Atomicity** â†’ All queries execute in **one transaction**.
     *
     * @param QueryBuilderEnum $operation  The type of query operation.
     * @param PDOStatement     $statement  The prepared statement.
     * @param array            $parameters Query parameters.
     *
     * @return static Returns the current instance.
     */
    public function registerQueryInUnitOfWork(
        QueryBuilderEnum $operation,
        PDOStatement     $statement,
        PDO              $pdo,
        array            $parameters = []
    ) : static {
        $this
            ->getUnitOfWork()
            ->registerQuery(
                operation : $operation,
                statement : $statement,
                pdo       : $pdo,
                parameters: $parameters,
            );

        return $this;
    }


    /**
     * Executes all **deferred queries** stored in the Unit of Work.
     *
     * âœ… **Why This?**
     * - **Batch execution for better performance**.
     * - **Ensures ACID compliance** (All-or-Nothing Transactions).
     *
     * @return Arrhae The results of executed queries.
     *
     * @throws QueryBuilderException If the transaction fails.
     */
    public function flush() : Arrhae
    {
        return $this->getUnitOfWork()->flush();
    }

    /**
     * Enables **DISTINCT** in queries.
     *
     * âœ… **Why?**
     * - Ensures that only **unique** results are returned.
     *
     * @return static Returns the current instance.
     */
    public function distinct() : static
    {
        $this->distinct = true;

        return $this;
    }

    /**
     * Switches the query to use the **read** database connection.
     *
     * âœ… **Why?**
     * - **Optimized for Performance** â†’ **Read operations** should not use the **write connection**.
     *
     * @return static Returns the current instance.
     */
    public function useReadConnection() : static
    {
        $this->useReadConnection = true;

        return $this;
    }

    /**
     * Checks if a record exists in the database.
     *
     * âœ… **Why?**
     * - **Efficient Existence Check** â†’ Uses `LIMIT 1` for **fast lookups**.
     *
     * @return bool Returns `true` if the record exists, otherwise `false`.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function exists() : bool
    {
        try {
            $stmt = $this->getConnection()->prepare(query: $this->buildSelectQuery() . ' LIMIT 1');
            $stmt->execute(params: $this->getParameters());

            return (bool) $stmt->fetch(mode: PDO::FETCH_ASSOC);
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Failed to check if record exists: " . $exception->getMessage()
            );
        }
    }

    /**
     * Executes the current query.
     *
     * âœ… **Why This Approach?**
     * - **Ensures Safe Execution** â†’ Always uses **prepared statements**.
     * - **Centralized Query Execution** â†’ All query execution **happens here**.
     *
     * @return array The query results.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function execute() : array
    {
        // Dynamically build the SQL query
        $query = $this->buildSelectQuery();

        // Get a PDO connection
        $pdo = $this->getConnection();

        // Prepare the statement (Prevents SQL Injection âœ…)
        $stmt = $pdo->prepare(query: $query);

        try {
            // Execute with bound parameters
            $stmt->execute($this->getParameters());
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message : "Query execution failed: " . $exception->getMessage(),
                previous: $exception
            );
        }

        return $stmt->fetchAll(mode: PDO::FETCH_ASSOC);
    }

    /**
     * Retrieves the first result from the query execution.
     *
     * This method is useful for retrieving a single record from the database without iterating
     * over the entire result set. It supports extracting specific columns using **dot notation**
     * or applying a **callback function** to the first item.
     *
     * ðŸ”¥ **Key Features:**
     * - **Retrieves a single record** â†’ Returns the first row from the result set.
     * - **Supports dot notation (`.`)** â†’ Fetch nested values like `'address.city'`.
     * - **Supports Closure transformation** â†’ Modify the result dynamically.
     * - **Returns a default value** â†’ If no record is found, fallback to a default.
     *
     * ---
     * âœ… **Basic Usage**
     * ```
     * $user = QueryBuilder::table('users')->where('status', 'active')->first();
     * echo $user['name']; // Outputs: "John Doe"
     * ```
     *
     * ---
     * âœ… **Extracting a Single Column**
     * ```
     * $email = QueryBuilder::table('users')->first('email', 'No email found');
     * echo $email; // Outputs: "user@example.com"
     * ```
     *
     * ---
     * âœ… **Using Dot Notation for Nested Values**
     * ```
     * $city = QueryBuilder::table('users')->first('address.city', 'Unknown');
     * echo $city; // Outputs: "New York"
     * ```
     *
     * ---
     * âœ… **Applying a Callback Function**
     * ```
     * $userName = QueryBuilder::table('users')->first(fn($user) => strtoupper($user['name']));
     * echo $userName; // Outputs: "JOHN DOE"
     * ```
     *
     * ---
     * âœ… **Handling Empty Results Gracefully**
     * ```
     * $user = QueryBuilder::table('users')->where('id', 9999)->first();
     * if (!$user) {
     *     echo "User not found.";
     * }
     * ```
     *
     * ---
     * âœ… **Combining `first()` with `get()` for More Flexibility**
     * ```
     * $users = QueryBuilder::table('users')->where('status', 'active')->get();
     *
     * if (!$users->isEmpty()) {
     *     echo "First active user: " . $users->first('name');
     * } else {
     *     echo "No active users found.";
     * }
     * ```
     *
     * ---
     * @param string|int|Closure|null $key      Optional. The key to extract using **dot notation** or a **Closure**.
     *                                          If `null`, returns the entire first row.
     * @param mixed                   $default  The default value to return if the key does not exist or no record is
     *                                          found.
     *
     * @return mixed The **first record**, the **extracted key's value**, the **result of a Closure**, or `$default` if
     *               empty.
     */
    public function first() : ?array
    {
        // Ensure the query fetches only one result
        $this->limit = 1;

        // Execute the query and retrieve results
        $results = $this->get();

        // Return the first record, or `null` if none found
        return $results->isEmpty() ? null : $results->first();
    }


    /**
     * Drops the specified table if it exists.
     *
     * âœ… **Why?**
     * - **Safe Drop** â†’ Prevents errors if the table doesn't exist.
     *
     * @return static Returns the current instance.
     *
     * @throws QueryBuilderException If the table name is missing.
     */
    public function drop() : static
    {
        if (! isset($this->tableName)) {
            throw new QueryBuilderException(message: "Table name is required to drop a table.");
        }

        return $this->raw(sql: "DROP TABLE IF EXISTS `{$this->tableName}`");
    }

    /**
     * Executes a raw SQL query **with parameter binding**.
     *
     * âœ… **Why?**
     * - **Safe Execution** â†’ Always **prepared & parameterized**.
     *
     * @param string $sql        The raw SQL query.
     * @param array  $parameters Query parameters.
     *
     * @return static Returns the current instance.
     *
     * @throws QueryBuilderException If execution fails.
     */
    public function raw(string $sql, array $parameters = []) : static
    {
        try {
            $stmt = $this->getConnection()->prepare(query: $sql);
            $stmt->execute(params: $parameters);

            return $this;
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Failed to execute raw query: " . $exception->getMessage()
            );
        }
    }

    /**
     * Specifies the columns to be selected in the query.
     *
     * ðŸ† **Key Features:**
     * - âœ… Allows dynamic selection of specific columns.
     * - âœ… Defaults to `SELECT *` if no columns are provided.
     * - âœ… Prevents SQL injection via strict column name validation.
     * - âœ… Ensures **readability & maintainability** through a fluent interface.
     *
     * ðŸ”¥ **Why This Matters?**
     * - Explicit column selection **reduces database load** and improves performance.
     * - Ensuring valid column names prevents **SQL injection** attacks.
     * - Defaults to `SELECT *` when called without arguments for flexibility.
     *
     * ---
     * ðŸ“Œ **Usage Example**
     * ```
     * $users = $queryBuilder->table('users')
     *     ->select() // Defaults to SELECT *
     *     ->where('status', 'active')
     *     ->get();
     * ```
     * ---
     *
     * @param string ...$columns The column names to be retrieved from the database.
     *
     * @return static Returns the current instance to allow method chaining.
     */
    public function select(string ...$columns) : static
    {
        // ðŸ— If no columns are provided, default to '*'
        $this->columns = empty($columns) ? ['*'] : $columns;

        // ðŸ” Validate column names (if columns are explicitly provided)
        foreach ($this->columns as $column) {
            $this->validateColumnName(name: $column);
        }

        return $this;
    }

}

=== QueryBuilder/Traits/BaseQueryBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

/**
 * **BaseQueryBuilderTrait**
 *
 * âœ… **Purpose:**
 * This trait acts as a **"Master Trait"**, grouping all essential traits required for a powerful, scalable,
 * and efficient **SQL Query Builder**.
 *
 * ðŸ— **Design Goals:**
 * - Centralized management of all reusable query-related traits.
 * - Enables **modular, reusable, and maintainable** code structure.
 * - Ensures the **Single Responsibility Principle (SRP)** by keeping logic in separate traits.
 * - Provides a **clean and organized** way to extend the QueryBuilder functionality.
 *
 * ðŸ›  **Key Features (Grouped Traits):**
 * - **ðŸ”„ Database Transactions** â†’ `DatabaseTransactionTrait`
 * - **ðŸ“Œ Identity Map Pattern** â†’ `IdentityMapTrait`
 * - **ðŸ“ INSERT, UPDATE, UPSERT** â†’ `InsertUpdateTrait`
 * - **ðŸ”— JOIN Clause Handling** â†’ `JoinClauseBuilderTrait`
 * - **ðŸ“Š ORDER BY, GROUP BY, HAVING** â†’ `OrderByAndGroupByBuilderTrait`
 * - **ðŸ§© Unit of Work Pattern** â†’ `ProvidesUnitOfWork`
 * - **âš¡ Query Optimization & Indexing** â†’ `QueryOptimizationTrait`
 * - **ðŸ” SELECT Queries, Caching & Pagination** â†’ `SelectQueryTrait`
 * - **ðŸ—‘ Soft Deletes & Data Deletion** â†’ `SoftDeleteAndDeleteTrait`
 * - **ðŸ”Ž WHERE Clause Handling** â†’ `WhereTrait`
 *
 * ðŸ† **Benefits of Using This Trait:**
 * - **Single inclusion point** for all QueryBuilder functionality.
 * - **Avoids trait conflicts** by defining method precedence (if needed).
 * - **Easier to maintain** when adding or modifying traits.
 * - **Improves testability** by ensuring well-structured, isolated functionalities.
 *
 * ðŸš€ **Usage Example in QueryBuilder Class:**
 * ```
 * class QueryBuilder
 * {
 *     use BaseQueryBuilderTrait;
 *
 *     // Additional QueryBuilder logic...
 * }
 * ```
 */
trait BaseQueryBuilderTrait
{
    use DatabaseTransactionTrait;
    use IdentityMapTrait;
    use InsertUpdateTrait;
    use JoinClauseBuilderTrait;
    use OrderByAndGroupByBuilderTrait;
    use ProvidesUnitOfWork;
    use QueryOptimizationTrait;
    use SelectQueryTrait;
    use SoftDeleteAndDeleteTrait;
    use WhereTrait;
    use SchemaQueryBuilderTrait;
}

=== QueryBuilder/Traits/DatabaseTransactionTrait.php ===
<?php

declare(strict_types=1);

/**
 * Trait DatabaseTransactionTrait
 *
 * Provides utility methods for handling database transactions, supporting both
 * standard and nested transactions through savepoints. Ensures robust error handling
 * by rolling back appropriately in case of failures and logging transaction errors.
 *
 * Applicable to classes managing a PDO-based database connection and requiring
 * transactional operations.
 */

namespace Gemini\Database\QueryBuilder\Traits;

use Exception;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use PDO;

/**
 * Provides functionality for managing database transactions,
 * including support for nested transactions using savepoints.
 */
trait DatabaseTransactionTrait
{
    private const string SAVEPOINT_PREFIX = 'SAVEPOINT_';

    /**
     * Runs a series of database operations within a single transaction.
     *
     * Supports nested transactions using SAVEPOINTS.
     * If any operation fails, it rolls back to the last savepoint or the main transaction.
     *
     * @param callable $operations A callable that contains the operations to be performed within the transaction.
     *
     * @throws Exception If any operation fails, an exception is thrown, and the transaction is rolled back.
     */
    public function transaction(callable $operations) : void
    {
        $pdo = $this->getDatabaseConnection();
        $isNested = $pdo->inTransaction();

        if ($isNested) {
            $savepoint = $this->createSavepoint(pdo: $pdo);
        } else {
            $this->beginTransaction();
        }

        try {
            $operations(); // Execute the operations
            $isNested ? $this->releaseSavepoint(pdo: $pdo, savepoint: $savepoint) : $this->commit();
        } catch (Exception $exception) {
            $isNested ? $this->rollbackToSavepoint(pdo: $pdo, savepoint: $savepoint) : $this->rollbackTransaction();
            $this->logTransactionError(exception: $exception);
            throw $exception;
        }
    }

    /**
     * Gets the current database connection.
     */
    public function getDatabaseConnection() : PDO
    {
        return $this->databaseConnection->getConnection();
    }

    /**
     * Creates a savepoint for nested transactions.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function createSavepoint(PDO $pdo) : string
    {
        $savepoint = self::SAVEPOINT_PREFIX . uniqid();

        $quotedSavepoint = $pdo->quote(string: $savepoint);

        if ($quotedSavepoint === false) {
            throw new QueryBuilderException(message: "PDO::quote() failed to quote the savepoint name.");
        }

        $pdo->exec(statement: "SAVEPOINT " . $quotedSavepoint);

        return $savepoint;
    }


    /**
     * Begins a new transaction on the current database connection.
     * If a transaction is already active, it does nothing.
     */
    public function beginTransaction() : void
    {
        $pdo = $this->getDatabaseConnection();
        if (! $pdo->inTransaction()) {
            $pdo->beginTransaction();
        }
    }

    /**
     * Releases a savepoint for nested transactions.
     */
    private function releaseSavepoint(PDO $pdo, string $savepoint) : void
    {
        $stmt = $pdo->prepare(query: "RELEASE SAVEPOINT :savepoint");
        $stmt->execute(params: ['savepoint' => $savepoint]);
    }

    /**
     * Commits the current database transaction.
     */
    public function commit() : void
    {
        $pdo = $this->getDatabaseConnection();
        if ($pdo->inTransaction()) {
            $pdo->commit();
        }
    }

    /**
     * Rolls back to a savepoint in nested transactions.
     */
    private function rollbackToSavepoint(PDO $pdo, string $savepoint) : void
    {
        $stmt = $pdo->prepare(query: "ROLLBACK TO SAVEPOINT :savepoint");
        $stmt->execute(params: ['savepoint' => $savepoint]);
    }

    /**
     * Rolls back the current database transaction.
     */
    public function rollbackTransaction() : void
    {
        $pdo = $this->getDatabaseConnection();
        if ($pdo->inTransaction()) {
            try {
                $pdo->rollBack();
            } catch (Exception $e) {
                $this->logger->error(message: 'Rollback failed: ' . $e->getMessage());
            }
        }
    }

    /**
     * Logs transaction-related errors.
     */
    private function logTransactionError(Exception $exception) : void
    {
        $this->logger->error(
            message: 'Transaction failed: ' . $exception->getMessage(),
            context: ['exception' => $exception]
        );
    }
}
=== QueryBuilder/Traits/IdentityMapTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **IdentityMapTrait**
 *
 * Implements the **Identity Map** pattern to cache and retrieve objects
 * within a single database transaction or request lifecycle.
 *
 * ðŸ† **Benefits:**
 * - âœ… **Prevents redundant queries** by storing retrieved data in memory.
 * - âœ… **Ensures consistency** by always returning the same instance of an entity.
 * - âœ… **Improves performance** by reducing database hits.
 * - âœ… **Supports cache integrations** (Redis, APCu, etc.).
 */
trait IdentityMapTrait
{
    /**
     * Stores cached entities, indexed by their unique keys.
     *
     * @var array<string,|null mixed>
     */
    private readonly array|null $identityMap;

    /**
     * Adds an entity to the identity map.
     *
     * If an entity with the same key already exists, it will be **overwritten**.
     *
     * @param string $key   The unique identifier for the entity.
     * @param mixed  $value The entity data to be stored.
     */
    public function addToIdentityMap(string $key, mixed $value) : void
    {
        $this->identityMap[$key] = $value;
    }

    /**
     * Retrieves an entity from the identity map by its key.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @return mixed|null The stored entity if found, otherwise `null`.
     */
    public function getFromIdentityMap(string $key) : mixed
    {
        return $this->identityMap[$key] ?? null;
    }

    /**
     * Checks if an entity exists in the identity map.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @return bool Returns `true` if the entity exists, otherwise `false`.
     */
    public function hasInIdentityMap(string $key) : bool
    {
        return array_key_exists($key, $this->identityMap);
    }

    /**
     * Removes an entity from the identity map.
     *
     * @param string $key The unique identifier of the entity.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function removeFromIdentityMap(string $key) : void
    {
        if (! array_key_exists($key, $this->identityMap)) {
            throw new QueryBuilderException(message: "Cannot remove entity: Key '{$key}' not found in Identity Map.");
        }

        unset($this->identityMap[$key]);
    }

    /**
     * Clears all stored entities from the identity map.
     */
    public function clearIdentityMap() : void
    {
        $this->identityMap = [];
    }
}

=== QueryBuilder/Traits/InsertUpdateTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use PDO;

/**
 * **InsertUpdateTrait**
 *
 * Provides transactional `INSERT`, `UPDATE`, `BATCH INSERT`, and `UPSERT` operations,
 * while integrating a **Unit of Work** mechanism to delay execution until explicitly flushed.
 *
 * **Security Enhancements:**
 * - ðŸ›¡ï¸ **Prevents SQL Injection** with strict parameter binding.
 * - ðŸ”’ **Ensures transactional integrity** for batch operations.
 * - ðŸš€ **Optimized for large datasets** (batch inserts split into smaller transactions).
 */
trait InsertUpdateTrait
{
    /**
     * Inserts multiple rows of data into the database in batches.
     *
     * This method takes an array of rows, splits them into smaller chunks, and executes
     * batch insert queries to optimize a database writes. It uses parameterized queries
     * to prevent SQL injection and works on tables with the structure defined by the
     * QueryBuilder instance.
     *
     * @param array $rows An array where each element is an associative array representing a row
     *                    to be inserted. Each row must contain the same keys, which correspond
     *                    to the column names in the database table.
     *
     * @return static Returns the current instance of the QueryBuilder to enable method chaining.
     *
     * @throws QueryBuilderException Throws an exception if the input array of rows is empty.
     */
    public function batchInsert(array $rows) : static
    {
        // Check if the input array of rows is empty
        if (empty($rows)) {
            // Throw a custom exception if no data is provided for the batch insert
            throw new QueryBuilderException(message: 'No data provided for batch insert.');
        }

        // Get the database connection instance (PDO)
        $pdo = $this->getConnection();
        // Disable emulation of prepared statements to improve security and prevent SQL injection
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // ðŸ›¡ï¸ Prevents SQL Injection

        // Extract the column names from the first row of the input data
        $columns = array_keys($rows[0]);
        // Create a comma-separated list of column names for the SQL statement
        $columnsList = implode(', ', $columns);

        // Split the input data into smaller chunks, with each chunk containing up to 500 rows
        $chunks = array_chunk($rows, 500); // âœ… Splits into batches of 500 rows

        // Iterate over each chunk of data
        foreach ($chunks as $chunk) {
            // Initialize an array to store SQL placeholders for the values
            $placeholders = [];
            // Initialize an array to store the query parameters
            $parameters = [];

            // Iterate over each row in the current chunk
            foreach ($chunk as $index => $row) {
                // Generate placeholders for the current row's values using the column names and row index
                $rowPlaceholders = array_map(static fn($key) => ":{$key}_{$index}", $columns);
                // Combine the placeholders into a parenthesized string and add to the placeholders array
                $placeholders[] = '(' . implode(', ', $rowPlaceholders) . ')';
                // Map the row values to their corresponding placeholders
                foreach ($row as $key => $value) {
                    $parameters["{$key}_{$index}"] = $value;
                }
            }

            // Generate the SQL query for inserting the current chunk of data
            $sql = sprintf(
                'INSERT INTO %s (%s) VALUES %s',
                $this->getTableName(),      // Get the table name from the QueryBuilder instance
                $columnsList,              // The list of columns to insert data into
                implode(', ', $placeholders) // Comma-separated list of placeholders for all rows
            );

            // Prepare the SQL statement to be executed
            $statement = $pdo->prepare(query: $sql);
            // Execute the prepared statement with the mapped parameters
            $this->registerQueryInUnitOfWork(
                operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
                statement : $statement,
                pdo       : $pdo,
                parameters: $parameters
            );
        }

        // Return the current QueryBuilder instance to support method chaining
        return $this;
    }

    /**
     * Performs an upsert operation, inserting a record if it does not exist,
     * or updating the specified columns if a duplicate key is found.
     *
     * The method supports MySQL's `ON DUPLICATE KEY UPDATE` or PostgreSQL's
     * `ON CONFLICT DO UPDATE` based on the database driver.
     * Uses parameterized queries to enhance security and **prevent SQL injection**.
     *
     * @param array $values        The dataset to be inserted. Keys are column names and values are their respective
     *                             values.
     * @param array $updateColumns The column names to be updated in case of a duplicate key or conflict.
     *
     * @return static The current instance for method chaining.
     * @throws QueryBuilderException If no data is provided or if required arrays are empty.
     *
     */
    public function upsert(array $values, array $updateColumns) : static
    {
        // Check if the `$values` array or `$updateColumns` array is empty.
        // If either is empty, throw a custom `QueryBuilderException` since there is no data to perform an upsert operation.
        if (empty($values) || empty($updateColumns)) {
            throw new QueryBuilderException(message: 'No data provided for upsert.');
        }

        // Retrieve the PDO database connection using the `getConnection` method.
        $pdo = $this->getConnection();

        // Set the PDO attribute to disable emulated prepared statements.
        // This improves security by preventing SQL injection attacks.
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // ðŸ›¡ï¸ Prevents SQL Injection

        // Create a comma-separated string of column names from the keys of the `$values` array.
        $columns = implode(', ', array_keys($values));

        // Create a comma-separated string of placeholders (e.g., `:column_name`) for prepared statements.
        $placeholders = implode(', ', array_map(static fn($key) => ":{$key}", array_keys($values)));

        // Create a comma-separated string of `column = :update_column` pairs for the ON DUPLICATE KEY UPDATE clause.
        $updates = implode(', ', array_map(static fn($col) => "{$col} = :update_{$col}", $updateColumns));

        // MySQL uses "ON DUPLICATE KEY UPDATE", while PostgreSQL uses "ON CONFLICT (...) DO UPDATE".
        // The query is dynamically adjusted based on the database driver.
        $sql = sprintf(
            'INSERT INTO %s (%s) VALUES (%s) ON DUPLICATE KEY UPDATE %s',
            $this->getTableName(), // Get the table name from the class property or throw if not set.
            $columns,              // Columns to insert data into.
            $placeholders,         // Placeholders for prepared statement values.
            $updates               // Update statement for duplicate key cases.
        );

        // Check if the current database driver is PostgreSQL using the PDO driver name.
        if ($pdo->getAttribute(attribute: PDO::ATTR_DRIVER_NAME) === QueryBuilderEnum::DRIVER_PGSQL->value) {
            // Create a comma-separated string of columns used in PostgreSQL's ON CONFLICT clause.
            $conflictColumns = implode(', ', $updateColumns);
            // Construct the SQL query string for PostgreSQL's INSERT INTO ... ON CONFLICT ... DO UPDATE statement.
            $sql = sprintf(
                'INSERT INTO %s (%s) VALUES (%s) ON CONFLICT (%s) DO UPDATE SET %s',
                $this->getTableName(),  // Get the table name from the class property or throw if not set.
                $columns,               // Columns to insert data into.
                $placeholders,          // Placeholders for prepared statement values.
                $conflictColumns,       // Columns to check for conflicts.
                $updates                // Update statement for conflict cases.
            );
        }

        // Prepare the SQL statement using the PDO `prepare` method.
        // This step ensures the query is safe to execute and supports parameterized values for security.
        $statement = $pdo->prepare(query: $sql);

        // â— This registers the query with the Unit of Work system, so it will be executed in a controlled batch during flush().
        // The type of operation is specified as an enum value representing the "INSERT" query type.
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
            statement : $statement,
            pdo       : $pdo,
            parameters: $values // The array of parameters to bind to the statement for execution.
        );

        // Return the current object instance, allowing method chaining.
        return $this;
    }

    /**
     * Inserts a single row into the database.
     *
     * Uses a prepared statement with parameterized queries to prevent SQL injection.
     *
     * @param array $parameters The key-value pairs representing column names and their respective values to be
     *                          inserted.
     *
     * @return static Returns the current instance for method chaining after a successful insert.
     *
     * @throws QueryBuilderException If no data is provided for the insert operation.
     */
    public function insert(array $parameters) : static
    {
        // Check if the provided parameters are empty, throw exception if true
        if (empty($parameters)) {
            throw new QueryBuilderException(message: 'No data provided for insert.');
        }

        // Retrieve the PDO database connection object
        $pdo = $this->getConnection();

        // Disable PDO's emulated prepared statements to prevent SQL Injection
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false); // ðŸ›¡ï¸ Prevents SQL Injection

        // Create a comma-separated list of column names from the parameter keys
        $columns = implode(', ', array_keys($parameters));

        // Create a comma-separated list of named placeholders corresponding to the parameter keys
        $placeholders = implode(', ', array_map(static fn($key) => ":{$key}", array_keys($parameters)));

        // Build the SQL query for inserting data into the table
        $sql = sprintf('INSERT INTO %s (%s) VALUES (%s)', $this->getTableName(), $columns, $placeholders);

        // Prepare the SQL query using the PDO connection
        $statement = $pdo->prepare(query: $sql);

        // Register the query in the unit of work for consistency and potential deferred execution
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_INSERT,
            statement : $statement,
            pdo       : $pdo,
            parameters: $parameters
        );

        // Return the current instance for method chaining
        return $this;
    }

    /**
     * Performs an update operation on records that match the specified conditions.
     *
     * Uses parameterized queries to **prevent SQL injection**. Both the updated data
     * and the conditions must be provided to ensure a valid operation.
     *
     * @param array $values     The data to update with column-value pairs.
     * @param array $conditions The conditions to determine which records to update.
     *
     * @return static Returns the current instance for method chaining.
     * @throws QueryBuilderException If no data or conditions are provided.
     *
     */
    public function update(array $values, array $conditions) : static
    {
        // Check if either the update data ($values) or the conditions ($conditions) are empty.
        // If either is empty, throw a QueryBuilderException to ensure both are provided.
        if (empty($values) || empty($conditions)) {
            throw new QueryBuilderException(message: 'No data or conditions provided for update.');
        }

        // Obtain the database connection using the `getConnection` method.
        // This ensures we have access to the database with a valid PDO instance.
        $pdo = $this->getConnection();

        // Set the PDO attribute to disable emulated prepared statements.
        // ðŸ›¡ï¸ This strengthens security by preventing SQL injection attacks.
        $pdo->setAttribute(attribute: PDO::ATTR_EMULATE_PREPARES, value: false);

        // Use array mapping to construct the `SET` portion of the SQL statement.
        // Each `SET` clause follows the format "column = :set_column".
        $setClauses = implode(', ', array_map(static fn($col) => "{$col} = :set_{$col}", array_keys($values)));

        // Use array mapping to construct the `WHERE` portion of the SQL statement.
        // Each condition in `WHERE` follows the format "column = :where_column".
        $whereClauses = implode(
            ' AND ',
            array_map(static fn($col) => "{$col} = :where_{$col}", array_keys($conditions))
        );

        // Create the final SQL query string using the table name, `SET` clauses, and `WHERE` clauses.
        // This forms a valid SQL UPDATE query.
        $sql = sprintf('UPDATE %s SET %s WHERE %s', $this->getTableName(), $setClauses, $whereClauses);

        // Prepare the SQL statement using the PDO instance.
        // This allows binding parameters securely before executing the query.
        $statement = $pdo->prepare(query: $sql);

        // Initialize an empty array to hold all parameters for the prepared statement.
        $parameters = [];

        // Populate the $parameters array for the `SET` part of the SQL query.
        // Prefix each key in $values with "set_" to match the placeholders in the query.
        foreach ($values as $key => $value) {
            $parameters["set_{$key}"] = $value;
        }

        // Populate the $parameters array for the `WHERE` part of the SQL query.
        // Prefix each key in $conditions with "where_" to match the placeholders in the query.
        foreach ($conditions as $key => $value) {
            $parameters["where_{$key}"] = $value;
        }

        // Registers a query with the Unit of Work, specifying it as an UPDATE operation.
        // The `QueryBuilderEnum::QUERY_TYPE_UPDATE` indicates the type of a query being performed.
        $this->registerQueryInUnitOfWork(
            operation : QueryBuilderEnum::QUERY_TYPE_UPDATE, // Specifies the type of query as an 'UPDATE' operation.
            statement : $statement, // Passes the prepared PDO statement to be executed.
            pdo       : $pdo,  // Passes PDO connection
            parameters: $parameters // Provides the parameters for the query, likely used for a prepared statement binding.
        );

        // Return the current instance, allowing method chaining if needed.
        return $this;
    }
}

=== QueryBuilder/Traits/JoinClauseBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **JoinClauseBuilderTrait**
 *
 * Handles SQL JOIN clauses, supporting INNER, LEFT, RIGHT, FULL, CROSS, NATURAL, and SELF joins.
 *
 * **Security Enhancements:**
 * - ðŸ›¡ï¸ **Prevents SQL Injection** by sanitizing table and column names.
 * - ðŸ” **Ensures JOIN conditions are valid** before appending them.
 * - ðŸ”’ **Forces table and alias validation** to avoid SQL tampering.
 */
trait JoinClauseBuilderTrait
{
    private array $joinClauses = [];

    /**
     * Builds the SQL JOIN clauses as a concatenated string.
     */
    public function buildJoins() : string
    {
        return empty($this->joinClauses) ? '' : ' ' . implode(' ', $this->joinClauses);
    }

    /**
     * Resets all JOIN clauses.
     */
    public function resetJoins() : static
    {
        $this->joinClauses = [];

        return $this;
    }

    /**
     * Adds a LEFT JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function leftJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'LEFT JOIN'
        );
    }

    /**
     * Adds a JOIN clause with an optional alias and multiple conditions.
     *
     * @throws QueryBuilderException
     */
    public function join(string $table, string|null $alias, array|string $conditions, string $type = 'JOIN') : static
    {
        $tableWithAlias = $alias ? sprintf(
            '%s AS %s',
            $this->quoteIdentifier(name: $table),
            $this->quoteIdentifier(name: $alias)
        ) : $this->quoteIdentifier(name: $table);

        // Ensure conditions are valid
        if (is_array($conditions)) {
            $conditionString = implode(' AND ', array_map(static fn($condition) => trim($condition), $conditions));
        } else {
            $conditionString = trim($conditions);
        }

        if (empty($table) || empty($conditionString)) {
            throw new QueryBuilderException(message: 'Invalid JOIN statement: table name and conditions are required.');
        }

        $this->joinClauses[] = sprintf('%s %s ON %s', strtoupper($type), $tableWithAlias, $conditionString);

        return $this;
    }

    /**
     * Adds a RIGHT JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function rightJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'RIGHT JOIN'
        );
    }

    /**
     * Adds a FULL OUTER JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function fullOuterJoin(string $table, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : null,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : 'FULL OUTER JOIN'
        );
    }

    /**
     * Adds a CROSS JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function crossJoin(string $table) : static
    {
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Invalid CROSS JOIN: table name cannot be empty.');
        }

        $this->joinClauses[] = sprintf('CROSS JOIN %s', $this->quoteIdentifier(name: $table));

        return $this;
    }

    /**
     * Adds a NATURAL JOIN clause.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function naturalJoin(string $table) : static
    {
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Invalid NATURAL JOIN: table name cannot be empty.');
        }

        $this->joinClauses[] = sprintf('NATURAL JOIN %s', $this->quoteIdentifier(name: $table));

        return $this;
    }

    /**
     * Adds a SELF JOIN clause (join on the same table using an alias).
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function selfJoin(string $table, string $alias, string $first, string $operator, string $second) : static
    {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: [$this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(name: $second)]
        );
    }

    /**
     * Adds a JOIN clause with an alias for the table.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinWithAlias(
        string $table,
        string $alias,
        string $first,
        string $operator,
        string $second,
        string $type = 'JOIN'
    ) : static {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: [
                            $this->quoteIdentifier(name: $first) . " {$operator} " . $this->quoteIdentifier(
                                name: $second
                            ),
                        ],
            type      : $type
        );
    }

    /**
     * Adds a JOIN clause using raw SQL.
     *
     * âš ï¸ **Warning:** Using raw SQL can expose your query to SQL injection risks.
     * Ensure that `$rawSql` is properly sanitized before passing it.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinRaw(string $rawSql) : static
    {
        if (empty($rawSql)) {
            throw new QueryBuilderException(message: 'Invalid JOIN RAW: SQL statement cannot be empty.');
        }

        $this->joinClauses[] = $rawSql;

        return $this;
    }

    /**
     * Adds a JOIN clause with multiple conditions.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function joinWithConditions(
        string      $table,
        string|null $alias,
        array       $conditions,
        string      $type = 'JOIN'
    ) : static {
        return $this->join(
            table     : $table,
            alias     : $alias,
            conditions: $conditions,
            type      : $type
        );
    }
}

=== QueryBuilder/Traits/OrderByAndGroupByBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\BaseQueryBuilder;
use Gemini\Database\QueryBuilder\QueryBuilder;
use InvalidArgumentException;
use PDO;

/**
 * Trait OrderByAndGroupByBuilderTrait
 *
 * Handles SQL ORDER BY, GROUP BY, and HAVING clauses using a fluent interface.
 *
 * âœ… OWASP Security: Prevents SQL Injection via safe query-building practices.
 * âœ… Strict Input Validation: Ensures only valid column names and values are accepted.
 */
trait OrderByAndGroupByBuilderTrait
{
    /**
     * Prefix used for placeholders in query building or other similar operations.
     */
    private const string PLACEHOLDER_PREFIX = 'orderByField_';

    /**
     * Stores ORDER BY clauses.
     */
    private array $orderByClauses = [];

    /**
     * Stores GROUP BY clauses.
     */
    private array $groupByClauses = [];

    /**
     * Stores HAVING clauses.
     */
    private array $havingClauses = [];

    /**
     * Stores bound parameters for safe query execution.
     */
    private array $boundParameters = [];

    /**
     * Resets all ORDER BY, GROUP BY, and HAVING clauses.
     */
    public function resetClauses() : self
    {
        $this->orderByClauses  = [];
        $this->groupByClauses  = [];
        $this->havingClauses   = [];
        $this->boundParameters = [];

        return $this;
    }

    /**
     * Adds an ORDER BY clause.
     *
     */
    public function orderBy(string $column, string $direction = 'ASC') : self
    {
        // Validate the column name to ensure it only contains valid characters (alphanumeric and underscores)
        $this->validateColumnName(name: $column);

        // Convert the order direction (ASC/DESC) to uppercase for consistent comparison
        $direction = strtoupper($direction);

        // Check whether the provided direction is valid (ASC or DESC)
        // If the direction is invalid, throw an exception with an appropriate error message
        if (! in_array($direction, ['ASC', 'DESC'], true)) {
            throw new InvalidArgumentException(message: 'Invalid ORDER BY direction. Use "ASC" or "DESC".');
        }

        // Append the valid ORDER BY clause to the array of clauses
        // The column name is safely enclosed using quoteIdentifier for preventing SQL injection
        $this->orderByClauses[] = sprintf('%s %s', $this->quoteIdentifier(name: $column), $direction);

        // Return the current instance to allow method chaining
        return $this;
    }

    /**
     * Adds an ORDER BY FIELD() clause for custom sorting.
     *
     */
    public function orderByField(string $column, array $values) : self
    {
        // Validate the column name to ensure it contains only alphanumeric characters and underscores
        $this->validateColumnName(name: $column);

        // Check if the input array of values is empty, and throw an exception if it is
        if (empty($values)) {
            throw new InvalidArgumentException(message: 'OrderByField requires a non-empty array of values.');
        }

        // Generate a set of placeholders and their corresponding bindings for the passed values
        $placeholdersWithBindings = $this->generatePlaceholdersWithBindings(values: $values);

        // Add an `ORDER BY FIELD` clause to the list of order clauses
        // The `FIELD` SQL function matches the column value to the provided list of placeholders
        $this->orderByClauses[] = sprintf(
            'FIELD(%s, %s)',
            // Sanitize and properly quote the column name according to the database driver
            $this->quoteIdentifier(name: $column),
            // Create a comma-separated list of placeholders (keys from the bindings array)
            implode(', ', array_keys($placeholdersWithBindings)) // Extract only keys for SQL placeholders
        );

        // Merge the generated parameter bindings with any previously existing bound parameters
        $this->boundParameters = array_merge($this->boundParameters, $placeholdersWithBindings);

        // Return the current instance to allow method chaining
        return $this;
    }

    /**
     * Generates a set of placeholders with corresponding value bindings
     * for use in a prepared SQL statement.
     *
     * @param array $values The array of values to create placeholders for.
     *
     * @return array An associative array where keys are placeholder names
     *               and values are the corresponding data from the input array.
     */
    private function generatePlaceholdersWithBindings(array $values) : array
    {
        // Initialize an array to hold the placeholder-value bindings
        $bindings = [];

        // Loop through each value in the provided array, with its index
        foreach ($values as $index => $value) {
            // Create a unique placeholder name using a prefix and the current index
            $placeholderName = ':' . self::PLACEHOLDER_PREFIX . $index;

            // Map the placeholder name to its corresponding value from the input
            $bindings[$placeholderName] = $value;
        }

        // Return the associative array of placeholders and their corresponding values
        return $bindings;
    }

    /**
     * Adds an ORDER BY RAND() clause for random ordering.
     */
    public function orderByRand() : self
    {
        $this->orderByClauses[] = 'RAND()';

        return $this;
    }

    /**
     * Adds a GROUP BY clause.
     *
     */
    public function groupBy(string $column) : self
    {
        $this->validateColumnName(name: $column);
        $this->groupByClauses[] = $this->quoteIdentifier(name: $column);

        return $this;
    }

    /**
     * Adds a HAVING clause with **secure parameter binding**.
     *
     */
    public function having(string $column, string $operator, mixed $value) : self
    {
        // Validate the column name to ensure it contains only alphanumeric characters and underscores.
        $this->validateColumnName(name: $column);

        // Check if the operator provided is valid by comparing it against the list of allowed operators.
        // If the operator is not valid, throw an InvalidArgumentException.
        if (! in_array($operator, ['=', '!=', '<', '>', '<=', '>=', 'LIKE', 'NOT LIKE', 'IN', 'NOT IN'], true)) {
            throw new InvalidArgumentException(message: 'Invalid HAVING operator.');
        }

        // Create a parameter placeholder by replacing periods in the column name with underscores.
        // The placeholder is prefixed with ":having_".
        $placeholder = sprintf(':having_%s', str_replace('.', '_', $column));

        // Build the HAVING clause using the quoted column name, the operator, and the placeholder.
        // Add the resulting clause to the `havingClauses` array.
        $this->havingClauses[] = sprintf('%s %s %s', $this->quoteIdentifier(name: $column), $operator, $placeholder);

        // Store the actual value of the parameter in the `boundParameters` array, keyed by the placeholder.
        // This helps ensure the value is safely bound to the statement later during query execution.
        $this->boundParameters[$placeholder] = $value;

        // Return the current object to allow method chaining.
        return $this;
    }

    /**
     * Modifies the query to sort the results in random order, using the appropriate SQL function based on the database
     * driver.
     *
     * @return BaseQueryBuilder|QueryBuilder|OrderByAndGroupByBuilderTrait Returns applied.
     */
    public function inRandomOrder() : self
    {
        // Retrieve the name of the database driver (e.g., 'mysql', 'pgsql') from the current connection.
        // This is done by accessing the PDO::ATTR_DRIVER_NAME attribute of the PDO connection object.
        $driver = $this->getConnection()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);

        // Add a clause to the `orderByClauses` array based on the database driver.
        // For PostgreSQL ('pgsql'), use `RANDOM()`; for other database drivers, use `RAND()`.
        $this->orderByClauses[] = match ($driver) {
            'pgsql' => 'RANDOM()', // If the database driver is Postgres, use the `RANDOM()` function for random ordering.
            default => 'RAND()',   // For other database drivers (e.g., MySQL), use the `RAND()` function for random ordering.
        };

        // Return the current object instance to allow method chaining.
        return $this;
    }

    /**
     * Builds the ORDER BY clause.
     */
    public function buildOrderBy() : string
    {
        return empty($this->orderByClauses) ? '' : ' ORDER BY ' . implode(', ', $this->orderByClauses);
    }

    /**
     * Builds the GROUP BY and HAVING clauses.
     */
    public function buildGroupByAndHaving() : string
    {
        $sql = '';

        if (! empty($this->groupByClauses)) {
            $sql .= ' GROUP BY ' . implode(', ', $this->groupByClauses);
        }

        if (! empty($this->havingClauses)) {
            $sql .= ' HAVING ' . implode(' AND ', $this->havingClauses);
        }

        return $sql;
    }

    /**
     * **Retrieves bound parameters** for safe query execution.
     */
    public function getBoundParameters() : array
    {
        return $this->boundParameters;
    }
}

=== QueryBuilder/Traits/ProvidesUnitOfWork.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\Database\QueryBuilder\UnitOfWork;

/**
 * Trait ProvidesUnitOfWork
 *
 * Ensures that any class using this trait has access to a UnitOfWork instance.
 */
trait ProvidesUnitOfWork
{
    /**
     * Retrieves the UnitOfWork instance.
     *
     * @return UnitOfWork The Unit of Work instance.
     * @throws QueryBuilderException
     */
    protected function getUnitOfWork() : UnitOfWork
    {
        if (! isset($this->unitOfWork) || ! $this->unitOfWork instanceof UnitOfWork) {
            // Check if the `unitOfWork` property is either not set or is not an instance of the `UnitOfWork` class.
            // If this condition is true, throw a `QueryBuilderException` with a descriptive message.
            throw new QueryBuilderException(message: "UnitOfWork is not set in the class using this trait.");
        }
        if (! method_exists($this, 'getTableName')) {
            // Check if the class using this trait does not define the `getTableName` method.
            // If the `getTableName` method doesn't exist, throw a `QueryBuilderException` with an appropriate message.
            throw new QueryBuilderException(message: "getTableName() is not set in the class using this trait.");
        }

        // If both checks pass (i.e., `unitOfWork` is set and is an instance of `UnitOfWork`, and `getTableName()` exists),
        // return the `unitOfWork` property, which is expected to handle database query registration and execution.
        return $this->unitOfWork;
    }
}

=== QueryBuilder/Traits/QueryOptimizationTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

/**
 * Trait QueryOptimizationTrait
 *
 * Provides query optimization strategies, including **indexing recommendations** and **performance insights**.
 *
 * âœ… Implements **OWASP security best practices** to prevent SQL injection.
 * âœ… Uses **PSR-3 Logging** instead of direct output.
 * âœ… Ensures **strict input validation** for indexing recommendations.
 */
trait QueryOptimizationTrait
{
    /**
     * @var array<string> Stores WHERE clauses for analysis.
     */
    private array $whereClauses = [];

    /**
     * Displays recommendations for indexing based on WHERE clauses.
     *
     * âœ… Uses structured **PSR-3 logging** instead of `echo`.
     * âœ… Ensures **strict column name validation** to prevent SQL injection.
     */
    public function showIndexingRecommendations() : void
    {
        $recommendations = $this->recommendIndexes();

        if (empty($recommendations)) {
            $this->logger->info(message: "ðŸ” No indexing recommendations. Your query is already optimized. ðŸš€");
        } else {
            $message = "âš¡ Recommended columns for indexing: " . implode(', ', $recommendations);
            $this->logger->info(message: $message);

            foreach ($recommendations as $column) {
                $this->logger->info(message: "ðŸ“Œ Consider: CREATE INDEX idx_{$column} ON your_table({$column});");
            }
        }
    }

    /**
     * Analyzes WHERE conditions and suggests which columns should be indexed.
     *
     * âœ… **Prevents SQL injection** via strict column validation.
     * âœ… **Ensures best performance** by avoiding unnecessary recommendations.
     *
     * @return array<int, string> List of recommended columns for indexing.
     */
    public function recommendIndexes() : array
    {
        if (empty($this->whereClauses)) {
            return [];
        }

        $indexes = [];

        foreach ($this->whereClauses as $clause) {
            // Extract column names from WHERE conditions.
            if (preg_match('/^([a-zA-Z0-9_]+)\s*(=|LIKE|IN|>|<|>=|<=)/', $clause, $matches)) {
                $column = $matches[1];

                // Validate column name before adding to recommendations.
                if ($this->isValidColumnName(column: $column) && ! in_array($column, $indexes, true)) {
                    $indexes[] = $column;
                }
            }
        }

        return $indexes;
    }

    /**
     * Validates a column name against SQL injection risks.
     *
     * âœ… Ensures column names are safe before they are used in SQL statements.
     */
    private function isValidColumnName(string $column) : bool
    {
        return preg_match('/^[a-zA-Z0-9_]+$/', $column) === 1;
    }
}

=== QueryBuilder/Traits/SchemaQueryBuilderTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Exception;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;

/**
 * **SchemaQueryBuilderTrait**
 *
 * Secure **Schema Management API** for QueryBuilder.
 *
 * âœ… **Features:**
 * - **Database Operations:** Create, Drop, Switch
 * - **Table Operations:** Rename, Drop, Exists Checks
 * - **OWASP Security:** Prevents **SQL Injection** & **Malicious Schema Manipulation**
 * - **Idempotency Checks:** Avoids unnecessary operations
 */
trait SchemaQueryBuilderTrait
{
    /**
     * **Switches to a different database** (if it exists).
     *
     * @param string $database The database name to switch to.
     *
     * @throws QueryBuilderException If the database does not exist.
     * @throws \Random\RandomException
     */
    public function useDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if (! $this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Cannot switch: Database '{$database}' does not exist.");
        }

        try {
            $this->raw(sql: "USE {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(
                message: "Failed to switch to database '{$database}'", code: 0, previous: $e
            );
        }
    }

    /**
     * **Validates a database name against OWASP recommendations.**
     *
     * @param string $database The database name to validate.
     *
     * @throws QueryBuilderException If the name is invalid.
     */
    private function validateDatabaseName(string $database) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $database)) {
            throw new QueryBuilderException(message: "Invalid database name: '{$database}'");
        }
    }

    /**
     * **Checks if a database exists.**
     *
     * @param string $database The database name.
     *
     * @return bool True if the database exists, otherwise false.
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Random\RandomException
     */
    public function databaseExists(string $database) : bool
    {
        $this->validateDatabaseName(database: $database);

        return $this
            ->table(tableName: 'information_schema.SCHEMATA')
            ->where(column: 'SCHEMA_NAME', value: $database)
            ->exists();
    }

    /**
     * **Creates a new database** (if it does not exist).
     *
     * @param string $database The database name.
     *
     * @throws QueryBuilderException If creation fails.
     * @throws \Random\RandomException
     */
    public function createDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if ($this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Database '{$database}' already exists.");
        }

        try {
            $this->raw(sql: "CREATE DATABASE {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to create database '{$database}'", code: 0, previous: $e);
        }
    }

    /**
     * **Drops an existing database** (if it exists).
     *
     * @param string $database The database name.
     *
     * @throws QueryBuilderException If deletion fails.
     * @throws \Random\RandomException
     */
    public function dropDatabase(string $database) : void
    {
        $this->validateDatabaseName(database: $database);

        if (! $this->databaseExists(database: $database)) {
            throw new QueryBuilderException(message: "Cannot drop: Database '{$database}' does not exist.");
        }

        try {
            $this->raw(sql: "DROP DATABASE IF EXISTS {$this->quoteIdentifier(name:$database)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to drop database '{$database}'", code: 0, previous: $e);
        }
    }

    /**
     * **Renames an existing table** (if it exists).
     *
     * @param string $oldName The current table name.
     * @param string $newName The new table name.
     *
     * @throws QueryBuilderException If renaming fails.
     * @throws \Random\RandomException
     * @throws \Random\RandomException
     */
    public function renameTable(string $oldName, string $newName) : void
    {
        $this->validateTableName(table: $oldName);
        $this->validateTableName(table: $newName);

        if (! $this->tableExists(table: $oldName)) {
            throw new QueryBuilderException(message: "Cannot rename: Table '{$oldName}' does not exist.");
        }

        if ($this->tableExists(table: $newName)) {
            throw new QueryBuilderException(message: "Cannot rename: Table '{$newName}' already exists.");
        }

        try {
            $this->raw(
                sql: "RENAME TABLE {$this->quoteIdentifier(name:$oldName)} TO {$this->quoteIdentifier(name:$newName)}"
            )->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to rename table '{$oldName}'", code: 0, previous: $e);
        }
    }

    /**
     * **Validates a table name against OWASP recommendations.**
     *
     * @param string $table The table name to validate.
     *
     * @throws QueryBuilderException If the name is invalid.
     */
    private function validateTableName(string $table) : void
    {
        if (! preg_match('/^[a-zA-Z0-9_]+$/', $table)) {
            throw new QueryBuilderException(message: "Invalid table name: '{$table}'");
        }
    }

    /**
     * **Checks if a table exists in the current database.**
     *
     * @param string $table The table name.
     *
     * @return bool True if the table exists, otherwise false.
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Random\RandomException
     */
    public function tableExists(string $table) : bool
    {
        $this->validateTableName(table: $table);

        return $this
            ->table(tableName: 'information_schema.tables')
            ->where(column: 'table_schema', value: $this->raw(sql: 'DATABASE()'))
            ->where(column: 'table_name', value: $table)
            ->exists();
    }

    /**
     * **Drops a table** (if it exists).
     *
     * @param string $table The table name.
     *
     * @throws QueryBuilderException If deletion fails.
     * @throws \Random\RandomException
     */
    public function dropTable(string $table) : void
    {
        $this->validateTableName(table: $table);

        if (! $this->tableExists(table: $table)) {
            throw new QueryBuilderException(message: "Cannot drop: Table '{$table}' does not exist.");
        }

        try {
            $this->raw(sql: "DROP TABLE IF EXISTS {$this->quoteIdentifier(name:$table)}")->execute();
        } catch (Exception $e) {
            throw new QueryBuilderException(message: "Failed to drop table '{$table}'", code: 0, previous: $e);
        }
    }
}

=== QueryBuilder/Traits/SelectQueryTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use JsonException;
use PDO;
use PDOException;
use PDOStatement;
use Psr\SimpleCache\CacheInterface;

/**
 * Trait SelectQueryTrait
 *
 * Provides functionality for handling SELECT queries, including:
 * - ðŸ”¥ Built-in caching (In-Memory + External Cache)
 * - ðŸš€ Query performance optimization
 * - ðŸ“Œ Pagination & indexing
 * - ðŸ’¾ Hybrid cache system with cache invalidation
 */
trait SelectQueryTrait
{
    /**
     * Controls whether the SELECT query should return distinct results.
     *
     * @readonly
     * @var bool Defaults to false for standard SELECT operations
     */
    protected bool $distinct = false;

    /**
     * Specifies the window function to be applied in the query.
     * Used for analytical operations like ROW_NUMBER(), RANK(), etc.
     *
     * @readonly
     * @var string|null Window function SQL expression or null if not used
     */
    protected string|null $windowFunction = null;

    /**
     * Defines the columns to be retrieved in the SELECT statement.
     * Supports both array of column names and complex expressions.*
     */
    protected array $columns = [];

    /**
     * Determines the locking strategy for the SELECT operation.
     * Supports pessimistic/optimistic locking mechanisms.
     *
     * @readonly
     * @var string|null Lock mode (e.g., 'FOR UPDATE', 'SHARED') or null for no explicit locking
     */
    protected string|null $lockMode = null;

    /**
     * Maximum number of rows to return in the result set.
     * Implements pagination control alongside offset.
     *
     * @readonly
     * @var positive-int|null Number of rows to limit or null for no limit
     */
    protected int|null $limit = null;

    /**
     * Number of rows to skip before starting to return rows.
     * Used in conjunction with the limit for pagination implementation.
     *
     * @readonly
     * @var non-negative-int|null Number of rows to offset or null for no offset
     */
    protected int|null $offset = null;

    /**
     * Determines if query results should be cached.
     * Enables performance optimization for frequently accessed data.
     *
     * @readonly
     * @var bool Defaults to false for real-time query execution
     */
    protected bool $cacheEnabled = false;

    /**
     * Duration in seconds for which cached results remain valid.
     * Affects cache invalidation strategy.
     *
     * @readonly
     * @var positive-int Cache time-to-live in seconds, defaults to 300 (5 minutes)
     */
    protected int $cacheTTL = 300;

    /**
     * Cache implementation for storing query results.
     * Supports PSR-16 compatible cache interfaces.
     *
     * @readonly
     * @var CacheInterface|null Cache implementation or null if caching is disabled
     */
    protected CacheInterface|null $cache = null;

    /**
     * Optional index hint for query optimization.
     * Allows explicit index selection for query execution.
     *
     * @readonly
     * @var string|null Index name to use or null for automatic index selection
     */
    protected string|null $indexHint = null;

    /**
     * Indicates whether to use a read-only database connection.
     * Supports read/write separation pattern in distributed systems.
     *
     * @readonly
     * @var bool|null True for read connection, false for write, null for default
     */
    protected bool|null $useReadConnection = false;

    /**
     * Specifies the NO LOCK hint for SQL Server compatibility.
     * Affects transaction isolation behavior.
     *
     * @readonly
     * @var string|null NO LOCK hint specification or null for default locking behavior
     */
    protected string|null $noLock = null;

    /**
     * Retrieves query results, supporting UnitOfWork if needed.
     *
     * @param bool $addToUnitOfWork If true, query will be deferred for execution.
     *
     * @return static|Arrhae The query results.
     * @throws QueryBuilderException
     * @throws JsonException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    public function get(bool $addToUnitOfWork = false) : static|Arrhae
    {
        if ($this->cacheEnabled && ($cached = $this->fetchFromCache())) {
            return new Arrhae(items: $cached);
        }

        $query = $this->buildSelectQuery();
        $pdo   = $this->getDatabaseConnection();
        $stmt  = $pdo->prepare(query: $query);

        if ($addToUnitOfWork) {
            $this
                ->getUnitOfWork()
                ->registerQuery(
                    operation : QueryBuilderEnum::QUERY_TYPE_SELECT,
                    statement : $stmt,
                    pdo       : $pdo,
                    parameters: $this->getParameters(),
                );

            return $this;
        }

        return $this->executeQuery(stmt: $stmt);
    }

    /**
     * Attempts to retrieve a cached result.
     *
     * @throws QueryBuilderException|\JsonException|\Psr\SimpleCache\InvalidArgumentException
     */
    private function fetchFromCache() : array|null
    {
        if (! $this->cache || ! $this->cacheEnabled) {
            return null;
        }

        $key = $this->generateCacheKey();

        return $this->cache->has(key: $key) ? $this->cache->get(key: $key) : null;
    }

    /**
     * Generates a unique cache key for the query.
     *
     * This function generates a unique cache key for an SQL `SELECT` query to reduce redundancy in repeated database
     * queries. It combines the generated query (from the `buildSelectQuery` method) and its parameters (from
     * `getParameters`) into a JSON format, using specific encoding options to ensure readability and
     * accuracy. The resulting JSON string is then hashed using the `xxh128` algorithm, which is fast and efficient,
     * and the generated hash is used as a unique cache identifier with the prefix `'query:'`. This method plays a
     * crucial role in implementing query caching, optimizing application performance, and reducing the number of
     * database calls.
     *
     * @throws QueryBuilderException|JsonException
     */
    private function generateCacheKey() : string
    {
        return 'query:' . hash(
                'xxh128',
                json_encode(
                    [
                        'query'      => $this->buildSelectQuery(),
                        'parameters' => $this->getParameters(),
                    ],
                    JSON_THROW_ON_ERROR | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES
                )
            );
    }

    /**
     * Generates the SELECT query string.
     *
     * @throws QueryBuilderException
     */
    private function buildSelectQuery() : string
    {
        return implode(
            ' ',
            array_filter(
                [
                    // Build the SELECT clause of the SQL query (e.g., "SELECT column1, column2").
                    $this->buildSelectClause(),

                    // Build the FROM clause of the SQL query (e.g., "FROM table_name").
                    $this->buildFromClause(),

                    // Build the JOIN clauses for the query, if any (e.g., "LEFT JOIN tableB ON ...").
                    $this->buildJoins(),

                    // Build the WHERE clause for the query, defining specific conditions (e.g., "WHERE column = value").
                    $this->buildWhereClauses(),

                    // Build the GROUP BY clause and HAVING condition for the query (e.g., "GROUP BY column HAVING COUNT(*) > 1").
                    $this->buildGroupByAndHaving(),

                    // Build the ORDER BY clause to sort the query results (e.g., "ORDER BY column ASC/DESC").
                    $this->buildOrderBy(),

                    // Build the LIMIT and OFFSET clauses to restrict the number of rows returned and set an offset (e.g., "LIMIT 10 OFFSET 20").
                    $this->buildLimitOffsetClause(),

                    // Lock mode (optional) used for concurrency (e.g., "FOR UPDATE" or "LOCK IN SHARE MODE").
                    $this->lockMode,

                    // Boolean property indicating whether a "NOLOCK" option should be added (used in specific database systems).
                    $this->noLock,
                ]
            )
        );
    }

    /**
     * Builds the SELECT clause.
     */
    private function buildSelectClause() : string
    {
        // Initialize the $columns array with 'DISTINCT' if the $this->distinct property is true,
        // otherwise, start with an empty array.
        $columns = $this->distinct ? ['DISTINCT'] : [];

        // Merge the current $columns array with $this->columns. If $this->columns is empty
        // or null, use ['*'] as the default (to select all columns).
        $columns = array_merge($columns, $this->columns ?: ['*']);

        // If the $this->windowFunction property is set (not null or falsy), append its
        // value to the $columns array. This is typically used for specialized SQL
        // window functions like ROW_NUMBER() or RANK().
        if ($this->windowFunction) {
            $columns[] = $this->windowFunction;
        }

        // Join all the elements of the $columns array into a comma-separated string
        // and prepend it with 'SELECT'. This constructs the final SQL SELECT clause.
        return 'SELECT ' . implode(', ', $columns);
    }

    /**
     * Builds the FROM clause.
     *
     * @throws QueryBuilderException
     */
    private function buildFromClause() : string
    {
        // Fetch the table name using `getTableName` and sanitize/quote it with `quoteIdentifier`.
        $table = $this->quoteIdentifier(name: $this->getTableName());

        // Check if the sanitized/quoted table name is empty.
        // Throws a `QueryBuilderException` if the table name is not provided.
        if (empty($table)) {
            throw new QueryBuilderException(message: 'Table name is required.');
        }

        // Return a string combining the SQL "FROM" clause and the quoted table name.
        return 'FROM ' . $table;
    }

    /**
     * Builds the LIMIT and OFFSET clauses.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function buildLimitOffsetClause() : string|null
    {
        if ($this->limit !== null && $this->limit < 0) {
            // If the $limit property is set (not null) and its value is less than 0,
            // this indicates an invalid value since a limit must be non-negative.
            // A QueryBuilderException is thrown to prevent invalid SQL queries.
            throw new QueryBuilderException(message: 'Limit must be a non-negative integer.');
        }

        if ($this->offset !== null && $this->offset < 0) {
            // If the $offset property is set (not null) and its value is less than 0,
            // this indicates an invalid value since an offset must be non-negative.
            // A QueryBuilderException is thrown similarly to the limit check above.
            throw new QueryBuilderException(message: 'Offset must be a non-negative integer.');
        }

        return implode(
            ' ', // The delimiter used to concatenate the resulting parts of the SQL clause.
            array_filter(
                [
                    // If $this->limit is set (not null), a "LIMIT" clause is constructed as a string
                    // containing the value of the $this->limit property. Otherwise, null is returned.
                    $this->limit !== null ? "LIMIT {$this->limit}" : null,

                    // Similarly, if $this->offset is set (not null), an "OFFSET" clause is constructed
                    // as a string containing the value of the $this->offset property.
                    // Otherwise, null is returned.
                    $this->offset !== null ? "OFFSET {$this->offset}" : null,
                ]
            )
        // The `array_filter()` function is used to remove null values from the array.
        // This prevents unnecessary spaces or invalid SQL fragments if no limit or offset is set.
        );
    }

    /**
     * Executes the SELECT query and caches the result if enabled.
     *
     * @throws QueryBuilderException|JsonException|\Psr\SimpleCache\InvalidArgumentException
     */
    private function executeQuery(PDOStatement $stmt) : Arrhae
    {
        try {
            // Attempts to execute the prepared SQL statement with the query parameters
            // `getParameters()` presumably returns an array of parameters for the query.
            $stmt->execute(params: $this->getParameters());
        } catch (PDOException $exception) {
            dumpx('executeQuery() dump: ', $exception, $stmt);
            // If an exception occurs during query execution, a custom `QueryBuilderException` is thrown.
            // It includes details about the error, such as the exception message and the executed SQL query.
            throw new QueryBuilderException(message: 'Query execution failed.', previous: $exception);
        }

        // Wraps the result of the executed query in an `Arrhae` object.
        // `fetchAll` retrieves the data from the query as an associative array.
        $result = new Arrhae(items: $stmt->fetchAll(mode: PDO::FETCH_ASSOC));

        if ($this->cacheEnabled) { // Checks if caching is enabled before proceeding.
            // Stores the query results in the cache.
            // `generateCacheKey()` generates a unique key for the query for identification in the cache.
            // `toArray()` converts the `Arrhae` object back to a standard array for caching purposes.
            $this->cache->set(
                key  : $this->generateCacheKey(), // Unique key identifying the cached data.
                value: $result->toArray(),        // The query result data is cached as a plain array.
                ttl  : $this->cacheTTL            // Time-to-live for the cache item (defaults to 300 seconds).
            );
        }

        // Returns the wrapped query result (`Arrhae` object) to the caller.
        return $result;
    }
}

=== QueryBuilder/Traits/SoftDeleteAndDeleteTrait.php ===
<?php
/** @noinspection SqlWithoutWhere */

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use DateTime;
use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;

/**
 * Trait SoftDeleteAndDeleteTrait
 *
 * Provides functionality for managing soft and permanent deletes, including:
 * - Soft delete support with timestamp tracking.
 * - Restore functionality for soft-deleted records.
 * - Permanent delete operations.
 * - Cascading delete operations across related tables.
 * - DELETE JOIN operations for multi-table deletions.
 * - Table truncation support.
 *
 * Implements the **Unit of Work** pattern to defer execution of delete-related operations
 * until explicitly committed.
 */
trait SoftDeleteAndDeleteTrait
{
    /**
     * Indicates whether soft delete functionality is enabled.
     */
    private bool $softDeletes = false;

    /**
     * Indicates whether to include soft-deleted records in queries.
     */
    private bool $withTrashed = false;

    /**
     * Indicates whether to retrieve only soft-deleted records.
     */
    private bool $onlyTrashed = false;

    /**
     * The name of the column used for soft deletes.
     */
    private string $deletedColumn = 'deleted_at';

    /**
     * Enables soft deletes and optionally sets the column used for soft deletion timestamps.
     */
    public function enableSoftDeletes(bool $softDeletes, string|null $deletedColumn = null) : static
    {
        $this->softDeletes = $softDeletes;
        if ($deletedColumn !== null) {
            $this->deletedColumn = $deletedColumn;
        }

        return $this;
    }

    /**
     * Includes soft-deleted records in queries.
     */
    public function withTrashed() : static
    {
        $this->withTrashed = true;
        $this->onlyTrashed = false;

        return $this;
    }

    /**
     * Restricts queries to only soft-deleted records.
     */
    public function onlyTrashed() : static
    {
        $this->onlyTrashed = true;
        $this->withTrashed = false;

        return $this;
    }

    /**
     * Resets filters applied for soft delete queries.
     */
    public function resetSoftDeleteFilters() : static
    {
        $this->withTrashed = false;
        $this->onlyTrashed = false;

        return $this;
    }

    /**
     * Applies soft delete conditions to queries.
     */
    public function applySoftDeleteConditions() : string
    {
        if (! $this->softDeletes) {
            return '';
        }

        return match (true) {
            $this->onlyTrashed   => sprintf(' AND %s IS NOT NULL', $this->deletedColumn),
            ! $this->withTrashed => sprintf(' AND %s IS NULL', $this->deletedColumn),
            default              => '',
        };
    }

    /**
     * Marks records as soft deleted by setting the deleted timestamp.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function softDelete() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'UPDATE ' . $this->getTableName() .
                        ' SET ' . $this->deletedColumn . ' = :deleted_at ' . $this->buildWhereClauses(),
            parameters: [':deleted_at' => (new DateTime())->format('Y-m-d H:i:s')],
            operation : QueryBuilderEnum::QUERY_TYPE_SOFT_DELETE
        );
    }

    /**
     * Registers an operation for deferred execution using the Unit of Work pattern.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function registerForUnitOfWork(string $sql, array $parameters, QueryBuilderEnum $operation) : static
    {
        $pdo       = $this->getConnection();
        $statement = $pdo->prepare($sql);

        $this
            ->getUnitOfWork()
            ->registerQuery(
                operation : $operation,
                statement : $statement,
                parameters: $parameters
            );

        return $this;
    }


    /**
     * Restores soft-deleted records by setting the deleted timestamp to NULL.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function restore() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'UPDATE ' . $this->getTableName() .
                        ' SET ' . $this->deletedColumn . ' = NULL ' . $this->buildWhereClauses(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_RESTORE
        );
    }

    /**
     * Permanently deletes records without applying soft deletes.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function forceDelete() : static
    {
        return $this->delete();
    }

    /**
     * Registers a delete operation in the Unit of Work queue.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function delete() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'DELETE FROM ' . $this->getTableName() . ' ' . $this->buildWhereClauses(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_DELETE
        );
    }

    /**
     * Registers a cascading delete operation for related tables.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function cascadeDelete(array $relatedTables) : static
    {
        foreach ($relatedTables as $table) {
            $this->registerForUnitOfWork(
                sql       : 'DELETE FROM ' . $table . ' ' . $this->buildWhereClauses(),
                parameters: [],
                operation : QueryBuilderEnum::QUERY_TYPE_CASCADE_DELETE
            );
        }

        return $this->delete();
    }

    /**
     * Registers a DELETE JOIN operation in Unit of Work.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function deleteJoin(string $joinTable, string $joinCondition) : static
    {
        return $this->registerForUnitOfWork(
            sql       : sprintf(
                            'DELETE %s FROM %s INNER JOIN %s ON %s %s',
                            $this->getTableName(),
                            $this->getTableName(),
                            $joinTable,
                            $joinCondition,
                            $this->buildWhereClauses()
                        ),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_DELETE_JOIN
        );
    }

    /**
     * Registers a truncate operation in Unit of Work.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function truncate() : static
    {
        return $this->registerForUnitOfWork(
            sql       : 'TRUNCATE TABLE ' . $this->getTableName(),
            parameters: [],
            operation : QueryBuilderEnum::QUERY_TYPE_TRUNCATE
        );
    }
}

=== QueryBuilder/Traits/WhereTrait.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder\Traits;

use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use InvalidArgumentException;
use PDO;

/**
 * Trait WhereTrait
 *
 * Provides fluent and expressive methods for dynamically building SQL `WHERE` clauses.
 *
 * **Key Features:**
 * âœ… Supports both simple (`where()`) and advanced (`whereIs()`) conditions.
 * âœ… Prevents SQL Injection via strict column validation & parameterized queries.
 * âœ… Implements `WHERE IN`, `WHERE JSON_CONTAINS`, `FULLTEXT SEARCH`, and date-based filtering.
 * âœ… Optimized for MySQL and PostgreSQL compatibility.
 *
 */
trait WhereTrait
{
    /**
     * Stores bound parameters for prepared statements.
     *
     * @var array<string, mixed>
     */
    private array $parameters = [];

    /**
     * Stores `WHERE` clause conditions.
     *
     * @var array<string>
     */
    private array $whereClauses = [];

    /**
     * Adds a `WHERE` condition with a default `=` operator.
     *
     * @throws \Random\RandomException
     */
    public function where(string $column, mixed $value) : static
    {
        return $this->whereIs(column: $column, operator: '=', value: $value);
    }

    /**
     * Adds a safe and sanitized WHERE condition to the query with specified comparison operator.
     *
     * This method implements a secure way to add WHERE clauses by:
     * - Validating column names against SQL injection
     * - Supporting NULL value comparisons with proper IS NULL syntax
     * - Using a allowlist of allowed SQL operators
     * - Implementing parameterized queries for values
     *
     * @param string $column   The database column name to compare (unquoted)
     * @param string $operator The comparison operator (=,=, <>, >, <, >=, <=, LIKE, NOT LIKE, IN, NOT IN)
     * @param mixed  $value    The value to compare against, null supported
     *
     * @return static Returns $this for method chaining
     * @throws \Random\RandomException   When secure parameter key generation fails
     *
     * @throws InvalidArgumentException When an invalid operator or column name is provided
     */
    public function whereIs(string $column, string $operator, mixed $value) : static
    {
        // Ensure the column name contains only alphanumeric characters and underscores for SQL injection prevention
        $this->validateColumnName(name: $column);

        // Get database-specific quoted identifier for the column name to prevent SQL injection
        $quotedColumn = $this->quoteIdentifier(name: $column);

        // Special handling for NULL comparisons to use proper SQL syntax (IS NULL, IS NOT NULL)
        if ($value === null) {
            if ($operator === '=') {
                $this->whereClauses[] = sprintf('%s IS NULL', $quotedColumn);
            } elseif ($operator === '!=') {
                $this->whereClauses[] = sprintf('%s IS NOT NULL', $quotedColumn);
            } else {
                throw new InvalidArgumentException(
                    message: "Invalid operator for NULL comparison: {$operator}"
                );
            }

            return $this;
        }

        // Define allowed SQL operators to prevent SQL injection via operator
        $supportedOperators = [
            '=',
            '!=',
            '<>',
            '>',
            '<',
            '>=',
            '<=',
            'LIKE',
            'NOT LIKE',
            'IN',
            'NOT IN',
        ];

        // Validate that only whitelisted operators are used
        if (! in_array($operator, $supportedOperators, true)) {
            throw new InvalidArgumentException(
                message: "Unsupported operator: {$operator}"
            );
        }

        // Create a unique parameter key for safe value binding
        $paramKey = $this->generateParamKey(column: $column);

        // Build and store the WHERE clause with parameterized value
        $this->whereClauses[]        = sprintf('%s %s :%s', $quotedColumn, $operator, $paramKey);
        $this->parameters[$paramKey] = $value;

        return $this;
    }

    /**
     * Generates a unique parameter key to prevent conflicts.
     *
     * @throws \Random\RandomException
     */
    private function generateParamKey(string $column) : string
    {
        return $column . '_' . bin2hex(random_bytes(4)); // âœ… Secure random key
    }

    /**
     * Adds a `WHERE IN` condition.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function whereIn(string $column, array $values) : static
    {
        if (empty($values)) {
            throw new QueryBuilderException(message: 'The `IN` clause requires a non-empty array.');
        }

        return $this->prepareInClause(column: $column, values: $values, not: false);
    }

    /**
     * Prepares a safe `IN` clause using parameterized queries.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    private function prepareInClause(string $column, array $values, bool $not) : static
    {
        $this->validateColumnName(name: $column);
        $column = $this->quoteIdentifier(name: $column);

        if (empty($values)) {
            throw new QueryBuilderException(message: "IN clause requires a non-empty array.");
        }

        $placeholders = [];
        foreach ($values as $index => $value) {
            $paramKey                    = "{$column}_{$index}";
            $placeholders[]              = ":{$paramKey}";
            $this->parameters[$paramKey] = $value;
        }

        $operator             = $not ? 'NOT IN' : 'IN';
        $this->whereClauses[] = sprintf('%s %s (%s)', $column, $operator, implode(', ', $placeholders));

        return $this;
    }

    /**
     * Adds a `WHERE NOT IN` condition.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException
     */
    public function whereNotIn(string $column, array $values) : static
    {
        return $this->prepareInClause(column: $column, values: $values, not: true);
    }

    /**
     * Adds a `WHERE IS NULL` condition.
     */
    public function whereNull(string $column) : static
    {
        $this->validateColumnName(name: $column);
        $column               = $this->quoteIdentifier(name: $column);
        $this->whereClauses[] = sprintf('%s IS NULL', $column);

        return $this;
    }

    /**
     * Adds a `WHERE IS NOT NULL` condition.
     */
    public function whereNotNull(string $column) : static
    {
        $this->validateColumnName(name: $column);
        $column               = $this->quoteIdentifier(name: $column);
        $this->whereClauses[] = sprintf('%s IS NOT NULL', $column);

        return $this;
    }

    /**
     * Adds an `OR WHERE` condition.
     *
     * @throws \Random\RandomException
     */
    public function orWhere(string $column, mixed $value) : static
    {
        return $this->orWhereIs(column: $column, operator: '=', value: $value);
    }

    /**
     * Adds an `OR WHERE` condition with a specified operator.
     *
     * @throws \Random\RandomException
     */
    public function orWhereIs(string $column, string $operator, mixed $value) : static
    {
        $this->validateColumnName(name: $column);

        $paramKey                    = $this->generateParamKey(column: $column);
        $this->whereClauses[]        = sprintf('OR %s %s :%s', $column, $operator, $paramKey);
        $this->parameters[$paramKey] = $value;

        return $this;
    }

    /**
     * Adds a `WHERE` condition that compares two columns.
     *
     */
    public function whereColumn(string $first, string $operator, string $second) : static
    {
        // Quote the identifier of the first column name to ensure it's safely encapsulated for SQL.
        // This prevents SQL injection by wrapping column names in suitable quotation marks.
        $first = $this->quoteIdentifier(name: $first);

        // Quote the identifier of the second column name, ensuring it's properly escaped for SQL.
        $second = $this->quoteIdentifier(name: $second);

        // Validate the provided operator to ensure that it's one of the acceptable SQL operators.
        // If invalid, an exception is thrown to prevent dangerous or malformed queries.
        if (! in_array($operator, ['=', '!=', '<', '>', '<=', '>='], true)) {
            throw new InvalidArgumentException(message: 'Invalid SQL operator.');
        }

        // Format and store the WHERE clause in the internal array of conditions (`whereClauses`).
        // The sprintf() is used for consistent and safe concatenation of identifiers and operators.
        $this->whereClauses[] = sprintf('%s %s %s', $first, $operator, $second);

        // Return the current object instance to facilitate method chaining (e.g., add multiple WHERE clauses).
        return $this;
    }

    /**
     * Adds an `OR WHERE` condition that compares two columns.
     */
    public function orWhereColumn(string $first, string $second, string $operator = '=') : static
    {
        $this->whereClauses[] = sprintf('OR %s %s %s', $first, $operator, $second);

        return $this;
    }

    /**
     * Adds a raw SQL expression as a WHERE clause to the query.
     *
     * @param string $sql      The raw SQL string representing the WHERE condition. It must only contain
     *                         valid characters (letters, numbers, underscores, parentheses, dots, commas,
     *                         asterisks, and spaces).
     * @param array  $bindings An associative array of parameter bindings where keys represent parameter
     *                         placeholders and values represent their corresponding values.
     *
     * @return static The current instance for method chaining.
     * @throws InvalidArgumentException If the provided SQL string contains invalid characters.
     */
    public function whereRaw(string $sql, array $bindings = []) : static
    {
        // Check if the provided SQL string contains a semicolon `;` or a double dash `--`.
        // These characters could indicate SQL injection risks or usage of raw SQL features like comments.
        if (str_contains($sql, ';') || str_contains($sql, '--')) {
            // If the string contains either of the above, throw an exception.
            // The exception message states that raw SQL must not include semicolons or comments.
            throw new InvalidArgumentException(message: 'Raw SQL must not contain semicolons or comments.');
        }

        // Adds the validated SQL string wrapped in parentheses to the `whereClauses` array.
        // The array collects raw SQL expressions for WHERE clauses.
        $this->whereClauses[] = "({$sql})";

        // Iterates over the provided bindings array (key-value pairs), where keys represent
        // parameter placeholders and values represent their corresponding values. These key-value pairs
        // are added to the `parameters` array, which stores all query parameter bindings.
        foreach ($bindings as $key => $value) {
            $this->parameters[$key] = $value;
        }

        // Returns the instance of the object to allow method chaining.
        return $this;
    }

    /**
     * Adds a `WHERE JSON_CONTAINS` condition for JSON column filtering.
     *
     * @throws \Random\RandomException
     * @throws \JsonException
     */
    public function whereJsonContains(string $column, mixed $value) : static
    {
        $this->validateColumnName(name: $column);
        $column = $this->quoteIdentifier(name: $column);

        if (! is_array($value) && ! is_object($value)) {
            throw new InvalidArgumentException(message: "Invalid JSON value. Must be array or object.");
        }

        $paramKey                    = $this->generateParamKey(column: $column);
        $this->whereClauses[]        = "JSON_CONTAINS({$column}, :{$paramKey})";
        $this->parameters[$paramKey] = json_encode($value, JSON_THROW_ON_ERROR);

        return $this;
    }

    /**
     * Adds a full-text search condition.
     */
    public function whereFullText(string $column, string $value) : static
    {
        $this->whereClauses[] = sprintf('MATCH(%s) AGAINST (?)', $column);
        $this->parameters[]   = $value;

        return $this;
    }

    /**
     * Adds a condition to filter records for today.
     */
    public function whereToday(string $column) : static
    {
        $this->whereClauses[] = sprintf('DATE(%s) = CURDATE()', $column);

        return $this;
    }

    /**
     * Adds a condition to filter past records.
     */
    public function wherePast(string $column) : static
    {
        $this->whereClauses[] = sprintf('%s < NOW()', $column);

        return $this;
    }

    /**
     * Adds a condition to filter future records.
     */
    public function whereFuture(string $column) : static
    {
        $this->whereClauses[] = sprintf('%s > NOW()', $column);

        return $this;
    }

    /**
     * Orders the query results in random order for items matching a specific condition.
     *
     * @return static Returns the current instance with a random ordering applied to the query.
     */
    public function whereInRandomOrder() : static
    {
        return $this->orderByRandom();
    }

    /**
     * Orders the results randomly.
     *
     * @return static The current query instance with a random ordering applied.
     */
    public function orderByRandom() : static
    {
        // Retrieve the PDO database connection.
        $pdo = $this->getConnection();

        // Determine the appropriate random ordering function based on the database driver.
        // Use 'RANDOM()' for PostgreSQL and 'RAND()' for other databases.
        $orderBy = ($pdo->getAttribute(attribute: PDO::ATTR_DRIVER_NAME) === 'pgsql') ? 'RANDOM()' : 'RAND()';

        // Append the random ordering clause to the list of "ORDER BY" clauses.
        $this->orderByClauses[] = $orderBy;

        // Return the current instance to enable method chaining.
        return $this;
    }

    /**
     * Builds the `WHERE` clause string.
     */
    public function buildWhereClauses() : string
    {
        return empty($this->whereClauses) ? '' : ' WHERE ' . implode(' AND ', $this->whereClauses);
    }

    /**
     * Retrieves all bound parameters.
     */
    public function getParameters() : array
    {
        return $this->parameters;
    }


    /**
     * Adds a "BETWEEN" condition to the SQL where clause for filtering results within a specified range.
     *
     * @param string $column The name of the column to apply the "BETWEEN" condition.
     * @param mixed  $start  The starting value of the range.
     * @param mixed  $end    The ending value of the range.
     * @param bool   $not    Indicates whether to negate the condition, resulting in "NOT BETWEEN".
     *
     * @return static Returns the current instance to allow method chaining.
     * @throws \Random\RandomException
     * @throws \Random\RandomException
     */
    public function whereBetween(string $column, mixed $start, mixed $end, bool $not = false) : static
    {
        // Validates that the column name contains only allowed characters (alphanumeric and underscores).
        $this->validateColumnName(name: $column);

        // Quotes the column name to safely use it in SQL queries, preventing SQL injection or reserved word conflicts.
        $column = $this->quoteIdentifier(name: $column);

        // Generates a unique parameter key for the start value of the "BETWEEN" condition.
        $paramStart = $this->generateParamKey(column: $column . '_start');

        // Generates a unique parameter key for the end value of the "BETWEEN" condition.
        $paramEnd = $this->generateParamKey(column: $column . '_end');

        // Assigns the start value to the `parameters` array using the generated key.
        $this->parameters[$paramStart] = $start;

        // Assigns the end value to the `parameters` array using the generated key.
        $this->parameters[$paramEnd] = $end;

        // Chooses the appropriate SQL operator based on the `$not` flag (either "BETWEEN" or "NOT BETWEEN").
        $operator = $not ? 'NOT BETWEEN' : 'BETWEEN';

        // Builds the SQL where clause for the "BETWEEN" condition and adds it to the list of where clauses.
        $this->whereClauses[] = sprintf('%s %s :%s AND :%s', $column, $operator, $paramStart, $paramEnd);

        // Returns the current instance to allow method chaining.
        return $this;
    }


    /**
     * Resets all `WHERE` conditions and parameters.
     */
    public function resetWhereConditions() : static
    {
        $this->whereClauses = [];
        $this->parameters   = [];

        return $this;
    }
}

=== QueryBuilder/UnitOfWork.php ===
<?php

declare(strict_types=1);

namespace Gemini\Database\QueryBuilder;

use Exception;
use Gemini\Database\DatabaseConnection;
use Gemini\Database\QueryBuilder\Enums\QueryBuilderEnum;
use Gemini\Database\QueryBuilder\Exception\QueryBuilderException;
use Gemini\DataHandling\ArrayHandling\Arrhae;
use PDO;
use PDOException;
use PDOStatement;

/**
 * **UnitOfWork**
 *
 * Implements the **Unit of Work** pattern to manage database operations within a single transaction.
 *
 * This service allows multiple **INSERT, UPDATE, DELETE, and SELECT** queries to be queued
 * and executed in a single batch transaction, improving **data consistency** and **performance**.
 *
 * ## **Key Features**
 * - ðŸ— **Batch Execution:** Defers multiple queries and executes them in a single transaction.
 * - ðŸ”„ **Atomic Transactions:** Ensures all queries succeed or the transaction rolls back.
 * - ðŸš€ **Performance Optimization:** Reduces the number of database connections per request.
 * - âœ… **Consistency:** Guarantees that queries are executed in a controlled order.
 *
 * **ðŸš€ Example Usage:**
 * ```
 * $unitOfWork->registerQuery(QueryBuilderEnum::QUERY_TYPE_INSERT, $stmt, $params);
 * $results = $unitOfWork->flush(); // Executes all registered queries in a transaction
 * ```
 *
 * @package Gemini\Database\QueryBuilder
 */
class UnitOfWork
{
    /**
     * Stores all queries scheduled for deferred execution.
     *
     * @var array<int, array{operation: QueryBuilderEnum, statement: PDOStatement, parameters: array}>
     */
    private array $unitOfWorkQueue = [];

    /**
     * UnitOfWork constructor.
     *
     * @param DatabaseConnection $databaseConnection The database connection manager.
     */
    public function __construct(private readonly DatabaseConnection $databaseConnection) {}

    /**
     * Registers a database query for deferred execution.
     *
     * Queries added here will be executed when `flush()` is called.
     *
     * @param QueryBuilderEnum $operation  The type of database operation (INSERT, UPDATE, DELETE, SELECT).
     * @param PDOStatement     $statement  The prepared PDO statement.
     * @param array            $parameters Optional parameters for the query.
     *
     * @throws QueryBuilderException If the query string is empty.
     */
    public function registerQuery(
        QueryBuilderEnum $operation,
        PDOStatement     $statement,
        PDO              $pdo,
        array            $parameters = [],
    ) : void {
        if (empty(trim($statement->queryString))) {
            throw new QueryBuilderException(message: "Cannot register an empty query in Unit of Work.");
        }

        $this->unitOfWorkQueue[] = compact('operation', 'statement', 'pdo', 'parameters');
    }

    /**
     * Executes all registered queries within a **single database transaction**.
     *
     * If an error occurs, all changes are rolled back to maintain **data consistency**.
     *
     * @return Arrhae Collection of query execution results.
     *
     * @throws QueryBuilderException If the transaction fails.
     */
    public function flush() : Arrhae
    {
        if (empty($this->unitOfWorkQueue)) {
            return new Arrhae(items: []);
        }

        $pdo = $this->databaseConnection->getConnection();
        $pdo->beginTransaction();
        $results = [];

        try {
            foreach ($this->unitOfWorkQueue as $query) {
                $results[] = $this->executeQuery(unitOfWork: $query);
            }
            $pdo->commit();
        } catch (PDOException|Exception $exception) {
            $pdo->rollBack();
            $this->unitOfWorkQueue = [];
            throw new QueryBuilderException(message: "Transaction failed in UnitOfWork: " . $exception->getMessage());
        }

        // Clear queue after successful execution.
        $this->unitOfWorkQueue = [];

        // Flatten the result structure if only a single query was executed.
        // This improves downstream readability and avoids unnecessary array nesting.
        if (count($results) === 1) {
            return new Arrhae(items: $results[0]);
        }

        // For multiple queries, wrap results under a 'batch' key to preserve structure.
        // Consumers can detect batch mode via Arrhae::isBatch().
        return new Arrhae(items: ['batch' => $results]);
    }

    /**
     * Executes a single query from the Unit of Work queue.
     *
     * If the query is an INSERT, returns both the affected rows and the last insert ID.
     *
     * @param array{operation: QueryBuilderEnum, statement: PDOStatement, pdo: PDO, parameters: array} $unitOfWork
     *     The queued query operation details.
     *
     * @return array Structured result containing affected_rows and optionally lastInsertId.
     *
     * @throws \Gemini\Database\QueryBuilder\Exception\QueryBuilderException When the execution of the query fails.
     */
    private function executeQuery(array $unitOfWork) : array
    {
        $statement  = $unitOfWork['statement'];
        $parameters = $unitOfWork['parameters'] ?? [];
        $operation  = $unitOfWork['operation'];
        $pdo        = $unitOfWork['pdo'];

        try {
            $statement->execute($parameters);

            $result = ['affected_rows' => $statement->rowCount()];

            if ($operation === QueryBuilderEnum::QUERY_TYPE_INSERT) {
                $result['lastInsertId'] = (int) $pdo->lastInsertId();
            }

            return $result;
        } catch (PDOException $exception) {
            throw new QueryBuilderException(
                message: "Error executing query: " . $exception->getMessage(), code: 0, previous: $exception
            );
        }
    }

}

