=== Foundation/Config/Config.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Config;

/**
 * The "Settings Book" for your database system.
 *
 * -- what is it?
 * This is a central place where we keep all the "fine-tuning" parameters for 
 * your database, like hostnames, usernames, passwords, and custom feature flags.
 *
 * -- how to imagine it:
 * Think of an "Address Book" or a "Contact List". Instead of hardcoding 
 * details all over your application, you put them here. You can look up 
 * settings by a simple name or a "Path" (e.g., 'database.mysql.host').
 *
 * -- why this exists:
 * To keep things organized and flexible. If your database server changes, 
 * you only need to change it in one place (the config), not in 50 different 
 * source code files. It also supports "Dot-Notation", which lets you 
 * organize settings into groups and subgroups easily.
 *
 * -- mental models:
 * - "In-Memory Storage": This book only exists while the computer is 
 *    running the request. It doesn't save back to a physical file automatically.
 *
 * -- what "dot-notation" means:
 * It's a "Address System" for complex data. Instead of just having a flat 
 * list of keys, we can have groups. To reach a setting inside a group, 
 * you use a dot (.). For example, `connections.mysql.host` is like 
 * saying: "Go to the 'connections' group, then find the 'mysql' subgroup, 
 * and finally tell me the 'host'." It keeps hundreds of settings neat and 
 * organized.
 */
final class Config
{
    /** @var array<string, mixed> The actual list of settings stored in memory. */
    private array $items = [];

    /**
     * Start the Settings Book with an initial list of items.
     *
     * @param array<string, mixed> $items The starting dictionary of settings.
     */
    public function __construct(array $items = [])
    {
        $this->items = $items;
    }

    /**
     * Look up a setting by its name or path.
     *
     * -- how to use paths:
     * You can use dots to reach deep into groups. For example:
     * `get('connections.mysql.host')`
     *
     * @param string $key     The name of the setting or the path to it.
     * @param mixed  $default If we can't find the setting, what should we give back instead?
     * @return mixed The setting value we found, or the default fallback.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        if (array_key_exists(key: $key, array: $this->items)) {
            return $this->items[$key];
        }

        if (! str_contains(haystack: $key, needle: '.')) {
            return $default;
        }

        $array = $this->items;
        foreach (explode(separator: '.', string: $key) as $segment) {
            if (is_array(value: $array) && array_key_exists(key: $segment, array: $array)) {
                $array = $array[$segment];
            } else {
                return $default;
            }
        }

        return $array;
    }

    /**
     * Add or change a setting during runtime.
     *
     * @param string $key   The name of the setting.
     * @param mixed  $value The new information to store.
     */
    public function set(string $key, mixed $value): void
    {
        $this->items[$key] = $value;
    }

    /**
     * Get the entire dictionary of all settings at once.
     *
     * @return array<string, mixed> The raw list of everything inside.
     */
    public function all(): array
    {
        return $this->items;
    }
}

=== Foundation/Connection/ConnectionFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\Exceptions\ConnectionFailure;
use Avax\Database\Connection\ValueObjects\ConnectionConfig;
use Avax\Database\Connection\ValueObjects\Dsn;
use PDO;
use Throwable;

/**
 * The "Connection Workshop" for building database links.
 *
 * -- what is it?
 * This is a specialized factory. Like a workshop that assembles a car 
 * from various parts (wheels, engine, frame), this factory assembles a 
 * working "Connection" from configuration settings.
 *
 * -- how to imagine it:
 * Think of it as an "Automated Switchboard Operator". You give it the 
 * phone number (DSN) and credentials (username/password), and it 
 * establishes the call. If the line is dead, it tells you exactly what 
 * went wrong.
 *
 * -- why this exists:
 * 1. Standardization: It ensures every database connection is set up with 
 *    the same security settings and defaults (like "Always report errors").
 * 2. Complexity Hiding: Creating a connection involves generating a complex 
 *    string called a "DSN". This factory hides all that messy work from you.
 * 3. Error Translation: Instead of getting cryptical system errors, you 
 *    get a clear "ConnectionFailure" that identifies which specific 
 *    connection broke.
 *
 * -- mental models:
 * - "DSN" (Data Source Name): The full "Technical Address" of your database.
 * - "PDO": The actual underlying engine that talks to MySQL/Postgres.
 * - "Wrapped Connection": We don't just give you a raw PDO tool; we give 
 *    you a tool that fits perfectly into our system's rules.
 */
final readonly class ConnectionFactory
{
    /**
     * Build and verify a database connection using a raw set of settings.
     *
     * @param array{
     *     driver?: string,
     *     host?: string,
     *     database?: string,
     *     username?: string,
     *     password?: string,
     *     charset?: string,
     *     name?: string
     * } $config The raw dictionary of details for the connection.
     * @return DatabaseConnection A fully established and ready-to-use connection tool.
     * @throws ConnectionFailure If the details are wrong or the database server is unreachable.
     */
    public static function from(array $config): DatabaseConnection
    {
        // First, we convert the raw array into a structured "ConnectionConfig" object.
        // This makes sure we didn't forget any important details like the host or username.
        $config = ConnectionConfig::from(config: $config);

        // Next, we calculate the "DSN" — the technical address the computer uses to call the DB.
        $dsn = Dsn::for(
            driver: $config->driver,
            host: $config->host,
            database: $config->database,
            charset: $config->charset
        );

        try {
            // We attempt to open the actual communication line.
            // We force several security/reliability rules here (like ERRMODE_EXCEPTION).
            $pdo = new PDO(
                dsn: $dsn->toString(),
                username: $config->username,
                password: $config->password,
                options: [
                    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                    PDO::ATTR_EMULATE_PREPARES   => false,
                ],
            );

            // Once established, we put it inside our own "PdoConnection" wrapper.
            return new PdoConnection(
                name: $config->name,
                pdo: $pdo,
            );
        } catch (Throwable $e) {
            // If anything goes wrong during construction, we wrap the error 
            // so we know exactly which connection name failed.
            throw new ConnectionFailure(
                name: $config->name,
                message: sprintf(
                    'Database connection [%s] failed: %s',
                    $config->name,
                    $e->getMessage()
                ),
                previous: $e
            );
        }
    }
}

=== Foundation/Connection/ConnectionManager.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\Exceptions\ConnectionException;
use Avax\Database\Connection\Exceptions\ConnectionFailure;
use Avax\Database\Events\EventBus;
use Avax\Database\Avax\Connection\Pool\ConnectionPool;
use Avax\Database\Avax\Connection\Pool\PooledConnectionAuthority;
use Avax\Database\Support\ExecutionScope;
use PDO;
use Throwable;

/**
 * The "Switchboard Operator" for all database connections.
 *
 * -- what is it?
 * This is the central manager that keeps track of every database connection 
 * in your application. Instead of creating connections manually everywhere, 
 * you ask the Manager to give you one by its name (like 'primary' or 'logs').
 *
 * -- how to imagine it:
 * Think of an old-fashioned telephone switchboard. You (the developer) say 
 * "Connect me to the Users database," and the Manager pulls the right cables, 
 * establishes the call, and hands you the receiver. It also remembers if 
 * you've already called that database so it doesn't waste time reconnecting.
 *
 * -- why this exists:
 * 1. Centralization: You have one place to manage all connections, whether 
 *    they are direct links or "Shared Pools".
 * 2. Efficiency: It caches connections. If you ask for the 'primary' 
 *    connection twice, it gives you the same object back the second time.
 * 3. Lifecycle Management: It coordinates with "Execution Scopes" to make 
 *    sure every query carries its "Trace ID" (luggage tag) for easy debugging.
 *
 * -- mental models:
 * - "Caching": Remembering a connection so we don't buy a new one every time.
 * - "Pool": A shared collection of connections that many parts of the app 
 *    can borrow from and return to.
 */
final class ConnectionManager
{
    /** @var array<string, DatabaseConnection> A memory bank for connections we've already opened. */
    private array $connections = [];

    /** @var array<string, ConnectionPool> A memory bank for "Shared Library" (Pool) setups. */
    private array $pools = [];

    /**
     * @param array<string, mixed> $config   The master Settings Book containing details for all connections.
     * @param EventBus|null        $eventBus The "Notification System" for reporting when connections open or fail.
     * @param ExecutionScope|null  $scope    The "Passenger Ticket" that links this manager to a specific request.
     */
    public function __construct(
        private readonly array      $config,
        private readonly ?EventBus  $eventBus = null,
        private ExecutionScope|null $scope = null
    ) {
        $this->scope ??= ExecutionScope::fresh();
    }

    /**
     * Run a task using a "Borrowed" connection from a shared collection (Pool).
     *
     * -- what "pool" means in this context:
     * It's a "Safe-Usage Wrapper". Instead of managing the connection 
     * yourself, you give the manager a task (the callback). The manager 
     * will go to the pool, borrow a connection, let you use it, and 
     * then put it back.
     *
     * -- when it happens:
     * The borrowing happens the second the method is called. The 
     * return (release) happens as soon as your callback finishes 
     * or if it crashes.
     *
     * -- common pitfall:
     * This only applies to the code INSIDE the callback. If you 
     * have other database code outside this 'pool()' block, it 
     * won't benefit from the automatic borrowing and returning.
     *
     * @param callable    $callback The code block you want to run.
     * @param string|null $name     The nickname of the connection to use.
     * @return mixed Whatever your code block returns.
     */
    public function pool(callable $callback, string|null $name = null): mixed
    {
        $connection = $this->flow()->usePool();
        if ($name) {
            $connection->on(name: $name);
        }

        return $connection->run(callback: $callback);
    }

    /**
     * Start a "Setup Wizard" (Fluent Flow) for a connection.
     *
     * -- what "flow" means in this context:
     * It's a configuration journey. Instead of passing 10 arguments 
     * to a single method, you "chain" simple commands together to 
     * tell the manager exactly what you want.
     *
     * -- when it happens:
     * The wizard starts immediately, but the database IS NOT 
     * contacted until you reach the very end of the chain 
     * (usually by calling 'connect()' or 'run()').
     *
     * -- common pitfall:
     * Don't forget to "finish" the flow! If you just call 
     * '$manager->flow()->usePool()', nothing actually happens. 
     * You must trigger an action method at the end of the chain.
     *
     * @return DatabaseFlow A helper object to help you build your connection request step-by-step.
     */
    public function flow(): DatabaseFlow
    {
        return new DatabaseFlow(manager: $this);
    }

    /**
     * Get the raw technical tool (PDO) for a specific database.
     *
     * @param string|null $name The nickname (e.g., 'primary').
     * @return PDO The raw technical engine.
     */
    public function getPdo(string|null $name = null): PDO
    {
        return $this->connection(name: $name)->getConnection();
    }

    /**
     * Get a connection tool by its nickname (Connection).
     *
     * -- what "connection" means in this context:
     * It's a "Persistence Gateway". It could be a direct line to 
     * the database, or an "Authority" that manages a shared pool. 
     * All you need to know is that you can use it to run queries.
     *
     * -- when it happens:
     * If the connection is already open, it is returned instantly 
     * (cached). If not, the hardware link is established now.
     *
     * -- common pitfall:
     * Don't assume this is a raw PDO object! In most cases, it 
     * is a wrapper that adds features like events and logging. 
     * If you REALLY need PDO, call 'getPdo()' instead.
     *
     * @param string|null $name The nickname of the connection. Use null for the default one.
     * @return DatabaseConnection The ready-to-use connection tool.
     */
    public function connection(string|null $name = null): DatabaseConnection
    {
        $name = $name ?: $this->getDefaultConnection();

        if (isset($this->connections[$name])) {
            return $this->connections[$name];
        }

        $connection = $this->makeConnection(name: $name);

        // We don't cache pooled authorities here because they handle their own 
        // internal caching/lazy-loading logic via the Pool.
        if ($connection instanceof PooledConnectionAuthority) {
            return $connection;
        }

        $this->connections[$name] = $connection;

        return $connection;
    }

    /**
     * Find out which connection is set as the "Main" one.
     */
    private function getDefaultConnection(): string
    {
        return $this->config['default'] ?? 'mysql';
    }

    /**
     * The internal logic for building a connection from scratch.
     */
    private function makeConnection(string $name): DatabaseConnection
    {
        $config = $this->config['connections'][$name] ?? null;

        if ($config === null) {
            throw new ConnectionException(name: $name, message: "Database connection configuration not found.");
        }

        $config['name'] = $name;

        // If the settings include a 'pool' section, we create a shared library pool.
        if (isset($config['pool'])) {
            if (! isset($this->pools[$name])) {
                $this->pools[$name] = new ConnectionPool(
                    config: $config,
                    eventBus: $this->eventBus
                );
            }

            $pool = $this->pools[$name];
            if ($this->scope) {
                $pool->withScope(scope: $this->scope);
            }

            return new PooledConnectionAuthority(pool: $pool);
        }

        // Otherwise, we just open a direct, private line to the database.
        $flow = DirectConnectionFlow::begin()->using(config: $config);

        if ($this->eventBus) {
            $flow->withEvents(eventBus: $this->eventBus);
        }

        if ($this->scope) {
            $flow->withScope(scope: $this->scope);
        }

        return $flow->connect();
    }

    /**
     * Create a copy of the manager with a specific "Context Label" (Scope).
     *
     * -- what "withScope" means in this context:
     * It's a "Configuration Fork". You are creating a twin 
     * manager that is identical in every way, except it uses 
     * a different "Luggage Tag" (Trace ID) for its logs.
     *
     * -- when it happens:
     * The effect is immediate on the RETURNED manager instance.
     *
     * -- common pitfall:
     * This method does NOT change the scope of the manager you 
     * currently have in your variable! You must save the new 
     * instance:
     * ❌ $mgr->withScope($newScope);
     * ✅ $debugMgr = $mgr->withScope($newScope);
     *
     * @param ExecutionScope $scope The Trace ID context for the new manager.
     */
    public function withScope(ExecutionScope $scope): self
    {
        $clone        = clone $this;
        $clone->scope = $scope;

        return $clone;
    }
}

=== Foundation/Connection/Contracts/DatabaseConnection.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Contracts;

use PDO;

/**
 * The "Rulebook" for any database connection.
 *
 * -- what is it?
 * This is an Interface (a contract). It doesn't perform any real work 
 * itself, but it lists the rules and methods that ANY database connection 
 * must follow to be allowed into our system.
 *
 * -- how to imagine it:
 * Think of it as a "Job Description". It says "If you want to be a 
 * Connection, you must be able to: 
 * 1. Let us use your tools (PDO).
 * 2. Tell us if you're still alive (Ping).
 * 3. Tell us your name."
 *
 * -- why this exists:
 * So that the rest of the application doesn't need to care if it's talking 
 * to a MySQL connection, a Postgres connection, or a "Shared Pool" connection. 
 * As long as they all follow this same rulebook, the application can treat 
 * them exactly the same.
 *
 * -- mental models:
 * - "Contract": A promise that these specific methods will always exist.
 * - "PDO": The actual underlying engine (hammer and nails) used to work 
 *    with bytes and rows.
 */
interface DatabaseConnection
{
    /**
     * Get the actual technical tool (PDO) used to run the queries.
     *
     * @return PDO The active, ready-to-work database engine.
     */
    public function getConnection(): PDO;

    /**
     * Check if the database is still "awake" and responsive.
     *
     * -- how it works:
     * We send a tiny "Heartbeat" signal. If the database replies, we 
     * know the connection is healthy. If not, the line is dead.
     *
     * @return bool True if the database is alive, false otherwise.
     */
    public function ping(): bool;

    /**
     * Get the nickname of this specific connection.
     *
     * -- why this exists:
     * Useful for logging. For example: "Error in connection [primary]" 
     * is much more helpful than just "Error in connection".
     *
     * @return string The technical label (name) of the connection.
     */
    public function getName(): string;
}

=== Foundation/Connection/DatabaseFlow.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Avax\Connection\Pool\Contracts\ConnectionPoolInterface;
use Throwable;

/**
 * The "One-Off Request" Helper.
 *
 * -- what is it?
 * This is a "Fluent Flow". It's a helper class that lets you say exactly 
 * what you want to do with a database connection in a single, readable line 
 * of code (e.g., "On the 'users' database, use a pooled connection, and 
 * run this task").
 *
 * -- how to imagine it:
 * Think of it as a "Valet Service". Instead of you parking the car yourself 
 * (managing the connection), you just give the keys and instructions to 
 * the Valet, and they handle the parking, the task, and returning the keys 
 * to the right place.
 *
 * -- why this exists:
 * 1. Readability: It makes the code look more like English: 
 *    `$flow->on('primary')->usePool()->run(...)`.
 * 2. Resource Safety: It uses a `try-finally` block behind the scenes. This 
 *    is a technical guarantee that even if your task crashes the program, 
 *    the "Valet" will still return the database connection to the shared pool.
 * 3. Configuration: It lets you tweak how a connection is handled on the fly 
 *    without changing global settings.
 *
 * -- mental models:
 * - "Fluent": A style of coding where methods return the object itself so 
 *    you can "chain" them together.
 * - "Finally Block": A "No matter what" rule. It runs even if an error happens.
 */
final class DatabaseFlow
{
    /** @var string|null The nickname of the database we want to talk to. */
    private string|null $connectionName = null;

    /** @var bool If true, we will borrow a connection from a shared collection. */
    private bool $pooled = false;

    /**
     * @param ConnectionManager $manager The "Switchboard Operator" who actually holds the cables.
     */
    public function __construct(private readonly ConnectionManager $manager) {}

    /**
     * Choose which database connection to use.
     *
     * @param string $name The nickname (e.g., 'secondary', 'archive').
     * @return self The helper object itself, so you can keep adding instructions.
     */
    public function on(string $name): self
    {
        $this->connectionName = $name;

        return $this;
    }

    /**
     * Tell the helper to use a "Shared Pool" for this task.
     *
     * -- how to imagine it:
     * Instead of opening a new private line, you are borrowing a shared line 
     * from the library. This is usually much faster.
     */
    public function usePool(): self
    {
        $this->pooled = true;

        return $this;
    }

    /**
     * Actually do the work (Go time!).
     *
     * -- how it works:
     * 1. The Valet gets the connection for you.
     * 2. The Valet runs your code.
     * 3. The Valet ensures the connection is returned safely, even if an 
     *    error occurred during your code.
     *
     * @param callable(DatabaseConnection): mixed $callback The code you want to run.
     * @return mixed Whatever your code block returns.
     */
    public function run(callable $callback): mixed
    {
        $connection = $this->manager->connection(name: $this->connectionName);

        // If we requested a pool and the connection supports it...
        if ($this->pooled && $connection instanceof ConnectionPoolInterface) {
            $instance = $connection->acquire();
            try {
                return $callback($instance);
            } finally {
                // This is the "No matter what" cleanup rule.
                $connection->release(connection: $instance);
            }
        }

        // Otherwise, just run the code with the standard connection.
        return $callback($connection);
    }
}

=== Foundation/Connection/DirectConnectionFlow.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Events\ConnectionFailed;
use Avax\Database\Events\ConnectionOpened;
use Avax\Database\Events\EventBus;
use Avax\Database\Support\ExecutionScope;
use Throwable;

/**
 * The "Private Line" Setup Helper.
 *
 * -- what is it?
 * This is a helper used to establish a direct, private connection to a database. 
 * While `ConnectionPool` is for shared connections, this class is for when 
 * you want a dedicated line just for yourself.
 *
 * -- how to imagine it:
 * Think of an "Installation Wizard". It asks you "What's the address?", 
 * "What are the keys?", "Should I tell anyone when I'm finished (Events)?", 
 * and then it finally presses the "Connect" button for you.
 *
 * -- why this exists:
 * 1. Step-by-Step Setup: It makes the complex process of opening a database 
 *    connection readable and clean.
 * 2. Automated Logging: If you provide an `EventBus` (Notification System), 
 *    this helper will automatically scream "Success!" or "Help, it failed!" 
 *    so your logs stay up to date.
 * 3. Tracing: It ensures that the very moment a connection is born, it 
 *    gets its "Luggage Tag" (Execution Scope) for debugging.
 *
 * -- mental models:
 * - "Direct": Not shared. You own this specific line.
 * - "Connect": The final step that actually plugs the cable in.
 */
final class DirectConnectionFlow
{
    /** @var array<string, mixed> The list of server addresses, usernames, and passwords. */
    private array $config = [];

    /** @var EventBus|null The system we use to send "I'm connected" or "I failed" messages. */
    private array|null $eventBus = null;

    /** @var ExecutionScope|null The "Passenger Ticket" used to tag this connection for logs. */
    private ExecutionScope|null $scope = null;

    /**
     * Private constructor — use `DirectConnectionFlow::begin()` to start.
     */
    private function __construct() {}

    /**
     * Start the setup wizard for a new database connection.
     *
     * @return self A fresh helper object ready for instructions.
     */
    public static function begin(): self
    {
        return new self();
    }

    /**
     * Give the helper the settings it needs (Host, Driver, etc.).
     *
     * @param array<string, mixed> $config The settings dictionary.
     * @return self The helper itself, so you can keep adding instructions.
     */
    public function using(array $config): self
    {
        $this->config = $config;

        return $this;
    }

    /**
     * Tell the helper where to send "Connected" or "Failed" notifications.
     */
    public function withEvents(EventBus $eventBus): self
    {
        $this->eventBus = $eventBus;

        return $this;
    }

    /**
     * Give the connection a "Luggage Tag" (Scope) so we can trace its work.
     */
    public function withScope(ExecutionScope $scope): self
    {
        $this->scope = $scope;

        return $this;
    }

    /**
     * Plug the cable in and establish the actual connection.
     *
     * -- how it works:
     * 1. It calls the `ConnectionFactory` to do the heavy lifting.
     * 2. If it works, it sends an "Opened" message.
     * 3. If it fails, it sends a "Failed" message and then throws the error.
     *
     * @return DatabaseConnection The ready-to-use database tool.
     * @throws Throwable If the server is down or the settings are wrong.
     */
    public function connect(): DatabaseConnection
    {
        $label = $this->config['name'] ?? 'default';
        $scope = $this->scope ?? ExecutionScope::fresh();

        try {
            $connection = ConnectionFactory::from(config: $this->config);
            // Signal to the system that the line is open.
            $this->eventBus?->dispatch(event: new ConnectionOpened(
                connectionName: $label,
                correlationId: $scope->correlationId
            ));

            return $connection;
        } catch (Throwable $e) {
            // Signal to the system that we had an error.
            $this->eventBus?->dispatch(event: new ConnectionFailed(
                connectionName: $label,
                exception: $e,
                correlationId: $scope->correlationId
            ));

            throw $e;
        }
    }
}

=== Foundation/Connection/Exceptions/ConnectionException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * A "Connection Error" report.
 *
 * -- what is it?
 * This is a specialized error (Exception). It's what the system "screams" 
 * when it tries to talk to a database but something goes wrong with 
 * the line itself (e.g., wrong password, server is offline).
 *
 * -- how to imagine it:
 * Think of it as a "Service Ticket". It's not just a generic "Something 
 * broke" message; it's a specific report that says "I tried to call the 
 * 'Primary' database, but the line was busy/dead."
 *
 * -- why this exists:
 * To make debugging easier. Instead of just seeing a raw computer error, 
 * this object carries the "Nickname" of the connection that failed, so 
 * you know exactly which server to check.
 *
 * -- mental models:
 * - "Immutable": Once this error is created, you can't change its details. 
 *    It's a permanent record of what happened at that moment.
 */
class ConnectionException extends DatabaseException
{
    /**
     * @param string         $name     The nickname of the database connection that failed.
     * @param string         $message  The human-readable description of what went wrong.
     * @param Throwable|null $previous The raw system error that triggered this report.
     */
    #[Override]
    public function __construct(
        private readonly string $name,
        string                  $message,
        Throwable|null          $previous = null
    ) {
        parent::__construct(message: "Connection [{$name}] failed: {$message}", code: 0, previous: $previous);
    }

    /**
     * Get the nickname of the failing database.
     *
     * @return string The nickname (e.g., 'primary').
     */
    public function getConnectionName(): string
    {
        return $this->name;
    }
}

=== Foundation/Connection/Exceptions/ConnectionFailure.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Throwable;

/**
 * A "Total Connection Failure" report.
 *
 * -- what is it?
 * This is a "Fatal" error. It's more serious than a generic connection 
 * error. It means the database server is completely unreachable or it flat-out 
 * rejected our attempt to talk to it.
 *
 * -- how to imagine it:
 * Think of trying to visit a store and finding the building has burned down 
 * or the doors are welded shut. It's not just a "wrong key" issue; it's a 
 * "the destination doesn't exist or is offline" issue.
 *
 * -- why this exists:
 * To trigger immediate recovery logic. When the system sees this specific 
 * error, it knows there's no point in "trying again" immediately—it might 
 * need to switch to a backup server or show a "Maintenance" page.
 *
 * -- mental models:
 * - "Fatal": The line is permanently dead or blocked.
 * - "Unreachable": We couldn't even find the server on the network.
 */
class ConnectionFailure extends DatabaseException
{
    /**
     * @param string         $name     The nickname of the connection that failed.
     * @param string         $message  The detailed explanation of the failure.
     * @param Throwable|null $previous The raw technical error from the network or driver.
     */
    public function __construct(
        public readonly string $name,
        string                 $message = "",
        ?Throwable             $previous = null
    ) {
        parent::__construct(message: $message, code: 0, previous: $previous);
    }
}

=== Foundation/Connection/Exceptions/PoolLimitReachedException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;

/**
 * A "No More Room" report for a connection pool.
 *
 * -- what is it?
 * This error means the "Shared Library" (Pool) is out of books (Connections). 
 * Every single connection is currently being used by someone else, and we've 
 * hit the maximum limit you set in the config.
 *
 * -- how to imagine it:
 * Think of a restaurant with only 10 tables. If all 10 tables are full and 
 * an 11th customer arrives, the host has to say "Sorry, we're at capacity." 
 * This error is that "Sorry" message.
 *
 * -- why this exists:
 * To prevent the server from exploding. If we kept opening new connections 
 * forever, the database server would eventually crash from of all the open 
 * socket lines. This error provides "Backpressure"—it tells the app to 
 * slow down or wait until a connection is returned.
 *
 * -- mental models:
 * - "Saturation": The pool is 100% full.
 * - "Backpressure": Forcing the application to wait or fail early rather 
 *    than overwhelming the database.
 */
final class PoolLimitReachedException extends DatabaseException
{
    /**
     * @param string $name  The nickname of the pool that is full.
     * @param int    $limit The maximum number of people allowed in at once.
     */
    #[Override]
    public function __construct(
        private readonly string $name,
        private readonly int    $limit
    ) {
        parent::__construct(message: "Connection pool [{$name}] reached its limit of {$limit} connections.");
    }

    /**
     * Get the nickname of the overcrowded pool.
     */
    public function getPoolName(): string
    {
        return $this->name;
    }

    /**
     * Get the maximum capacity of the pool.
     */
    public function getLimit(): int
    {
        return $this->limit;
    }
}

=== Foundation/Connection/PdoConnection.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use PDO;
use Throwable;

/**
 * The Standard "Telephone Line" (PDO Connection).
 *
 * -- what is it?
 * This is the actual implementation of a database connection using PHP's 
 * built-in "PDO" engine. It's the most common way to talk to databases 
 * in PHP.
 *
 * -- how to imagine it:
 * Think of it as the "Physical Handset" of a phone. You've already done 
 * the work to open the line; this object is the thing you hold to 
 * actually speak (send SQL) and listen (get results).
 *
 * -- why this exists:
 * To provide a consistent "Wrapper" around the messy details of standard 
 * PHP drivers. It carries a nickname (so we know which DB we're using) 
 * and a "Ping" feature to make sure the line hasn't gone dead while 
 * we weren't looking.
 *
 * -- mental models:
 * - "PDO" (PHP Data Objects): The lower-level engine provided by PHP 
 *    that handles the actual network bytes.
 * - "Wrapper": We don't just use PDO directly; we put it in this class 
 *    to make sure it behaves exactly how our system expects.
 */
final readonly class PdoConnection implements DatabaseConnection
{
    /**
     * @param string $name The nickname for this connection (e.g., 'primary').
     * @param PDO    $pdo  The active technical engine already plugged into the DB.
     */
    public function __construct(private string $name, private PDO $pdo) {}

    /**
     * Get the actual technical engine (PDO) to run your SQL.
     */
    public function getConnection(): PDO
    {
        return $this->pdo;
    }

    /**
     * Send a "Heartbeat" (Ping) to make sure the database is alive.
     *
     * -- how it works:
     * We try to run a very tiny query (`SELECT 1`). If the database 
     * is still there and working, it will say "1" and we return true. 
     * If there's a timeout or an error, we return false.
     */
    public function ping(): bool
    {
        try {
            $this->pdo->query(query: "SELECT 1");

            return true;
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Get the nickname assigned to this connection.
     */
    public function getName(): string
    {
        return $this->name;
    }
}

=== Foundation/Connection/Pool/BorrowedConnection.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Avax\Connection\Pool\Contracts\ConnectionPoolInterface;
use Avax\Database\Avax\Connection\Pool\Exceptions\ConnectionException;
use PDO;

/**
 * A "Library Card" for a database connection.
 *
 * -- what is it?
 * You don't own this database connection; you are temporarily "borrowing" 
 * it from a shared pool (the library).
 *
 * -- how to imagine it:
 * Think of it as a physical key to a room. As long as you are holding the 
 * key, the room is yours. But when you are done, you MUST return the key 
 * so the next person can use the room.
 *
 * -- why this exists:
 * To prevent "leaks". If a developer forgets to manually return a 
 * connection, this object will automatically "hand it back" to the 
 * library as soon as the code execution leaves the current function 
 * (this is called the RAII pattern).
 *
 * -- misuse warning:
 * Do NOT store this object as a permanent property in a long-lived class. 
 * If you keep it, the connection stays blocked, and eventually, the 
 * "library" will run out of connections for everyone else.
 *
 * -- what "RAII" means:
 * It's a fancy way of saying "Cleaning up after yourself automatically". 
 * In this class, we "Acquire" the connection when the object is created, 
 * and we "Release" it automatically when the object is destroyed (deleted 
 * from memory). This means you don't have to remember to close the 
 * connection—the program does it for you.
 */
final class BorrowedConnection implements DatabaseConnection
{
    /** @var bool A flag to make sure we don't try to return the connection twice. */
    private bool $released = false;

    /**
     * @param DatabaseConnection      $connection The actual, physical connection to the database.
     * @param ConnectionPoolInterface $pool       The "Library Manager" that knows how to put this connection back on the shelf.
     */
    public function __construct(
        private readonly DatabaseConnection      $connection,
        private readonly ConnectionPoolInterface $pool
    ) {}

    /**
     * Get the underlying PDO tool to run your queries.
     *
     * @return PDO The active technical tool for the database.
     * @throws ConnectionException If the connection was lost or closed unexpectedly.
     */
    public function getConnection(): PDO
    {
        return $this->connection->getConnection();
    }

    /**
     * Check if the database is still alive and talking to us.
     *
     * @return bool True if it responds, false if the line is dead.
     */
    public function ping(): bool
    {
        return $this->connection->ping();
    }

    /**
     * Get the technical nickname of this connection (e.g., 'primary', 'read-only').
     */
    public function getName(): string
    {
        return $this->connection->getName();
    }

    /**
     * The Automatic Cleanup (Destructor).
     *
     * -- how it works:
     * When PHP is done with this object (e.g., the function ends), it 
     * automatically calls this method. We use this last chance to 
     * return the connection to the pool so it isn't wasted.
     */
    public function __destruct()
    {
        $this->release();
    }

    /**
     * Manually return the connection early.
     *
     * -- why this exists:
     * If you are done with your work early, you can return the connection 
     * immediately instead of waiting for the object to be destroyed.
     */
    public function release(): void
    {
        if (! $this->released) {
            $this->pool->release(connection: $this);
            $this->released = true;
        }
    }

    /**
     * Internal tool for the pool manager to see the "Raw" connection.
     *
     * @return DatabaseConnection The physical connection instance without the wrapper.
     * @internal You should never need to call this in your application code.
     */
    public function getOriginalConnection(): DatabaseConnection
    {
        return $this->connection;
    }
}

=== Foundation/Connection/Pool/ConnectionPool.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Connection\DirectConnectionFlow;
use Avax\Database\Connection\Exceptions\PoolLimitReachedException;
use Avax\Database\Events\ConnectionAcquired;
use Avax\Database\Events\EventBus;
use Avax\Database\Avax\Connection\Pool\Contracts\ConnectionPoolInterface;
use Avax\Database\Avax\Connection\Pool\DTO\ConnectionPoolMetrics;
use Avax\Database\Support\ExecutionScope;
use SplQueue;
use Throwable;

/**
 * The "Shared Library" (Connection Pool) for efficient database access.
 *
 * -- what is it?
 * This is a manager that maintains a "Pool" of active database connections. 
 * Instead of creating a new connection every time you want to save a row 
 * (which is very slow), you "borrow" one from the pool and return it 
 * immediately when you're done.
 *
 * -- how to imagine it:
 * Think of a "Shared Car Service". Instead of every person in a large building 
 * buying their own car (opening their own connection), there are 10 cars 
 * parked in the basement. You take a car, do your grocery shopping, and 
 * park it back for the next person.
 *
 * -- why this exists:
 * 1. Speed: Opening a new database connection involves a lot of hidden 
 *    "handshakes" between computers. Keeping a pool of already-open 
 *    connections saves several milliseconds on every request.
 * 2. Resource Protection: Most database servers have a hard limit on how many 
 *    people can talk to them at once (e.g., 100). If you have 500 users 
 *    visiting your site, you can't open 500 connections. The pool ensures 
 *    only a few "Keys" are circulating at once.
 *
 * -- mental models:
 * - "Idle Pool": Connections sitting in the garage waiting to be used.
 * - "Borrowed": A connection currently out in the world being used for a query.
 *
 * -- what "lease" (or borrow) means:
 * It's a temporary permission. You don't "OWN" the connection; you 
 * are just using it for a few milliseconds. Once your query is done, 
 * you MUST return it so someone else can use it.
 *
 * -- what "pruning" means:
 * It's like house cleaning. Database connections can "go bad" if they 
 * sit idle for too long (the server might hang up on them). Pruning 
 * is the process of checking every sitting car in the garage and 
 * throwing away the ones that won't start anymore.
 */
final class ConnectionPool implements ConnectionPoolInterface
{
    /** @var SplQueue<array{connection: DatabaseConnection, released_at: float}> The "Garage" where idle connections are parked. */
    private SplQueue $pool;

    /** @var PoolState The internal authority who keeps track of how many "Cars" are currently out. */
    private PoolState $state;

    /** @var ExecutionScope|null The "Luggage Tag" (Trace ID) for this pool's actions. */
    private ExecutionScope|null $scope = null;

    /**
     * @param array<string, mixed> $config   The instructions for the garage (e.g., "Max 10 cars").
     * @param EventBus|null        $eventBus The "Notification System" for reporting when a car is taken or returned.
     */
    public function __construct(
        private readonly array    $config,
        private readonly ?EventBus $eventBus = null
    ) {
        $this->pool  = new SplQueue();
        $this->state = new PoolState(
            maxConnections: (int) ($this->config['pool']['max_connections'] ?? 10)
        );
    }

    /**
     * Borrow a healthy connection from the pool (Acquire).
     *
     * -- what "acquire" means in this context:
     * It's the act of requesting a "Lease" on a database connection. 
     * You are asking the manager to either give you an existing 
     * idle connection or open a new one if the garage isn't full.
     *
     * -- when it happens:
     * The connection is physically reserved for you the moment 
     * this method returns.
     *
     * -- common pitfall:
     * This is a "Borrowed" item. If you acquire it, you MUST release 
     * it (or let the BorrowedConnection object be destroyed). If 
     * you keep acquiring without releasing, you will eventually 
     * block the entire application because the pool will run out 
     * of slots.
     */
    public function acquire(): DatabaseConnection
    {
        $this->pruneStaleConnections();

        // 1. Try to reuse an existing one.
        if (! $this->pool->isEmpty()) {
            $item       = $this->pool->dequeue();
            $connection = $item['connection'];

            if ($this->validateConnection(connection: $connection)) {
                $this->state->recordRecycledAcquisition();

                $this->eventBus?->dispatch(event: new ConnectionAcquired(
                    connectionName: $this->getName(),
                    isRecycled: true,
                    correlationId: $this->scope?->correlationId ?? 'ctx_unknown'
                ));

                return new BorrowedConnection(connection: $connection, pool: $this);
            }

            // If the connection was dead, we release its slot in our counter.
            $this->state->releaseSlot();
        }

        // 2. If no recyclables, try to create a new one.
        $name = $this->config['name'] ?? 'anonymous';

        if (! $this->state->tryReserveSlot()) {
            $limit = $this->config['pool']['max_connections'] ?? 10;
            throw new PoolLimitReachedException(name: $name, limit: (int) $limit);
        }

        $flow = DirectConnectionFlow::begin()
            ->using(config: $this->config);

        if ($this->eventBus) {
            $flow->withEvents(eventBus: $this->eventBus);
        }

        if ($this->scope) {
            $flow->withScope(scope: $this->scope);
        }

        $connection = $flow->connect();

        $this->eventBus?->dispatch(event: new ConnectionAcquired(
            connectionName: $this->getName(),
            isRecycled: false,
            correlationId: $this->scope?->correlationId ?? 'ctx_unknown'
        ));

        return new BorrowedConnection(connection: $connection, pool: $this);
    }

    /**
     * Clean out old, stale connections from the garage (Pruning).
     *
     * -- what "pruning" means in this context:
     * It's a "Health Check". We look at every idle connection in 
     * the garage and throw away the ones that are too old or 
     * have already been closed by the database server.
     *
     * -- when it happens:
     * It happens automatically every time someone calls 'acquire()', 
     * ensuring you always get a fresh, working connection.
     *
     * -- common pitfall:
     * This does NOT close active connections! It only touches 
     * the ones that are currently "parked" and waiting to be reused.
     *
     * @return int How many connections were thrown in the trash.
     */
    public function pruneStaleConnections(): int
    {
        $maxIdleTime = $this->config['pool']['max_idle_time_seconds'] ?? 300;
        $currentTime = microtime(as_float: true);
        $prunedCount = 0;

        $validConnections = new SplQueue();

        while (! $this->pool->isEmpty()) {
            $item     = $this->pool->dequeue();
            $idleTime = $currentTime - $item['released_at'];

            // If it's too old or doesn't "Ping" correctly, it's gone.
            if ($idleTime > $maxIdleTime || ! $this->validateConnection(connection: $item['connection'])) {
                $this->state->releaseSlot();
                $prunedCount++;
                continue;
            }

            $validConnections->enqueue(value: $item);
        }

        // Put the survivors back in the garage.
        while (! $validConnections->isEmpty()) {
            $this->pool->enqueue(value: $validConnections->dequeue());
        }

        return $prunedCount;
    }

    /**
     * Ask a connection "Are you alive?" (Ping).
     */
    public function validateConnection(DatabaseConnection|null $connection = null): bool
    {
        if ($connection === null) {
            return false;
        }

        try {
            return $connection->ping();
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Test the overall health of the pool.
     */
    public function ping(): bool
    {
        try {
            $borrowed  = $this->acquire();
            $isHealthy = $borrowed->ping();

            if ($borrowed instanceof BorrowedConnection) {
                $borrowed->release();
            }

            return $isHealthy;
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Return a used connection to the pool (Release).
     *
     * -- what "release" means in this context:
     * It's "Parking the Car". You are telling the pool that you 
     * are finished with the connection and it can now be given 
     * to someone else.
     *
     * -- when it happens:
     * The connection is returned to the idle list immediately.
     *
     * -- common pitfall:
     * NEVER use the connection object again after you have 
     * released it! It now belongs to the pool again, and it might 
     * be handed to a completely different part of your app in 
     * the next millisecond.
     */
    public function release(DatabaseConnection $connection): void
    {
        if ($connection instanceof BorrowedConnection) {
            $connection = $connection->getOriginalConnection();
        }

        if (! $this->validateConnection(connection: $connection)) {
            $this->state->releaseSlot();

            return;
        }

        $maxIdle = $this->config['pool']['max_idle_connections'] ?? 5;

        // If the lot is full of idle cars, get rid of the oldest 'parked' one.
        if ($this->pool->count() >= $maxIdle) {
            $this->pool->dequeue();
            $this->state->releaseSlot();
        }

        $this->pool->enqueue(
            value: [
                'connection'  => $connection,
                'released_at' => microtime(as_float: true),
            ]
        );
    }

    /**
     * Get the nickname of this pool.
     */
    public function getName(): string
    {
        return $this->config['name'] ?? 'pool';
    }

    /**
     * Attach a "Luggage Tag" (Scope) to this pool for logging and tracing.
     */
    public function withScope(ExecutionScope $scope): self
    {
        $this->scope = $scope;

        return $this;
    }

    /**
     * Get a "Status Report" (Metrics) of how the garage is doing.
     *
     * @return ConnectionPoolMetrics A report containing counts of idle/active cars.
     */
    public function getMetrics(): ConnectionPoolMetrics
    {
        $maxIdleTime = 0;
        if (! $this->pool->isEmpty()) {
            $oldest      = $this->pool->bottom();
            $maxIdleTime = (int) (microtime(as_float: true) - $oldest['released_at']);
        }

        return new ConnectionPoolMetrics(
            data: [
                'spawnedConnections' => $this->state->getSpawnedCount(),
                'idleConnections'    => $this->pool->count(),
                'activeConnections'  => $this->state->getSpawnedCount() - $this->pool->count(),
                'maxConnections'     => (int) ($this->config['pool']['max_connections'] ?? 10),
                'totalAcquisitions'  => $this->state->getTotalAcquisitions(),
                'maxIdleTime'        => $maxIdleTime,
            ]
        );
    }
}

=== Foundation/Connection/Pool/ConnectionPoolFlow.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool;

/**
 * The "Pool Builder" (Wizard) for shared database connections.
 *
 * -- what is it?
 * This is a "Fluent Flow" (a setup wizard) that helps you construct a 
 * `ConnectionPool`. Instead of manually setting up complex objects, you 
 * use this class to say what settings you want in a simple, readable way.
 *
 * -- how to imagine it:
 * Think of an "Assembly Line". You put your configuration settings on the 
 * conveyor belt (`using`), and at the end of the line, a fully working 
 * `ConnectionPool` (`pool`) comes off the assembly line.
 *
 * -- why this exists:
 * 1. Readability: It makes the technical setup code look more like English 
 *    (`begin()->using($config)->pool()`).
 * 2. Separation: It keeps the messy logic of "how to build a pool" separate 
 *    from the pool's actual job of "how to manage connections".
 *
 * -- what "fluent flow" means:
 * It's a style of writing code that reads like a sentence. Instead of 
 * writing many separate lines, you "chain" methods together using arrows 
 * (->). This is called "Fluent" because the code flows naturally from 
 * left to right, making it much easier for humans to read and understand 
 * the step-by-step process.
 */
final class ConnectionPoolFlow
{
    /** @var array<string, mixed> The settings we are carrying through the assembly line. */
    private array $config = [];

    /**
     * Private constructor — use `ConnectionPoolFlow::begin()` to start the wizard.
     */
    private function __construct() {}

    /**
     * Start the setup wizard for a new connection pool (Begin).
     *
     * -- what "begin" means in this context:
     * It's the "First Step" on the assembly line. It creates the 
     * initial empty container that will carry your configuration.
     *
     * -- when it happens:
     * The wizard starts immediately in your computer's memory.
     *
     * -- common pitfall:
     * Calling 'begin()' alone does nothing. You MUST chain it 
     * with other methods like 'using()' and finally 'pool()' to 
     * actually get anything useful.
     */
    public static function begin(): self
    {
        return new self();
    }

    /**
     * Give the wizard the settings to use (Using).
     *
     * -- what "using" means in this context:
     * It's the "Loading Phase". You are putting the instructions 
     * (Host, User, Password, Limits) onto the conveyor belt.
     *
     * -- when it happens:
     * The settings are recorded immediately in the wizard's state.
     *
     * -- common pitfall:
     * The wizard just "holds" these settings. It won't tell 
     * you if they are wrong (like a bad password) until you 
     * actually try to use the final pool to connect to the 
     * database later.
     */
    public function using(array $config): self
    {
        $this->config = $config;

        return $this;
    }

    /**
     * Finish the wizard and get the final product (Pool).
     *
     * -- what "pool" means in this context:
     * It's the "Assembly Moment". The wizard takes all the 
     * instructions you gave it and builds the real, working 
     * ConnectionPool object.
     *
     * -- when it happens:
     * The real pool is created the exact microsecond this 
     * method is called.
     *
     * -- common pitfall:
     * This is the END of the journey. Once you call 'pool()', 
     * the wizard is done. You cannot go back and add more 
     * 'using()' instructions to this specific wizard instance.
     */
    public function pool(): ConnectionPool
    {
        return new ConnectionPool(config: $this->config);
    }
}

=== Foundation/Connection/Pool/Contracts/ConnectionPoolInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool\Contracts;

use Avax\Database\Connection\Contracts\DatabaseConnection;

/**
 * The "Shared Library Rules" (Pool Interface).
 *
 * -- what is it?
 * This is an Interface (a contract). It defines the basic operations that 
 * ANY connection pool must support.
 *
 * -- how to imagine it:
 * Think of it as the "Signage" on a public library. The sign says: 
 * "Anyone who calls themselves a Library must allow people to:
 * 1. Borrow a book (Acquire).
 * 2. Return a book (Release).
 * 3. Tell us the library's name."
 *
 * -- why this exists:
 * So that different parts of our program can use ANY kind of connection 
 * pool (like a simple one or a complex enterprise one) without needing 
 * to know how it works inside. As long as it follows these three simple 
 * rules, it's a valid pool.
 */
interface ConnectionPoolInterface
{
    /**
     * Borrow a database connection from the pool.
     *
     * @return DatabaseConnection A ready-to-use tool to talk to your database.
     */
    public function acquire(): DatabaseConnection;

    /**
     * Hand a database connection back to the pool so others can use it.
     *
     * @param DatabaseConnection $connection The tool you are finished using.
     */
    public function release(DatabaseConnection $connection): void;

    /**
     * Get the nickname of this pool.
     */
    public function getName(): string;
}

=== Foundation/Connection/Pool/DTO/ConnectionPoolMetrics.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool\DTO;

use Avax\DataHandling\ObjectHandling\DTO\AbstractDTO;
use Avax\DataHandling\Validation\Attributes\Rules\IntegerRule;

/**
 * The "Status Report" (Snapshot) for a connection pool.
 *
 * -- what is it?
 * This is a DTO (Data Transfer Object). It's a simple, typed container used 
 * to carry a "Snapshot" of how the connection pool is doing right now.
 *
 * -- how to imagine it:
 * Think of a "Dashboard" in a car. It doesn't drive the car; it just 
 * shows you the speed, fuel level, and oil pressure. This class shows 
 * you the "Fuel level" (how many connections are left) and "Speed" (how 
 * many times people have used it) of the pool.
 *
 * -- why this exists:
 * To provide a clean, standard way to look into the "Black Box" of 
 * the connection pool. If you're building a monitoring page or trying 
 * to debug why the app is slow, this report tells you if the pool is 
 * overcrowded or empty.
 *
 * -- mental models:
 * - "Spawned": Connections that have been created and are currently alive.
 * - "Active": Connections that someone is currently using.
 * - "Idle": Connections sitting in the garage waiting for work.
 */
final class ConnectionPoolMetrics extends AbstractDTO
{
    /** @var int The total number of connections that exist right now. */
    #[IntegerRule]
    public int $spawnedConnections;

    /** @var int How many connections are busy right now. */
    #[IntegerRule]
    public int $activeConnections;

    /** @var int How many connections are waiting for work in the garage. */
    #[IntegerRule]
    public int $idleConnections;

    /** @var int The absolute maximum number of connections we are allowed to open. */
    #[IntegerRule]
    public int $maxConnections;

    /** @var int A historical counter of how many times any connection was borrowed since the start. */
    #[IntegerRule]
    public int $totalAcquisitions;

    /** @var int The longest time a connection is allowed to sit idle before we "prune" it (throw it away). */
    #[IntegerRule]
    public int $maxIdleTime;
}

=== Foundation/Connection/Pool/PoolState.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool;

/**
 * The "Ledger" (Internal Accountant) of the connection pool.
 *
 * -- what is it?
 * This is a simple counter class. It doesn't open connections or talk to 
 * databases; it just keeps track of the numbers (How many connections are open? 
 * Are we full? How many times have we used the pool?).
 *
 * -- how to imagine it:
 * Think of a "Bouncer" at a club with a clicker counter. He doesn't know 
 * how to dance (run SQL), but he knows exactly how many people are inside 
 * and when to stop letting new people in because the room is full.
 *
 * -- why this exists:
 * To separate the "Business Logic" of pooling from the simple "Accounting" 
 * of numbers. It makes the code cleaner and ensures we never accidentally 
 * open more connections than we're allowed.
 *
 * -- mental models:
 * - "Slot": A permission space for one connection.
 * - "Spawned": A connection that has been created (born) and is currently 
 *    active or waiting.
 */
final class PoolState
{
    /** @var int The current number of connections we have "Created" and are still managing. */
    private int $spawnedCount      = 0;

    /** @var int A persistent counter of every single time someone borrowed a connection. */
    private int $totalAcquisitions = 0;

    /**
     * @param int $maxConnections The absolute maximum number of people allowed in at once.
     */
    public function __construct(private readonly int $maxConnections) {}

    /**
     * Try to "Check in" and reserve a space for a new connection.
     *
     * -- how it works:
     * We check the counter. If we are under the limit, we "click" the 
     * counter up and say "Yes, you can proceed". If we are full, we 
     * say "No".
     *
     * @return bool True if there was room, false if we are at capacity.
     */
    public function tryReserveSlot(): bool
    {
        if ($this->spawnedCount >= $this->maxConnections) {
            return false;
        }

        $this->spawnedCount++;
        $this->totalAcquisitions++;

        return true;
    }

    /**
     * Record that someone borrowed an ALREADY-EXISTING connection.
     *
     * -- why this exists:
     * Even if we didn't need to open a new connection, we still want to 
     * count that a "Borrow" happened for our statistics.
     */
    public function recordRecycledAcquisition(): void
    {
        $this->totalAcquisitions++;
    }

    /**
     * Tell the accountant that a connection was destroyed or closed.
     *
     * -- intent:
     * This "frees up" a slot so someone else can open a new connection 
     * later if they need to.
     */
    public function releaseSlot(): void
    {
        $this->spawnedCount = max(0, $this->spawnedCount - 1);
    }

    /**
     * Get the current number of living connections.
     */
    public function getSpawnedCount(): int
    {
        return $this->spawnedCount;
    }

    /**
     * Get the total historical number of "Borrows" performed.
     */
    public function getTotalAcquisitions(): int
    {
        return $this->totalAcquisitions;
    }
}

=== Foundation/Connection/Pool/PooledConnectionAuthority.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Avax\Connection\Pool;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Avax\Connection\Pool\Contracts\ConnectionPoolInterface;
use PDO;

/**
 * The "Personal Assistant" for picking up and returning database connections.
 *
 * -- what is it?
 * This is a smart proxy. It represents a database connection, but it doesn't 
 * actually hold one until you REALLY need to use it.
 *
 * -- how to imagine it:
 * Think of someone sitting in a library. Instead of holding a book the 
 * whole time (and blocking others from reading it), they only go to the 
 * shelf and grab the book the second they need to look up a word. Once 
 * they leave the library, they automatically put the book back.
 *
 * -- why this exists:
 * 1. Laziness: It prevents "checking out" a connection from the pool if 
 *    your code doesn't end up actually running a query. This keeps 
 *    connections available for other parts of your app longer.
 * 2. Automatic Return: Just like `BorrowedConnection`, it ensures that 
 *    once this object is no longer needed, the connection goes back 
 *    to the pool automatically.
 *
 * -- mental models:
 * - "Authority": This object is the middleman between you and the 
 *    actual connection pool.
 *
 * -- what "lazy loading" means:
 * It's like only turning on the lights when you enter the room. Instead 
 * of opening a database connection as soon as the app starts, we wait 
 * until the very last second (when you actually try to run a query). 
 * This saves memory and prevents our app from holding onto resources 
 * it isn't using yet.
 *
 * -- what "proxy" means:
 * It's a "Stand-in" or a "Body Double". You talk to this object as 
 * if it were a real database connection, but behind the scenes, it's 
 * just managing the real connection for you.
 */
final class PooledConnectionAuthority implements DatabaseConnection, ConnectionPoolInterface
{
    /** @var DatabaseConnection|null The actual tool we've grabbed from the library (null if we haven't needed it yet). */
    private ?DatabaseConnection $borrowed = null;

    /**
     * @param ConnectionPoolInterface $pool The "Library" we borrow from.
     */
    public function __construct(
        private readonly ConnectionPoolInterface $pool
    ) {}

    /**
     * Get the active PDO tool. If we haven't borrowed one yet, we grab it now.
     */
    public function getConnection(): PDO
    {
        return $this->resolveBorrowed()->getConnection();
    }

    /**
     * The "Grab it now" logic (Lazy Loading).
     *
     * -- how it works:
     * We check if we already have a connection. If not, we ask the pool 
     * for a fresh one. We only do this once.
     */
    private function resolveBorrowed(): DatabaseConnection
    {
        if ($this->borrowed === null) {
            $this->borrowed = $this->pool->acquire();
        }

        return $this->borrowed;
    }

    /**
     * Standard protocol to ask the pool for a NEW connection.
     *
     * @return DatabaseConnection A fresh tool from the shared resource.
     */
    public function acquire(): DatabaseConnection
    {
        return $this->pool->acquire();
    }

    /**
     * Check if the database is still responsive.
     *
     * @return bool True if we can still "talk" to the database.
     */
    public function ping(): bool
    {
        return $this->resolveBorrowed()->ping();
    }

    /**
     * Get the technical nickname of this connection.
     */
    public function getName(): string
    {
        return $this->pool->getName();
    }

    /**
     * Hand a connection back to the shared library.
     */
    public function release(DatabaseConnection $connection): void
    {
        $this->pool->release(connection: $connection);
    }

    /**
     * The "Closing Time" cleanup.
     * 
     * -- intent:
     * When this assistant is no longer needed, it "clears its desk". 
     * By setting `borrowed` to null, we trigger its own cleanup logic 
     * (the destructor), which returns the connection to the pool.
     */
    public function __destruct()
    {
        $this->borrowed = null;
    }
}

=== Foundation/Connection/ValueObjects/ConnectionConfig.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\ValueObjects;

use SensitiveParameter;

/**
 * The "Connection Credentials" (ID Card).
 *
 * -- what is it?
 * This is an immutable object (a record) that holds all the "Passport" information 
 * for a database connection: its driver, host, database name, and the secret 
 * keys (username/password).
 *
 * -- how to imagine it:
 * Think of an "ID Card" or a "Passport". It contains the name and all the 
 * essential details of who you are and where you live. You can't change the 
 * information on the card once it's printed; you'd have to get a new card.
 *
 * -- why this exists:
 * 1. Type Safety: Instead of passing around messy arrays (where you might 
 *    misspell 'db_name' instead of 'database'), this object guarantees 
 *    that every detail has the right name and type.
 * 2. Security: It uses a special PHP feature (`SensitiveParameter`) to hide 
 *    your password so it doesn't accidentally show up in error logs or 
 *    emails if the site crashes.
 * 3. Standardization: It provides sensible defaults, so even if you forget 
 *    to specify a host, it assumes you're working on your local machine.
 *
 * -- mental models:
 * - "Immutable": Once created, its data cannot be changed. This prevents 
 *    bugs where one part of the code accidentally changes a password 
 *    meant for another part.
 * - "Sensitive": Private information that should be masked in logs.
 */
final readonly class ConnectionConfig
{
    /**
     * @param string $driver   The type of engine (e.g., 'mysql' or 'sqlite').
     * @param string $host     The "Home Address" (IP or hostname) of the server.
     * @param string $database The specific name of the database file or schema.
     * @param string $username The "User Identity" used to log in.
     * @param string $password The "Secret Key" (Hidden from accidental logging).
     * @param string $charset  The "Language" the database speaks (e.g., utf8).
     * @param string $name     A simple nickname to identify this specific config.
     */
    public function __construct(
        public string                       $driver = 'mysql',
        public string                       $host = '127.0.0.1',
        public string                       $database = '',
        public string                       $username = 'root',
        #[SensitiveParameter] public string $password = '',
        public string                       $charset = 'utf8mb4',
        public string                       $name = 'default',
    ) {}

    /**
     * Build an ID Card from a raw list of setttings.
     *
     * @param array{
     *     driver?: string,
     *     host?: string,
     *     database?: string,
     *     username?: string,
     *     password?: string,
     *     charset?: string,
     *     name?: string
     * } $config The raw dictionary of details.
     * @return self A fresh, perfectly structured ID Card.
     */
    public static function from(array $config): self
    {
        return new self(
            driver: $config['driver'] ?? 'mysql',
            host: $config['host'] ?? '127.0.0.1',
            database: $config['database'] ?? '',
            username: $config['username'] ?? 'root',
            password: $config['password'] ?? '',
            charset: $config['charset'] ?? 'utf8mb4',
            name: $config['name'] ?? 'default'
        );
    }
}

=== Foundation/Connection/ValueObjects/Dsn.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Connection\ValueObjects;

use InvalidArgumentException;

/**
 * The "Technical Address" (DSN) of your database.
 *
 * -- what is it?
 * DSN stands for "Data Source Name". In plain English, it's the specific, 
 * technical string that a computer needs to "call" a database (e.g., 
 * 'mysql:host=127.0.0.1;dbname=test').
 *
 * -- how to imagine it:
 * Think of it as a "Full URL" or a "Deep Link". Just like you use 
 * `https://google.com` to find a website, a database driver uses the 
 * DSN to find a database. Different databases (MySQL, SQLite) use 
 * different address formats; this class handles the translation.
 *
 * -- why this exists:
 * 1. Consistency: It hides the messy details of how DSN strings are 
 *    formatted. You just give it the "Host" and "Database Name", and 
 *    it builds the perfect string for you.
 * 2. SQLite Support: It knows that SQLite uses a different format (file 
 *    path instead of host/port) and handles that automatically.
 * 3. Security: It uses safe formatting to ensure the final address string 
 *    isn't corrupted by weird characters.
 *
 * -- mental models:
 * - "DSN": The "Phone Number" of the database.
 * - "Immutable": Once you create a "Phone Number", you can't edit it. You 
 *    have to create a new one.
 */
final readonly class Dsn
{
    /**
     * Private constructor — use `Dsn::for()` to create one.
     *
     * @param string $dsn The final, "Computer-Ready" address string.
     */
    private function __construct(private string $dsn) {}

    /**
     * Build a technical address from simple settings.
     *
     * @param string $driver   The type of database (e.g., 'mysql', 'sqlite').
     * @param string $host     The computer's address (e.g., '127.0.0.1').
     * @param string $database The name of the specific database (e.g., 'users_db').
     * @param string $charset  The "Language" (Encoding) to use (e.g., 'utf8').
     * @return self An immutable object holding the perfectly formatted address.
     */
    public static function for(
        string $driver,
        string $host,
        string $database,
        string $charset,
    ): self {
        // Different drivers have different "Address Formats".
        // SQLite:   "sqlite:/path/to/db.sqlite"
        // MySQL:    "mysql:host=127.0.0.1;dbname=test;charset=utf8"
        $dsn = match ($driver) {
            'sqlite' => sprintf('sqlite:%s', $database),
            default  => sprintf('%s:host=%s;dbname=%s;charset=%s', $driver, $host, $database, $charset),
        };

        return new self(dsn: $dsn);
    }

    /**
     * Get the final "Computer-Ready" address string.
     *
     * -- intent:
     * This is the string we pass to the PDO engine (the phone) to 
     * actually start the call.
     */
    public function toString(): string
    {
        return $this->dsn;
    }
}

=== Foundation/Events/ConnectionAcquired.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * System Signal: Database Connection Acquired.
 *
 * -- intent:
 * Broadcasts a technical notification whenever a database connection is 
 * successfully checked out for use, facilitating telemetry, auditing, and 
 * resource utilization tracking.
 *
 * -- invariants:
 * - Instances must be strictly immutable.
 * - Must capture whether the resource was freshly spawned or recycled from the pool.
 * - Must carry a correlation ID for cross-component trace tracking.
 *
 * -- boundaries:
 * - Does NOT contain the physical connection resource (security/payload boundary).
 * - Serves strictly as a telemetry signal.
 */
final readonly class ConnectionAcquired extends Event
{
    /**
     * @param string $connectionName The technical identifier assigned to the target database.
     * @param bool   $isRecycled     Flag indicating if the connection was retrieved from the pool (true) or freshly established (false).
     * @param string $correlationId  The technical trace identifier used for correlating this event with a specific execution scope.
     */
    public function __construct(
        public string $connectionName,
        public bool   $isRecycled,
        string        $correlationId
    ) {
        parent::__construct(correlationId: $correlationId);
    }
}

=== Foundation/Events/ConnectionFailed.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Throwable;

/**
 * System Signal: Database Connection Failed.
 *
 * -- intent:
 * Broadcasts a critical technical notification when a physical connection 
 * attempt to the database cluster fails, allowing for immediate alerting, 
 * error logging, and downstream circuit breaking.
 *
 * -- invariants:
 * - Instances must be strictly immutable to ensure error report stability.
 * - Must encapsulate the original Throwable for technical root-cause analysis.
 * - Must carry a correlation ID to trace which operation triggered the failure.
 *
 * -- boundaries:
 * - Does NOT perform error handling; only signals the occurrence.
 * - Does NOT contain sensitive credentials (security boundary).
 */
final readonly class ConnectionFailed extends Event
{
    /**
     * @param string    $connectionName The technical identifier of the database gateway that failed to respond.
     * @param Throwable $exception      The native driver exception or technical error captured during the attempt.
     * @param string    $correlationId  The technical trace identifier used for correlating this failure with a specific execution scope.
     */
    public function __construct(
        public string    $connectionName,
        public Throwable $exception,
        string           $correlationId
    ) {
        parent::__construct(correlationId: $correlationId);
    }
}

=== Foundation/Events/ConnectionOpened.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * System Signal: Physical Database Connection Opened.
 *
 * -- intent:
 * Broadcasts a technical notification when a fresh physical communication 
 * channel (socket) is successfully negotiated with the database server, 
 * facilitating infrastructure auditing and connection count tracking.
 *
 * -- invariants:
 * - Instances must be strictly immutable.
 * - Must identify the target database by its logical name.
 * - Must carry a correlation ID for observability tracing.
 *
 * -- boundaries:
 * - Does NOT indicate query success; only indicates the transport layer is established.
 * - Serves strictly as an infrastructure signal.
 */
final readonly class ConnectionOpened extends Event
{
    /**
     * @param string $connectionName The technical identifier assigned to the established database channel.
     * @param string $correlationId  The technical trace identifier used for correlating this event with a specific execution scope.
     */
    public function __construct(
        public string $connectionName,
        string        $correlationId
    ) {
        parent::__construct(correlationId: $correlationId);
    }
}

=== Foundation/Events/Contracts/DispatchStrategyInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events\Contracts;

use Avax\Database\Events\Event;

/**
 * Technical contract defining the processing strategy for system-wide signals.
 *
 * -- intent:
 * Abstract the execution policy (synchronous, asynchronous, queued, or deferred) 
 * for signal distribution, allowing the EventBus to remain agnostic of the 
 * physical performance profile required for observer execution.
 *
 * -- invariants:
 * - Implementations must accept a generic Event payload and a collection of listeners.
 * - The strategy must not modify the Event payload during processing.
 *
 * -- boundaries:
 * - Does NOT handle listener discovery (delegated to EventBus).
 * - Does NOT handle error normalization (delegated to listeners or specific strategies).
 */
interface DispatchStrategyInterface
{
    /**
     * Coordinate the technical execution of a collection of observers for a specific signal.
     *
     * -- intent:
     * Physically triggers the provided listeners in accordance with the 
     * implementation's performance strategy (e.g., executing all listeners 
     * sequentially in the current process).
     *
     * @param Event              $event     The technical signal payload to be distributed.
     * @param iterable<callable> $listeners The collection of authorized technical handlers/observers to be triggered.
     * @return void
     */
    public function handle(Event $event, iterable $listeners): void;
}

=== Foundation/Events/Contracts/EventBusInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events\Contracts;

use Avax\Database\Events\Event;
use Avax\Database\Events\EventSubscriberInterface;

/**
 * The "Radio Command Center" (Event Bus Rulebook).
 *
 * -- what is it?
 * This is an Interface (a contract) that defines how the system should 
 * handle "Shouts" (Events). Any object that wants to be the "Event Bus" 
 * for the application must follow these rules.
 *
 * -- how to imagine it:
 * Think of the "Dispatcher" in a taxi company. The Dispatcher must be able 
 * to:
 * 1. Hear a shout from a taxi (Dispatch).
 * 2. Know which taxi drivers are listening to which channels (Subscribe).
 * 3. Sign up many drivers at once (Register Subscriber).
 *
 * -- why this exists:
 * To make the notification system swappable. We might have a simple 
 * Dispatcher today, but tomorrow we might need a more complex one that 
 * records all messages to a database. As long as they both follow this 
 * rulebook, the rest of the application doesn't care which taxi company 
 * we use.
 */
interface EventBusInterface
{
    /**
     * Shout out an event to everyone listening.
     *
     * @param Event $event The "News" piece (e.g., "Connection Opened").
     */
    public function dispatch(Event $event): void;

    /**
     * Sign up a multi-topic "Subscriber" (a class that listens to many things).
     *
     * @param EventSubscriberInterface $subscriber A helper who has a list of everything they care about.
     */
    public function registerSubscriber(EventSubscriberInterface $subscriber): void;

    /**
     * Manually sign up a single listener for a specific signal.
     *
     * @param string   $event    The full name of the News Type you want to hear.
     * @param callable $listener The specific code block to run.
     */
    public function subscribe(string $event, callable $listener): void;
}

=== Foundation/Events/Event.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Avax\Database\Support\SequenceTracker;

/**
 * The "System Shout" (Base Event).
 *
 * -- what is it?
 * This is the parent class for all "Events" in the system. An event is a 
 * "Signal" or a "Message" that one part of the system sends to another 
 * to say "Hey, I just did something!" (e.g., "I just opened a connection" 
 * or "I just ran a query").
 *
 * -- how to imagine it:
 * Think of a "Radio Broadcast". When a specific part of the engine finishes 
 * a job, it broadcasts a message on a specific frequency. Anyone who is 
 * listening (Subscribers) can hear the message and react to it (e.g., a 
 * logger might write it to a file).
 *
 * -- why this exists:
 * 1. Decoupling: The part of the system sending the message doesn't need to 
 *    know WHO is listening or WHAT they will do. It just shouts "I'm done!".
 * 2. Traceability: Every single message automatically gets a "Timestamp" 
 *    (when it happened), a "Correlation ID" (which request it belongs to), 
 *    and a "Sequence Number" (the exact order of events).
 * 3. Auditing: Because every event is a structured object, we can easily 
 *    collect them and build a perfect timeline of what the database was 
 *    doing at any given microsecond.
 *
 * -- mental models:
 * - "Correlation ID": The "Luggage Tag" (Trace ID) that links many different 
 *    events to a single user request.
 * - "Monotonic Sequence": A counter that only goes UP. It ensures we know 
 *    exactly if Event A happened before Event B, even if the computer's 
 *    clock is slightly off.
 */
abstract readonly class Event
{
    /** @var float The exact moment (with microseconds) this shout was made. */
    public float $timestamp;

    /** @var string The "Luggage Tag" that connects this event to the current request. */
    public string $correlationId;

    /** @var int The "Order Number" (Sequence) to keep events in the right chronological chain. */
    public int $sequence;

    /**
     * @param string $correlationId The Trace ID representing the active work context.
     */
    public function __construct(string $correlationId)
    {
        $this->timestamp     = microtime(as_float: true);
        $this->correlationId = $correlationId;
        $this->sequence      = SequenceTracker::next();
    }

    /**
     * Get the technical "Type" (Name) of this event.
     *
     * @return string The full name of the event class.
     */
    public function getName(): string
    {
        return static::class;
    }
}

=== Foundation/Events/EventBus.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Avax\Database\Events\Contracts\DispatchStrategyInterface;
use Avax\Database\Events\Contracts\EventBusInterface;
use Avax\Database\Events\Strategy\SyncDispatchStrategy;

/**
 * The "Notification Center" (Event Bus) for the database.
 *
 * -- what is it?
 * This is the central hub that manages "Shouts" (Events) and "Listeners" 
 * (Subscribers). When one part of the system broadcasts an event, the Bus 
 * makes sure that everyone interested hears about it.
 *
 * -- how to imagine it:
 * Think of a "Newsletter" or an "Internal PA System". Classes that want to know 
 * when something happens (like a Logger) "Subscribe" to the newsletter. When the 
 * "News" (Event) happens, the Bus delivers a copy to everyone on the list.
 *
 * -- why this exists:
 * 1. Clean Code: It keeps the core database logic from getting cluttered with 
 *    side tasks. The `ConnectionPool` just says "I opened a connection!", it 
 *    doesn't need to know how to write to a log file or send a Slack message.
 * 2. Flexibility: You can add or remove listeners easily without changing the 
 *    code that sends the events.
 * 3. Strategy: It supports different "Dispatch Strategies". For example, you 
 *    could have the listeners run immediately (Sync) or put them in a queue 
 *    to run later (Async).
 *
 * -- mental models:
 * - "Strategy": The delivery method (e.g., Email vs. Courier).
 *
 * -- what "dispatch" means:
 * It's the act of "Shouting" or "Broadcasting" a message. When the system 
 * calls `dispatch()`, it's not talking to anyone specific. It's just 
 * announcing: "This event happened!". It's up to the EventBus to find 
 * everyone who cares about that announcement.
 *
 * -- what "subscriber" means:
 * It's a "Persistent Listener". Instead of just listening once, a 
 * subscriber is like a magazine subscription. They tell the system: 
 * "Every time a 'QueryExecuted' event happens, I want to hear about it." 
 * They stay on the list until the system shuts down.
 */
final class EventBus implements EventBusInterface
{
    /** @var array<string, array<int, callable>> A list of everyone signed up for each type of news. */
    private array $listeners = [];

    /**
     * @param DispatchStrategyInterface $strategy The logic for HOW to deliver the news (e.g., "Do it now" or "Queue it").
     */
    public function __construct(
        private readonly DispatchStrategyInterface $strategy = new SyncDispatchStrategy()
    ) {}

    /**
     * Shout out an event to everyone listening (Dispatch).
     *
     * -- what "dispatch" means in this context:
     * It's the "Broadcasting Phase". You are handing a piece of news 
     * to the manager and saying: "Tell everyone who needs to know 
     * that this just happened."
     *
     * -- when it happens:
     * The announcement is made immediately. However, when the 
     * listeners actually *run* depends on the 'Strategy' being 
     * used (e.g., they might run now, or be queued for later).
     *
     * -- common pitfall:
     * Calling 'dispatch()' does NOT guarantee that the listeners will 
     * succeed. If a listener crashes, it might stop other listeners 
     * from hearing the news, depending on the strategy. Also, 
     * dispatching is "fire and forget"—the sender doesn't wait 
     * for a "reply" from the listeners.
     *
     * @param Event $event THE piece of news (e.g., "Query Executed").
     */
    public function dispatch(Event $event): void
    {
        $name = $event->getName();

        // If no one is listening to this channel, we don't do anything.
        if (! isset($this->listeners[$name])) {
            return;
        }

        // We hand the job over to the "Strategy" (e.g., our Delivery Driver).
        $this->strategy->handle(event: $event, listeners: $this->listeners[$name]);
    }

    /**
     * Sign up a multi-topic "Subscriber" (a class that listens to many things).
     *
     * @param EventSubscriberInterface $subscriber A helper object that contains multiple different listeners.
     */
    public function registerSubscriber(EventSubscriberInterface $subscriber): void
    {
        foreach ($subscriber->getSubscribedEvents() as $event => $method) {
            $this->subscribe(event: $event, listener: [$subscriber, $method]);
        }
    }

    /**
     * Sign up to hear about specific news (Subscribe).
     *
     * -- what "subscribe" means in this context:
     * It's like signing up for a newsletter. You are giving the 
     * manager your "Address" (a callable function) and asking 
     * to be notified every time a specific type of event occurs.
     *
     * -- when it happens:
     * Your name is added to the list immediately. You will start 
     * hearing about events that are dispatched AFTER this point.
     *
     * -- common pitfall:
     * You cannot "undo" a subscription easily in this simple 
     * version. Once you're on the list, you're on it for the 
     * duration of the request. Also, if you subscribe the same 
     * function twice, it will run TWICE for every event.
     *
     * @param string   $event    The full name of the Event you want to hear about.
     * @param callable $listener The specific function/code to run when it happens.
     */
    public function subscribe(string $event, callable $listener): void
    {
        $this->listeners[$event][] = $listener;
    }
}

=== Foundation/Events/EventSubscriberInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

/**
 * The "Subscription Form" (Event Subscriber Rulebook).
 *
 * -- what is it?
 * This is an Interface (a contract) for classes that want to listen to 
 * multiple different things at once. Instead of signing up one-by-one, 
 * a "Subscriber" provides a full list of everything it's interested in.
 *
 * -- how to imagine it:
 * Think of the "Back Page" of a magazine where you check off which topics 
 * you want to get updates for. You say "Send me the Sports news to my 
 * home phone, and the Weather news to my email."
 *
 * -- why this exists:
 * To keep things organized. If you have a class that handles "Logging", it 
 * might want to listen to 5 different database events. Instead of manually 
 * signing it up 5 times, it just says "Here is my list of 5 things I care about".
 */
interface EventSubscriberInterface
{
    /**
     * Get the list of all events this class wants to hear about.
     *
     * @return array<string, string> A map where the "News Type" is the key and your "Handler Method" is the value.
     */
    public function getSubscribedEvents(): array;
}

=== Foundation/Events/QueryExecuted.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events;

use Override;
use SensitiveParameter;

/**
 * The "Query Finished" Shout (Telemetry).
 *
 * -- what is it?
 * This is the message sent after a database query has successfully finished. 
 * It carries all the "Evidence" of the work: the SQL used, how long it 
 * took, and which database it talked to.
 *
 * -- how to imagine it:
 * Think of a "Delivery Confirmation". When a courier delivers a package, 
 * they send back a signal saying "Job done! It took 20 minutes, used this 
 * route, and arrived at the Front door."
 *
 * -- why this exists:
 * 1. Performance Tracking: It records exactly how many milliseconds the 
 *    query took. If your site is slow, you can look at these events to 
 *    find the "Slow Queries" that need fixing.
 * 2. Security (Redaction): It has a built-in "Privacy Mask". By default, 
 *    it hides the values you sent to the database (like passwords or 
 *    emails) so they don't end up in your logs as plain text. This 
 *    process is called "Redaction".
 * 3. Auditing: It provides a perfect trail for security audits, showing 
 *    exactly what queries were run and by which request.
 *
 * -- mental models:
 * - "Redaction": Using a black marker to hide private words on a document.
 * - "Bindings": The "Fill-in-the-blank" values you sent with the query.
 * - "Correlation ID": The "Luggage Tag" linking this query to THE specific 
 *    user request.
 */
final readonly class QueryExecuted extends Event
{
    /** @var array<array-key, mixed> THE values sent with the query (Safe or Redacted version). */
    public array $bindings;

    /** @var array<array-key, string> THE "Blacked-out" version of the values for public logs. */
    public array $redactedBindings;

    /** @var bool A checkmark: "Did we hide the private info?" */
    public bool $bindingsRedacted;

    /** @var array<array-key, mixed> THE "Raw" original values (Hidden from logs by PHP security). */
    #[SensitiveParameter]
    public array $rawBindings;

    /**
     * @param string $sql            The actual SQL text that was run.
     * @param array  $bindings       The "Fill-in-the-blank" values used.
     * @param float  $timeMs         How many milliseconds it took to finish.
     * @param string $connectionName The nickname of the database used.
     * @param string $correlationId  The Trace ID (Luggage Tag) for this request.
     * @param bool   $redactBindings Should we use the "Black Marker" to hide values in the main report?
     */
    #[Override]
    public function __construct(
        public string $sql,
        array $bindings,
        public float $timeMs,
        public string $connectionName,
        string $correlationId,
        bool $redactBindings = true
    ) {
        $this->rawBindings      = $bindings;
        $this->redactedBindings = self::redactBindings(bindings: $bindings);
        $this->bindingsRedacted = $redactBindings;
        $this->bindings         = $redactBindings ? $this->redactedBindings : $this->rawBindings;
        parent::__construct(correlationId: $correlationId);
    }

    /**
     * The internal "Black Marker" (Redactor).
     * 
     * -- how it works:
     * It takes all your input values and replaces them with the text 
     * "[REDACTED]". This keeps passwords and private data out of your 
     * log files.
     */
    private static function redactBindings(array $bindings): array
    {
        return array_map(callback: static fn($value) => '[REDACTED]', array: $bindings);
    }
}

=== Foundation/Events/Strategy/SyncDispatchStrategy.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events\Strategy;

use Avax\Database\Events\Contracts\DispatchStrategyInterface;
use Avax\Database\Events\Event;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * Technical execution engine for the synchronous distribution of system signals.
 *
 * -- intent:
 * Implements a "Blocking Dispatch" strategy where every registered observer 
 * is triggered immediately within the same request thread as the producer, 
 * ensuring predictable order and immediate state consistency.
 *
 * -- invariants:
 * - Observers must be executed sequentially in the order of registration.
 * - Individual observer failures must be defensively captured to prevent 
 *   disruption of the entire dispatch chain.
 * - Failures must be logged if an authorized technical logger is provided.
 *
 * -- boundaries:
 * - Does NOT support parallel execution or background processing.
 * - Only handles the physical invocation of listeners.
 */
final readonly class SyncDispatchStrategy implements DispatchStrategyInterface
{
    /**
     * @param LoggerInterface|null $logger Optional technical logger for capturing observer execution failures.
     */
    public function __construct(private ?LoggerInterface $logger = null) {}

    /**
     * Coordinate the sequential and defensive triggering of all authorized observers.
     *
     * -- intent:
     * Physically iterates through the listener collection, invoking each with 
     * the signal payload while providing a safety boundary to isolate 
     * cross-observer side-effects.
     *
     * @param Event              $event     The technical signal payload to be distributed.
     * @param iterable<callable> $listeners The collection of authorized technical handlers to be triggered.
     * @return void
     */
    public function handle(Event $event, iterable $listeners): void
    {
        foreach ($listeners as $listener) {
            try {
                $listener($event);
            } catch (Throwable $e) {
                // Defensive capture: isolate observer failure from the producer's thread.
                $this->logger?->error(
                    message: "Event listener execution failed: " . $e->getMessage(),
                    context: [
                        'event'     => $event::class,
                        'exception' => $e
                    ]
                );
            }
        }
    }
}

=== Foundation/Events/Subscribers/DatabaseLoggerSubscriber.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Events\Subscribers;

use Avax\Database\Config\Config;
use Avax\Database\Events\ConnectionAcquired;
use Avax\Database\Events\ConnectionFailed;
use Avax\Database\Events\ConnectionOpened;
use Avax\Database\Events\EventSubscriberInterface;
use Avax\Database\Events\QueryExecuted;
use Psr\Log\LoggerInterface;

/**
 * Infrastructure observer for logging database activity and lifecycle events.
 *
 * -- intent:
 * Centralizes technical telemetry across the database component for unified 
 * monitoring, security auditing, and performance profiling. It translates 
 * internal signals into standardized PSR-3 log entries.
 *
 * -- invariants:
 * - All log entries must include a correlation ID for request tracing.
 * - Sensitivity policies (redaction) must be enforced based on configuration or event flags.
 * - Critical failures (ConnectionFailed) must be recorded at ERROR level.
 *
 * -- boundaries:
 * - Does NOT perform specialized log aggregation (delegated to the PSR-3 implementation).
 * - Does NOT make performance optimizations based on the signals it observes.
 */
final readonly class DatabaseLoggerSubscriber implements EventSubscriberInterface
{
    /**
     * @param LoggerInterface $logger The PSR-3 logging implementation for outputting telemetry.
     * @param Config|null     $config Optional configuration registry for dynamic control over logging levels and redaction.
     */
    public function __construct(
        private LoggerInterface $logger,
        private ?Config         $config = null
    ) {}

    /**
     * Map database signal types to their corresponding handler logic.
     *
     * -- intent:
     * Declare the collection of events this observer is designed to monitor
     * and process.
     *
     * @return array<string, string> Collection mapping Event class names to handler method names.
     */
    public function getSubscribedEvents(): array
    {
        return [
            ConnectionOpened::class   => 'onConnectionOpened',
            ConnectionFailed::class   => 'onConnectionFailed',
            QueryExecuted::class      => 'onQueryExecuted',
            ConnectionAcquired::class => 'onConnectionAcquired',
        ];
    }

    /**
     * Record a log entry when a connection is retrieved from the resource pool.
     *
     * -- intent:
     * Track connection checkout frequency and recycling health (cache hits)
     * for pool optimization monitoring.
     *
     * @param ConnectionAcquired $event The signal payload containing acquisition details.
     * @return void
     */
    public function onConnectionAcquired(ConnectionAcquired $event): void
    {
        $this->logger->info(message: "Database connection acquired", context: [
            'correlation_id' => $event->correlationId,
            'connection'     => $event->connectionName,
            'recycled'       => $event->isRecycled,
            'timestamp'      => $event->timestamp,
        ]);
    }

    /**
     * Record a log entry when a fresh physical connection is established.
     *
     * -- intent:
     * Monitor the creation of new driver instances to detect potential
     * connection "churn" or pool exhaustion.
     *
     * @param ConnectionOpened $event The signal payload containing the new connection data.
     * @return void
     */
    public function onConnectionOpened(ConnectionOpened $event): void
    {
        $this->logger->info(message: "Database connection opened", context: [
            'correlation_id' => $event->correlationId,
            'connection'     => $event->connectionName,
            'timestamp'      => $event->timestamp,
        ]);
    }

    /**
     * Record a critical log entry when a driver negotiation failure occurs.
     *
     * -- intent:
     * Provide immediate visibility and technical context for connection
     * failures to assist in alerting and post-mortem analysis.
     *
     * @param ConnectionFailed $event The signal payload containing the failure exception.
     * @return void
     */
    public function onConnectionFailed(ConnectionFailed $event): void
    {
        $this->logger->error(message: "Database connection failed", context: [
            'correlation_id' => $event->correlationId,
            'connection'     => $event->connectionName,
            'exception'      => $event->exception->getMessage(),
            'timestamp'      => $event->timestamp,
        ]);
    }

    /**
     * Record a detailed log entry upon successful query completion.
     *
     * -- intent:
     * Document query performance and execution signatures while strictly
     * enforcing security redaction policies to prevent data leakage into logs.
     *
     * @param QueryExecuted $event The signal payload containing SQL, bindings, and timing data.
     * @return void
     */
    public function onQueryExecuted(QueryExecuted $event): void
    {
        $shouldRedact = $this->config?->get(key: 'logging.redact', default: true) ?? true;
        $includeRaw   = $this->config?->get(key: 'logging.include_raw_bindings', default: false) ?? false;

        $this->logger->debug(message: "Query executed", context: [
            'correlation_id' => $event->correlationId,
            'connection'     => $event->connectionName,
            'sql'            => $event->sql,
            'bindings'       => $shouldRedact || $event->bindingsRedacted ? $event->redactedBindings : $event->bindings,
            'raw_bindings'   => $includeRaw && ! $shouldRedact ? $event->rawBindings : '[REDACTED]',
            'time_ms'        => $event->timeMs,
            'timestamp'      => $event->timestamp,
        ]);
    }
}

=== Foundation/Exceptions/DatabaseException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Exceptions;

use RuntimeException;

/**
 * The "Parent Error" (Base Exception) for everything database-related.
 *
 * -- what is it?
 * This is the root class for every error in our database system. Whether 
 * it's a "Connection Failed" error or a "Table Not Found" error, they all 
 * share this parent.
 *
 * -- how to imagine it:
 * Think of it as a "Main Fuse Box". If any specific "Light" (Database component) 
 * fails, the signal eventually reaches this main box.
 *
 * -- why this exists:
 * To give developers a "Panic Button". Instead of trying to catch 50 different 
 * tiny errors, you can just say `catch (DatabaseException $e)` to catch 
 * ANYTHING that went wrong inside the database component in one go.
 */
abstract class DatabaseException extends RuntimeException implements DatabaseThrowable {}

=== Foundation/Exceptions/DatabaseThrowable.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Exceptions;

use Throwable;

/**
 * The "Database Error Badge" (Throwable Interface).
 *
 * -- what is it?
 * This is an Interface (a badge). It doesn't have any methods; it's simply 
 * a "Mark" that we put on any error class related to the database.
 *
 * -- how to imagine it:
 * Think of it as a "Yellow Sticker" placed on high-priority tools. If any 
 * tool (Error) has this sticker, you know it came from the Database department. 
 * If it doesn't have the sticker, it came from somewhere else (like the 
 * "Email" or "File" departments).
 *
 * -- why this exists:
 * To help developers "Sort" their errors. When an error happens, a 
 * developer can ask: "Does this error have the Database Badge?". If yes, 
 * they can handle it with database-specific logic (like "Try to reconnect").
 */
interface DatabaseThrowable extends Throwable {}

=== Foundation/Identity/IdentityMap.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Identity;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Avax\Database\Transaction\Exceptions\TransactionException;
use Throwable;

/**
 * The "To-Do List" (Identity Map) for your database changes.
 *
 * -- what is it?
 * In technical terms, this is a "Unit of Work". In plain language, it's a 
 * notepad where we write down all the changes you want to make to the 
 * database, but we don't do them yet.
 *
 * -- how to imagine it:
 * Imagine you're doing chores. Instead of running to the trash can every 
 * time you find a tiny piece of paper (which is slow), you put them all 
 * in a bag (this class). Once the bag is full, you take it to the trash 
 * can in one single trip.
 *
 * -- why this exists:
 * 1. Speed: Talking to the database is slow. Doing 100 things in one batch 
 *    is much faster than doing 100 individual trips.
 * 2. Accuracy: We keep track of which objects we've already "seen" so we 
 *    don't load the same data twice.
 * 3. Safety: It ensures that if you start a task, EITHER everything gets 
 *    done OR nothing gets done. No halfway finished work.
 *
 * -- mental models:
 * - "Flush/Execute": The moment we actually do all the "To-Do" items.
 *
 * -- what "deferred" means:
 * Changes are NOT written immediately. We first collect them in memory 
 * and only apply them after the surrounding operation (like a transaction) 
 * completes successfully. This prevents "partial writes" where half of 
 * your data is saved but the other half fails.
 *
 * -- what "identity map" means:
 * It's a "Memory" for database records. If you ask for User #1 twice, 
 * the system returns the SAME object both times rather than loading 
 * from the database again. This ensures that if you change User #1 in 
 * one part of the code, the change is "seen" everywhere else.
 */
final class IdentityMap
{
    /** @var array<string, mixed> A memory of every record we've already loaded. */
    private array $map = [];

    /** @var array<int, array{operation: string, sql: string, bindings: array}> The list of pending chores. */
    private array $deferred = [];

    /**
     * @param TransactionManagerInterface $transactionManager The "Safety Officer" who ensures the batch is atomic.
     * @param DatabaseConnection          $connection         The tool used to talk to the database driver.
     */
    public function __construct(
        private readonly TransactionManagerInterface $transactionManager,
        private readonly DatabaseConnection          $connection
    ) {}

    /**
     * Write a new chore onto our "To-Do List" (Schedule).
     *
     * -- what "schedule" means in this context:
     * It's the act of recording an intent. Instead of telling the 
     * database to do something now, we just write the SQL and the 
     * values into a private list (the 'deferred' array).
     *
     * -- when it happens:
     * The recording happens immediately in your computer's memory. 
     * The database knows NOTHING about this change yet.
     *
     * -- common pitfall:
     * Don't assume that calling this means the data is "saved". If 
     * your script crashes before 'execute()' is called, these 
     * changes will be lost forever. It's only a notepad, not a 
     * permanent record.
     *
     * @param string $operation What kind of change (e.g., 'INSERT', 'DELETE').
     * @param string $sql       The raw SQL command to run eventually.
     * @param array  $bindings  The secure values to plug into the command.
     */
    public function schedule(string $operation, string $sql, array $bindings = []): void
    {
        $this->deferred[] = compact('operation', 'sql', 'bindings');
    }

    /**
     * Do all the chores on the list right now (Execute).
     *
     * -- what "execute" means in this context:
     * It's the "Flush" moment. We take every single item we've been 
     * collecting in the 'deferred' list and send them to the 
     * database one by one inside a single safety bubble.
     *
     * -- when it happens:
     * It happens at the exact microsecond this method is called. 
     * Usually, this is triggered automatically at the end of a 
     * successful transaction.
     *
     * -- common pitfall:
     * If even ONE chore fails, the whole batch is rolled back. 
     * This means you shouldn't put "optional" or "unrelated" 
     * changes in the same Identity Map if they don't need to 
     * succeed together.
     *
     * @throws Throwable If any single chore fails or the database crashes.
     */
    public function execute(): void
    {
        if (empty($this->deferred)) {
            return;
        }

        $this->transactionManager->transaction(callback: function (TransactionManagerInterface $tx) {
            foreach ($this->deferred as $job) {
                $stmt = $tx->getConnection()->getConnection()->prepare(query: $job['sql']);
                if (! $stmt->execute(params: $job['bindings'])) {
                    throw new TransactionException(
                        message: "Failed to execute deferred operation: " . $job['operation'],
                        nestingLevel: 0
                    );
                }
            }
        });

        // Clear the list after we're done.
        $this->deferred = [];
    }
}

=== Foundation/Lifecycle/Kernel.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Registry\ModuleRegistry;
use Throwable;

/**
 * The "Engine Starter" (Kernel) for the database system.
 *
 * -- what is it?
 * This is the central brain that wake ups and shuts down the database system. 
 * Its job is to find all the different parts of the database (like the 
 * "Transaction Manager" or "Query Builder") and make sure they are 
 * plugged in and ready to work.
 *
 * -- how to imagine it:
 * Think of the "Ignition System" in a car. When you turn the key (`boot`), 
 * the Kernel checks the fuel, the spark plugs, and the battery (the modules) 
 * to make sure everything is working before the car starts moving. When you 
 * turn the car off (`shutdown`), it makes sure the lights and radio are 
 * turned off so the battery doesn't die.
 *
 * -- why this exists:
 * 1. Automation: You don't have to manually set up 50 different classes. 
 *    The Kernel reads a "Manifest" (a shopping list) of all modules and 
 *    sets them up for you.
 * 2. Order: It ensures things happen in the right order (Find -> Register 
 *    -> Start).
 * 3. Cleanup: It's responsible for the "Graceful Shutdown", making sure 
 *    no database connections are left hanging when the program finishes.
 *
 * -- mental models:
 * - "Boot": Waking up and preparing for work.
 * - "Shutdown": Cleaning up and going to sleep.
 * - "Manifest": The "Master List" of all features the database has.
 */
final class Kernel
{
    /**
     * @param Container      $container The "Toolbox" where we store all our services.
     * @param ModuleRegistry $registry  The "Librarian" who keeps track of which modules are active.
     */
    public function __construct(
        private readonly Container      $container,
        private readonly ModuleRegistry $registry
    ) {}

    /**
     * Wake up the entire database system (Boot).
     *
     * -- what "boot" means in this context:
     * It's the "Ignition Phase". We take all the dry configuration 
     * files and turn them into live, working software objects stored 
     * in the system's memory.
     *
     * -- when it happens:
     * This must be called at the very beginning of your application. 
     * Before 'boot()' is called, none of the database tools 
     * (like QueryBuilder) will exist or work.
     *
     * -- common pitfall:
     * Calling 'boot()' twice doesn't do anything extra, but it's 
     * a waste of time. Also, don't forget that if 'boot()' fails 
     * (throws an exception), your entire database system is 
     * consider "dead" and cannot be used.
     */
    public function boot(): void
    {
        $modules = Manifest::getModules();

        foreach ($modules as $name => $class) {
            $this->registry->register(name: $name, class: $class, container: $this->container);
        }

        $this->registry->boot();
    }

    /**
     * Shut everything down safely (Shutdown).
     *
     * -- what "shutdown" means in this context:
     * It's the "Cleanup Crew". It tells every active module to 
     * stop what they are doing, finish their pending work, and 
     * close their connection to the outside world.
     *
     * -- when it happens:
     * This is usually called at the very end of a request, 
     * just before the PHP script finishes execution.
     *
     * -- common pitfall:
     * If you skip 'shutdown()', you might leave "orphan" connections 
     * on your database server. If this happens too many times, your 
     * database will eventually refuse to accept new connections 
     * because it thinks the old ones are still "active".
     */
    public function shutdown(): void
    {
        $this->registry->shutdown();
    }
}

=== Foundation/Lifecycle/LifecycleInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

/**
 * The "Life Rules" (Lifecycle Contract) for database features.
 *
 * -- what is it?
 * This is an Interface (a contract). It defines the three most important 
 * moments in every database feature's life: Birth, Work, and Death.
 *
 * -- how to imagine it:
 * Think of the "Daily Schedule" for a worker. The schedule says:
 * 1. Morning (`register`): Get your tools ready and put them in your locker.
 * 2. Day (`boot`): Start your tasks and talk to your coworkers.
 * 3. Evening (`shutdown`): Turn off the machines, clean up your desk, and 
 *    go home.
 *
 * -- why this exists:
 * So that the `Kernel` (the boss) can manage every database feature (like 
 * "Transactions" or "Query Builder") exactly the same way. The boss 
 * doesn't need to know what a worker does, only that they follows this 
 * three-step daily schedule. This ensures the system starts up and shuts 
 * down perfectly every single time.
 */
interface LifecycleInterface
{
    /**
     * The "Birth" phase. Get your tools ready.
     *
     * -- intent:
     * This is where a module tells the system what "Service Recipes" it has. 
     * It adds its tools to the toolbox but doesn't start using them yet.
     */
    public function register(): void;

    /**
     * The "Working" phase. Start your engines.
     *
     * -- intent:
     * This is where the module actually "Wakes up". It can now talk to 
     * other modules and start performing its duties.
     */
    public function boot(): void;

    /**
     * The "Cleanup" phase. Turn off the lights.
     *
     * -- intent:
     * This is the final step. The module must close any open files or 
     * database connections and make sure everything is clean before 
     * it is destroyed.
     */
    public function shutdown(): void;
}

=== Foundation/Lifecycle/Manifest.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Lifecycle;

use Avax\Migrations\Module;

/**
 * The "Master Feature List" (Manifest).
 *
 * -- what is it?
 * This is a simple "Shopping List" or "Directory". It lists all the 
 * different features (Modules) that are currently available in the 
 * database system.
 *
 * -- how to imagine it:
 * Think of the "Index" or "Table of Contents" in a book. It tells you 
 * exactly which chapters exist and where to find them. The Kernel 
 * reads this list to know what it needs to "wake up" during the 
 * start-up process.
 *
 * -- why this exists:
 * To make the system modular. If you want to add a new feature to the 
 * database (like a "Caching Module"), you just add it to this list. 
 * The system will automatically find it, register it, and start it 
 * up without you having to change any other core code.
 *
 * -- mental models:
 * - "Module": A standalone "Chapter" of functionality (e.g., Transactions).
 * - "Discovery": The process of scanning this list to see what's ready to use.
 */
final class Manifest
{
    /**
     * Get the list of all active database features.
     *
     * -- how it works:
     * It looks at a predefined list of classes. For each one, it checks if 
     * the class "exists" and if it has a `declare()` method (the module's 
     * ID card). If everything looks good, it adds it to the active registry.
     *
     * @return array<string, string> A list of [Feature Nickname => Class Name].
     */
    public static function getModules(): array
    {
        $potentialModules = [
            \Avax\Database\Transaction\Module::class,
            \Avax\Database\QueryBuilder\Module::class,
            Module::class,
        ];

        $registry = [];
        foreach ($potentialModules as $class) {
            // We check if the class is actually there and if it follows our rules.
            if (class_exists(class: $class) && method_exists(object_or_class: $class, method: 'declare')) {
                $declaration                    = $class::declare();
                $registry[$declaration['name']] = $declaration['class'];
            }
        }

        return $registry;
    }
}

=== Foundation/Query/AST/JoinNode.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query\AST;

use Avax\Database\QueryBuilder\Core\Builder\JoinClause;

/**
 * Technical representation of a SQL JOIN operation within the query Abstract Syntax Tree (AST).
 *
 * -- intent:
 * Encapsulates all metadata required to compile a relational connection between 
 * two data sources, including the target table, join strategy, and logical conditions.
 *
 * -- invariants:
 * - Instances must be strictly immutable to ensure thread-safe query state management.
 * - Supports both simple column-comparison joins and complex, multi-clause join conditions.
 * - The 'type' property must correspond to a valid SQL join strategy (inner, left, right, etc).
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Does NOT validate the existence of columns or tables.
 */
final readonly class JoinNode
{
    /**
     * @param string          $table    The technical name of the target database table to be joined.
     * @param string          $type     The relational strategy for the join (e.g., 'inner', 'left', 'right', 'cross').
     * @param string|null     $first    The primary column label used in the comparison (Left-hand side).
     * @param string|null     $operator The SQL comparison operator (e.g., '=', '!=', 'LIKE').
     * @param string|null     $second   The secondary column label used in the comparison (Right-hand side).
     * @param JoinClause|null $clause   Optional container for complex, multi-condition join logic.
     */
    public function __construct(
        public string      $table,
        public string      $type = 'inner',
        public ?string     $first = null,
        public ?string     $operator = null,
        public ?string     $second = null,
        public ?JoinClause $clause = null
    ) {}
}

=== Foundation/Query/AST/NestedWhereNode.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query\AST;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;

/**
 * Technical representation of a nested logical grouping (SQL parentheses) within the query Abstract Syntax Tree (AST).
 *
 * -- intent:
 * Encapsulates a sub-query context that should be compiled as a grouped set 
 * of logical conditions, allowing for complex order-of-operation control 
 * (e.g., WHERE (a = 1 OR b = 2) AND c = 3).
 *
 * -- invariants:
 * - Instances must be strictly immutable to maintain query state stability.
 * - The 'query' property must contain a Builder instance representing the nested logical branch.
 * - The 'boolean' property determines the logical connection to the preceding outer constraint.
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Only handles the grouping of WHERE clauses; does NOT perform full sub-selects.
 */
final readonly class NestedWhereNode
{
    /**
     * @param QueryBuilder $query   The localized builder instance containing the nested logical criteria.
     * @param string       $boolean The logical joiner used to attach this group to the outer query scope ('AND' or 'OR').
     */
    public function __construct(
        public QueryBuilder $query,
        public string       $boolean = 'AND'
    ) {}
}

=== Foundation/Query/AST/OrderNode.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query\AST;

/**
 * Technical representation of a sorting instruction within the query Abstract Syntax Tree (AST).
 *
 * -- intent:
 * Encapsulates the specific metadata required to compile a SQL ORDER BY clause, 
 * supporting both simple field-based sorting and complex raw SQL sorting snippets.
 *
 * -- invariants:
 * - Instances must be strictly immutable to ensure safe query state propagation.
 * - The 'direction' property must represent a valid SQL sorting orientation (ASC/DESC).
 * - Distinguishes between standard column-based sorting and 'Raw' SQL fragments.
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Does NOT validate the technical existence of the specified sorting columns.
 */
final readonly class OrderNode
{
    /**
     * @param string|null $column    The technical identifier of the field to be used for sorting.
     * @param string      $direction The sorting orientation, strictly 'ASC' (ascending) or 'DESC' (descending).
     * @param string|null $sql       The literal SQL fragment to be used if the type is 'Raw'.
     * @param string      $type      The classification of the sorting node (e.g., 'Basic', 'Raw').
     */
    public function __construct(
        public ?string $column = null,
        public string  $direction = 'ASC',
        public ?string $sql = null,
        public string  $type = 'Basic'
    ) {}
}

=== Foundation/Query/AST/WhereNode.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query\AST;

/**
 * Technical representation of a logical filtering constraint within the query Abstract Syntax Tree (AST).
 *
 * -- intent:
 * Encapsulates the specific metadata required to compile a single SQL WHERE 
 * condition, distinguishing between basic comparisons, null checks, and raw fragments.
 *
 * -- invariants:
 * - Instances must be strictly immutable to maintain query state integrity across clones.
 * - The 'boolean' property determines the logical connection (AND/OR) to preceding constraints.
 * - The 'type' property signals to the Grammar how to handle the values and operator.
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Does NOT sanitize or validate the provided value (assumed sanitized by the builder).
 */
final readonly class WhereNode
{
    /**
     * @param string $column   The technical name of the field or a raw SQL fragment to be filtered.
     * @param string $operator The SQL comparison operator (e.g., '=', '<>', 'LIKE', 'IS NULL').
     * @param mixed  $value    The comparison target value, which may be a scalar, array, or null.
     * @param string $boolean  The logical joiner used to link this node ('AND' or 'OR').
     * @param string $type     The type classification of the constraint (e.g., 'Basic', 'Null', 'Raw').
     */
    public function __construct(
        public string $column,
        public string $operator,
        public mixed  $value = null,
        public string $boolean = 'AND',
        public string $type = 'Basic'
    ) {}
}

=== Foundation/Query/ColumnIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * Technical value object representing a database column identifier with optional aliasing.
 *
 * -- intent:
 * Encapsulates the technical metadata required to identify a specific data 
 * field within a query result set or source, facilitating standardized 
 * projection and relational mapping.
 *
 * -- invariants:
 * - Instances must be strictly immutable to ensure projection stability.
 * - Supports optional SQL aliasing ('AS' clause) for domain-specific labeling.
 *
 * -- boundaries:
 * - Does NOT perform character quoting (delegated to Grammar).
 * - Does NOT validate the technical existence of the column.
 */
final readonly class ColumnIdentifier
{
    /**
     * @param string      $name  The technical identifier of the database column.
     * @param string|null $alias The optional domain-specific label (alias) for the projection.
     */
    public function __construct(
        public string      $name,
        public string|null $alias = null
    ) {}

    /**
     * Convert the technical identifier into a displayable SQL-like string format.
     *
     * -- intent:
     * Provides a standardized string representation of the column and its 
     * alias, primarily used for diagnostic logging and early-stage compilation.
     *
     * @return string The raw technical representation of the column identifier.
     */
    public function __toString(): string
    {
        if ($this->alias === null) {
            return $this->name;
        }

        return "{$this->name} AS {$this->alias}";
    }
}

=== Foundation/Query/Condition.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * technical value object encapsulating a single logical comparison constraint (Condition).
 *
 * -- intent:
 * Provides a standardized, immutable container for transporting logical 
 * filtering criteria (column, operator, value) from the QueryBuilder to the 
 * Grammar engine for final SQL compilation.
 *
 * -- invariants:
 * - Instances must be strictly immutable to maintain query state integrity.
 * - Captures the full state of a logical query filter in a dialect-neutral format.
 * - The 'boolean' property determines the logical connection (AND/OR) to preceding filters.
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Does NOT sanitize or validate the provided value (assumed sanitized by the producer).
 */
final readonly class Condition
{
    /**
     * @param string $column   The technical identifier of the database column to be filtered.
     * @param string $operator The logical comparison operator (e.g., '=', '<', '>', 'LIKE').
     * @param mixed  $value    The comparison target value (scalar, array, or expression).
     * @param string $boolean  The logical joiner used to link this condition ('AND' or 'OR').
     */
    public function __construct(
        public string $column,
        public string $operator,
        public mixed  $value,
        public string $boolean = 'AND'
    ) {}
}

=== Foundation/Query/PaginationOptions.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * technical value object encapsulating pagination parameters for large-scale dataset traversal.
 *
 * -- intent:
 * Provides a structured, type-safe representation of record offsets and limits, 
 * abstracting the calculations required to transform high-level "Page" 
 * concepts into physical SQL "OFFSET" and "LIMIT" instructions.
 *
 * -- invariants:
 * - Instances must be strictly immutable.
 * - Page indices are assumed to be 1-based for application-level consistency.
 * - Logical offsets are calculated based on page size (perPage).
 *
 * -- boundaries:
 * - Does NOT perform the technical SQL retrieval.
 * - Does NOT handle the total result set counting (delegated to Aggregates).
 */
final readonly class PaginationOptions
{
    /**
     * @param int      $page    The current logical 1-based page index.
     * @param int      $perPage The technical volume of records to be retrieved per resulting page.
     * @param int|null $total   The optional total record count discovered for calculating pagination metadata.
     */
    public function __construct(
        public int      $page = 1,
        public int      $perPage = 15,
        public int|null $total = null
    ) {}

    /**
     * Coordinate the calculation of the technical record offset for SQL execution.
     *
     * -- intent:
     * Transforms the logical application-level page number into the physical 
     * record offset required by the database driver.
     *
     * @return int The calculated physical record offset (0-based).
     */
    public function getOffset(): int
    {
        return ($this->page - 1) * $this->perPage;
    }
}

=== Foundation/Query/QueryState.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

use Avax\Database\Query\AST\JoinNode;
use Avax\Database\Query\AST\NestedWhereNode;
use Avax\Database\Query\AST\OrderNode;
use Avax\Database\Query\AST\WhereNode;
use Avax\Database\Query\ValueObjects\BindingBag;

/**
 * Immutable technical state container for database query metadata.
 *
 * -- intent:
 * Prevents any shared-state mutations and ensures strictly deterministic SQL 
 * compilation by encapsulating all query parameters (projection, sources, 
 * filters, ordering) in a read-only structure. This follows the 
 * functional-style builder pattern where every state transition yields 
 * a fresh, isolated container.
 *
 * -- invariants:
 * - Instances must be strictly immutable; every modification returns a new instance.
 * - BindingBag must never leak raw state during construction or modification.
 * - All structural nodes (where, join, order) must be represented as specialized DTOs.
 * - All state transitions are atomic and self-contained.
 *
 * -- boundaries:
 * - Does NOT perform physical SQL compilation or dialect negotiation (delegated to Grammar).
 * - Does NOT validate the semantic correctness of the query (e.g., column existence).
 * - Does NOT interact with the persistence layer (delegated to Executor).
 */
final readonly class QueryState
{
    /**
     * @param string[]                         $columns       The list of technical column identifiers or expressions for projection.
     * @param string|null                      $from          The primary technical identifier for the data source (table).
     * @param JoinNode[]                       $joins         The collection of structural nodes representing source relationships.
     * @param array<WhereNode|NestedWhereNode> $wheres        The hierarchical collection of logical filters and branches.
     * @param string[]                         $groups        The collection of column identifiers used for result aggregation.
     * @param array                            $havings       The collection of logical filters applied to aggregate sets.
     * @param OrderNode[]                      $orders        The collection of structural nodes defining the result set sequence.
     * @param int|null                         $limit         The strictly enforced upper limit of records to be retrieved.
     * @param int|null                         $offset        The number of records to bypass before the retrieval window starts.
     * @param array                            $values        The associative map of column/value pairs for mutation operations.
     * @param string[]                         $updateColumns The specific technical columns targeted for update or upsert logic.
     * @param bool                             $distinct      Toggle indicating if strictly unique records should be projected.
     * @param BindingBag                       $bindings      The immutable container for secure, parameterized query tokens.
     */
    public function __construct(
        public array       $columns = ['*'],
        public string|null $from = null,
        public array       $joins = [],
        public array       $wheres = [],
        public array       $groups = [],
        public array       $havings = [],
        public array       $orders = [],
        public int|null    $limit = null,
        public int|null    $offset = null,
        public array       $values = [],
        public array       $updateColumns = [],
        public bool        $distinct = false,
        private BindingBag $bindings = new BindingBag()
    ) {}

    /**
     * Coordinate the assignment of a primary technical data source.
     *
     * -- intent:
     * Defines the source table (FROM) for the upcoming SQL operation, 
     * returning a fresh state to maintain transition isolation.
     *
     * @param string $table The physical identifier of the target database table.
     * @return self A fresh QueryState instance with the applied source.
     */
    public function withFrom(string $table): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'from' => $table]
        );
    }

    /**
     * Coordinate the definition of the data projection (SELECT) columns.
     *
     * -- intent:
     * Overwrites the current columns collection with a new set of projecting 
     * technical identifiers or expressions.
     *
     * @param string[] $columns The collection of technical column identifiers for the projection.
     * @return self A fresh QueryState instance with the applied projection.
     */
    public function withColumns(array $columns): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'columns' => $columns]
        );
    }

    /**
     * Coordinate the enforcement of result set uniqueness (DISTINCT).
     *
     * -- intent:
     * Sets the technical flag that instructs the Grammar to include 
     * the DISTINCT keyword in the compiled projection.
     *
     * @param bool $distinct Flag indicating if unique records are required.
     * @return self A fresh QueryState instance with the applied flag.
     */
    public function withDistinct(bool $distinct = true): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'distinct' => $distinct]
        );
    }

    /**
     * Coordinate the setting of a strictly enforced record limit.
     *
     * -- intent:
     * Caps the number of records retrieved by the persistence engine, 
     * typically used for pagination or existence checks.
     *
     * @param int|null $limit The maximum record volume allowed in the result set.
     * @return self A fresh QueryState instance with the applied limit.
     */
    public function withLimit(int|null $limit): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'limit' => $limit]
        );
    }

    /**
     * Coordinate the setting of a record bypass offset.
     *
     * -- intent:
     * Skip a specified number of leading records in the retrieval window, 
     * essential for deep-traversal pagination logic.
     *
     * @param int|null $offset The technical volume of records to skip.
     * @return self A fresh QueryState instance with the applied offset.
     */
    public function withOffset(int|null $offset): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'offset' => $offset]
        );
    }

    /**
     * Coordinate the attachment of technical data for mutation operations.
     *
     * -- intent:
     * Stores the key-value map representing the new state to be persisted 
     * in an INSERT or UPDATE context.
     *
     * @param array $values The associative map of technical column/value pairs.
     * @return self A fresh QueryState instance with the applied mutation payload.
     */
    public function withValues(array $values): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'values' => $values]
        );
    }

    /**
     * Coordinate the targeting of specific columns for modification.
     *
     * -- intent:
     * Defines a subset of technical columns that should be updated, 
     * typically used in complex UPSERT or partial UPDATE scenarios.
     *
     * @param string[] $columns The collection of technical identifiers allowed for update.
     * @return self A fresh QueryState instance with the applied target columns.
     */
    public function withUpdateColumns(array $columns): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'updateColumns' => $columns]
        );
    }

    /**
     * Coordinate the addition of a source relationship (JOIN).
     *
     * -- intent:
     * Appends a new structural node defining a relationship with another 
     * data source to the existing joins collection.
     *
     * @param JoinNode $join The structural node abstraction defining the join relationship.
     * @return self A fresh QueryState instance with the added relationship.
     */
    public function addJoin(JoinNode $join): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'joins' => [...$this->joins, $join]]
        );
    }

    /**
     * Coordinate the addition of a logical filtering instruction (WHERE).
     *
     * -- intent:
     * Appends a new logical node (atomic or hierarchical) to the hierarchical 
     * filtering bag for later SQL compilation.
     *
     * @param WhereNode|NestedWhereNode $where The logical node abstraction representing a query filter.
     * @return self A fresh QueryState instance with the added filter.
     */
    public function addWhere(WhereNode|NestedWhereNode $where): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'wheres' => [...$this->wheres, $where]]
        );
    }

    /**
     * Coordinate the addition of an aggregation column (GROUP BY).
     *
     * -- intent:
     * Incorporates a new technical identifier into the collection used 
     * for record grouping and server-side analysis.
     *
     * @param string $column The structural identifier of the column to group by.
     * @return self A fresh QueryState instance with the added grouping instruction.
     */
    public function addGroup(string $column): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'groups' => [...$this->groups, $column]]
        );
    }

    /**
     * Coordinate the bulk definition of record grouping criteria.
     *
     * -- intent:
     * Overwrites the current grouping collection with a new set of technical 
     * identifiers for aggregation.
     *
     * @param string[] $groups The collection of column identifiers for aggregation.
     * @return self A fresh QueryState instance with the bulk applied groups.
     */
    public function withGroups(array $groups): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'groups' => $groups]
        );
    }

    /**
     * Coordinate the addition of an aggregate result filter (HAVING).
     *
     * -- intent:
     * Appends a logical condition applied to groups/aggregates, maintaining 
     * the collection of aggregate-level constraints.
     *
     * @param array $having The technical data representing an aggregate filter.
     * @return self A fresh QueryState instance with the added aggregate filter.
     */
    public function addHaving(array $having): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'havings' => [...$this->havings, $having]]
        );
    }

    /**
     * Coordinate the addition of a result set ordering instruction (ORDER BY).
     *
     * -- intent:
     * Appends a sorting abstraction to the collection, defining the final 
     * chronological or alphabetic sequence of the retrieved data.
     *
     * @param OrderNode $order The structural abstraction defining the sorting logic.
     * @return self A fresh QueryState instance with the applied sorting.
     */
    public function addOrder(OrderNode $order): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'orders' => [...$this->orders, $order]]
        );
    }

    /**
     * Coordinate the secure attachment of a technical parameter token.
     *
     * -- intent:
     * Delegates the value to the protective BindingBag to ensure it is 
     * handled as a bound parameter, preventing SQL injection.
     *
     * @param mixed $value The raw technical data value to be sanitized and bound.
     * @return self A fresh QueryState instance with the secured parameter.
     */
    public function addBinding(mixed $value): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'bindings' => $this->bindings->with(value: $value)]
        );
    }

    /**
     * Coordinate the secure bulk attachment of technical parameter tokens.
     *
     * -- intent:
     * Facilitates the mass-parameterization of query values while 
     * maintaining immutable state transitions.
     *
     * @param array $values The collection of raw data tokens to be secured.
     * @return self A fresh QueryState instance with the merged parameter tokens.
     */
    public function mergeBindings(array $values): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'bindings' => $this->bindings->merge(parameters: $values)]
        );
    }

    /**
     * Coordinate the complete reset of the secure parameter bag.
     *
     * -- intent:
     * Provides a clean slate for parameterization, typically used when a 
     * query is reused or forked for a significantly different compilation.
     *
     * @return self A fresh QueryState instance with a cleared parameter bag.
     */
    public function resetBindings(): self
    {
        return new self(
            ...[...get_object_vars(object: $this), 'bindings' => new BindingBag()]
        );
    }

    /**
     * Retrieve the comprehensive collection of secure parameter values.
     *
     * -- intent:
     * Exposes the final, linearized collection of parameters for consumption 
     * by the persistence driver after SQL compilation.
     *
     * @return array<array-key, mixed> THE collection of raw data tokens to be parameterized.
     */
    public function getBindings(): array
    {
        return $this->bindings->all();
    }
}

=== Foundation/Query/QuotedIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * technical value object representing a database identifier that has already been sanitized and quoted.
 *
 * -- intent:
 * Optimizes the SQL compilation process by explicitly flagging technical 
 * identifiers (columns, tables) that have already been processed by a driver-specific 
 * quoting technician, preventing redundant double-quoting and potential syntax errors.
 *
 * -- invariants:
 * - Instances must be strictly immutable to maintain identifier integrity.
 * - The encapsulated value is assumed to be technical SQL ready for injection.
 * - Supports seamless integration through the Stringable contract.
 *
 * -- boundaries:
 * - Does NOT perform the technical quoting (delegated to Grammar).
 * - Does NOT validate the identifier's existence or semantic correctness.
 */
final readonly class QuotedIdentifier
{
    /**
     * @param string $value The pre-sanitized and dialect-aware quoted identifier technical string.
     */
    public function __construct(public string $value) {}

    /**
     * Retrieve the encapsulated quoted identifier as a primitive technical string.
     *
     * -- intent:
     * Support seamless integration with string-based SQL concatenation 
     * during the final compilation phase.
     *
     * @return string The raw quoted identifier string.
     */
    public function __toString(): string
    {
        return $this->value;
    }
}

=== Foundation/Query/TableIdentifier.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query;

/**
 * technical value object representing a database table identifier with optional aliasing.
 *
 * -- intent:
 * Encapsulates the technical metadata required to identify a data source 
 * (table) within a query, facilitating standardized source targeting and 
 * relational linking across builder layers.
 *
 * -- invariants:
 * - Instances must be strictly immutable to ensure source stability.
 * - Supports optional SQL aliasing ('AS' clause) for complex joined queries.
 *
 * -- boundaries:
 * - Does NOT perform character quoting (delegated to Grammar).
 * - Does NOT validate the technical existence of the table in the schema.
 */
final readonly class TableIdentifier
{
    /**
     * @param string      $name  The technical identifier (physical name) of the database table.
     * @param string|null $alias The optional domain-specific label (alias) assigned to the table source.
     */
    public function __construct(
        public string      $name,
        public string|null $alias = null
    ) {}

    /**
     * Convert the technical table identifier into a displayable SQL-like string format.
     *
     * -- intent:
     * Provides a standardized string representation of the table and its alias, 
     * primarily used for diagnostic logging and high-level SQL targeting.
     *
     * @return string The raw technical representation of the table identifier.
     */
    public function __toString(): string
    {
        if ($this->alias === null) {
            return $this->name;
        }

        return "{$this->name} AS {$this->alias}";
    }
}

=== Foundation/Query/ValueObjects/BindingBag.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Query\ValueObjects;

/**
 * Immutable container for query parameter bindings.
 *
 * -- intent:
 * Prevents "binding bleed" and ensures strict state isolation for SQL 
 * parameterization by encapsulating all data values in a read-only structure.
 *
 * -- invariants:
 * - The bag must be strictly immutable; all modification methods return a new instance.
 * - Internal value storage must preserve the order of insertion.
 * - Binding values are kept raw until serialized for the driver.
 *
 * -- boundaries:
 * - Does NOT perform type casting or serialization logic.
 * - Does NOT validate the structure of the SQL query.
 * - Does NOT handle naming of parameters (assumes positional placeholders).
 */
final readonly class BindingBag
{
    /**
     * @param array<array-key, mixed> $values The internal storage for raw, sanitized query parameters.
     */
    public function __construct(
        private array $values = []
    ) {}

    /**
     * Create a new bag instance containing an additional parameter value.
     *
     * -- intent:
     * Appends a value to the current binding sequence while maintaining the 
     * immutability of the existing state.
     *
     * @param mixed $value The data token to be added and eventually parameterized.
     * @return self A fresh BindingBag instance containing the new value.
     */
    public function with(mixed $value): self
    {
        $values   = $this->values;
        $values[] = $value;

        return new self(values: $values);
    }

    /**
     * Merge a collection of multiple parameters into a new bag instance.
     *
     * -- intent:
     * Perform bulk addition of multiple data tokens for SQL parameterization
     * without mutating existing state.
     *
     * @param array<array-key, mixed> $parameters A collection of raw data values to be bound.
     * @return self A fresh BindingBag instance containing the merged sequence of values.
     */
    public function merge(array $parameters): self
    {
        return new self(values: array_merge($this->values, $parameters));
    }

    /**
     * Retrieve all bound parameters as a flattened, ordered array.
     *
     * -- intent:
     * Provide the final sequence of data tokens to be injected into the
     * prepared statement by the database driver.
     *
     * @return array<array-key, mixed> A collection of all raw, ordered parameter values.
     */
    public function all(): array
    {
        return $this->values;
    }

    /**
     * Check if the bag is currently devoid of any parameter bindings.
     *
     * -- intent:
     * Determine if the query context requires any data points for safe 
     * parameter substitution.
     *
     * @return bool True if no parameters are currently bound, false otherwise.
     */
    public function isEmpty(): bool
    {
        return empty($this->values);
    }
}

=== Foundation/Registry/Exceptions/ModuleException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Registry\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * A "Feature Failure" report (Module Error).
 *
 * -- what is it?
 * This is a specialized error that happens when something goes wrong with 
 * a specific database "Feature" (Module) while it's starting up or 
 * shutting down.
 *
 * -- how to imagine it:
 * Think of an "Accident Report" in a factory. It doesn't just say 
 * "Something broke"; it says "The conveyor belt broke while we were 
 * trying to turn it on (Boot phase)."
 *
 * -- why this exists:
 * To provide laser-focused diagnostics. It tells you two critical things:
 * 1. Which exact feature failed (e.g., 'QueryBuilder').
 * 2. What it was doing at the time ('Registering', 'Booting', or 'Shutdown').
 *
 * -- mental models:
 * - "Phase": The specific stage of a module's life (Born -> Working -> Dying).
 * - "Immutable": The details of this report cannot be changed once written.
 */
final class ModuleException extends DatabaseException
{
    /**
     * @param string         $moduleClass The name of the feature class that failed.
     * @param string         $phase       The step it was on (e.g., 'booting', 'registering').
     * @param string         $message     A clear explanation of what went wrong.
     * @param Throwable|null $previous    The raw system error that caused the crash.
     */
    #[Override]
    public function __construct(
        private readonly string $moduleClass,
        private readonly string $phase,
        string                  $message,
        Throwable|null          $previous = null
    ) {
        parent::__construct(
            message: "Module [{$moduleClass}] failed during [{$phase}]: {$message}",
            code: 0,
            previous: $previous
        );
    }

    /**
     * Get the name of the problematic feature.
     */
    public function getModuleClass(): string
    {
        return $this->moduleClass;
    }

    /**
     * Get the stage of life where the error happened.
     */
    public function getPhase(): string
    {
        return $this->phase;
    }
}

=== Foundation/Registry/ModuleRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Registry;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\Registry\Exceptions\ModuleException;
use Throwable;

/**
 * The "Librarian" (Module Registry) of the Database features.
 *
 * -- what is it?
 * This is the central repository that manages the lifecycle of every 
 * feature module in the system. When the Kernel finds a new feature, 
 * it hands it to this Librarian to be organized, started, and eventually 
 * cleaned up.
 *
 * -- how to imagine it:
 * Think of a "Project Manager" or a "Librarian". They have a list of 
 * all the "Books" (Modules) in the library. They know which ones are 
 * checked in, which ones are open and working (`booted`), and they 
 * make sure that when the library closes, every book is put back on 
 * the shelf properly (`shutdown`).
 *
 * -- why this exists:
 * 1. Coordination: Features often depend on each other. The Librarian 
 *    ensures that every feature is "Registered" (added to the list) 
 *    before any of them are allowed to "Boot" (start working).
 * 2. Error Handling: If a feature fails to start, the Librarian catches 
 *     the error and provides a clear report (`ModuleException`) explaining 
 *    which feature broke and during which phase.
 * 3. Graceful Exit: It guarantees that no feature is left in a messy state 
 *    when the application finishes.
 *
 * -- mental models:
 * - "Register": Adding a feature to the team.
 * - "Boot": Telling a feature to start its engine.
 * - "Shutdown": Telling everyone to clean up and go home.
 *
 * -- what "lifecycle" means:
 * It's the "Birth, Life, and Death" of a piece of software. Instead 
 * of just letting code run randomly, we force it to follow a strict 
 * schedule: First it must be "Born" (Created), then it "Starts Up" 
 * (Boot), and finally it "Cleans Up" (Shutdown). This structure 
 * makes the system stable and predictable.
 */
final class ModuleRegistry
{
    /** @var array<string, LifecycleInterface> The collection of all features currently on the team. */
    private array $modules = [];

    /** @var array<string, bool> A list of which team members have finished their "Start-up" logic. */
    private array $booted = [];

    /**
     * Invite a new feature to the team (Register).
     *
     * -- what "register" means in this context:
     * It's the "Introduction Phase". We create the module object and 
     * let it announce which tools it wants to put into the common 
     * shared Toolbox (Container).
     *
     * -- when it happens:
     * This is the very first step of a module's life. It happens 
     * during the Kernel's 'boot' sequence.
     *
     * -- common pitfall:
     * At this stage, the module exists but IT IS CLOSED. You cannot 
     * use its main features yet. It's like a shop that has just 
     * received its inventory but hasn't opened its doors to customers.
     *
     * @param string    $name      The nickname of the feature (e.g., 'query_builder').
     * @param string    $class     The technical class name (the recipe) for the feature.
     * @param Container $container The "Toolbox" where the feature will store its tools.
     * @throws ModuleException If the feature is missing or refuses to join the team.
     */
    public function register(string $name, string $class, Container $container): void
    {
        if (! class_exists(class: $class)) {
            throw new ModuleException(moduleClass: $class, phase: 'registration', message: "Module class not found.");
        }

        try {
            // We create a fresh instance of the feature.
            $module = new $class(container: $container);

            if (! $module instanceof LifecycleInterface) {
                throw new ModuleException(
                    moduleClass: $class,
                    phase: 'registration',
                    message: "Module must implement LifecycleInterface."
                );
            }

            // We tell the feature to put its tools in the toolbox.
            $module->register();
            $this->modules[$name] = $module;
        } catch (Throwable $e) {
            throw new ModuleException(
                moduleClass: $class,
                phase: 'registration',
                message: $e->getMessage(),
                previous: $e
            );
        }
    }

    /**
     * Start the engine for every registered feature (Boot).
     *
     * -- what "boot" means in this context:
     * It's the "Grand Opening". We tell every module that registration 
     * is over and they are now allowed to start their internal 
     * engines, open connections, and begin working.
     *
     * -- when it happens:
     * It happens once all modules have been registered. This ensures 
     * that Module A can talk to Module B, because we know Module B's 
     * registration is already finished.
     *
     * -- common pitfall:
     * Don't confuse this with the Kernel's 'boot()'. The Kernel is 
     * the manager who *calls* this method. If you call this manually, 
     * you might be bypassing important setup steps.
     *
     * @throws ModuleException If a feature fails to start correctly.
     */
    public function boot(): void
    {
        foreach ($this->modules as $name => $module) {
            if (! isset($this->booted[$name])) {
                try {
                    $module->boot();
                    $this->booted[$name] = true;
                } catch (Throwable $e) {
                    throw new ModuleException(
                        moduleClass: $module::class,
                        phase: 'boot',
                        message: $e->getMessage(),
                        previous: $e
                    );
                }
            }
        }
    }

    /**
     * Tell everyone to clean up and go home (Shutdown).
     *
     * -- what "shutdown" means in this context:
     * It's the "Final Goodbye". We go through our list of active 
     * modules and tell them to close their files, log their last 
     * entries, and disconnect from any remote servers.
     *
     * -- when it happens:
     * It's triggered at the very end of the system's life, usually 
     * right before the script exits.
     *
     * -- common pitfall:
     * Once 'shutdown()' is called, the registry is WIPED CLEAN. 
     * You cannot "re-start" the system without calling 'register' 
     * and 'boot' all over again from the beginning.
     */
    public function shutdown(): void
    {
        foreach ($this->modules as $module) {
            try {
                $module->shutdown();
            } catch (Throwable $e) {
                throw new ModuleException(
                    moduleClass: $module::class,
                    phase: 'shutdown',
                    message: $e->getMessage(),
                    previous: $e
                );
            }
        }

        // Reset the registry to an empty state.
        $this->modules = [];
        $this->booted  = [];
    }

    /**
     * Find a specific active feature by its nickname.
     *
     * @param string $name The nickname (e.g., 'query_builder').
     * @return LifecycleInterface The requested feature.
     */
    public function getModule(string $name): LifecycleInterface
    {
        if (! isset($this->modules[$name])) {
            throw new ModuleException(moduleClass: $name, phase: 'retrieval', message: "Module not registered.");
        }

        return $this->modules[$name];
    }
}

=== Foundation/Support/ExecutionScope.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Support;

use Random\RandomException;

/**
 * A "Passenger Ticket" for your database operations.
 *
 * -- what is it?
 * This object holds the "Context" of what's happening. The most important 
 * part is the `correlationId`—a unique ID for the current request.
 *
 * -- how to imagine it:
 * Think of it as a luggage tag. Every query that happens during a 
 * single request gets the SAME luggage tag. If something breaks, you can 
 * look at the logs and find all the queries that share that same tag.
 *
 * -- why this exists:
 * In a busy system, thousands of queries might happen at once. Without 
 * this scope, your logs would be a giant mess of mixed-up lines. This 
 * scope helps you "thread the needle" and see only the queries that 
 * belong to ONE specific user or action.
 *
 * -- mental models:
 * - "Correlation ID": A social security number for a request. It links 
 *    different events together.
 * - "Metadata": Extra notes you want to carry along (e.g., "User ID: 123", 
 *    "Page: Checkout").
 */
final readonly class ExecutionScope
{
    /**
     * @param string $correlationId The unique "Trace ID" for this specific run.
     * @param array  $metadata      Any extra notes you want to carry with the query for logging.
     */
    public function __construct(
        public string $correlationId,
        public array  $metadata = []
    ) {}

    /**
     * Create a brand new "Ticket" (Scope) with a random unique ID.
     *
     * @param array $metadata Initial notes to include on the ticket.
     * @return self A fresh, ready-to-use context object.
     * @throws RandomException If the computer's "dice roller" fails to generate a unique ID.
     */
    public static function fresh(array $metadata = []): self
    {
        $id = bin2hex(string: random_bytes(length: 8));

        return new self(correlationId: $id, metadata: $metadata);
    }
}

=== Foundation/Support/SequenceTracker.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Support;

/**
 * The "Number Clicker" (Sequence Tracker).
 *
 * -- what is it?
 * This is a very simple tool that gives out numbers in order (1, 2, 3...). 
 * It's primarily used to tag events so we know exactly which one happened 
 * first.
 *
 * -- how to imagine it:
 * Think of the "Take a Number" machine at a deli counter. Every event 
 * that happens in the database pulls a ticket from this machine, so 
 * we can perfectly reconstruct the order of events later, even if 
 * they happen only microseconds apart.
 *
 * -- why this exists:
 * To provide a "Source of Truth" for time. Computers can sometimes have 
 * tiny fluctuations in their clocks, but a simple counter never lies 
 * about the order of arrival.
 *
 * -- mental models:
 * - "Monotonic": It only ever goes UP. It never repeats and never goes 
 *   backwards.
 */
final class SequenceTracker
{
    /** @var int The current number on the clicker. */
    private static int $counter = 0;

    /**
     * Pull the next number from the machine.
     *
     * @return int The next number in the chain.
     */
    public static function next(): int
    {
        return ++self::$counter;
    }
}

=== Foundation/Transaction/Contracts/TransactionManagerInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction\Contracts;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Throwable;

/**
 * technical contract defining the authoritative capabilities for coordinating atomic database transactions.
 *
 * -- intent:
 * Establishes a dialect-neutral, consistent interface for managing the 
 * lifecycle of atomic database operations, ensuring that ACID properties 
 * can be enforced across the entire system persistence layer.
 *
 * -- invariants:
 * - Implementation must maintain transactional depth (nesting) to prevent premature commits.
 * - Every manual transition (Begin/Commit/Rollback) must return the manager for fluent chaining.
 * - Callback-based transaction management must provide automated recovery.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation or result projection (QueryBuilder domain).
 * - Depends on the DatabaseConnection contract for driver-level negotiations.
 */
interface TransactionManagerInterface
{
    /**
     * Coordinate the execution of a professional technical closure within a managed database transaction.
     *
     * -- intent:
     * Provides a high-level orchestration for executing a unit of work that 
     * requires strict atomicity, ensuring automated ROLLBACK upon failure 
     * and COMMIT upon success.
     *
     * @param callable $callback The technical logic (unit of work) to be executed within the protected scope.
     * @throws Throwable If the technical transaction management or callback execution fails.
     * @return mixed The scalar or composite result returned by the provided callback.
     */
    public function transaction(callable $callback): mixed;

    /**
     * Physically signal the start of a fresh technical transaction window on the database driver.
     *
     * -- intent:
     * Instructs the persistence engine to open a protected session window, 
     * buffering subsequent mutations until a finalization signal is received.
     *
     * @return TransactionManagerInterface The current manager instance for continued fluent configuration.
     */
    public function begin(): TransactionManagerInterface;

    /**
     * Coordinate the permanent persistence of all technical changes made within the current transaction window.
     *
     * -- intent:
     * Instructs the persistence engine to finalize the atomic sequence and 
     * permanently commit all buffered mutations to non-volatile storage.
     *
     * @return TransactionManagerInterface The current manager instance.
     */
    public function commit(): TransactionManagerInterface;

    /**
     * Coordinate the technical reversion of all changes made during the active transaction window.
     *
     * -- intent:
     * Discards all buffered mutations and restores the database state to the 
     * moment the current transaction window was initiated, safeguarding data integrity.
     *
     * @return TransactionManagerInterface The current manager instance.
     */
    public function rollback(): TransactionManagerInterface;

    /**
     * Retrieve the authorized technical connection gateway managed by this authority.
     *
     * -- intent:
     * Provides authorized access to the technical connection instance that 
     * is currently bound to the transaction lifecycle.
     *
     * @return DatabaseConnection The active transaction-bound persistence gateway.
     */
    public function getConnection(): DatabaseConnection;
}

=== Foundation/Transaction/Exceptions/TransactionException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * technical exception triggered when a database transaction-level operation fails.
 *
 * -- intent:
 * Provides specific technical context for failures occurring during the 
 * coordination of atomic persistence sequences, capturing both the failure 
 * description and the transaction nesting depth to facilitate precise diagnostic analysis.
 *
 * -- invariants:
 * - Instances must be strictly immutable to maintain error condition integrity.
 * - Always includes the technical transaction depth (nesting level) at the moment of failure.
 * - Supports chaining via the native technical 'previous' exception mechanism.
 *
 * -- boundaries:
 * - Does NOT perform transaction recovery; strictly used for classification and reporting.
 * - Inherits from the base DatabaseException contract.
 */
final class TransactionException extends DatabaseException
{
    /**
     * @param string         $message      The detailed technical description of the transaction coordination failure.
     * @param int            $nestingLevel The technical transaction depth (0-based or 1-based) when the failure was intercepted.
     * @param Throwable|null $previous     The underlying technical driver or unit-of-work exception.
     */
    #[Override]
    public function __construct(
        string               $message,
        private readonly int $nestingLevel,
        Throwable|null       $previous = null
    ) {
        parent::__construct(
            message: "Transaction failed (Level {$nestingLevel}): {$message}",
            code: 0,
            previous: $previous
        );
    }

    /**
     * Retrieve the technical transaction nesting depth recorded at the moment of failure.
     *
     * -- intent:
     * Enables developers to diagnose complex nested transaction issues, 
     * identifying if the failure occurred at the root or within a saved point.
     *
     * @return int The technical integer representation of the transaction depth.
     */
    public function getNestingLevel(): int
    {
        return $this->nestingLevel;
    }
}

=== Foundation/Transaction/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;

/**
 * The "Safety Guard" Feature (Transaction Module).
 *
 * -- what is it?
 * This module adds "Transaction Management" to the database system. 
 * Transactions make sure that a group of changes are all saved together 
 * (Atomic), or none of them are saved if something goes wrong.
 *
 * -- how to imagine it:
 * Think of it as inviting a "Notary" or a "Safety Supervisor" to the 
 * database party. The Supervisor watches over every change you make and 
 * won't let the permanent records be updated until they are 100% sure 
 * everything is correct.
 *
 * -- why this exists:
 * 1. Data Integrity: It protects your data. If you are transferring money 
 *    from Account A to Account B, you need BOTH changes to happen. If the 
 *    power goes out halfway through, the Transaction Module "rolls back" 
 *    the first change so money isn't lost.
 * 2. Organization: It wires up the `Transaction` class so it can be 
 *    easily requested by other parts of the system (like the 
 *    `QueryOrchestrator`).
 * 3. Standardization: Like all features, it plugs into the system's 
 *    `boot()` and `shutdown()` cycle.
 *
 * -- mental models:
 * - "ACID": The technical set of rules (Atomicity, Consistency, Isolation, 
 *    Durability) that this module helps enforce to keep data safe.
 * - "Nesting": The ability to have a transaction "inside" another 
 *    transaction (using Savepoints). This module tracks those levels.
 */
final readonly class Module implements LifecycleInterface
{
    /**
     * @param Container $container The "Toolbox" where we store the transaction recipes.
     */
    public function __construct(private Container $container) {}

    /**
     * Provide the "ID Card" (Metadata) for this feature.
     */
    public static function declare(): array
    {
        return [
            'name'  => 'transaction',
            'class' => self::class
        ];
    }

    /**
     * Set up the "Safety Supervisor" (Transaction Manager) in the toolbox.
     *
     * -- intent:
     * We tell the system: "Whenever someone asks for a `TransactionManager`, 
     * create a new `Transaction` object and link it to the active 
     * database connection."
     */
    public function register(): void
    {
        $this->container->singleton(abstract: TransactionManagerInterface::class, concrete: static function ($c) {
            return Transaction::on(connection: $c->get(id: DatabaseConnection::class));
        });
    }

    /**
     * Optional "Wake up" logic.
     */
    public function boot(): void
    {
        // No additional boot logic required for transactions.
    }

    /**
     * Optional "Cleanup" logic.
     */
    public function shutdown(): void
    {
        // Internal clean-up logic if required.
    }
}

=== Foundation/Transaction/Transaction.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Avax\Database\Transaction\Exceptions\TransactionException;
use Throwable;

/**
 * The "Safety Net" for your database operations.
 *
 * -- what is it?
 * A transaction is an "All or Nothing" operation. It ensures that if you're 
 * doing a multi-step task (like moving money from Bank A to Bank B), 
 * EITHER both steps succeed OR both are discarded as if they never happened.
 *
 * -- how to imagine it:
 * Think of it as a "Safety Bubble". While you are inside the bubble, 
 * you can mess around and change data. If you're happy, you "Burst the 
 * bubble and keep the changes" (Commit). If something goes wrong, you 
 * "Burst the bubble and undo everything" (Rollback).
 *
 * -- why this exists:
 * To prevent data corruption. Without transactions, if your server crashes 
 * halfway through an operation, you could end up with a mess where money 
 * left Bank A but never arrived at Bank B.
 *
 * -- mental models:
 * - "Commit": Writing in permanent ink.
 * - "Rollback": Using a giant eraser to wipe the whiteboard clean.
 *
 * -- what "nesting" means:
 * It's like a box inside a box. If you're doing a big project (outer 
 * transaction) and you start a small sub-task (inner transaction), 
 * the sub-task can fail and be undone without ruining the whole big 
 * project. This allows complex apps to stay organized.
 *
 * -- what "savepoints" mean:
 * They are "Bookmarks" or "Checkpoints". If you're playing a video game, 
 * you save your progress before a boss fight. A savepoint is exactly 
 * that for the database—it's a spot you can jump back to if things get 
 * messy, without having to restart the entire transaction from the 
 * beginning.
 */
final class Transaction implements TransactionManagerInterface
{
    /** @var int How many bubbles deep are we currently? (0 = no transaction active). */
    private int $transactions = 0;

    /**
     * @param DatabaseConnection $connection The physical persistence gateway to use.
     */
    private function __construct(
        private readonly DatabaseConnection $connection
    ) {}

    /**
     * Start a new transaction manager for a specific connection.
     *
     * @return self A fresh manager ready to start a "Bubble".
     */
    public static function on(DatabaseConnection $connection): self
    {
        return new self(connection: $connection);
    }

    /**
     * A cleaner name for starting a transaction.
     *
     * @param callable $callback The code you want to protect.
     * @return mixed Whatever your code returns.
     */
    public function run(callable $callback): mixed
    {
        return $this->transaction(callback: $callback);
    }

    /**
     * Run a block of code inside a transaction bubble.
     *
     * -- how it works:
     * We start the transaction, run your code, and if no errors occur, 
     * we save the changes. If your code crashes (throws an exception), 
     * we automatically erase all changes made since we started.
     */
    public function transaction(callable $callback): mixed
    {
        $this->begin();

        try {
            $result = $callback($this);
            $this->commit();

            return $result;
        } catch (Throwable $e) {
            try {
                $this->rollback();
            } catch (Throwable) {
                // We ignore rollback errors to make sure we show you the REAL error that happened first.
            }

            if ($e instanceof TransactionException) {
                throw $e;
            }

            throw new TransactionException(
                message: "Transaction failed: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }
    }

    /**
     * Start the atomic "Safety Bubble" (Begin).
     *
     * -- what "begin" means in this context:
     * It sends a specific command to the database saying: "Everything I 
     * tell you from now on is just a draft. Don't make it official yet."
     *
     * -- when it happens:
     * A 'BEGIN' or 'SAVEPOINT' SQL command is sent to the database 
     * the second this method is called.
     *
     * -- common pitfall:
     * This is NOT a "local flag". If you call 'begin()' and then your 
     * script hangs, the database might keep that connection "pending" 
     * for a long time, potentially locking other users out of the data. 
     * Always pair this with a 'commit()' or 'rollback()'.
     */
    public function begin(): self
    {
        try {
            if ($this->transactions === 0) {
                $this->connection->getConnection()->beginTransaction();
            } else {
                // Create a bookmark for the inner bubble.
                $savepointName = 'sp_' . $this->transactions;
                $this->connection->getConnection()->exec(statement: "SAVEPOINT {$savepointName}");
            }

            $this->transactions++;
        } catch (Throwable $e) {
            throw new TransactionException(
                message: "Failed to begin transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }

        return $this;
    }

    /**
     * Access the connection being used for this transaction.
     */
    public function getConnection(): DatabaseConnection
    {
        return $this->connection;
    }

    /**
     * Make the changes permanent (Commit).
     *
     * -- what "commit" means in this context:
     * It tells the database: "I'm happy with all the draft changes I 
     * just made. Go ahead and write them in permanent ink now."
     *
     * -- when it happens:
     * The changes become visible to the rest of the world the exact 
     * millisecond the database receives the 'COMMIT' command.
     *
     * -- common pitfall:
     * There is NO UNDO after a commit! Once you call this, your 
     * changes are part of the history. If you realize you 
     * made a mistake later, you'll have to write a new query 
     * to "undo" the data manually.
     */
    public function commit(): self
    {
        try {
            if ($this->transactions === 0) {
                throw new TransactionException(
                    message: "Cannot commit: no active transaction",
                    nestingLevel: 0,
                    previous: null
                );
            }

            if ($this->transactions === 1) {
                $this->connection->getConnection()->commit();
            } else {
                // Remove the inner bookmark.
                $savepointName = 'sp_' . ($this->transactions - 1);
                $this->connection->getConnection()->exec(statement: "RELEASE SAVEPOINT {$savepointName}");
            }

            $this->transactions = max(0, $this->transactions - 1);
        } catch (Throwable $e) {
            throw new TransactionException(
                message: "Failed to commit transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }

        return $this;
    }

    /**
     * Erase all pending changes (Rollback).
     *
     * -- what "rollback" means in this context:
     * It tells the database: "Ignore everything I just said since my 
     * last 'begin' or 'savepoint' command. Throw the drafts away and 
     * act like nothing happened."
     *
     * -- when it happens:
     * The database immediately discards the pending changes for 
     * this connection.
     *
     * -- common pitfall:
     * This ONLY erases database changes. If you sent an email, 
     * charged a credit card, or deleted a file from the server 
     * inside the transaction, those actions ARE NOT undone by 
     * a database rollback!
     */
    public function rollback(): self
    {
        try {
            if ($this->transactions === 0) {
                throw new TransactionException(
                    message: "Cannot rollback: no active transaction",
                    nestingLevel: 0,
                    previous: null
                );
            }

            if ($this->transactions === 1) {
                $this->connection->getConnection()->rollBack();
                $this->transactions = 0;
            } else {
                // Revert back to the inner bookmark.
                $savepointName = 'sp_' . ($this->transactions - 1);
                $this->connection->getConnection()->exec(statement: "ROLLBACK TO SAVEPOINT {$savepointName}");
                $this->transactions = max(0, $this->transactions - 1);
            }
        } catch (Throwable $e) {
            $this->transactions = 0;
            throw new TransactionException(
                message: "Failed to rollback transaction: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }

        return $this;
    }

    /**
     * Create an automatic, self-cleaning transaction "Scope".
     *
     * -- what "scope" means here:
     * It creates a managed boundary. You get a special helper object 
     * that tracks whether you finished your work.
     *
     * -- when it happens:
     * 'begin()' is called at the start of this method. If the 
     * callback reaches the end, it calls 'commit()'. If a crash 
     * happens, the helper object automatically calls 'rollback()' 
     * when it is deleted from memory.
     *
     * -- common pitfall:
     * This is the safest way to do transactions, but don't 
     * confuse it with the "Logging Scope" in the QueryOrchestrator. 
     * This scope is about *time* and *safety*, not about *context labeling*.
     */
    public function scope(callable $callback): mixed
    {
        $scope = new TransactionScope(manager: $this);

        try {
            $result = $callback($scope);
            $scope->complete();

            return $result;
        } catch (Throwable $e) {
            // The scope object's destructor will handle the rollback for us.
            throw $e;
        }
    }

    /**
     * Create a custom "Bookmark" (Savepoint).
     *
     * -- what "savepoint" means in this context:
     * It's a "Local Milestone". It's like saving your progress in 
     * a video game just before a difficult part. If you fail 
     * that part, you can return to the milestone WITHOUT re-doing 
     * the whole mission from the start.
     *
     * -- when it happens:
     * A 'SAVEPOINT' SQL command is sent to the database immediately.
     *
     * -- common pitfall:
     * Creating a savepoint does NOT save your data to the 
     * database permanently. It's just a bookmark inside a 
     * transaction that is still "pending". You still need 
     * to 'commit()' at the very end.
     *
     * @param string $name A unique nickname for this bookmark.
     */
    public function savepoint(string $name): self
    {
        if (! $this->isValidSavepointName(name: $name)) {
            throw new TransactionException(
                message: "Invalid savepoint name: {$name}. Only alphanumeric characters and underscores are allowed.",
                nestingLevel: $this->transactions,
                previous: null
            );
        }

        try {
            $this->connection->getConnection()->exec(statement: "SAVEPOINT {$name}");
        } catch (Throwable $e) {
            throw new TransactionException(
                message: "Failed to create savepoint [{$name}]: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }

        return $this;
    }

    /**
     * Check if a bookmark nickname is safe to use.
     */
    private function isValidSavepointName(string $name): bool
    {
        return $name !== ''
            && strlen(string: $name) <= 64
            && preg_match(pattern: '/^[a-zA-Z0-9_]+$/', subject: $name) === 1;
    }

    /**
     * Undo everything back to a specific "Bookmark" (Savepoint).
     */
    public function rollbackTo(string $name): self
    {
        if (! $this->isValidSavepointName(name: $name)) {
            throw new TransactionException(
                message: "Invalid savepoint name: {$name}. Only alphanumeric characters and underscores are allowed.",
                nestingLevel: $this->transactions,
                previous: null
            );
        }

        try {
            $this->connection->getConnection()->exec(statement: "ROLLBACK TO SAVEPOINT {$name}");
        } catch (Throwable $e) {
            throw new TransactionException(
                message: "Failed to rollback to savepoint [{$name}]: " . $e->getMessage(),
                nestingLevel: $this->transactions,
                previous: $e
            );
        }

        return $this;
    }
}

=== Foundation/Transaction/TransactionScope.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Transaction;

use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use Throwable;

/**
 * Technical RAII-style scope value object for managing the lifetime of a specific transaction block.
 *
 * -- intent:
 * Implements the "Dispose/RAII" pattern to ensure deterministic transaction 
 * finalization. This allows developers to open a transaction window that 
 * automatically reverts (ROLLBACK) upon destruction if an explicit 
 * completion (COMMIT) signal was not dispatched, safeguarding against 
 * dangling transactions.
 *
 * -- invariants:
 * - Must instantiate a new transaction window upon construction.
 * - Must perform an automated ROLLBACK in the destructor if 'complete()' was not triggered.
 * - 'complete()' must be final and prevent subsequent automated rollbacks.
 *
 * -- boundaries:
 * - Does NOT perform the technical persistence operations (delegated to Manager).
 * - Acts strictly as a lifecycle guardian for the transaction window.
 */
final class TransactionScope
{
    /** @var bool Logical flag indicating if the technical transaction window has been finalized/committed. */
    private bool $completed = false;

    /**
     * @param TransactionManagerInterface $manager The active technical authority responsible for atomicity and persistence.
     */
    public function __construct(private readonly TransactionManagerInterface $manager)
    {
        $this->manager->begin();
    }

    /**
     * Coordinate the automated teardown and defensive rollback of a dangling transaction window.
     *
     * -- intent:
     * Prevents data corruption and persistent connection locks by ensuring 
     * that every transaction opened by this scope is closed, either through 
     * success (COMMIT) or defensive failure recovery (ROLLBACK).
     */
    public function __destruct()
    {
        if (! $this->completed) {
            try {
                $this->manager->rollback();
            } catch (Throwable) {
                // Defensive: isolation of secondary destruction failures to prevent process termination.
            }
        }
    }

    /**
     * Coordinate the manual finalization and technical COMMIT of all changes within this scope.
     *
     * -- intent:
     * Signals the successful and complete execution of the enclosed unit 
     * of work, instructing the manager to persist changes and disabling the 
     * automated rollback guardian.
     *
     * @return void
     */
    public function complete(): void
    {
        $this->manager->commit();
        $this->completed = true;
    }
}

=== Migrations/Design/BaseMigration.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Migrations\Design\Table\Blueprint;
use Closure;
use RuntimeException;

/**
 * Base migration class providing fluent schema building methods (DSL).
 *
 * -- intent: provide the primary design tool for schema changes.
 */
abstract class BaseMigration
{
    /**
     * Query builder instance for executing migration statements.
     *
     * @var QueryBuilder|null
     */
    protected ?QueryBuilder $queryBuilder = null;

    /**
     * Set the query builder instance for this migration.
     *
     * -- intent: enable dependency injection instead of service locator pattern.
     *
     * @param QueryBuilder $builder Query builder instance
     *
     * @return void
     */
    public function setQueryBuilder(QueryBuilder $builder) : void
    {
        $this->queryBuilder = $builder;
    }

    /**
     * Run the migrations.
     */
    abstract public function up() : void;

    /**
     * Reverse the migrations.
     */
    abstract public function down() : void;

    /**
     * Create a new table in the database.
     */
    protected function create(string $table, Closure $callback) : void
    {
        $blueprint = new Blueprint(table: $table);
        $callback($blueprint);

        $grammar = $this->getGrammar();
        $sql     = $blueprint->toSql(grammar: $grammar);

        foreach ($sql as $statement) {
            $this->getConnection()->statement(query: $statement);
        }
    }

    /**
     * Get the grammar instance from the query builder.
     *
     * @return GrammarInterface
     * @throws RuntimeException If query builder is not set
     */
    private function getGrammar()
    {
        return $this->getConnection()->getGrammar();
    }

    /**
     * Get the query builder instance.
     *
     * -- intent: provide access to query builder with proper dependency injection.
     *
     * @return QueryBuilder
     * @throws RuntimeException If query builder is not set
     */
    protected function getConnection() : QueryBuilder
    {
        if ($this->queryBuilder === null) {
            throw new RuntimeException(
                message: 'QueryBuilder must be set on migration instance. ' .
                'Use setQueryBuilder() method or inject via constructor in migration classes.'
            );
        }

        return $this->queryBuilder;
    }

    /**
     * Modify an existing table.
     */
    protected function table(string $table, Closure $callback) : void
    {
        $blueprint = (new Blueprint(table: $table))->setAlterMode();
        $callback($blueprint);

        $grammar = $this->getGrammar();
        $sql     = $blueprint->toSql(grammar: $grammar);

        foreach ($sql as $statement) {
            $this->getConnection()->statement(query: $statement);
        }
    }

    /**
     * Drop a table if it exists.
     */
    protected function dropIfExists(string $table) : void
    {
        $this->drop(table: $table);
    }

    /**
     * Drop a table.
     */
    protected function drop(string $table) : void
    {
        $grammar = $this->getGrammar();
        $sql     = "DROP TABLE IF EXISTS " . $grammar->wrap(value: $table);

        $this->getConnection()->statement(query: $sql);
    }
}

=== Migrations/Design/Column/DSL/ColumnDefinition.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Column\DSL;

/**
 * Functional technician for defining a database column's technical properties.
 *
 * -- intent: provide a domain-fluent DSL for structural column design.
 */
class ColumnDefinition
{
    /**
     * Constructor initializing the base technical identifiers via PHP 8.3 features.
     *
     * -- intent: capture the name and technical type of the column.
     *
     * @param string $name       Technical name of the column
     * @param string $type       Database-specific data type
     * @param array  $attributes Collection of column modifiers (nullable, default, etc)
     */
    public function __construct(
        public readonly string $name,
        public readonly string $type,
        public array           $attributes = []
    ) {}

    /**
     * Mark the column as allowing NULL values.
     *
     * -- intent: provide a pragmatic shorthand for the NULL attribute.
     *
     * @param bool $value Whether null is allowed
     *
     * @return $this
     */
    public function nullable(bool $value = true) : self
    {
        $this->attributes['nullable'] = $value;

        return $this;
    }

    /**
     * Define a default value for the column.
     *
     * -- intent: provide a pragmatic shorthand for the DEFAULT attribute.
     *
     * @param mixed $value Fallback data value
     *
     * @return $this
     */
    public function default(mixed $value) : self
    {
        $this->attributes['default'] = $value;

        return $this;
    }

    /**
     * Mark the column as an automatically incrementing primary key.
     *
     * -- intent: provide a domain-specific shorthand for identity columns.
     *
     * @return $this
     */
    public function autoIncrement() : self
    {
        $this->attributes['auto_increment'] = true;

        return $this;
    }

    /**
     * Mark the column as UNSIGNED (positive numbers only).
     *
     * -- intent: provide storage optimization for non-negative integers.
     *
     * @return $this
     */
    public function unsigned() : self
    {
        $this->attributes['unsigned'] = true;

        return $this;
    }

    /**
     * Mark the column as a PRIMARY KEY.
     *
     * -- intent: designate this column as the table's primary identifier.
     *
     * @return $this
     */
    public function primary() : self
    {
        $this->attributes['primary'] = true;

        return $this;
    }

    /**
     * Mark the column as UNIQUE.
     *
     * -- intent: enforce uniqueness constraint on this column.
     *
     * @return $this
     */
    public function unique() : self
    {
        $this->attributes['unique'] = true;

        return $this;
    }

    /**
     * Add an INDEX on this column.
     *
     * -- intent: optimize query performance for this column.
     *
     * @param string|null $name Optional index name
     *
     * @return $this
     */
    public function index(?string $name = null) : self
    {
        $this->attributes['index'] = $name ?? true;

        return $this;
    }

    /**
     * Set the character set for this column (MySQL).
     *
     * -- intent: define encoding for string columns.
     *
     * @param string $charset Character set name (e.g., 'utf8mb4')
     *
     * @return $this
     */
    public function charset(string $charset) : self
    {
        $this->attributes['charset'] = $charset;

        return $this;
    }

    /**
     * Set the collation for this column (MySQL).
     *
     * -- intent: define sorting rules for string columns.
     *
     * @param string $collation Collation name (e.g., 'utf8mb4_unicode_ci')
     *
     * @return $this
     */
    public function collation(string $collation) : self
    {
        $this->attributes['collation'] = $collation;

        return $this;
    }

    /**
     * Mark the column to use CURRENT_TIMESTAMP as default.
     *
     * -- intent: auto-populate timestamp columns with current time.
     *
     * @return $this
     */
    public function useCurrent() : self
    {
        $this->attributes['use_current'] = true;

        return $this;
    }

    /**
     * Mark the column to update to CURRENT_TIMESTAMP on row update.
     *
     * -- intent: auto-track last modification time.
     *
     * @return $this
     */
    public function useCurrentOnUpdate() : self
    {
        $this->attributes['on_update_current'] = true;

        return $this;
    }

    /**
     * Set the column to be stored (computed column).
     *
     * -- intent: define a generated/computed column.
     *
     * @return $this
     */
    public function storedAs(string $expression) : self
    {
        $this->attributes['stored_as'] = $expression;

        return $this;
    }

    /**
     * Set the column to be virtual (computed column).
     *
     * -- intent: define a virtual generated column.
     *
     * @return $this
     */
    public function virtualAs(string $expression) : self
    {
        $this->attributes['virtual_as'] = $expression;

        return $this;
    }

    /**
     * Add a foreign key constraint.
     *
     * -- intent: establish referential integrity with another table.
     *
     * @param string $table    Referenced table name
     * @param string $column   Referenced column name
     * @param string $onDelete ON DELETE action (CASCADE, SET NULL, etc.)
     * @param string $onUpdate ON UPDATE action
     *
     * @return $this
     */
    public function references(string $table, string $column = 'id', string $onDelete = 'CASCADE', string $onUpdate = 'CASCADE') : self
    {
        $this->attributes['foreign'] = [
            'table'     => $table,
            'column'    => $column,
            'on_delete' => $onDelete,
            'on_update' => $onUpdate,
        ];

        return $this;
    }

    /**
     * Attach a technical comment to the database column.
     *
     * -- intent: facilitate database self-documentation via column comments.
     *
     * @param string $text Explanatory description
     *
     * @return $this
     */
    public function comment(string $text) : self
    {
        $this->attributes['comment'] = $text;

        return $this;
    }
}

=== Migrations/Design/Column/Renderer/ColumnSQLRenderer.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Column\Renderer;

use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Migrations\Design\Column\DSL\ColumnDefinition;

/**
 * Professional technician for translating column definitions into SQL fragments.
 *
 * -- intent: centralize the transformation logic from DSL attributes to dialect SQL.
 */
final class ColumnSQLRenderer
{
    /**
     * Transform a ColumnDefinition into a cohesive SQL string portion.
     *
     * -- intent: coordinate the rendering of name, type, and all active modifiers.
     *
     * @param ColumnDefinition $column  The design metadata
     * @param GrammarInterface $grammar The dialect technician for wrapping
     *
     * @return string
     */
    public function render(ColumnDefinition $column, GrammarInterface $grammar) : string
    {
        $sql = $grammar->wrap(value: $column->name) . ' ' . $column->type;

        // UNSIGNED modifier (must come before NULL/NOT NULL)
        if (isset($column->attributes['unsigned']) && $column->attributes['unsigned']) {
            $sql .= ' UNSIGNED';
        }

        // Character set and collation (MySQL specific)
        if (isset($column->attributes['charset'])) {
            $sql .= ' CHARACTER SET ' . $column->attributes['charset'];
        }

        if (isset($column->attributes['collation'])) {
            $sql .= ' COLLATE ' . $column->attributes['collation'];
        }

        // Generated/Computed columns
        if (isset($column->attributes['virtual_as'])) {
            $sql .= ' AS (' . $column->attributes['virtual_as'] . ') VIRTUAL';
        }

        if (isset($column->attributes['stored_as'])) {
            $sql .= ' AS (' . $column->attributes['stored_as'] . ') STORED';
        }

        // NULL/NOT NULL constraint
        if (isset($column->attributes['nullable'])) {
            $sql .= $column->attributes['nullable'] ? ' NULL' : ' NOT NULL';
        } else {
            // Default to NOT NULL if not specified
            $sql .= ' NOT NULL';
        }

        // DEFAULT value
        if (array_key_exists(key: 'default', array: $column->attributes)) {
            $sql .= ' DEFAULT ' . $this->formatDefault(value: $column->attributes['default']);
        }

        // CURRENT_TIMESTAMP defaults
        if (isset($column->attributes['use_current']) && $column->attributes['use_current']) {
            $sql .= ' DEFAULT CURRENT_TIMESTAMP';
        }

        // ON UPDATE CURRENT_TIMESTAMP
        if (isset($column->attributes['on_update_current']) && $column->attributes['on_update_current']) {
            $sql .= ' ON UPDATE CURRENT_TIMESTAMP';
        }

        // AUTO_INCREMENT (implies PRIMARY KEY)
        if (isset($column->attributes['auto_increment'])) {
            $sql .= ' AUTO_INCREMENT PRIMARY KEY';
        } // PRIMARY KEY (standalone)
        elseif (isset($column->attributes['primary']) && $column->attributes['primary']) {
            $sql .= ' PRIMARY KEY';
        }

        // UNIQUE constraint
        if (isset($column->attributes['unique']) && $column->attributes['unique']) {
            $sql .= ' UNIQUE';
        }

        // COMMENT
        if (isset($column->attributes['comment'])) {
            $sql .= " COMMENT '" . addslashes(string: $column->attributes['comment']) . "'";
        }

        return $sql;
    }

    /**
     * Normalize default values for SQL concatenation.
     *
     * -- intent: ensure that data types are appropriately quoted or handled as keywords.
     *
     * @param mixed $value Raw data value
     *
     * @return string
     */
    private function formatDefault(mixed $value) : string
    {
        if (is_string(value: $value)) {
            return "'{$value}'";
        }

        if (is_bool(value: $value)) {
            return $value ? '1' : '0';
        }

        if ($value === null) {
            return 'NULL';
        }

        return (string) $value;
    }
}

=== Migrations/Design/Table/Blueprint.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Table;

use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Migrations\Design\Column\DSL\ColumnDefinition;
use Avax\Migrations\Design\Column\Renderer\ColumnSQLRenderer;

/**
 * Enterprise-grade designer for defining database table structures.
 *
 * -- intent: provide a collection-based DSL for managing multiple column definitions.
 */
final class Blueprint
{
    // Storage for the column design objects
    private array $columns = [];

    // Storage for commands (drop, rename, etc.)
    private array $commands = [];

    // Whether the table is being created or altered
    private bool $creating = true;

    /**
     * Constructor promoting the target table name via PHP 8.3 features.
     *
     * -- intent: capture the identifier for the table being designed.
     *
     * @param string $table Technical table name
     */
    public function __construct(
        private readonly string $table
    ) {}

    /**
     * Mark the blueprint for table alteration instead of creation.
     */
    public function setAlterMode() : self
    {
        $this->creating = false;

        return $this;
    }

    /**
     * Add a high-performance auto-incrementing primary key ID.
     *
     * -- intent: provide a pragmatic shorthand for the standard 'id' column.
     *
     * @param string $name Technical name, defaults to 'id'
     *
     * @return ColumnDefinition
     */
    public function id(string $name = 'id') : ColumnDefinition
    {
        return $this->addColumn(type: 'BIGINT', name: $name)->autoIncrement();
    }

    /**
     * Internal technician for registering a new column design.
     *
     * -- intent: centralize column object instantiation and storage.
     *
     * @param string $type Technical database type
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    private function addColumn(string $type, string $name) : ColumnDefinition
    {
        $column          = new ColumnDefinition(name: $name, type: $type);
        $this->columns[] = $column;

        return $column;
    }

    // ========================================
    // NUMERIC TYPES
    // ========================================

    /**
     * Add a TINYINT column (1 byte, -128 to 127).
     *
     * -- intent: provide storage for very small integers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function tinyInteger(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TINYINT', name: $name);
    }

    /**
     * Add a SMALLINT column (2 bytes, -32,768 to 32,767).
     *
     * -- intent: provide storage for small integers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function smallInteger(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'SMALLINT', name: $name);
    }

    /**
     * Add an INT column (4 bytes, -2B to 2B).
     *
     * -- intent: provide storage for standard integers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function integer(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'INT', name: $name);
    }

    /**
     * Add a BIGINT column (8 bytes, -9Q to 9Q).
     *
     * -- intent: provide storage for very large integers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function bigInteger(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'BIGINT', name: $name);
    }

    /**
     * Add a DECIMAL column with precision and scale.
     *
     * -- intent: provide exact numeric storage for financial data.
     *
     * @param string $name      Technical name
     * @param int    $precision Total number of digits
     * @param int    $scale     Number of decimal places
     *
     * @return ColumnDefinition
     */
    public function decimal(string $name, int $precision = 8, int $scale = 2) : ColumnDefinition
    {
        return $this->addColumn(type: "DECIMAL({$precision},{$scale})", name: $name);
    }

    /**
     * Add a FLOAT column (4 bytes, approximate).
     *
     * -- intent: provide storage for single-precision floating point.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function float(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'FLOAT', name: $name);
    }

    /**
     * Add a DOUBLE column (8 bytes, approximate).
     *
     * -- intent: provide storage for double-precision floating point.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function double(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'DOUBLE', name: $name);
    }

    /**
     * Add a BOOLEAN column (TINYINT(1)).
     *
     * -- intent: provide storage for true/false values.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function boolean(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TINYINT(1)', name: $name);
    }

    /**
     * Add a MEDIUMINT column (3 bytes, MySQL).
     *
     * -- intent: provide storage for medium-range integers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function mediumInteger(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'MEDIUMINT', name: $name);
    }

    /**
     * Add a SERIAL column (PostgreSQL auto-increment INT).
     *
     * -- intent: provide PostgreSQL-native auto-incrementing integer.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function serial(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'SERIAL', name: $name);
    }

    /**
     * Add a BIGSERIAL column (PostgreSQL auto-increment BIGINT).
     *
     * -- intent: provide PostgreSQL-native auto-incrementing big integer.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function bigSerial(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'BIGSERIAL', name: $name);
    }

    /**
     * Add a REAL column (4 bytes, approximate).
     *
     * -- intent: provide storage for real numbers (alias for FLOAT in some DBs).
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function real(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'REAL', name: $name);
    }

    // ========================================
    // STRING TYPES
    // ========================================

    /**
     * Add a variable-length string column.
     *
     * -- intent: provide a pragmatic shorthand for VARCHAR columns.
     *
     * @param string $name   Technical name
     * @param int    $length Maximum character capacity
     *
     * @return ColumnDefinition
     */
    public function string(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "VARCHAR({$length})", name: $name);
    }

    /**
     * Add a fixed-length string column.
     *
     * -- intent: provide storage for fixed-width data like codes.
     *
     * @param string $name   Technical name
     * @param int    $length Exact character capacity
     *
     * @return ColumnDefinition
     */
    public function char(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "CHAR({$length})", name: $name);
    }

    /**
     * Add a TEXT column (up to 64KB).
     *
     * -- intent: provide storage for medium-length text content.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function text(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TEXT', name: $name);
    }

    /**
     * Add a MEDIUMTEXT column (up to 16MB).
     *
     * -- intent: provide storage for large text content.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function mediumText(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'MEDIUMTEXT', name: $name);
    }

    /**
     * Add a LONGTEXT column (up to 4GB).
     *
     * -- intent: provide storage for very large text content.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function longText(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'LONGTEXT', name: $name);
    }

    /**
     * Add a TINYTEXT column (up to 255 bytes, MySQL).
     *
     * -- intent: provide storage for very small text content.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function tinyText(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TINYTEXT', name: $name);
    }

    /**
     * Add an NCHAR column (Unicode fixed-length string).
     *
     * -- intent: provide storage for Unicode fixed-width data.
     *
     * @param string $name   Technical name
     * @param int    $length Exact character capacity
     *
     * @return ColumnDefinition
     */
    public function nchar(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "NCHAR({$length})", name: $name);
    }

    /**
     * Add an NVARCHAR column (Unicode variable-length string).
     *
     * -- intent: provide storage for Unicode variable-length text.
     *
     * @param string $name   Technical name
     * @param int    $length Maximum character capacity
     *
     * @return ColumnDefinition
     */
    public function nvarchar(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "NVARCHAR({$length})", name: $name);
    }

    /**
     * Add an NTEXT column (Unicode large text).
     *
     * -- intent: provide storage for large Unicode text content.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function ntext(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'NTEXT', name: $name);
    }

    /**
     * Add a BINARY column for fixed-length binary data.
     *
     * -- intent: provide storage for binary data like hashes.
     *
     * @param string $name   Technical name
     * @param int    $length Byte capacity
     *
     * @return ColumnDefinition
     */
    public function binary(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "BINARY({$length})", name: $name);
    }

    /**
     * Add a UUID column (CHAR(36)).
     *
     * -- intent: provide storage for universally unique identifiers.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function uuid(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'CHAR(36)', name: $name);
    }

    /**
     * Add a native UUID column (PostgreSQL).
     *
     * -- intent: provide PostgreSQL-native UUID storage.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function uuidNative(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'UUID', name: $name);
    }

    /**
     * Add a VARBINARY column (variable-length binary).
     *
     * -- intent: provide storage for variable-length binary data.
     *
     * @param string $name   Technical name
     * @param int    $length Maximum byte capacity
     *
     * @return ColumnDefinition
     */
    public function varbinary(string $name, int $length = 255) : ColumnDefinition
    {
        return $this->addColumn(type: "VARBINARY({$length})", name: $name);
    }

    /**
     * Add a BLOB column (Binary Large Object, up to 64KB).
     *
     * -- intent: provide storage for binary files and data.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function blob(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'BLOB', name: $name);
    }

    /**
     * Add a TINYBLOB column (up to 255 bytes, MySQL).
     *
     * -- intent: provide storage for very small binary data.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function tinyBlob(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TINYBLOB', name: $name);
    }

    /**
     * Add a MEDIUMBLOB column (up to 16MB, MySQL).
     *
     * -- intent: provide storage for medium-sized binary data.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function mediumBlob(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'MEDIUMBLOB', name: $name);
    }

    /**
     * Add a LONGBLOB column (up to 4GB, MySQL).
     *
     * -- intent: provide storage for very large binary data.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function longBlob(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'LONGBLOB', name: $name);
    }

    /**
     * Add a BYTEA column (PostgreSQL binary data).
     *
     * -- intent: provide PostgreSQL-native binary storage.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function bytea(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'BYTEA', name: $name);
    }

    /**
     * Add a BIT column (bit field).
     *
     * -- intent: provide storage for bit flags.
     *
     * @param string $name   Technical name
     * @param int    $length Number of bits
     *
     * @return ColumnDefinition
     */
    public function bit(string $name, int $length = 1) : ColumnDefinition
    {
        return $this->addColumn(type: "BIT({$length})", name: $name);
    }

    // ========================================
    // DATE/TIME TYPES
    // ========================================

    /**
     * Add a DATE column (YYYY-MM-DD).
     *
     * -- intent: provide storage for calendar dates.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function date(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'DATE', name: $name);
    }

    /**
     * Add a DATETIME column (YYYY-MM-DD HH:MM:SS).
     *
     * -- intent: provide storage for precise timestamps.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function datetime(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'DATETIME', name: $name);
    }

    /**
     * Add a TIMESTAMP column (auto-updating).
     *
     * -- intent: provide storage for event timestamps.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function timestamp(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TIMESTAMP', name: $name);
    }

    /**
     * Add a TIME column (HH:MM:SS).
     *
     * -- intent: provide storage for time of day.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function time(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TIME', name: $name);
    }

    /**
     * Add a YEAR column (4-digit year).
     *
     * -- intent: provide storage for year values.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function year(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'YEAR', name: $name);
    }

    /**
     * Add an INTERVAL column (PostgreSQL time period).
     *
     * -- intent: provide storage for time intervals/durations.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function interval(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'INTERVAL', name: $name);
    }

    /**
     * Add basic created_at and updated_at timestamp columns.
     *
     * -- intent: provide a domain-specific shorthand for audit record-keeping.
     *
     * @return void
     */
    public function timestamps() : void
    {
        $this->addColumn(type: 'TIMESTAMP', name: 'created_at')->nullable();
        $this->addColumn(type: 'TIMESTAMP', name: 'updated_at')->nullable();
    }

    /**
     * Add a soft delete timestamp column.
     *
     * -- intent: provide support for soft deletion pattern.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function softDeletes(string $name = 'deleted_at') : ColumnDefinition
    {
        return $this->addColumn(type: 'TIMESTAMP', name: $name)->nullable();
    }

    // ========================================
    // SPECIAL TYPES
    // ========================================

    /**
     * Add a JSON column.
     *
     * -- intent: provide storage for structured JSON documents.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function json(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'JSON', name: $name);
    }

    /**
     * Add a JSONB column (PostgreSQL binary JSON).
     *
     * -- intent: provide optimized storage for JSON with indexing.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function jsonb(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'JSONB', name: $name);
    }

    /**
     * Add an ENUM column with allowed values.
     *
     * -- intent: provide storage for predefined value sets.
     *
     * @param string $name   Technical name
     * @param array  $values Allowed values
     *
     * @return ColumnDefinition
     */
    public function enum(string $name, array $values) : ColumnDefinition
    {
        $quoted = array_map(callback: fn ($v) => "'{$v}'", array: $values);

        return $this->addColumn(type: 'ENUM(' . implode(separator: ',', array: $quoted) . ')', name: $name);
    }

    /**
     * Add a SET column with multiple allowed values.
     *
     * -- intent: provide storage for multi-select value sets.
     *
     * @param string $name   Technical name
     * @param array  $values Allowed values
     *
     * @return ColumnDefinition
     */
    public function set(string $name, array $values) : ColumnDefinition
    {
        $quoted = array_map(callback: fn ($v) => "'{$v}'", array: $values);

        return $this->addColumn(type: 'SET(' . implode(separator: ',', array: $quoted) . ')', name: $name);
    }

    /**
     * Add an XML column.
     *
     * -- intent: provide storage for XML documents.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function xml(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'XML', name: $name);
    }

    // ========================================
    // GIS / SPATIAL TYPES
    // ========================================

    /**
     * Add a POINT column (geometric point).
     *
     * -- intent: provide storage for 2D point coordinates.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function point(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'POINT', name: $name);
    }

    /**
     * Add a LINESTRING column (geometric line).
     *
     * -- intent: provide storage for line/path coordinates.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function lineString(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'LINESTRING', name: $name);
    }

    /**
     * Add a POLYGON column (geometric polygon).
     *
     * -- intent: provide storage for area/boundary coordinates.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function polygon(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'POLYGON', name: $name);
    }

    /**
     * Add a GEOMETRY column (generic spatial type).
     *
     * -- intent: provide storage for any geometric shape.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function geometry(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'GEOMETRY', name: $name);
    }

    /**
     * Add a GEOGRAPHY column (geodetic coordinates).
     *
     * -- intent: provide storage for earth-surface coordinates.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function geography(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'GEOGRAPHY', name: $name);
    }

    // ========================================
    // POSTGRESQL SPECIFIC TYPES
    // ========================================

    /**
     * Add an INET column (PostgreSQL IP address).
     *
     * -- intent: provide storage for IPv4/IPv6 addresses.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function inet(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'INET', name: $name);
    }

    /**
     * Add a CIDR column (PostgreSQL network range).
     *
     * -- intent: provide storage for network CIDR blocks.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function cidr(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'CIDR', name: $name);
    }

    /**
     * Add a MACADDR column (PostgreSQL MAC address).
     *
     * -- intent: provide storage for hardware MAC addresses.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function macaddr(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'MACADDR', name: $name);
    }

    /**
     * Add a TSVECTOR column (PostgreSQL full-text search).
     *
     * -- intent: provide storage for indexed searchable text.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function tsvector(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TSVECTOR', name: $name);
    }

    /**
     * Add a TSQUERY column (PostgreSQL full-text query).
     *
     * -- intent: provide storage for search queries.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function tsquery(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'TSQUERY', name: $name);
    }

    // ========================================
    // SQL SERVER SPECIFIC TYPES
    // ========================================

    /**
     * Add a MONEY column (SQL Server currency).
     *
     * -- intent: provide storage for monetary values.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function money(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'MONEY', name: $name);
    }

    /**
     * Add a SMALLMONEY column (SQL Server small currency).
     *
     * -- intent: provide storage for smaller monetary values.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function smallMoney(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'SMALLMONEY', name: $name);
    }

    /**
     * Add a UNIQUEIDENTIFIER column (SQL Server GUID).
     *
     * -- intent: provide storage for SQL Server GUIDs.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function uniqueIdentifier(string $name) : ColumnDefinition
    {
        return $this->addColumn(type: 'UNIQUEIDENTIFIER', name: $name);
    }

    /**
     * Add a ROWVERSION column (SQL Server row versioning).
     *
     * -- intent: provide automatic row version tracking.
     *
     * @param string $name Technical name
     *
     * @return ColumnDefinition
     */
    public function rowVersion(string $name = 'row_version') : ColumnDefinition
    {
        return $this->addColumn(type: 'ROWVERSION', name: $name);
    }

    /**
     * Drop a column from the table.
     */
    public function dropColumn(string ...$names) : void
    {
        foreach ($names as $name) {
            $this->commands[] = ['type' => 'drop', 'name' => $name];
        }
    }

    /**
     * Rename a column on the table.
     */
    public function renameColumn(string $from, string $to) : void
    {
        $this->commands[] = ['type' => 'rename', 'from' => $from, 'to' => $to];
    }

    /**
     * Translate the blueprint design into a collection of physical SQL statements.
     *
     * -- intent: coordinate the rendering of all designed columns into a CREATE or ALTER command.
     *
     * @param GrammarInterface $grammar The dialect technician for wrapping and syntax
     *
     * @return array<string> List of SQL statements to execute
     */
    public function toSql(GrammarInterface $grammar) : array
    {
        return $this->creating ? $this->toCreateSql(grammar: $grammar) : $this->toAlterSql(grammar: $grammar);
    }

    /**
     * Generate CREATE TABLE statement.
     */
    private function toCreateSql(GrammarInterface $grammar) : array
    {
        $renderer = new ColumnSQLRenderer();
        $columns  = array_map(
            callback: fn (ColumnDefinition $col) => $renderer->render(column: $col, grammar: $grammar),
            array   : $this->columns
        );

        $sql = "CREATE TABLE " . $grammar->wrap(value: $this->table) . " (";
        $sql .= implode(separator: ', ', array: $columns);
        $sql .= ")";

        return [$sql];
    }

    /**
     * Generate ALTER TABLE statements.
     */
    private function toAlterSql(GrammarInterface $grammar) : array
    {
        $sql      = [];
        $renderer = new ColumnSQLRenderer();

        // Handle new columns (ADD)
        foreach ($this->columns as $column) {
            $sql[] = "ALTER TABLE " . $grammar->wrap(value: $this->table) . " ADD " . $renderer->render(column: $column, grammar: $grammar);
        }

        // Handle commands (DROP, RENAME)
        foreach ($this->commands as $command) {
            if ($command['type'] === 'drop') {
                $sql[] = "ALTER TABLE " . $grammar->wrap(value: $this->table) . " DROP COLUMN " . $grammar->wrap(value: $command['name']);
            } elseif ($command['type'] === 'rename') {
                $sql[] = "ALTER TABLE " . $grammar->wrap(value: $this->table) . " RENAME COLUMN " . $grammar->wrap(value: $command['from']) . " TO " . $grammar->wrap(value: $command['to']);
            }
        }

        return $sql;
    }
}

=== Migrations/Design/Table/TableDefinition.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\Table;

/**
 * Technical value object representing the metadata of a database table.
 *
 * -- intent: transport structural table identifiers across the migration system.
 */
final readonly class TableDefinition
{
    /**
     * Constructor promoting the immutable table name via PHP 8.3 features.
     *
     * -- intent: capture the technical identity of a database table.
     *
     * @param string $name Technical table identifier
     */
    public function __construct(
        public string $name
    ) {}
}

=== Migrations/Design/TypeMapping/SQLToPHPTypeMapper.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Design\TypeMapping;

/**
 * Enterprise-grade SQL to PHP type mapper for DTOs, Entities, and Value Objects.
 *
 * -- intent: provide accurate type mapping for code generation and ORM integration.
 */
final class SQLToPHPTypeMapper
{
    /**
     * Complete mapping of SQL types to PHP native types.
     *
     * @var array<string, string>
     */
    private const TYPE_MAP
        = [
            // NUMERIC TYPES
            'TINYINT'          => 'int',
            'SMALLINT'         => 'int',
            'MEDIUMINT'        => 'int',
            'INT'              => 'int',
            'INTEGER'          => 'int',
            'BIGINT'           => 'int',
            'SERIAL'           => 'int',
            'BIGSERIAL'        => 'int',
            'DECIMAL'          => 'string',
            'NUMERIC'          => 'string',
            'FLOAT'            => 'float',
            'REAL'             => 'float',
            'DOUBLE'           => 'float',
            'BOOLEAN'          => 'bool',
            'BOOL'             => 'bool',
            'BIT'              => 'int',

            // STRING TYPES
            'CHAR'             => 'string',
            'VARCHAR'          => 'string',
            'TEXT'             => 'string',
            'TINYTEXT'         => 'string',
            'MEDIUMTEXT'       => 'string',
            'LONGTEXT'         => 'string',
            'NCHAR'            => 'string',
            'NVARCHAR'         => 'string',
            'NTEXT'            => 'string',

            // BINARY TYPES
            'BINARY'           => 'string',
            'VARBINARY'        => 'string',
            'BLOB'             => 'string',
            'TINYBLOB'         => 'string',
            'MEDIUMBLOB'       => 'string',
            'LONGBLOB'         => 'string',
            'BYTEA'            => 'string',

            // DATE/TIME TYPES
            'DATE'             => 'DateTimeImmutable',
            'DATETIME'         => 'DateTimeImmutable',
            'TIMESTAMP'        => 'DateTimeImmutable',
            'TIME'             => 'DateTimeImmutable',
            'YEAR'             => 'int',
            'INTERVAL'         => 'DateInterval',

            // JSON TYPES
            'JSON'             => 'array',
            'JSONB'            => 'array',

            // SPECIAL TYPES
            'ENUM'             => 'string',
            'SET'              => 'array',
            'UUID'             => 'string',
            'XML'              => 'string',

            // GIS / SPATIAL TYPES
            'POINT'            => 'array',
            'LINESTRING'       => 'array',
            'POLYGON'          => 'array',
            'GEOMETRY'         => 'array',
            'GEOGRAPHY'        => 'array',

            // POSTGRESQL SPECIFIC
            'INET'             => 'string',
            'CIDR'             => 'string',
            'MACADDR'          => 'string',
            'TSVECTOR'         => 'string',
            'TSQUERY'          => 'string',

            // SQL SERVER SPECIFIC
            'MONEY'            => 'string',
            'SMALLMONEY'       => 'string',
            'UNIQUEIDENTIFIER' => 'string',
            'ROWVERSION'       => 'string',
        ];

    /**
     * Map SQL type to PHP DocBlock type hint.
     *
     * @param string $sqlType
     * @param bool   $nullable
     *
     * @return string
     */
    public function toDocBlockType(string $sqlType, bool $nullable = false) : string
    {
        $phpType = $this->toPhpType(sqlType: $sqlType);

        $enhancedType = match ($phpType) {
            'array' => $this->getArrayDocType(sqlType: $sqlType),
            default => $phpType,
        };

        return $nullable ? "{$enhancedType}|null" : $enhancedType;
    }

    /**
     * Map SQL type to PHP native type.
     *
     * @param string $sqlType
     *
     * @return string
     */
    public function toPhpType(string $sqlType) : string
    {
        $baseType = $this->extractBaseType(sqlType: $sqlType);

        return self::TYPE_MAP[$baseType] ?? 'mixed';
    }

    private function extractBaseType(string $sqlType) : string
    {
        $baseType = preg_replace(pattern: '/[\(\s].*/', replacement: '', subject: $sqlType);

        return strtoupper(string: trim(string: $baseType));
    }

    private function getArrayDocType(string $sqlType) : string
    {
        $baseType = $this->extractBaseType(sqlType: $sqlType);

        return match ($baseType) {
            'JSON', 'JSONB' => 'array<string, mixed>',
            'SET'           => 'array<int, string>',
            'POINT'         => 'array{x: float, y: float}',
            'LINESTRING'    => 'array<int, array{x: float, y: float}>',
            'POLYGON'       => 'array<int, array<int, array{x: float, y: float}>>',
            default         => 'array',
        };
    }

    /**
     * @param string $sqlType
     *
     * @return string|null
     */
    public function suggestValueObject(string $sqlType) : ?string
    {
        if (! $this->shouldUseValueObject(sqlType: $sqlType)) {
            return null;
        }

        $baseType = $this->extractBaseType(sqlType: $sqlType);

        return match ($baseType) {
            'UUID'       => 'Uuid',
            'INET'       => 'IpAddress',
            'CIDR'       => 'NetworkRange',
            'MACADDR'    => 'MacAddress',
            'MONEY'      => 'Money',
            'SMALLMONEY' => 'Money',
            'POINT'      => 'GeoPoint',
            'POLYGON'    => 'GeoPolygon',
            'GEOMETRY'   => 'Geometry',
            'GEOGRAPHY'  => 'Geography',
            default      => null,
        };
    }

    /**
     * @param string $sqlType
     *
     * @return bool
     */
    public function shouldUseValueObject(string $sqlType) : bool
    {
        $baseType = $this->extractBaseType(sqlType: $sqlType);

        return in_array(needle: $baseType, haystack: [
            'UUID',
            'INET',
            'CIDR',
            'MACADDR',
            'MONEY',
            'SMALLMONEY',
            'POINT',
            'POLYGON',
            'GEOMETRY',
            'GEOGRAPHY',
        ],              strict: true);
    }

    public function getSupportedTypes() : array
    {
        return array_keys(array: self::TYPE_MAP);
    }

    public function isSupported(string $sqlType) : bool
    {
        $baseType = $this->extractBaseType(sqlType: $sqlType);

        return isset(self::TYPE_MAP[$baseType]);
    }
}

=== Migrations/Exceptions/MigrationException.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use Throwable;

/**
 * Triggered during failures in the migration runner or structural execution.
 *
 * -- intent: provide specific diagnostic context for broken schema changes.
 */
final class MigrationException extends DatabaseException
{
    /**
     * Constructor capturing the migration class and technical SQL.
     *
     * -- intent: link the failure to the specific migration file and query.
     *
     * @param string         $migrationClass Technical class name of the migration
     * @param string         $message        Detailed failure description
     * @param string|null    $sql            The specific SQL statement that failed
     * @param Throwable|null $previous       Underlying system trigger
     */
    #[Override]
    public function __construct(
        private readonly string      $migrationClass,
        string                       $message,
        private readonly string|null $sql = null,
        Throwable|null               $previous = null
    )
    {
        parent::__construct(message: "Migration [{$migrationClass}] failed: {$message}", code: 0, previous: $previous);
    }

    /**
     * Retrieve the problematic migration's class name.
     *
     * -- intent: identify the broken migration script.
     *
     * @return string
     */
    public function getMigrationClass() : string
    {
        return $this->migrationClass;
    }

    /**
     * Retrieve the SQL statement that caused the structural failure.
     *
     * -- intent: facilitate manual correction of the schema.
     *
     * @return string|null
     */
    public function getSql() : string|null
    {
        return $this->sql;
    }
}



=== Migrations/Execution/Console/DatabaseCreateCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Console command to create a new database.
 */
final class DatabaseCreateCommand
{
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    public function handle(string $name) : int
    {
        echo "\033[36mCreating database: {$name}...\033[0m\n";

        try {
            $this->builder->createDatabase(name: $name);
            echo "\033[32mDatabase created successfully!\033[0m\n";

            return 0;
        } catch (Throwable $e) {
            echo "\033[31mFailed to create database: {$e->getMessage()}\033[0m\n";

            return 1;
        }
    }
}

=== Migrations/Execution/Console/DatabaseDropCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Console command to drop a database.
 */
final class DatabaseDropCommand
{
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    public function handle(string $name) : int
    {
        echo "\033[33mCAUTION: You are about to DROP the entire database: {$name}\033[0m\n";
        echo "Are you sure you want to proceed? [y/N]: ";

        $confirmation = trim(string: fgets(stream: STDIN));
        if (strtolower(string: $confirmation) !== 'y') {
            echo "Operation cancelled.\n";

            return 0;
        }

        echo "\033[36mDropping database: {$name}...\033[0m\n";

        try {
            $this->builder->dropDatabase(name: $name);
            echo "\033[32mDatabase dropped successfully!\033[0m\n";

            return 0;
        } catch (Throwable $e) {
            echo "\033[31mFailed to drop database: {$e->getMessage()}\033[0m\n";

            return 1;
        }
    }
}

=== Migrations/Execution/Console/DatabaseExportCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Migrations\Export\DatabaseExporter;
use Throwable;

/**
 * Console command to export the database.
 */
final class DatabaseExportCommand
{
    public function __construct(
        private readonly DatabaseExporter $exporter
    ) {}

    public function handle(string $path, ?string $table = null) : int
    {
        $target = $table ? "table: {$table}" : "full database";

        echo "\033[33mNOTICE: You are about to export {$target}.\033[0m\n";
        echo "This might take some time depending on your data size. Proceed? [y/N]: ";

        $confirmation = trim(string: fgets(stream: STDIN));
        if (strtolower(string: $confirmation) !== 'y') {
            echo "Operation cancelled.\n";

            return 0;
        }

        echo "\033[36mExporting {$target} to: {$path}...\033[0m\n";

        try {
            $file = $this->exporter->exportToSql(path: $path, table: $table);
            echo "\033[32mExport successful: {$file}\033[0m\n";

            return 0;
        } catch (Throwable $e) {
            echo "\033[31mExport failed: {$e->getMessage()}\033[0m\n";

            return 1;
        }
    }
}

=== Migrations/Execution/Console/DatabaseSeedCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Throwable;

/**
 * Console command to run database seeders.
 */
final class DatabaseSeedCommand
{
    public function handle(string $seedersPath, ?string $class = 'DatabaseSeeder') : int
    {
        $class = $class ?: 'DatabaseSeeder';
        $file  = rtrim(string: $seedersPath, characters: DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $class . '.php';

        if (! file_exists(filename: $file)) {
            echo "\033[31mSeeder file not found: {$file}\033[0m\n";

            return 1;
        }

        echo "\033[36mRunning seeder: {$class}...\033[0m\n";

        try {
            require_once $file;
            $seeder = new $class();
            $seeder->run();

            echo "\033[32mDatabase seeding completed successfully!\033[0m\n";

            return 0;
        } catch (Throwable $e) {
            echo "\033[31mSeeding failed: {$e->getMessage()}\033[0m\n";

            return 1;
        }
    }
}

=== Migrations/Execution/Console/MigrateCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Migrations\Execution\Repository\MigrationRepository;
use Avax\Migrations\Execution\Runner\MigrationRunner;
use Avax\Migrations\Generate\MigrationLoader;
use Throwable;

/**
 * Console command to run pending migrations.
 */
final class MigrateCommand
{
    public function __construct(
        private readonly MigrationRepository $repository,
        private readonly MigrationRunner     $runner,
        private readonly MigrationLoader     $loader
    ) {}

    public function handle(string $path, bool $dryRun = false) : int
    {
        if ($dryRun) {
            $this->info(msg: 'DRY RUN MODE: No changes will be executed.');
        }

        $this->info(msg: 'Running migrations...');
        $this->repository->ensureTableExists();

        $ran = $this->repository->getRan();

        // --- Enterprise Integrity Check ---
        $ranMap = array_column(array: $ran, column_key: 'checksum', index_key: 'migration');
        foreach ($ran as $record) {
            $name       = $record['migration'];
            $dbChecksum = $record['checksum'];

            if ($dbChecksum) {
                $fileChecksum = $this->loader->getChecksum(name: $name, path: $path);
                if ($fileChecksum && $dbChecksum !== $fileChecksum) {
                    $this->error(msg: "CRITICAL: Migration integrity violation in '{$name}'.");
                    $this->error(msg: "The file has been modified after execution. Please revert changes.");

                    return 1;
                }
            }
        }

        $pending = $this->loader->getPending(path: $path, ran: $ran);

        if (empty($pending)) {
            $this->info(msg: 'Nothing to migrate.');

            return 0;
        }

        $this->info(msg: sprintf('Found %d pending migration(s).', count(value: $pending)));

        try {
            $this->runner->up(migrations: $pending, path: $path, dryRun: $dryRun);

            if ($dryRun) {
                $this->success(msg: 'Dry run completed successfully. No changes made.');
            } else {
                $this->success(msg: sprintf('Migrated %d migration(s) successfully!', count(value: $pending)));
            }

            foreach (array_keys(array: $pending) as $name) {
                echo "  ✓ {$name}\n";
            }

            return 0;
        } catch (Throwable $e) {
            $this->error(msg: 'Migration failed: ' . $e->getMessage());

            return 1;
        }
    }

    private function info(string $msg) : void
    {
        echo "\033[36m{$msg}\033[0m\n";
    }

    private function error(string $msg) : void
    {
        echo "\033[31m{$msg}\033[0m\n";
    }

    private function success(string $msg) : void
    {
        echo "\033[32m{$msg}\033[0m\n";
    }
}

=== Migrations/Execution/Console/MigrateMakeCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Migrations\Generate\MigrationGenerator;
use Throwable;

/**
 * Console command to create new migration files.
 */
final class MigrateMakeCommand
{
    public function __construct(
        private readonly MigrationGenerator $generator
    ) {}

    public function handle(string $name, string $path, array $options = []) : int
    {
        $table  = $options['table'] ?? null;
        $create = $options['create'] ?? false;

        $this->info(msg: "Creating migration: {$name}");

        try {
            $filepath = $this->generator->generate(name: $name, path: $path, table: $table, create: $create);
            $filename = basename(path: $filepath);
            $this->success(msg: "Migration created successfully!");
            echo "  📄 {$filename}\n";

            return 0;
        } catch (Throwable $e) {
            $this->error(msg: 'Failed to create migration: ' . $e->getMessage());

            return 1;
        }
    }

    private function info(string $msg) : void
    {
        echo "\033[36m{$msg}\033[0m\n";
    }

    private function success(string $msg) : void
    {
        echo "\033[32m{$msg}\033[0m\n";
    }

    private function error(string $msg) : void
    {
        echo "\033[31m{$msg}\033[0m\n";
    }
}

=== Migrations/Execution/Console/MigrateRollbackCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Migrations\Execution\Repository\MigrationRepository;
use Avax\Migrations\Execution\Runner\MigrationRunner;
use Avax\Migrations\Generate\MigrationLoader;
use Throwable;

/**
 * Console command to rollback migrations.
 */
final class MigrateRollbackCommand
{
    public function __construct(
        private readonly MigrationRepository $repository,
        private readonly MigrationRunner     $runner,
        private readonly MigrationLoader     $loader
    ) {}

    public function handle(string $path, int $steps = 1) : int
    {
        $this->info(msg: "Rolling back {$steps} batch(es)...");

        $records = $this->repository->getLastBatch(steps: $steps);
        if (empty($records)) {
            $this->info(msg: 'Nothing to rollback.');

            return 0;
        }

        $all        = $this->loader->load(path: $path);
        $toRollback = [];
        foreach ($records as $record) {
            $name = $record['migration'];
            if (isset($all[$name])) {
                $toRollback[] = $all[$name];
            }
        }

        try {
            $this->runner->rollback(migrations: $toRollback, steps: $steps);
            $this->success(msg: sprintf('Rolled back %d migration(s) successfully!', count(value: $toRollback)));
            foreach ($records as $record) {
                echo "  ✓ {$record['migration']}\n";
            }

            return 0;
        } catch (Throwable $e) {
            $this->error(msg: 'Rollback failed: ' . $e->getMessage());

            return 1;
        }
    }

    private function info(string $msg) : void
    {
        echo "\033[36m{$msg}\033[0m\n";
    }

    private function success(string $msg) : void
    {
        echo "\033[32m{$msg}\033[0m\n";
    }

    private function error(string $msg) : void
    {
        echo "\033[31m{$msg}\033[0m\n";
    }
}

=== Migrations/Execution/Console/MigrateStatusCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console;

use Avax\Migrations\Execution\Repository\MigrationRepository;
use Avax\Migrations\Generate\MigrationLoader;

/**
 * Console command to show migration status.
 */
final class MigrateStatusCommand
{
    public function __construct(
        private readonly MigrationRepository $repository,
        private readonly MigrationLoader     $loader
    ) {}

    public function handle(string $path) : int
    {
        $this->info(msg: 'Migration Status:');
        echo "\n";

        $all = $this->loader->load(path: $path);
        $ran = $this->repository->getRan();

        if (empty($all)) {
            echo "No migrations found.\n";

            return 0;
        }

        echo str_pad(string: 'Migration', length: 50) . " | Status  | Integrity\n";
        echo str_repeat(string: '-', times: 80) . "\n";

        $ranMap = array_column(array: $ran, column_key: 'checksum', index_key: 'migration');

        foreach ($all as $name => $migration) {
            $isRan  = isset($ranMap[$name]);
            $status = $isRan ? "\033[32mRAN\033[0m" : "\033[33mPENDING\033[0m";

            $integrity = '---';
            if ($isRan) {
                $dbChecksum   = $ranMap[$name];
                $fileChecksum = $this->loader->getChecksum(name: $name, path: $path);

                if (! $dbChecksum) {
                    $integrity = "\033[34mLEGACY\033[0m"; // Table created before checksum support
                } elseif ($dbChecksum === $fileChecksum) {
                    $integrity = "\033[32mOK\033[0m";
                } else {
                    $integrity = "\033[31mTAMPERED\033[0m";
                }
            }

            echo str_pad(string: $name, length: 50) . " | " . str_pad(string: $status, length: 15) . " | {$integrity}\n";
        }

        echo "\n";
        $this->info(msg: sprintf('Total: %d | Ran: %d | Pending: %d', count(value: $all), count(value: $ran), count(value: $all) - count(value: $ran)));

        return 0;
    }

    private function info(string $msg) : void
    {
        echo "\033[36m{$msg}\033[0m\n";
    }
}

=== Migrations/Execution/Console/Operations/TableDropCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console\Operations;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Console command to drop one or more tables.
 */
final class TableDropCommand
{
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    /**
     * Handle the command execution.
     *
     * @param string $tables Comma-separated or single table name
     *
     * @return int Exit code
     */
    public function handle(string $tables) : int
    {
        echo "\033[33mCAUTION: You are about to DROP the following table(s): {$tables}\033[0m\n";
        echo "Are you sure? [y/N]: ";

        $confirmation = trim(string: fgets(stream: STDIN));
        if (strtolower(string: $confirmation) !== 'y') {
            echo "Operation cancelled.\n";

            return 0;
        }

        $tableList = array_map(callback: 'trim', array: explode(separator: ',', string: $tables));

        foreach ($tableList as $table) {
            echo "\033[36mDropping table: {$table}...\033[0m ";
            try {
                $this->builder->dropIfExists(table: $table);
                echo "\033[32mDONE\033[0m\n";
            } catch (Throwable $e) {
                echo "\033[31mFAILED: {$e->getMessage()}\033[0m\n";

                return 1;
            }
        }

        return 0;
    }
}

=== Migrations/Execution/Console/Operations/TableTruncateCommand.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Console\Operations;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Console command to truncate one or more tables.
 */
final class TableTruncateCommand
{
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    /**
     * Handle the command execution.
     *
     * @param string $tables Comma-separated or single table name
     *
     * @return int Exit code
     */
    public function handle(string $tables) : int
    {
        echo "\033[33mCAUTION: You are about to TRUNCATE (clear) the following table(s): {$tables}\033[0m\n";
        echo "Are you sure? [y/N]: ";

        $confirmation = trim(string: fgets(stream: STDIN));
        if (strtolower(string: $confirmation) !== 'y') {
            echo "Operation cancelled.\n";

            return 0;
        }

        $tableList = array_map(callback: 'trim', array: explode(separator: ',', string: $tables));

        foreach ($tableList as $table) {
            echo "\033[36mTruncating table: {$table}...\033[0m ";
            try {
                $this->builder->truncate(table: $table);
                echo "\033[32mDONE\033[0m\n";
            } catch (Throwable $e) {
                echo "\033[31mFAILED: {$e->getMessage()}\033[0m\n";

                return 1;
            }
        }

        return 0;
    }
}

=== Migrations/Execution/Migration.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution;

/**
 * Technical contract for all database migration executions.
 *
 * -- intent: define the structural lifecycle (Up/Down) that the Execution Engine triggers.
 */
interface Migration
{
    /**
     * Apply the structural database modifications.
     */
    public function up() : void;

    /**
     * Revert the structural database modifications.
     */
    public function down() : void;
}

=== Migrations/Execution/Repository/MigrationRepository.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Repository;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Technical authority for the 'migrations' table auditing and record management.
 *
 * -- intent: centralize persistence and retrieval of migration execution history.
 */
final class MigrationRepository
{
    private string $table = 'migrations';

    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    /**
     * @throws Throwable
     */
    public function getRan() : array
    {
        return $this->builder->from(table: $this->table)
            ->select('migration', 'checksum')
            ->get();
    }

    /**
     * @throws Throwable
     */
    public function getLastBatch(int $steps = 1) : array
    {
        $maxBatch = (int) $this->builder->from(table: $this->table)->max(column: 'batch');
        $minBatch = max(0, $maxBatch - $steps + 1);

        return $this->builder->from(table: $this->table)
            ->where(column: 'batch', operator: '>=', value: $minBatch)
            ->orderBy(column: 'batch', direction: 'DESC')
            ->orderBy(column: 'migration', direction: 'DESC')
            ->get();
    }

    /**
     * @throws Throwable
     */
    public function getNextBatchNumber() : int
    {
        return (int) $this->builder->from(table: $this->table)->max(column: 'batch') + 1;
    }

    /**
     * @throws Throwable
     */
    public function log(string $name, int $batch, string $checksum) : void
    {
        $this->builder->from(table: $this->table)->insert(values: [
                                                                      'migration' => $name,
                                                                      'batch'     => $batch,
                                                                      'checksum'  => $checksum
                                                                  ]);
    }

    public function remove(string $name) : void
    {
        $this->builder->from(table: $this->table)->where(column: 'migration', value: $name)->delete();
    }

    public function ensureTableExists() : void
    {
        try {
            $this->builder->from(table: $this->table)->limit(limit: 1)->get();
        } catch (Throwable $e) {
            $this->createRepository();
        }
    }

    /**
     * @throws Throwable
     */
    public function createRepository() : void
    {
        $this->builder->create(table: $this->table, callback: function ($table) {
            $table->id();
            $table->string(name: 'migration');
            $table->integer(name: 'batch');
            $table->string(name: 'checksum')->nullable();
        });
    }
}

=== Migrations/Execution/Runner/MigrationRunner.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Runner;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Migrations\Exceptions\MigrationException;
use Avax\Migrations\Execution\Repository\MigrationRepository;
use Throwable;

/**
 * Technical supervisor responsible for the execution lifecycle of migrations.
 *
 * -- intent: coordinate the UP/DOWN operations of migrations and update the system audit trail.
 */
final readonly class MigrationRunner
{
    public function __construct(
        private MigrationRepository $repository,
        private QueryBuilder        $builder
    ) {}

    public function up(array $migrations, string $path, bool $dryRun = false) : void
    {
        if ($dryRun) {
            $this->builder->pretend();
        }

        try {
            $ran      = $this->repository->getRan();
            $ranNames = array_column(array: $ran, column_key: 'migration');
            $batch    = $this->repository->getNextBatchNumber();

            foreach ($migrations as $name => $migration) {
                if (in_array(needle: $name, haystack: $ranNames, strict: true)) {
                    continue;
                }

                $checksum = md5_file(filename: rtrim(string: $path, characters: DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $name . '.php');
                $this->runMigration(migration: $migration, method: 'up', name: $name, batch: $batch, checksum: $checksum);
            }
        } catch (Throwable $e) {
            throw new MigrationException(migrationClass: 'Runner', message: $e->getMessage(), previous: $e);
        }
    }

    private function runMigration($migration, string $method, string $name, int|null $batch = null, ?string $checksum = null) : void
    {
        try {
            // Inject QueryBuilder into migration if it supports it
            if (method_exists(object_or_class: $migration, method: 'setQueryBuilder')) {
                $migration->setQueryBuilder($this->builder);
            }

            $this->builder->transaction(callback: function () use ($migration, $method, $name, $batch, $checksum) {
                $migration->{$method}();

                if ($method === 'up') {
                    $this->repository->log(name: $name, batch: (int) $batch, checksum: $checksum);
                } else {
                    $this->repository->remove(name: $name);
                }
            });
        } catch (Throwable $e) {
            throw new MigrationException(
                migrationClass: $name,
                message       : "Failed during [{$method}]: " . $e->getMessage(),
                previous      : $e
            );
        }
    }

    public function rollback(array $migrations, int $steps = 1) : void
    {
        try {
            $migrationsByName = [];
            foreach ($migrations as $m) {
                $migrationsByName[$m::class] = $m;
            }

            $records = $this->repository->getLastBatch(steps: $steps);

            foreach ($records as $record) {
                $name = $record['migration'];

                if (isset($migrationsByName[$name])) {
                    $this->runMigration(migration: $migrationsByName[$name], method: 'down', name: $name);
                }
            }
        } catch (Throwable $e) {
            throw new MigrationException(migrationClass: 'Runner', message: $e->getMessage(), previous: $e);
        }
    }
}

=== Migrations/Execution/Seeding/Seeder.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Execution\Seeding;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;

/**
 * Base Seeder class.
 *
 * -- intent: provide a foundation for populating tables with sample or initial data.
 */
abstract class Seeder
{
    /**
     * Seed the given seeder class.
     */
    public function call(string $class) : void
    {
        basename(path: $class);
        echo "\033[36mSeeding:\033[0m {$class}\n";
        (new $class())->run();
    }

    /**
     * Run the database seeds.
     */
    abstract public function run() : void;

    /**
     * Get a query builder instance for a table.
     */
    protected function command(string $table) : QueryBuilder
    {
        return app(abstract: QueryBuilder::class)->from($table);
    }
}

=== Migrations/Export/DatabaseExporter.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Export;

use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Throwable;

/**
 * Database exporter.
 *
 * -- intent: provide functionality to export database schema and/or data.
 */
final class DatabaseExporter
{
    public function __construct(
        private readonly QueryBuilder $builder
    ) {}

    /**
     * Export the database schema and data to a SQL file.
     *
     * -- intent: generate a SQL dump of the database.
     *
     * @param string      $path  Path to save the export
     * @param string|null $table Optional specific table to export
     *
     * @return string Path to the exported file
     * @throws Throwable If export fails
     */
    public function exportToSql(string $path, ?string $table = null) : string
    {
        $filename = ($table ?: 'full_db') . '_export_' . date(format: 'Y_m_d_His') . '.sql';
        $fullPath = rtrim(string: $path, characters: DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $filename;

        if (! is_dir(filename: $path)) {
            mkdir(directory: $path, permissions: 0755, recursive: true);
        }

        $output = "-- Avax Database Export\n";
        $output .= "-- Generated: " . date(format: 'Y-m-d H:i:s') . "\n";
        $output .= $table ? "-- Table: {$table}\n\n" : "-- Scope: Full Database\n\n";

        $tables = $table ? [['name' => $table]] : $this->builder->raw(value: "SHOW TABLES")->get();

        foreach ($tables as $tableRow) {
            $tableName = array_values(array: $tableRow)[0];

            // 1. Export Schema
            $createTable = $this->builder->raw(value: "SHOW CREATE TABLE `{$tableName}`")->get()[0];
            $output      .= "DROP TABLE IF EXISTS `{$tableName}`;\n";
            $output      .= "{$createTable['Create Table']};\n\n";

            // 2. Export Data (Simple implementation)
            $rows = $this->builder->from(table: $tableName)->get();
            if (! empty($rows)) {
                $output .= "-- Data for `{$tableName}`\n";
                foreach ($rows as $row) {
                    $cols    = implode(separator: '`, `', array: array_keys(array: $row));
                    $vals    = array_map(callback: fn ($v) => is_null(value: $v) ? 'NULL' : "'" . addslashes(string: (string) $v) . "'", array: array_values(array: $row));
                    $valsStr = implode(separator: ', ', array: $vals);
                    $output  .= "INSERT INTO `{$tableName}` (`{$cols}`) VALUES ({$valsStr});\n";
                }
                $output .= "\n";
            }
        }

        file_put_contents(filename: $fullPath, data: $output);

        return $fullPath;
    }
}

=== Migrations/Generate/MigrationGenerator.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Generate;

use DateTime;
use RuntimeException;

/**
 * Migration file generator using external stubs.
 *
 * -- intent: create new migration files by populating templates.
 */
final class MigrationGenerator
{
    /**
     * Generate a new migration file.
     *
     * @param string      $name   Migration name (e.g., 'create_users_table')
     * @param string      $path   Target directory
     * @param string|null $table  Associated table name
     * @param bool        $create Whether this is a creation migration
     *
     * @return string Created file path
     */
    public function generate(string $name, string $path, ?string $table = null, bool $create = false) : string
    {
        $timestamp = $this->getTimestamp();
        $className = $this->getClassName(name: $name);
        $filename  = "{$timestamp}_{$name}.php";
        $filepath  = rtrim(string: $path, characters: DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $filename;

        $stub    = $this->getStubContent(table: $table, create: $create);
        $content = $this->populateStub(stub: $stub, className: $className, table: $table);

        if (! is_dir(filename: $path)) {
            mkdir(directory: $path, permissions: 0755, recursive: true);
        }

        file_put_contents(filename: $filepath, data: $content);

        return $filepath;
    }

    private function getTimestamp() : string
    {
        return (new DateTime())->format(format: 'Y_m_d_His');
    }

    private function getClassName(string $name) : string
    {
        return str_replace(
            search : ' ',
            replace: '',
            subject: ucwords(string: str_replace(search: '_', replace: ' ', subject: $name))
        );
    }

    private function getStubContent(?string $table, bool $create) : string
    {
        $stubName = 'blank.stub';

        if ($table !== null) {
            $stubName = $create ? 'create.stub' : 'update.stub';
        }

        $stubPath = __DIR__ . DIRECTORY_SEPARATOR . 'Stubs' . DIRECTORY_SEPARATOR . $stubName;

        if (! file_exists(filename: $stubPath)) {
            throw new RuntimeException(message: "Migration stub not found: {$stubPath}");
        }

        return file_get_contents(filename: $stubPath);
    }

    private function populateStub(string $stub, string $className, ?string $table) : string
    {
        $replacements = [
            '{{className}}' => $className,
            '{{table}}'     => $table ?? '',
        ];

        return str_replace(
            search : array_keys(array: $replacements),
            replace: array_values(array: $replacements),
            subject: $stub
        );
    }
}

=== Migrations/Generate/MigrationLoader.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations\Generate;

use Avax\Migrations\Design\BaseMigration;
use DirectoryIterator;

/**
 * Migration file loader and instantiator.
 *
 * -- intent: discover and load migration files from filesystem.
 */
final class MigrationLoader
{
    /**
     * Calculate the checksum for a migration file.
     */
    public function getChecksum(string $name, string $path) : string
    {
        $file = rtrim(string: $path, characters: DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $name . '.php';

        if (! file_exists(filename: $file)) {
            return '';
        }

        return md5_file(filename: $file);
    }

    public function getPending(string $path, array $ran) : array
    {
        $all = $this->load(path: $path);

        $ranNames = array_column(array: $ran, column_key: 'migration');

        return array_filter(
            array   : $all,
            callback: fn ($name) => ! in_array(needle: $name, haystack: $ranNames, strict: true),
            mode    : ARRAY_FILTER_USE_KEY
        );
    }

    public function load(string $path) : array
    {
        if (! is_dir(filename: $path)) {
            return [];
        }

        $migrations = [];
        $files      = $this->getMigrationFiles(path: $path);

        foreach ($files as $file) {
            $migration = $this->loadMigrationFile(file: $file);

            if ($migration !== null) {
                $migrations[$this->getMigrationName(file: $file)] = $migration;
            }
        }

        ksort(array: $migrations);

        return $migrations;
    }

    private function getMigrationFiles(string $path) : array
    {
        $files = [];

        foreach (new DirectoryIterator(directory: $path) as $fileInfo) {
            if ($fileInfo->isDot() || ! $fileInfo->isFile()) {
                continue;
            }

            if ($fileInfo->getExtension() === 'php') {
                $files[] = $fileInfo->getPathname();
            }
        }

        sort(array: $files);

        return $files;
    }

    private function loadMigrationFile(string $file) : ?BaseMigration
    {
        $migration = require $file;

        if ($migration instanceof BaseMigration) {
            return $migration;
        }

        return null;
    }

    public function getMigrationName(string $file) : string
    {
        return str_replace(search: '.php', replace: '', subject: basename(path: $file));
    }
}

=== Migrations/Generate/Stubs/blank.stub ===
<?php

declare(strict_types=1);

use Avax\Migrations\Design\BaseMigration;

/**
 * Migration: {{className}}
 */
return new class extends BaseMigration
{
    /**
     * Run the migrations.
     */
    public function up() : void
    {
        // Write your migration logic here
    }

    /**
     * Reverse the migrations.
     */
    public function down() : void
    {
        // Write your rollback logic here
    }
};

=== Migrations/Generate/Stubs/create.stub ===
<?php

declare(strict_types=1);

use Avax\Migrations\Design\BaseMigration;
use Avax\Migrations\Design\Table\Blueprint;

/**
 * Migration: {{className}}
 */
return new class extends BaseMigration
{
    /**
     * Run the migrations.
     */
    public function up() : void
    {
        $this->create(table: '{{table}}', callback: function (Blueprint $table) {
            $table->id();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down() : void
    {
        $this->drop(table: '{{table}}');
    }
};

=== Migrations/Generate/Stubs/update.stub ===
<?php

declare(strict_types=1);

use Avax\Migrations\Design\BaseMigration;
use Avax\Migrations\Design\Table\Blueprint;

/**
 * Migration: {{className}}
 */
return new class extends BaseMigration
{
    /**
     * Run the migrations.
     */
    public function up() : void
    {
        $this->table(table: '{{table}}', callback: function (Blueprint $table) {
            // Add your columns here
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down() : void
    {
        $this->table(table: '{{table}}', callback: function (Blueprint $table) {
            // Reverse your changes here
        });
    }
};

=== Migrations/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Migrations;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Migrations\Execution\Repository\MigrationRepository;
use Avax\Migrations\Execution\Runner\MigrationRunner;

/**
 * Functional module responsible for the database Migration feature.
 *
 * -- intent: coordinate the registration of migration repositories and runners.
 */
final readonly class Module implements LifecycleInterface
{
    /**
     * Constructor promoting the foundation container via PHP 8.3 features.
     *
     * -- intent: link the module to the central dependency injection system.
     *
     * @param Container $container The active DI vessel
     */
    public function __construct(
        private Container $container
    ) {}

    public static function declare() : array
    {
        return [
            'name'  => 'migrations',
            'class' => self::class
        ];
    }

    /**
     * Register Migration services into the foundation container.
     *
     * -- intent: define the resolution recipes for migration persistence and execution technicians.
     *
     * @return void
     */
    public function register() : void
    {
        $this->container->singleton(abstract: MigrationRepository::class, concrete: function ($c) {
            return new MigrationRepository(builder: $c->get(id: QueryBuilder::class));
        });

        $this->container->singleton(abstract: MigrationRunner::class, concrete: function ($c) {
            return new MigrationRunner(
                repository: $c->get(id: MigrationRepository::class),
                builder   : $c->get(id: QueryBuilder::class)
            );
        });
    }

    /**
     * Perform initialization logic for the migration feature.
     *
     * -- intent: ensure the feature is ready for use after registration.
     *
     * @return void
     */
    public function boot() : void
    {
        // No additional boot logic required for migrations
    }

    /**
     * Gracefully terminate the migration feature resources.
     *
     * -- intent: signal the end of the migration feature availability.
     *
     * @return void
     */
    public function shutdown() : void
    {
        // Shutdown logic if required
    }
}

=== Migrations/examples/2025_12_25_043000_create_products_table.php ===
<?php

declare(strict_types=1);

use Avax\Migrations\BaseMigration;
use Avax\Migrations\Design\Table\Blueprint;

/**
 * Example migration demonstrating the complete migration engine.
 *
 * Generated with: php migrate make create_products_table --create=products
 */
return new class extends BaseMigration {
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up() : void
    {
        $this->create(table: 'products', callback: function (Blueprint $table) {
            // Primary key
            $table->id();

            // Basic information
            $table->string(name: 'name', length: 255)->unique();
            $table->string(name: 'slug', length: 255)->unique()->index();
            $table->text(name: 'description')->nullable();
            $table->mediumText(name: 'full_description')->nullable();

            // Pricing (use DECIMAL for exact precision!)
            $table->decimal(name: 'price', precision: 10, scale: 2)->unsigned();
            $table->decimal(name: 'discount_percent', precision: 5, scale: 2)->unsigned()->default(value: 0);
            $table->decimal(name: 'cost', precision: 10, scale: 2)->unsigned()->nullable();

            // Inventory
            $table->integer(name: 'stock')->unsigned()->default(value: 0);
            $table->integer(name: 'reserved')->unsigned()->default(value: 0);
            $table->tinyInteger(name: 'min_order_qty')->unsigned()->default(value: 1);

            // Status & Flags
            $table->enum(name: 'status', values: ['draft', 'active', 'archived'])->default(value: 'draft');
            $table->boolean(name: 'is_featured')->default(value: false);
            $table->boolean(name: 'is_digital')->default(value: false);
            $table->boolean(name: 'requires_shipping')->default(value: true);

            // Categorization
            $table->set(name: 'tags', values: ['new', 'sale', 'bestseller', 'limited'])->nullable();

            // Metadata (JSON for flexible attributes)
            $table->json(name: 'attributes')->nullable(); // Color, size, material, etc.
            $table->json(name: 'seo_meta')->nullable();   // SEO title, description, keywords
            $table->json(name: 'shipping_info')->nullable();

            // External identifiers
            $table->uuid(name: 'external_id')->unique();
            $table->string(name: 'sku', length: 100)->unique();
            $table->string(name: 'barcode', length: 50)->nullable()->unique();

            // Foreign keys
            $table->bigInteger(name: 'category_id')->unsigned()
                ->references(table: 'categories', column: 'id', onDelete: 'CASCADE');
            $table->bigInteger(name: 'brand_id')->unsigned()->nullable()
                ->references(table: 'brands', column: 'id', onDelete: 'SET NULL');
            $table->bigInteger(name: 'created_by')->unsigned()->nullable()
                ->references(table: 'users', column: 'id', onDelete: 'SET NULL');

            // Timestamps
            $table->timestamps();                      // created_at, updated_at
            $table->softDeletes();                     // deleted_at
            $table->timestamp(name: 'published_at')->nullable();

            // Tracking & Analytics
            $table->integer(name: 'views')->unsigned()->default(value: 0)
                ->comment(text: 'Total product page views');
            $table->integer(name: 'sales_count')->unsigned()->default(value: 0)
                ->comment(text: 'Total number of sales');
            $table->decimal(name: 'avg_rating', precision: 3, scale: 2)->unsigned()->nullable()
                ->comment(text: 'Average customer rating (0.00 to 5.00)');

            // Auto-updating timestamp
            $table->timestamp(name: 'last_modified')->useCurrent()->useCurrentOnUpdate();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down() : void
    {
        $this->drop(table: 'products');
    }
};

=== Migrations/examples/all_types_demonstration.php ===
<?php

declare(strict_types=1);

use Avax\Migrations\Design\Table\Blueprint;
use Avax\Migrations\Migration;

/**
 * Comprehensive demonstration of ALL 63 supported SQL data types.
 *
 * -- intent: showcase complete type coverage across MySQL, PostgreSQL, and SQL Server.
 */
return new class extends Migration {
    /**
     * Execute the migration to create the comprehensive types table.
     *
     * @return void
     */
    public function up() : void
    {
        $this->create(table: 'all_sql_types_demo', callback: function (Blueprint $table) {
            // ========================================
            // NUMERIC TYPES (12)
            // ========================================
            $table->id(); // BIGINT AUTO_INCREMENT PRIMARY KEY
            $table->tinyInteger(name: 'tiny_int_col')->unsigned()->default(value: 0);
            $table->smallInteger(name: 'small_int_col')->default(value: 1);
            $table->mediumInteger(name: 'medium_int_col')->unsigned(); // MySQL
            $table->integer(name: 'int_col')->unsigned()->default(value: 0);
            $table->bigInteger(name: 'big_int_col')->nullable();
            $table->serial(name: 'serial_col'); // PostgreSQL
            $table->bigSerial(name: 'big_serial_col'); // PostgreSQL

            $table->decimal(name: 'decimal_col', precision: 10, scale: 2)->unsigned();
            $table->float(name: 'float_col')->default(value: 0.0);
            $table->double(name: 'double_col')->nullable();
            $table->real(name: 'real_col')->nullable();
            $table->boolean(name: 'bool_col')->default(value: true);

            // ========================================
            // STRING TYPES (11)
            // ========================================
            $table->string(name: 'varchar_col', length: 255)->unique();
            $table->char(name: 'char_col', length: 10)->default(value: 'CODE');
            $table->tinyText(name: 'tiny_text_col'); // MySQL
            $table->text(name: 'text_col')->nullable();
            $table->mediumText(name: 'medium_text_col')->nullable();
            $table->longText(name: 'long_text_col')->nullable();

            // Unicode strings (SQL Server)
            $table->nchar(name: 'nchar_col', length: 10);
            $table->nvarchar(name: 'nvarchar_col', length: 255);
            $table->ntext(name: 'ntext_col')->nullable();

            // ========================================
            // BINARY TYPES (9)
            // ========================================
            $table->binary(name: 'binary_col', length: 64);
            $table->varbinary(name: 'varbinary_col', length: 255);
            $table->blob(name: 'blob_col')->nullable();
            $table->tinyBlob(name: 'tiny_blob_col'); // MySQL
            $table->mediumBlob(name: 'medium_blob_col'); // MySQL
            $table->longBlob(name: 'long_blob_col'); // MySQL
            $table->bytea(name: 'bytea_col'); // PostgreSQL
            $table->bit(name: 'bit_col', length: 8);

            // ========================================
            // UUID / IDENTIFIERS (3)
            // ========================================
            $table->uuid(name: 'uuid_col')->unique();
            $table->uuidNative(name: 'uuid_native_col')->unique(); // PostgreSQL
            $table->uniqueIdentifier(name: 'guid_col'); // SQL Server

            // ========================================
            // DATE/TIME TYPES (7)
            // ========================================
            $table->date(name: 'date_col')->nullable();
            $table->datetime(name: 'datetime_col')->nullable();
            $table->timestamp(name: 'timestamp_col')->useCurrent();
            $table->time(name: 'time_col')->nullable();
            $table->year(name: 'year_col')->nullable();
            $table->interval(name: 'interval_col'); // PostgreSQL
            $table->timestamps(); // created_at, updated_at
            $table->softDeletes(); // deleted_at

            // ========================================
            // JSON TYPES (2)
            // ========================================
            $table->json(name: 'json_col')->nullable();
            $table->jsonb(name: 'jsonb_col')->nullable(); // PostgreSQL

            // ========================================
            // ENUM & SET (2)
            // ========================================
            $table->enum(name: 'enum_col', values: ['option1', 'option2', 'option3'])->default(value: 'option1');
            $table->set(name: 'set_col', values: ['tag1', 'tag2', 'tag3', 'tag4'])->nullable();

            // ========================================
            // SPECIAL TYPES (1)
            // ========================================
            $table->xml(name: 'xml_col')->nullable();

            // ========================================
            // GIS / SPATIAL TYPES (5)
            // ========================================
            $table->point(name: 'point_col')->nullable();
            $table->lineString(name: 'linestring_col')->nullable();
            $table->polygon(name: 'polygon_col')->nullable();
            $table->geometry(name: 'geometry_col')->nullable();
            $table->geography(name: 'geography_col')->nullable();

            // ========================================
            // POSTGRESQL SPECIFIC (5)
            // ========================================
            $table->inet(name: 'inet_col')->nullable(); // IP address
            $table->cidr(name: 'cidr_col')->nullable(); // Network range
            $table->macaddr(name: 'macaddr_col')->nullable(); // MAC address
            $table->tsvector(name: 'tsvector_col')->nullable(); // Full-text search
            $table->tsquery(name: 'tsquery_col')->nullable(); // Full-text query

            // ========================================
            // SQL SERVER SPECIFIC (3)
            // ========================================
            $table->money(name: 'money_col')->nullable();
            $table->smallMoney(name: 'small_money_col')->nullable();
            $table->rowVersion(name: 'row_version_col'); // Auto-updated

            // ========================================
            // ADVANCED FEATURES
            // ========================================

            // Auto-updating timestamp
            $table->timestamp(name: 'last_modified')->useCurrent()->useCurrentOnUpdate();

            // Column with comment
            $table->string(name: 'internal_code', length: 50)
                ->unique()
                ->comment(text: 'Internal tracking code for analytics');

            // Unsigned integer with index
            $table->integer(name: 'indexed_value')->unsigned()->index();

            // Charset and collation (MySQL)
            $table->string(name: 'utf8_col', length: 255)
                ->charset(charset: 'utf8mb4')
                ->collation(collation: 'utf8mb4_unicode_ci');
        });
    }

    /**
     * Reverse the migration by dropping the table.
     *
     * @return void
     */
    public function down() : void
    {
        $this->drop(table: 'all_sql_types_demo');
    }
};

=== Migrations/examples/comprehensive_types_example.php ===
<?php

declare(strict_types=1);

use Avax\Migrations\Design\Table\Blueprint;
use Avax\Migrations\Migration;

/**
 * Example migration demonstrating comprehensive SQL data type support.
 *
 * -- intent: showcase all available column types and modifiers.
 */
return new class extends Migration {
    /**
     * Execute the migration to create the example table.
     *
     * @return void
     */
    public function up() : void
    {
        $this->create(table: 'comprehensive_example', callback: function (Blueprint $table) {
            // ========================================
            // NUMERIC TYPES
            // ========================================
            $table->id(); // Auto-incrementing BIGINT primary key
            $table->tinyInteger(name: 'status')->unsigned()->default(value: 0);
            $table->smallInteger(name: 'priority')->default(value: 1);
            $table->integer(name: 'views')->unsigned()->default(value: 0);
            $table->bigInteger(name: 'large_number')->nullable();
            $table->decimal(name: 'price', precision: 10, scale: 2)->unsigned();
            $table->float(name: 'rating')->default(value: 0.0);
            $table->double(name: 'precise_value')->nullable();
            $table->boolean(name: 'is_active')->default(value: true);

            // ========================================
            // STRING TYPES
            // ========================================
            $table->string(name: 'title', length: 255)->unique();
            $table->string(name: 'slug', length: 255)->unique()->index();
            $table->char(name: 'country_code', length: 2)->default(value: 'US');
            $table->text(name: 'description')->nullable();
            $table->mediumText(name: 'content')->nullable();
            $table->longText(name: 'full_text')->nullable();
            $table->uuid(name: 'external_id')->unique();
            $table->binary(name: 'hash', length: 64)->nullable();

            // ========================================
            // DATE/TIME TYPES
            // ========================================
            $table->date(name: 'birth_date')->nullable();
            $table->datetime(name: 'published_at')->nullable();
            $table->timestamp(name: 'verified_at')->nullable();
            $table->time(name: 'opening_time')->nullable();
            $table->year(name: 'year_established')->nullable();
            $table->timestamps(); // created_at, updated_at
            $table->softDeletes(); // deleted_at

            // ========================================
            // SPECIAL TYPES
            // ========================================
            $table->json(name: 'metadata')->nullable();
            $table->enum(name: 'type', values: ['article', 'video', 'podcast'])->default(value: 'article');
            $table->set(name: 'tags', values: ['tech', 'business', 'science', 'health'])->nullable();

            // ========================================
            // ADVANCED FEATURES
            // ========================================

            // Foreign key example
            $table->bigInteger(name: 'user_id')->unsigned()->references(table: 'users', column: 'id', onDelete: 'CASCADE');

            // Computed/Generated columns (MySQL 5.7+)
            // $table->integer(name: 'full_price')->storedAs(expression: 'price * quantity');
            // $table->string(name: 'full_name', length: 255)->virtualAs(expression: "CONCAT(first_name, ' ', last_name)");

            // Timestamp with auto-update
            $table->timestamp(name: 'last_modified')->useCurrent()->useCurrentOnUpdate();

            // Column with comment
            $table->string(name: 'internal_code', length: 50)
                ->unique()
                ->comment(text: 'Internal tracking code for analytics');
        });
    }

    /**
     * Reverse the migration by dropping the table.
     *
     * @return void
     */
    public function down() : void
    {
        $this->drop(table: 'comprehensive_example');
    }
};

=== Migrations/examples/type_mapper_usage.php ===
<?php

declare(strict_types=1);

/**
 * PHP Type Mapper Usage Examples
 *
 * Demonstrates how to use SQLToPHPTypeMapper for DTO/Entity generation.
 */

use Avax\Migrations\TypeMapping\SQLToPHPTypeMapper;

require_once __DIR__ . '/../TypeMapping/SQLToPHPTypeMapper.php';

$mapper = new SQLToPHPTypeMapper();

echo "=== SQL to PHP Type Mapping Examples ===\n\n";

// ========================================
// BASIC TYPE MAPPING
// ========================================

echo "1. Basic Type Mapping:\n";
echo "   VARCHAR(255) → " . $mapper->toPhpType('VARCHAR(255)') . "\n";
echo "   BIGINT → " . $mapper->toPhpType('BIGINT') . "\n";
echo "   DECIMAL(10,2) → " . $mapper->toPhpType('DECIMAL(10,2)') . "\n";
echo "   TIMESTAMP → " . $mapper->toPhpType('TIMESTAMP') . "\n";
echo "   JSON → " . $mapper->toPhpType('JSON') . "\n";
echo "   BOOLEAN → " . $mapper->toPhpType('BOOLEAN') . "\n\n";

// ========================================
// PHPDOC TYPE HINTS
// ========================================

echo "2. PHPDoc Type Hints:\n";
echo "   JSON (nullable) → " . $mapper->toDocBlockType('JSON', nullable: true) . "\n";
echo "   POINT → " . $mapper->toDocBlockType('POINT') . "\n";
echo "   SET → " . $mapper->toDocBlockType('SET') . "\n";
echo "   BIGINT (nullable) → " . $mapper->toDocBlockType('BIGINT', nullable: true) . "\n\n";

// ========================================
// VALUE OBJECT SUGGESTIONS
// ========================================

echo "3. Value Object Suggestions:\n";
$types = ['UUID', 'INET', 'MONEY', 'POINT', 'VARCHAR'];
foreach ($types as $type) {
    $shouldUse = $mapper->shouldUseValueObject($type) ? 'YES' : 'NO';
    $vo        = $mapper->suggestValueObject($type) ?? 'N/A';
    echo "   {$type}: Use VO? {$shouldUse}, Suggested: {$vo}\n";
}
echo "\n";

// ========================================
// DTO GENERATION EXAMPLE
// ========================================

echo "4. Generated DTO Example:\n\n";

$columns = [
    ['name' => 'id', 'type' => 'BIGINT', 'nullable' => false],
    ['name' => 'email', 'type' => 'VARCHAR(255)', 'nullable' => false],
    ['name' => 'age', 'type' => 'INT', 'nullable' => true],
    ['name' => 'price', 'type' => 'DECIMAL(10,2)', 'nullable' => false],
    ['name' => 'created_at', 'type' => 'TIMESTAMP', 'nullable' => false],
    ['name' => 'metadata', 'type' => 'JSON', 'nullable' => true],
    ['name' => 'location', 'type' => 'POINT', 'nullable' => false],
    ['name' => 'external_id', 'type' => 'UUID', 'nullable' => false],
];

echo "<?php\n\n";
echo "declare(strict_types=1);\n\n";
echo "final class ProductDTO\n{\n";

foreach ($columns as $column) {
    $phpType = $mapper->toPhpType($column['type']);
    $docType = $mapper->toDocBlockType($column['type'], $column['nullable']);
    $vo      = $mapper->suggestValueObject($column['type']);

    // Use Value Object if suggested
    if ($vo !== null) {
        $phpType = $vo;
    }

    // Add nullable prefix
    $typeHint = $column['nullable'] ? "?{$phpType}" : $phpType;

    // Add PHPDoc for complex types
    if (in_array(needle: $phpType, haystack: ['array', 'GeoPoint'], strict: true)) {
        echo "    /** @var {$docType} */\n";
    }

    echo "    public {$typeHint} \${$column['name']};\n\n";
}

echo "}\n\n";

// ========================================
// SUPPORTED TYPES LIST
// ========================================

echo "5. All Supported Types (" . count(value: $mapper->getSupportedTypes()) . " total):\n";
$types  = $mapper->getSupportedTypes();
$chunks = array_chunk(array: $types, length: 5);
foreach ($chunks as $chunk) {
    echo "   " . implode(separator: ', ', array: $chunk) . "\n";
}
echo "\n";

// ========================================
// TYPE VALIDATION
// ========================================

echo "6. Type Validation:\n";
$testTypes = ['VARCHAR', 'BIGINT', 'FOOBAR', 'JSON', 'INVALID'];
foreach ($testTypes as $type) {
    $isSupported = $mapper->isSupported($type) ? '✓ Supported' : '✗ Not Supported';
    echo "   {$type}: {$isSupported}\n";
}
echo "\n";

echo "=== End of Examples ===\n";

=== QueryBuilder/Core/Builder/Concerns/HasAdvancedMutations.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Throwable;

/**
 * Trait providing complex data modification capabilities for the QueryBuilder.
 *
 * -- intent:
 * Extends the QueryBuilder with advanced, industrialized mutation patterns 
 * such as atomic UPSERT (insert-or-update) and thread-safe arithmetic 
 * operations (increment/decrement) at the database level.
 *
 * -- invariants:
 * - Mutations must be dispatched via the QueryOrchestrator to ensure atomicity.
 * - Arithmetic operations must be performed using database-side expressions 
 *   to prevent race conditions.
 * - UPSERT operations must normalize input values into a consistent batch format.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation (delegated to Grammar).
 * - Only applies to compatible database engines that support complex mutations.
 */
trait HasAdvancedMutations
{
    /**
     * Perform an atomic UPSERT (Insert or Update) operation.
     *
     * -- intent:
     * Dispatches a single instruction to the database to either insert new 
     * records or update existing ones if a unique constraint conflict occurs, 
     * significantly reducing net database round-trips.
     *
     * @param array        $values   A single associative array or a collection of arrays representing records.
     * @param array|string $uniqueBy The collection of technical field names that define the unique constraint.
     * @param array|null   $update   The collection of technical fields to modify upon conflict (defaults to all provided values).
     * @throws Throwable If the SQL compilation for the specific dialect or physical execution fails.
     * @return int The total number of affected rows (database-specific semantics apply).
     */
    public function upsert(array $values, array|string $uniqueBy, array|null $update = null): int
    {
        if (empty($values)) {
            return 0;
        }

        if (! is_array(value: reset(array: $values))) {
            $values = [$values];
        }

        if ($update === null) {
            $update = array_keys(array: reset(array: $values));
        }

        $state = $this->state
            ->withValues(values: $values)
            ->withUpdateColumns(columns: (array) $update);

        $sql = $this->grammar->compileUpsert(
            state: $state,
            uniqueBy: (array) $uniqueBy,
            update: $state->updateColumns
        );

        return $this->orchestrator->execute(
            sql: $sql,
            bindings: $state->getBindings()
        )->getAffectedRows();
    }

    /**
     * Atomically increment a numeric field by a specific quantity.
     *
     * -- intent:
     * Execute a server-side addition to a specific column, ensuring that 
     * the operation is thread-safe and immune to typical application-level 
     * read-modify-write race conditions.
     *
     * @param string          $column The technical name of the numeric field to increment.
     * @param int|float|null  $amount The quantity to add (defaults to 1).
     * @param array           $extra  Optional additional fields to update simultaneously for auditing or state tracking.
     * @throws Throwable If the resulting SQL update execution fails.
     * @return bool True if the operation was successful.
     */
    public function increment(string $column, int|float|null $amount = null, array $extra = []): bool
    {
        $amount  ??= 1;
        $wrapped = $this->grammar->wrap(value: $column);
        $update  = array_merge([$column => $this->raw(value: "{$wrapped} + {$amount}")], $extra);

        return $this->update(values: $update);
    }

    /**
     * Atomically decrement a numeric field by a specific quantity.
     *
     * -- intent:
     * Execute a server-side subtraction from a specific column, ensuring 
     * thread-safe value modification at the database level.
     *
     * @param string          $column The technical name of the numeric field to decrement.
     * @param int|float|null  $amount The quantity to subtract (defaults to 1).
     * @param array           $extra  Optional additional fields to update simultaneously.
     * @throws Throwable If the resulting SQL update execution fails.
     * @return bool True if the operation was successful.
     */
    public function decrement(string $column, int|float|null $amount = null, array $extra = []): bool
    {
        $amount  ??= 1;
        $wrapped = $this->grammar->wrap(value: $column);
        $update  = array_merge([$column => $this->raw(value: "{$wrapped} - {$amount}")], $extra);

        return $this->update(values: $update);
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasAggregates.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Throwable;

/**
 * Trait providing statistical and aggregate function capabilities for the QueryBuilder.
 *
 * -- intent:
 * Extends the QueryBuilder with a comprehensive Domain Specific Language (DSL) 
 * for performing server-side calculations (count, min, max, average, sum), 
 * optimizing data retrieval by aggregating results at the database level.
 *
 * -- invariants:
 * - Aggregate methods must return a single scalar value.
 * - Aggregate logic must use a cloned builder instance to prevent polluting the original query state.
 * - Results must be extracted from a virtual 'aggregate' column in the result set.
 *
 * -- boundaries:
 * - Does NOT handle complex window functions (delegated to raw expressions).
 * - Does NOT perform client-side calculation (all logic is SQL-based).
 */
trait HasAggregates
{
    /**
     * Retrieve the total count of records matching the current criteria.
     *
     * -- intent:
     * Provide a high-level shorthand for executing an SQL "COUNT(*)" or 
     * specific field aggregation to determine existence or volume.
     *
     * @param string $columns The specific technical field to target for counting (defaults to '*').
     * @throws Throwable If the query execution fails at the driver level.
     * @return int The total number of matching records found.
     */
    public function count(string $columns = '*'): int
    {
        return (int) $this->aggregate(function: 'count', columns: [$columns]);
    }

    /**
     * Retrieve the maximum value found in a specific field.
     *
     * -- intent:
     * Provide a high-level shorthand for executing an SQL "MAX(column)" 
     * aggregation across the current filtered dataset.
     *
     * @param string $column The technical field name whose peak value is required.
     * @throws Throwable If the query execution fails at the driver level.
     * @return mixed The highest scalar value found in the specified field.
     */
    public function max(string $column): mixed
    {
        return $this->aggregate(function: 'max', columns: [$column]);
    }

    /**
     * Retrieve the minimum value found in a specific field.
     *
     * -- intent:
     * Provide a high-level shorthand for executing an SQL "MIN(column)" 
     * aggregation across the current filtered dataset.
     *
     * @param string $column The technical field name whose lowest value is required.
     * @throws Throwable If the query execution fails at the driver level.
     * @return mixed The lowest scalar value found in the specified field.
     */
    public function min(string $column): mixed
    {
        return $this->aggregate(function: 'min', columns: [$column]);
    }

    /**
     * Calculate the average (mean) value for a specific numeric field.
     *
     * -- intent:
     * Provide a high-level shorthand for executing an SQL "AVG(column)" 
     * aggregation across the current filtered dataset.
     *
     * @param string $column The technical field name to target for averaging.
     * @throws Throwable If the query execution fails at the driver level.
     * @return mixed The calculated average value, or 0 if no records match.
     */
    public function avg(string $column): mixed
    {
        return $this->aggregate(function: 'avg', columns: [$column]);
    }

    /**
     * Calculate the cumulative sum of values in a specific numeric field.
     *
     * -- intent:
     * Provide a high-level shorthand for executing an SQL "SUM(column)" 
     * aggregation across the current filtered dataset.
     *
     * @param string $column The technical field name to target for summation.
     * @throws Throwable If the query execution fails at the driver level.
     * @return mixed The total cumulative sum calculated by the database server.
     */
    public function sum(string $column): mixed
    {
        return $this->aggregate(function: 'sum', columns: [$column]);
    }

    /**
     * Internal technician for executing a generic SQL aggregate function.
     *
     * -- intent:
     * Centralize the logic for query cloning, state modification, and scalar 
     * result extraction for all statistical aggregation operations.
     *
     * @param string $function The name of the SQL aggregate function (e.g., 'COUNT', 'SUM').
     * @param array  $columns  The technical field identifiers to target for the calculation.
     * @throws Throwable If the underlying query execution or result extraction fails.
     * @return mixed The resulting scalar data point retrieved from the aggregate projection.
     */
    protected function aggregate(string $function, array $columns = ['*']): mixed
    {
        $clone        = clone $this;
        $clone->state = $clone->state->withColumns(columns: [
            $this->raw(value: "{$function}(" . implode(separator: ', ', array: (array) $columns) . ") as aggregate")
        ]);

        $result = $clone->get();

        if (empty($result)) {
            return 0;
        }

        return $result[0]['aggregate'] ?? 0;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasConditions.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\Query\AST\NestedWhereNode;
use Avax\Database\Query\AST\WhereNode;
use Closure;
use InvalidArgumentException;

/**
 * Trait providing high-level logical filtering (WHERE) capabilities for the QueryBuilder.
 *
 * -- intent:
 * Extends the QueryBuilder with a comprehensive Domain Specific Language (DSL) 
 * for constructing structured SQL WHERE clauses, including support for 
 * nested groups, range filters, and membership checks.
 *
 * -- invariants:
 * - Every filter addition must return a new, cloned builder instance.
 * - Current filtering metadata must be appended to the QueryState's wheres collection.
 * - Bound parameters for filters must be securely merged into the QueryState's BindingBag.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation (delegated to Grammar).
 * - Does NOT validate column existence or technical types.
 */
trait HasConditions
{
    /**
     * Add a basic filtering criterion to the current query context.
     *
     * -- intent:
     * Restrict the result set based on a field comparison (equality, greater 
     * than, etc.) or initiate a nested logical group through a closure.
     *
     * @param string|Closure $column   The technical field name to filter, or a closure for nested logic.
     * @param mixed          $operator The SQL comparison operator or the target value (if operator is omitted).
     * @param mixed          $value    The comparison target value (if operator is explicitly provided).
     * @param string         $boolean  The logical joiner used to attach this condition ('AND' or 'OR').
     * @return self A fresh, cloned builder instance with the added filter.
     */
    public function where(
        string|Closure $column,
        mixed          $operator = null,
        mixed          $value = null,
        string         $boolean = 'AND'
    ): self {
        if ($column instanceof Closure) {
            return $this->whereNested(callback: $column, boolean: $boolean);
        }

        if (func_num_args() === 2) {
            $value    = $operator;
            $operator = '=';
        }

        $clone        = clone $this;
        $clone->state = $clone->state->addWhere(where: new WhereNode(
            column: $column,
            operator: (string) $operator,
            value: $value,
            boolean: $boolean
        ));

        if (! in_array(needle: $operator, haystack: ['IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN'])) {
            $clone->state = $clone->state->addBinding(value: $value);
        }

        return $clone;
    }

    /**
     * Add an "OR WHERE" criterion to the current query context.
     *
     * -- intent:
     * Provide an alternative logical branch for filtering results, 
     * acting as a shorthand for where() with the 'OR' boolean joiner.
     *
     * @param string|Closure $column   The technical field name or nested condition closure.
     * @param mixed          $operator The SQL comparison operator.
     * @param mixed          $value    The comparison target value.
     * @return self A fresh, cloned builder instance with the OR filter.
     */
    public function orWhere(string|Closure $column, mixed $operator = null, mixed $value = null): self
    {
        return $this->where(column: $column, operator: $operator, value: $value, boolean: 'OR');
    }

    /**
     * Filter results by a membership check against a specific collection of values.
     *
     * -- intent:
     * Provide an expressive DSL for SQL "IN" and "NOT IN" logic, 
     * handling bulk parameter binding automatically.
     *
     * @param string      $column  The technical field name to check for membership.
     * @param array       $values  The collection of allowed data tokens.
     * @param string|null $boolean The logical joiner ('AND' or 'OR').
     * @param bool        $not     Flag indicating whether to use negative (NOT IN) logic.
     * @return self A fresh, cloned builder instance with the membership filter.
     */
    public function whereIn(string $column, array $values, string|null $boolean = null, bool $not = false): self
    {
        $boolean  ??= 'AND';
        $operator = $not ? 'NOT IN' : 'IN';

        $clone        = clone $this;
        $clone->state = $clone->state->addWhere(where: new WhereNode(
            column: $column,
            operator: $operator,
            value: $values,
            boolean: $boolean
        ));

        $clone->state = $clone->state->mergeBindings(values: $values);

        return $clone;
    }

    /**
     * Add an "OR WHERE IN" criterion to the current query context.
     *
     * -- intent:
     * Provide an alternative membership filtering branch, acting as a 
     * shorthand for whereIn() with the 'OR' boolean joiner.
     *
     * @param string $column The technical field name to check.
     * @param array  $values The collection of allowed data tokens.
     * @return self A fresh, cloned builder instance with the OR membership filter.
     */
    public function orWhereIn(string $column, array $values): self
    {
        return $this->whereIn(column: $column, values: $values, boolean: 'OR');
    }

    /**
     * Filter results by verifying a column's value falls within a specified range.
     *
     * -- intent:
     * Provide an expressive DSL for SQL "BETWEEN" and "NOT BETWEEN" logic,
     * ensuring exactly two values are provided for the range.
     *
     * @param string      $column  The technical field name to check.
     * @param array       $values  A pair of values defining the inclusive range.
     * @param string|null $boolean The logical joiner ('AND' or 'OR').
     * @param bool        $not     Flag indicating whether to use negative (NOT BETWEEN) logic.
     * @throws InvalidArgumentException If the provided values array does not contain exactly two items.
     * @return self A fresh, cloned builder instance with the range filter.
     */
    public function whereBetween(string $column, array $values, string|null $boolean = null, bool $not = false): self
    {
        $boolean ??= 'AND';
        if (count(value: $values) !== 2) {
            throw new InvalidArgumentException(message: "BETWEEN requires exactly two values.");
        }

        $operator = $not ? 'NOT BETWEEN' : 'BETWEEN';

        $clone        = clone $this;
        $clone->state = $clone->state->addWhere(where: new WhereNode(
            column: $column,
            operator: $operator,
            value: $values,
            boolean: $boolean
        ));

        $clone->state = $clone->state->mergeBindings(values: $values);

        return $clone;
    }

    /**
     * Coordinate the addition of a nested logical branch (grouped conditions).
     *
     * -- intent:
     * Encapsulate multiple conditions within parentheses in the resulting SQL,
     * allowing for complex logical grouping and order-of-operation control.
     *
     * @param Closure $callback A configuration closure receiving a fresh builder instance.
     * @param string  $boolean  The logical joiner for the entire nested group.
     * @return self A fresh, cloned builder instance containing the nested logical node.
     */
    protected function whereNested(Closure $callback, string $boolean = 'AND'): self
    {
        $query = $this->newQuery();

        $callback($query);

        $clone        = clone $this;
        $clone->state = $clone->state->addWhere(where: new NestedWhereNode(
            query: $query,
            boolean: $boolean
        ));

        $clone->state = $clone->state->mergeBindings(values: $query->state->getBindings());

        return $clone;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasControlStructures.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Closure;

/**
 * Trait providing programmatic branching and logical flow structures for the QueryBuilder.
 *
 * -- intent:
 * Extends the fluent QueryBuilder API with high-level control structures, 
 * allowing for dynamic query building based on external application state 
 * without breaking the continuous method chain.
 *
 * -- invariants:
 * - Callbacks must receive the current builder instance as their primary argument.
 * - Methods should return the resulting builder instance from the callback or 
 *   the current instance if no modification occurred.
 * - Promotes a declarative style for complex, multi-path query construction.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation or state storage directly.
 * - Callbacks are responsible for cloning or mutation policies (typically builder methods handle cloning).
 */
trait HasControlStructures
{
    /**
     * Programmatic branch: execute a callback only if a specific condition is met.
     *
     * -- intent:
     * Support dynamic query modification (e.g., adding filters based on user input) 
     * by encapsulating the logic within a conditional fluently-chained block.
     *
     * @param mixed         $condition Scalar, boolean, or truthy data point to evaluate.
     * @param callable      $callback  The logic to execute if the condition evaluates to true.
     * @param callable|null $default   Optional alternative logic to execute if the condition is false.
     * @return self The resulting builder instance after applying the conditional logic.
     */
    public function when(mixed $condition, callable $callback, callable|null $default = null): self
    {
        if ($condition) {
            return $callback($this, $condition) ?: $this;
        }

        if ($default !== null) {
            return $default($this, $condition) ?: $this;
        }

        return $this;
    }

    /**
     * Programmatic branch: execute a callback only if a specific condition is NOT met.
     *
     * -- intent:
     * Provides an expressive inverse of the when() method, typically used for 
     * applying default filters or logic when a specific flag is absent.
     *
     * @param mixed         $condition Scalar, boolean, or truthy data point to evaluate.
     * @param callable      $callback  The logic to execute if the condition evaluates to false.
     * @param callable|null $default   Optional alternative logic to execute if the condition is true.
     * @return self The resulting builder instance after applying the inverse conditional logic.
     */
    public function unless(mixed $condition, callable $callback, callable|null $default = null): self
    {
        return $this->when(condition: ! $condition, callback: $callback, default: $default);
    }

    /**
     * Fluent diagnostic hook: execute a callback on the builder without modifying the chain return.
     *
     * -- intent:
     * Provide a mechanism for side-effects (logging, debugging, inspection) 
     * within the fluent chain without requiring variable assignment.
     *
     * @param Closure $callback A logic hook receiving the current builder instance.
     * @return self The current builder instance.
     */
    public function tap(Closure $callback): self
    {
        $callback($this);

        return $this;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasGroups.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

/**
 * Trait providing aggregation grouping (GROUP BY) and aggregate filtering (HAVING) capabilities.
 *
 * -- intent:
 * Extends the QueryBuilder with a Domain Specific Language (DSL) for 
 * consolidating records based on shared attribute values and applying 
 * logical filters to the resulting aggregations.
 *
 * -- invariants:
 * - Every grouping or having addition must return a new, cloned builder instance.
 * - Grouping metadata must be accumulated within the QueryState's groups collection.
 * - Having parameters must be securely added to the QueryState's BindingBag.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation (delegated to Grammar).
 * - Does NOT validate the technical correctness of aggregate functions used in HAVING.
 */
trait HasGroups
{
    /**
     * Consolidate the result set by one or more specific technical fields.
     *
     * -- intent:
     * Organize matching records into groups based on identical values in the 
     * specified columns, typically used for performing server-side aggregations.
     *
     * @param string|array ...$columns A variable list of field names or arrays of names to group by.
     * @return self A fresh, cloned builder instance with the grouping criteria applied.
     */
    public function groupBy(string|array ...$columns): self
    {
        $clone  = clone $this;
        $groups = $this->state->groups;

        foreach ($columns as $column) {
            $groups = array_merge($groups, (array) $column);
        }

        $clone->state = $clone->state->withGroups(groups: $groups);

        return $clone;
    }

    /**
     * Apply a filtering criterion to aggregated groups in the result set.
     *
     * -- intent:
     * Provide a DSL for the SQL "HAVING" clause, allowing for logical 
     * filtering based on aggregate function results (e.g., HAVING count(*) > 5).
     *
     * @param string $column   The technical column name or aggregate function expression to filter.
     * @param string $operator The SQL comparison operator (e.g., '=', '>', '<').
     * @param mixed  $value    The comparison target value, which will be safely parameterized.
     * @param string $boolean  The logical joiner used to attach this condition ('AND' or 'OR').
     * @return self A fresh, cloned builder instance with the aggregate filter applied.
     */
    public function having(string $column, string $operator, mixed $value, string $boolean = 'AND'): self
    {
        $clone        = clone $this;
        $clone->state = $clone->state->addHaving(having: compact('column', 'operator', 'value', 'boolean'));
        $clone->state = $clone->state->addBinding(value: $value);

        return $clone;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasJoins.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\Query\AST\JoinNode;
use Avax\Database\QueryBuilder\Core\Builder\JoinClause;
use Closure;

/**
 * Trait providing relational join capabilities for the QueryBuilder.
 *
 * -- intent:
 * Extends the QueryBuilder with a Domain Specific Language (DSL) for 
 * establishing relationships between different data sources (tables), 
 * allowing for complex relational retrieval and mutation.
 *
 * -- invariants:
 * - Every join addition must return a new, cloned builder instance.
 * - Join metadata must be encapsulated within a JoinNode abstraction.
 * - Supports both simple column-to-column comparisons and complex closure-based conditions.
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation (delegated to Grammar).
 * - Does NOT perform schema verification for the target tables.
 */
trait HasJoins
{
    /**
     * Add an INNER JOIN clause to the current query context.
     *
     * -- intent:
     * Enforce a strict relational intersection between the primary source 
     * and the target table, retrieving only records that exist in both.
     *
     * @param string         $table    The technical name of the target database table to link.
     * @param string|Closure $first    The left-hand field name or a configuration closure for complex logic.
     * @param string|null    $operator The SQL comparison operator (defaults to '=' if second is provided).
     * @param string|null    $second   The right-hand field name belonging to the target table.
     * @return self A fresh, cloned builder instance with the inner join applied.
     */
    public function join(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ): self {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'inner');
    }

    /**
     * Add a LEFT JOIN clause to the current query context.
     *
     * -- intent:
     * Retrieve all records from the primary source while optionally linking 
     * matching records from the secondary target table.
     *
     * @param string         $table    The technical name of the target database table to link.
     * @param string|Closure $first    The left-hand field name or a configuration closure.
     * @param string|null    $operator The SQL comparison operator.
     * @param string|null    $second   The right-hand field name.
     * @return self A fresh, cloned builder instance with the left join applied.
     */
    public function leftJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ): self {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'left');
    }

    /**
     * Add a RIGHT JOIN clause to the current query context.
     *
     * -- intent:
     * Retrieve all records from the secondary target table while optionally 
     * linking matching records from the primary source.
     *
     * @param string         $table    The technical name of the target database table to link.
     * @param string|Closure $first    The left-hand field name or a configuration closure.
     * @param string|null    $operator The SQL comparison operator.
     * @param string|null    $second   The right-hand field name.
     * @return self A fresh, cloned builder instance with the right join applied.
     */
    public function rightJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null
    ): self {
        return $this->addJoin(table: $table, first: $first, operator: $operator, second: $second, type: 'right');
    }

    /**
     * Add a CROSS JOIN clause to the current query context.
     *
     * -- intent:
     * Produce a Cartesian product of the primary source and the target table,
     * linking every record of one to every record of the other.
     *
     * @param string $table The technical name of the target database table to cross-link.
     * @return self A fresh, cloned builder instance with the cross join applied.
     */
    public function crossJoin(string $table): self
    {
        return $this->addJoin(table: $table, first: '', type: 'cross');
    }

    /**
     * Internal technician for constructing and registering join definitions.
     *
     * -- intent:
     * Centralize the construction of JoinNode abstractions and their registration
     * within the QueryState container, handling both simple and complex signatures.
     *
     * @param string         $table    The technical identifier of the target table.
     * @param string|Closure $first    Condition column label or a logic configuration closure.
     * @param string|null    $operator The comparison operator used in the ON clause.
     * @param string|null    $second   The target comparison field label.
     * @param string         $type     The join strategy type (inner/left/right/cross).
     * @return self A fresh, cloned builder instance containing the new join metadata.
     */
    protected function addJoin(
        string         $table,
        string|Closure $first,
        string|null    $operator = null,
        string|null    $second = null,
        string         $type = 'inner'
    ): self {
        $clone = clone $this;

        if ($first instanceof Closure) {
            $joinClause = new JoinClause(grammar: $this->grammar);
            $first($joinClause);

            $clone->state = $clone->state->addJoin(join: new JoinNode(
                table: $table,
                type: $type,
                clause: $joinClause
            ));
        } else {
            $clone->state = $clone->state->addJoin(join: new JoinNode(
                table: $table,
                type: $type,
                first: $first,
                operator: $operator,
                second: $second
            ));
        }

        return $clone;
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasOrders.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\Query\AST\OrderNode;

/**
 * Trait providing sorting and ordering capabilities for the QueryBuilder.
 *
 * -- intent:
 * Extends the QueryBuilder with a Domain Specific Language (DSL) for 
 * defining the sequence of retrieved result sets (ORDER BY), supporting 
 * both standard column sorting and specialized random or chronological patterns.
 *
 * -- invariants:
 * - Every ordering instruction must return a new, cloned builder instance.
 * - Ordering metadata must be encapsulated within an OrderNode abstraction.
 * - Supports sequential ordering instructions (multiple ORDER BY clauses).
 *
 * -- boundaries:
 * - Does NOT handle SQL compilation (delegated to Grammar).
 * - Does NOT validate the existence of the targeted sorting columns.
 */
trait HasOrders
{
    /**
     * Add a primary sorting criterion (ORDER BY) to the current query context.
     *
     * -- intent:
     * Specify the technical field and orientation for the result set 
     * sequence at the database level.
     *
     * @param string $column    The technical field name to target for sorting.
     * @param string $direction The sorting orientation ('ASC' or 'DESC').
     * @return self A fresh, cloned builder instance with the applied order.
     */
    public function orderBy(string $column, string $direction = 'ASC'): self
    {
        $clone        = clone $this;
        $clone->state = $clone->state->addOrder(order: new OrderNode(
            column: $column,
            direction: strtoupper(string: $direction)
        ));

        return $clone;
    }

    /**
     * Add a descending sorting criterion (ORDER BY ... DESC).
     *
     * -- intent:
     * Provide an expressive shorthand for reverse chronological or reverse 
     * numeric sorting patterns.
     *
     * @param string $column The technical field name to target for descending sort.
     * @return self A fresh, cloned builder instance with the descending order.
     */
    public function orderByDesc(string $column): self
    {
        return $this->orderBy(column: $column, direction: 'DESC');
    }

    /**
     * Sort the resulting records in a random sequence.
     *
     * -- intent:
     * Provide a pragmatic DSL for fetching unpredictable results, delegating 
     * the specific random function generation to the grammar dialect.
     *
     * @return self A fresh, cloned builder instance with random ordering active.
     */
    public function inRandomOrder(): self
    {
        $clone        = clone $this;
        $clone->state = $clone->state->addOrder(order: new OrderNode(
            sql: $this->grammar->compileRandomOrder(),
            type: 'Raw'
        ));

        return $clone;
    }

    /**
     * Sort the result set by the most recent records first.
     *
     * -- intent:
     * Provide a chronological shorthand for prioritizing recently updated or 
     * created domain records.
     *
     * @param string $column The timestamp or sequence field to target (defaults to 'created_at').
     * @return self A fresh, cloned builder instance sorted by newest first.
     */
    public function latest(string $column = 'created_at'): self
    {
        return $this->orderBy(column: $column, direction: 'DESC');
    }

    /**
     * Sort the result set by the oldest records first.
     *
     * -- intent:
     * Provide a chronological shorthand for prioritizing historical domain 
     * records across the current dataset.
     *
     * @param string $column The timestamp or sequence field to target (defaults to 'created_at').
     * @return self A fresh, cloned builder instance sorted by oldest first.
     */
    public function oldest(string $column = 'created_at'): self
    {
        return $this->orderBy(column: $column, direction: 'ASC');
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasSchema.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Migrations\Design\Table\Blueprint;
use Throwable;

/**
 * Trait bridging the QueryBuilder with the Migration system for integrated schema management.
 *
 * -- intent:
 * Provides a high-level, fluent Domain Specific Language (DSL) for performing 
 * structural database modifications (creating tables, dropping schemas) 
 * directly within the builder context, facilitating rapid provisioning and teardown.
 *
 * -- invariants:
 * - Structural modifications must be dispatched via the QueryOrchestrator.
 * - Table creation must use the Blueprint abstraction to maintain dialect neutrality.
 * - Destructive operations (DROP/TRUNCATE) must be explicitly invoked with identifiers.
 *
 * -- boundaries:
 * - Does NOT handle the long-term versioning of schema changes (delegated to MigrationRepository).
 * - Does NOT perform safety checks beyond "IF EXISTS" clauses provided by grammar.
 */
trait HasSchema
{
    /**
     * Create a new database table structure fluently.
     *
     * -- intent:
     * Provide a standardized entry point for defining and executing table 
     * structural designs, delegating SQL generation to the Blueprint and Grammar.
     *
     * @param string   $table    The technical identifier for the new database table.
     * @param callable $callback A design closure receiving a Blueprint instance to define columns and indexes.
     * @throws Throwable If the SQL compilation for the dialect or physical execution fails.
     * @return void
     */
    public function create(string $table, callable $callback): void
    {
        $blueprint = new Blueprint(table: $table);
        $callback($blueprint);

        $statements = $blueprint->toSql(grammar: $this->grammar);

        foreach ($statements as $sql) {
            $this->orchestrator->execute(sql: $sql);
        }
    }

    /**
     * Remove a table from the database schema with built-in existence safety.
     *
     * -- intent:
     * Provide a safe, dialect-aware shorthand for destroying a table structure 
     * if it currently exists in the target database.
     *
     * @param string $table The technical name of the table to be removed.
     * @throws Throwable If the drop instruction execution fails at the driver level.
     * @return void
     */
    public function dropIfExists(string $table): void
    {
        $sql = $this->grammar->compileDropIfExists(table: $table);
        $this->orchestrator->execute(sql: $sql);
    }

    /**
     * Efficiently clear all records from a database table without destroying its structure.
     *
     * -- intent:
     * Provide a low-level, high-performance reset mechanism (SQL TRUNCATE) for 
     * clearing raw data while preserving the schema and its indexes.
     *
     * @param string|null $table The optional technical name of the table (defaults to the builder's current source).
     * @throws Throwable If the truncate instruction execution fails.
     * @return void
     */
    public function truncate(string|null $table = null): void
    {
        $table = $table ?: $this->state->from;
        $sql   = $this->grammar->compileTruncate(table: $table);
        $this->orchestrator->execute(sql: $sql);
    }

    /**
     * Create a new database container/schema.
     *
     * -- intent:
     * Provide a direct mechanism for provisioning high-level schema containers 
     * within the database cluster.
     *
     * @param string $name The technical identifier for the new database/schema.
     * @throws Throwable If the creation command fails at the persistence layer.
     * @return void
     */
    public function createDatabase(string $name): void
    {
        $sql = $this->grammar->compileCreateDatabase(name: $name);
        $this->orchestrator->execute(sql: $sql);
    }

    /**
     * Permanently remove a database container/schema.
     *
     * -- intent:
     * Provide a direct mechanism for executing destructive schema-level removals.
     * WARNING: This operation is non-reversible and deletes all internal data.
     *
     * @param string $name The technical identifier of the database to be destroyed.
     * @throws Throwable If the destruction command fails.
     * @return void
     */
    public function dropDatabase(string $name): void
    {
        $sql = $this->grammar->compileDropDatabase(name: $name);
        $this->orchestrator->execute(sql: $sql);
    }
}

=== QueryBuilder/Core/Builder/Concerns/HasSoftDeletes.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use Avax\Database\Query\AST\WhereNode;
use Throwable;

/**
 * Trait providing automated soft-deletion filtering and data lifecycle management.
 *
 * -- intent:
 * Extends the QueryBuilder with transparent handling of "shadow-deleted" 
 * records—data that is logically removed from the application but physically 
 * persists in the database with a deletion timestamp.
 *
 * -- invariants:
 * - By default, all queries must exclude records with a non-null deletion timestamp.
 * - The soft-delete filter must be injectable at the final compilation stage.
 * - Every mode modification (with/only trashed) must return a new, cloned builder instance.
 *
 * -- boundaries:
 * - Does NOT handle the physical schema definitions (delegated to Schema/Migrations).
 * - Only applies to tables containing a technical deletion column (default 'deleted_at').
 */
trait HasSoftDeletes
{
    /** @var bool Flag indicating if deleted records should be included in the resulting dataset */
    protected bool $withTrashed = false;

    /** @var bool Flag indicating if the query should exclusively retrieve deleted records */
    protected bool $onlyTrashed = false;

    /**
     * Include soft-deleted records in the resulting query dataset.
     *
     * -- intent:
     * Explicitly override the default exclusion policy, allowing for auditing
     * or complex reporting across both active and deleted domain records.
     *
     * @return self A fresh, cloned builder instance with soft-deleted inclusion active.
     */
    public function withTrashed(): self
    {
        $clone              = clone $this;
        $clone->withTrashed = true;

        return $clone;
    }

    /**
     * Filter the results to exclusively include records marked as soft-deleted.
     *
     * -- intent:
     * Isolate domain records that have been logically removed from the active
     * set, typically for recovery, permanent destruction, or auditing.
     *
     * @return self A fresh, cloned builder instance targeting only deleted records.
     */
    public function onlyTrashed(): self
    {
        $clone              = clone $this;
        $clone->onlyTrashed = true;

        return $clone;
    }

    /**
     * Restore domain records from their logically deleted state.
     *
     * -- intent:
     * Nullify the deletion timestamp for records matching the current criteria,
     * bringing them back into the active result set.
     *
     * @param string $column The technical deletion field identifier (defaults to 'deleted_at').
     * @throws Throwable If the restoration update fails at the persistence layer.
     * @return bool True if the records were successfully marked as active.
     */
    public function restore(string $column = 'deleted_at'): bool
    {
        return $this->update(values: [$column => null]);
    }

    /**
     * Add a filtering criterion to check for the absence of a value (IS NULL).
     *
     * -- intent:
     * Provide an expressive DSL for SQL "IS NULL" logic, primarily used for 
     * checking existence flags or soft-delete statuses.
     *
     * @param string      $column  The technical field name to target for the null check.
     * @param string|null $boolean The logical joiner used to attach this condition ('AND' or 'OR').
     * @param bool        $not     Flag indicating whether to check for existence (IS NOT NULL) instead.
     * @return self A fresh, cloned builder instance with the null filter.
     */
    public function whereNull(string $column, string|null $boolean = null, bool $not = false): self
    {
        $boolean  ??= 'AND';
        $operator = $not ? 'IS NOT NULL' : 'IS NULL';

        $clone        = clone $this;
        $clone->state = $clone->state->addWhere(where: new WhereNode(
            column: $column,
            operator: $operator,
            type: 'Null',
            boolean: $boolean
        ));

        return $clone;
    }

    /**
     * Add a filtering criterion to check for the presence of a value (IS NOT NULL).
     *
     * -- intent:
     * Provide an expressive DSL for SQL "IS NOT NULL" logic, acting as a 
     * categorical filter for required technical metadata.
     *
     * @param string $column  The technical field name to target for the non-null check.
     * @param string $boolean The logical joiner used to attach this condition ('AND' or 'OR').
     * @return self A fresh, cloned builder instance with the non-null filter.
     */
    public function whereNotNull(string $column, string $boolean = 'AND'): self
    {
        return $this->whereNull(column: $column, boolean: $boolean, not: true);
    }

    /**
     * Internal technician for injecting the relevant soft-delete filters.
     *
     * -- intent:
     * Provide an automated mechanism for enforcing data isolation based on 
     * the current feature flags (withTrashed, onlyTrashed), ensuring that 
     * logical deletion is respected in all final SQL instructions.
     *
     * @param string $column The technical deletion field identifier (defaults to 'deleted_at').
     * @return self A fresh, cloned builder instance with the appropriate deletion filters injected.
     */
    public function withSoftDeleteFilter(string $column = 'deleted_at'): self
    {
        if ($this->withTrashed) {
            return $this;
        }

        if ($this->onlyTrashed) {
            return $this->whereNotNull(column: $column);
        }

        return $this->whereNull(column: $column);
    }
}

=== QueryBuilder/Core/Builder/Concerns/Macroable.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder\Concerns;

use BadMethodCallException;
use Closure;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;

/**
 * Trait Macroable
 *
 * -- intent: enable runtime extension of the builder through dynamic method registration.
 */
trait Macroable
{
    // Global registry for dynamic builder macros
    protected static array $macros = [];

    /**
     * Register multiple macros at once from a specific mixin class.
     *
     * -- intent: facilitate bulk extension from external provider classes.
     *
     * @param object|string $mixin Target class containing custom methods
     *
     * @return void
     * @throws ReflectionException If class analysis fails
     */
    public static function mixin(object|string $mixin) : void
    {
        $methods = (new ReflectionClass(objectOrClass: $mixin))->getMethods(
            filter: ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED
        );

        foreach ($methods as $method) {
            $method->setAccessible(accessible: true);
            static::macro(name: $method->name, macro: $method->invoke(object: $mixin));
        }
    }

    /**
     * Register a new custom macro (dynamic method).
     *
     * -- intent: provide a way to inject domain-specific helpers into the fluent API.
     *
     * @param string          $name  Method technical name
     * @param callable|object $macro Implementation closure or invokable object
     *
     * @return void
     */
    public static function macro(string $name, callable|object $macro) : void
    {
        static::$macros[$name] = $macro;
    }

    /**
     * Handle dynamic calls to macros or trigger standard failure.
     *
     * -- intent: automate the execution of injected methods via magic interceptor.
     *
     * @param string $method     Target method name
     * @param array  $parameters Call arguments
     *
     * @return mixed
     * @throws BadMethodCallException If method is not found in macros or class
     */
    public function __call(string $method, array $parameters) : mixed
    {
        if (! static::hasMacro(name: $method)) {
            throw new BadMethodCallException(message: "Method [{$method}] does not exist on " . static::class);
        }

        $macro = static::$macros[$method];

        if ($macro instanceof Closure) {
            return call_user_func_array(
                callback: $macro->bindTo(newThis: $this, newscope: static::class),
                args    : $parameters
            );
        }

        return call_user_func_array(callback: $macro, args: $parameters);
    }

    /**
     * Verify if a specific macro name has been registered.
     *
     * -- intent: provide a way to check for feature existence at runtime.
     *
     * @param string $name Method name to check
     *
     * @return bool
     */
    public static function hasMacro(string $name) : bool
    {
        return isset(static::$macros[$name]);
    }
}

=== QueryBuilder/Core/Builder/JoinClause.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder;

use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;

/**
 * technical builder for constructing and compiling JOIN clause conditions.
 *
 * -- intent:
 * Provides a specialized, fluent interface for defining complex relational 
 * links (ON conditions) between data sources, facilitating the use of 
 * closures to group logical conditions within a join context.
 *
 * -- invariants:
 * - Conditions are captured as technical primitive mappings.
 * - Compilation must utilize the provided Grammar for secure identifier wrapping.
 * - Logical joiners (AND/OR) must be respected in the final SQL string.
 *
 * -- boundaries:
 * - Does NOT handle the high-level join type (INNER/LEFT) (delegated to HasJoins).
 * - Serves strictly as a condition builder for a single JOIN relationship.
 */
final class JoinClause
{
    /** @var array<int, array{first: string, operator: string, second: string, boolean: string}> Collection of captured join conditions. */
    private array $conditions = [];

    /**
     * @param GrammarInterface $grammar The authorized technical SQL grammar used for secure identifier projection.
     */
    public function __construct(private readonly GrammarInterface $grammar) {}

    /**
     * Coordinate the addition of an 'OR ON' logical condition to the join clause.
     *
     * -- intent:
     * Appends a new comparison constraint linked via the OR logical operator, 
     * allowing for alternative relationship matches.
     *
     * @param string      $first    The structural identifier of the left-hand column.
     * @param string|null $operator The technical comparison operator (defaults to '=' if second is provided).
     * @param string|null $second   The structural identifier of the right-hand column or the value (if operator is omitted).
     * @return self The current builder instance for further fluent configuration.
     */
    public function orOn(string $first, ?string $operator = null, ?string $second = null): self
    {
        return $this->on(first: $first, operator: $operator, second: $second, boolean: 'OR');
    }

    /**
     * Coordinate the addition of an 'ON' (AND ON) logical condition to the join clause.
     *
     * -- intent:
     * Provides the primary mechanism for defining a relational constraint, 
     * supporting both the standard three-argument form and the shortcut 
     * two-argument equality form.
     *
     * @param string      $first    The structural identifier of the left-hand column.
     * @param string|null $operator The technical comparison operator or the target value (for shortcuts).
     * @param string|null $second   The structural identifier of the right-hand target column.
     * @param string      $boolean  The logical joiner used to link this condition ('AND' or 'OR').
     * @return self The current builder instance.
     */
    public function on(string $first, ?string $operator = null, ?string $second = null, string $boolean = 'AND'): self
    {
        // Technical shortcut: handle two-argument equality form.
        if ($operator !== null && $second === null) {
            $second   = $operator;
            $operator = '=';
        }

        $this->conditions[] = [
            'first'    => $first,
            'operator' => $operator ?? '=',
            'second'   => $second ?? '',
            'boolean'  => $boolean,
        ];

        return $this;
    }

    /**
     * Coordinate the technical compilation of all captured conditions into a valid SQL string.
     *
     * -- intent:
     * Transforms the internal condition collection into a dialect-aware SQL 
     * snapshot, ensuring all identifiers are correctly escaped via the grammar technician.
     *
     * @return string The compiled technical SQL 'ON' clause string.
     */
    public function toSql(): string
    {
        if (empty($this->conditions)) {
            return '';
        }

        $sql = [];
        foreach ($this->conditions as $i => $condition) {
            $prefix   = $i === 0 ? '' : ($condition['boolean'] . ' ');
            $first    = $this->grammar->wrap(value: $condition['first']);
            $operator = $condition['operator'];
            $second   = $this->grammar->wrap(value: $condition['second']);

            $sql[] = $prefix . "{$first} {$operator} {$second}";
        }

        return implode(separator: ' ', array: $sql);
    }
}

=== QueryBuilder/Core/Builder/QueryBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Builder;

use Avax\Database\Identity\IdentityMap;
use Avax\Database\Query\QueryState;
use Avax\Database\QueryBuilder\Core\Executor\QueryOrchestrator;
use Avax\Database\QueryBuilder\Core\Grammar\GrammarInterface;
use Avax\Database\QueryBuilder\DTO\MutationResult;
use Avax\Database\QueryBuilder\Exceptions\InvalidCriteriaException;
use Avax\Database\QueryBuilder\ValueObjects\Expression;
use ReflectionClass;
use Throwable;

/**
 * The "Sentence Builder" for your database queries.
 *
 * -- what is it?
 * This is the primary tool you use to talk to your database. Instead of 
 * writing raw SQL strings like "SELECT * FROM users", you use this class 
 * to build that sentence using PHP methods.
 *
 * -- how to imagine it:
 * Think of it as a LEGO set. You start with a base (the table), and then 
 * you add blocks (where, order by, select). Each time you add a block, 
 * you get a fresh "snapshot" of the query.
 *
 * -- why this exists:
 * 1. Security: It automatically protects you from "SQL Injection" (hackers 
 *    trying to trick your database).
 * 2. Convenience: You don't have to remember different SQL versions for 
 *    MySQL, SQLite, etc. The builder handles the translation.
 * 3. Immutability: Calling a method like `->where()` doesn't change the 
 *    original object; it returns a new one. This is like "Save As" instead 
 *    of "Save".
 *
 * -- misuse warning:
 * Because every method returns a NEW object, you must catch it:
 * ❌ $query->where(...); (The 'where' is lost!)
 * ✅ $query = $query->where(...); (Correct!)
 *
 * -- what "immutability" means:
 * It's like "Save As". Instead of changing the original QueryBuilder 
 * object, every method creates a brand new copy with your changes 
 * added. This is great because you can create a "base" query (like 
 * "Users who are active") and then branch off it multiple times 
 * without them interfering with each other.
 *
 * -- what "grammar" means:
 * It's a "Translator". Every database (MySQL, SQLite, Postgres) has a 
 * slightly different "accent" or rules for its language. The Grammar 
 * class knows these specific rules and translates your high-level PHP 
 * commands into precise SQL that your specific database understands.
 */
class QueryBuilder
{
    use Concerns\Macroable;
    use Concerns\HasConditions;
    use Concerns\HasJoins;
    use Concerns\HasOrders;
    use Concerns\HasAggregates;
    use Concerns\HasGroups;
    use Concerns\HasControlStructures;
    use Concerns\HasSoftDeletes;
    use Concerns\HasAdvancedMutations;
    use Concerns\HasSchema;

    /** @var QueryState The internal "memory" of all the blocks (table, filters, columns) we've added so far. */
    protected QueryState $state;

    /** @var bool If true, we don't save changes immediately. We wait and do them all at once later. */
    protected bool $isDeferred = false;

    /**
     * Set up the builder with its two "helpers".
     *
     * @param GrammarInterface  $grammar      The "Translator". It knows how to turn your PHP code into specific SQL for MySQL/SQLite/etc.
     * @param QueryOrchestrator $orchestrator The "Conductor". It doesn't write SQL, but it knows how to send the final SQL to the database and get results back.
     */
    public function __construct(
        protected readonly GrammarInterface $grammar,
        protected QueryOrchestrator         $orchestrator
    ) {
        $this->state = new QueryState();

        // If this class has a 'tableName' property defined (like in a Model), we use it as the default target.
        if (property_exists(object_or_class: $this, property: 'tableName')) {
            $ref       = new ReflectionClass(objectOrClass: $this);
            $tableName = $ref->getProperty(name: 'tableName')->getValue(object: $this);

            if (is_string(value: $tableName) && $tableName !== '') {
                $this->state = $this->state->withFrom(table: $tableName);
            }
        }
    }

    /**
     * Create a perfect copy of this builder.
     *
     * -- intent:
     * This is the "Save As" mechanism. It ensures that when you branch off a 
     * common search, you don't mess up the original search object.
     */
    public function __clone()
    {
        $this->orchestrator = clone $this->orchestrator;
    }

    /**
     * Start a brand new, empty query using the same database setup.
     *
     * @return static A fresh builder instance with no filters or tables set.
     */
    public function newQuery(): static
    {
        return new static(
            grammar: $this->grammar,
            orchestrator: $this->orchestrator
        );
    }

    /**
     * Inject a "raw" fragment of SQL directly (The Escape Hatch).
     *
     * -- what "raw" means in this context:
     * It tells the builder: "Do not attempt to secure, quote, or translate 
     * this specific string. Just paste it exactly as I wrote it into 
     * the final SQL."
     *
     * -- when it happens:
     * The raw text is stored in the query state immediately, but it only 
     * touches the database when you finally call an execution method 
     * like 'get()' or 'insert()'.
     *
     * -- common pitfall:
     * Never use this for user-provided data (like search terms)! That's 
     * how SQL Injection happens. Only use 'raw()' for database 
     * functions like 'NOW()' or complex 'CASE' statements that the 
     * builder doesn't support yet.
     *
     * @param string $value The raw SQL text you want to inject.
     * @throws InvalidCriteriaException If the text looks like a hack attempt (e.g., contains semicolons or comments).
     * @return Expression A wrapper that tells the builder "Don't quote or escape this text".
     */
    public function raw(string $value): Expression
    {
        $this->assertSafeRawExpression(expression: $value, context: 'raw');

        return new Expression(value: $value);
    }

    /**
     * Activate "Pretend" mode (Dry Run/Rehearsal).
     *
     * -- what "pretend" means in this context:
     * It forces the builder to stop talking to the real database. Every 
     * action you take will be logged to your terminal so you can 
     * verify the SQL looks correct, but nothing will be saved.
     *
     * -- when it happens:
     * The effect starts immediately on the RETURNED object.
     *
     * -- common pitfall:
     * This is NOT a "simulation" that checks if your query would 
     * actually work. The database is totally bypassed, so it won't 
     * warn you if you have a typo in a table name or if a column 
     * is missing. It only checks the *logic* of the builder itself.
     *
     * @return self A builder copy that only pretends to execute.
     */
    public function pretend(): self
    {
        $clone = clone $this;
        $clone->orchestrator->pretend(value: true);

        return $clone;
    }

    /**
     * Execute a raw SQL "Statement" that doesn't return data (e.g., cleanup commands).
     *
     * @param string $query    The SQL command to run.
     * @param array  $bindings Numbers or strings to safely plug into the command.
     * @return bool True if the database accepted the command.
     */
    public function statement(string $query, array $bindings = []): bool
    {
        $result = $this->orchestrator->execute(sql: $query, bindings: $bindings);

        return $result instanceof MutationResult ? $result->isSuccessful() : (bool) $result;
    }

    /**
     * Choose the table you want to talk to.
     *
     * @param string $table The name of the table in your database (e.g., 'users').
     * @return self A builder copy focused on this specific table.
     */
    public function from(string $table): self
    {
        $clone        = clone $this;
        $clone->state = $this->state->withFrom(table: $table);

        return $clone;
    }

    /**
     * Choose exactly which columns you want to see.
     *
     * -- intent:
     * Like a camera zoom. Instead of seeing everything (*), you focus only on 
     * specific fields. This saves memory and time.
     *
     * @param string ...$columns List of field names (e.g., 'id', 'email', 'name').
     * @return self A builder copy that only asks for these columns.
     */
    public function select(string ...$columns): self
    {
        $clone        = clone $this;
        $clone->state = $this->state->withColumns(columns: empty($columns) ? ['*'] : $columns);

        return $clone;
    }

    /**
     * Mix raw SQL into your column selection.
     *
     * -- why this exists:
     * Useful for things like "COUNT(*) as total" or "CONCAT(first, last)".
     *
     * @param string ...$expressions Raw SQL snippets for selection.
     * @return self A builder copy with these custom selections added.
     */
    public function selectRaw(string ...$expressions): self
    {
        foreach ($expressions as $expression) {
            $this->assertSafeRawExpression(expression: $expression, context: 'selectRaw');
        }

        $clone        = clone $this;
        $clone->state = $this->state->withColumns(columns: array_merge($this->state->columns ?: [], $expressions));

        return $clone;
    }

    /**
     * Security Check: Make sure raw SQL fragments aren't dangerous.
     * 
     * @param string $expression The text to check.
     * @param string $context    Where this check is happening (for error messages).
     * @throws InvalidCriteriaException If dangerous characters are found.
     */
    private function assertSafeRawExpression(string $expression, string $context): void
    {
        if ($expression === '') {
            throw new InvalidCriteriaException(method: $context, reason: "Raw expressions must not be empty.");
        }

        if (preg_match(pattern: '/[;]|--|\\/\\*/', subject: $expression) === 1) {
            throw new InvalidCriteriaException(
                method: $context,
                reason: "Raw expressions must not contain statement terminators or comments."
            );
        }

        if (preg_match(pattern: '/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/', subject: $expression) === 1) {
            throw new InvalidCriteriaException(
                method: $context,
                reason: "Raw expressions must not contain control characters."
            );
        }

        if (preg_match(pattern: '/^[\\x20-\\x7E]+$/', subject: $expression) !== 1) {
            throw new InvalidCriteriaException(
                method: $context,
                reason: "Raw expressions must be plain ASCII characters to allow safe inspection."
            );
        }
    }

    /**
     * Remove all duplicate rows from your results.
     *
     * @return self A builder copy with the UNIQUE/DISTINCT filter active.
     */
    public function distinct(): self
    {
        $clone        = clone $this;
        $clone->state = $this->state->withDistinct(distinct: true);

        return $clone;
    }

    /**
     * Skip the first X number of rows.
     *
     * -- intent:
     * Essential for "Page 2" or "Page 3" of results. If each page has 10 
     * items, Page 2 would skip the first 10.
     *
     * @param int $offset How many rows to jump over.
     * @return self A builder copy with this skip applied.
     */
    public function offset(int $offset): self
    {
        if ($offset < 0) {
            throw new InvalidCriteriaException(method: 'offset', reason: "OFFSET must be a non-negative integer.");
        }

        $clone        = clone $this;
        $clone->state = $this->state->withOffset(offset: $offset);

        return $clone;
    }

    /**
     * Use "Deferred" (Buffered) execution for changes.
     *
     * -- what "deferred" means in this context:
     * It tells the builder: "Don't send my changes (INSERT/UPDATE/DELETE) 
     * to the database yet. Write them down in my memory bank 
     * (Identity Map) instead."
     *
     * -- when it happens:
     * The changes are "stored" globally the moment you call 'update()' 
     * or 'insert()', but they are only "flushed" (sent to the DB) 
     * when the current transaction completes or when you manually 
     * call 'execute()' on the Identity Map.
     *
     * -- common pitfall:
     * This only works for DATA CHANGES. 'SELECT' queries (get(), first(), 
     * etc.) are NEVER deferred and always talk to the live database 
     * immediately. Don't use this if you need to read the data you 
     * just "saved" in the very next line of code!
     *
     * @param IdentityMap|null $identityMap The "To-Do list" tracker to use.
     * @return self A builder copy that buffers its mutations.
     */
    public function deferred(IdentityMap|null $identityMap = null): self
    {
        $clone             = clone $this;
        $clone->isDeferred = true;

        if ($identityMap !== null) {
            $clone->orchestrator = $clone->orchestrator->withIdentityMap(map: $identityMap);
        }

        if ($clone->orchestrator->getIdentityMap() === null) {
            throw new InvalidCriteriaException(
                method: 'deferred',
                reason: "IdentityMap must be available via Orchestrator or provided to use deferred execution."
            );
        }
        return $clone;
    }

    /**
     * Quickly check if ANY records exist matching your search.
     *
     * -- how it works:
     * It doesn't fetch the data; it just asks the database "is anyone there?". 
     * Much faster than fetching 100 or even 1 row.
     *
     * @return bool True if at least one match exists.
     */
    public function exists(): bool
    {
        $instance = clone $this;

        if (method_exists(object_or_class: $instance, method: 'withSoftDeleteFilter')) {
            $instance = $instance->withSoftDeleteFilter();
        }

        $sql    = $instance->grammar->compileSelect(state: $instance->limit(limit: 1)->state);
        $result = $instance->orchestrator->query(sql: $sql, bindings: $instance->state->getBindings());

        return ! empty($result);
    }

    /**
     * Stop after finding X number of rows.
     *
     * @param int $limit The maximum number of rows you want back.
     * @return self A builder copy with this ceiling applied.
     */
    public function limit(int $limit): self
    {
        if ($limit < 0) {
            throw new InvalidCriteriaException(method: 'limit', reason: "LIMIT must be a non-negative integer.");
        }

        $clone        = clone $this;
        $clone->state = $this->state->withLimit(limit: $limit);

        return $clone;
    }

    /**
     * Grab just the first row from the results.
     *
     * @param string|callable|null $key     If set, we give you just this specific column from the row.
     * @param mixed                $default What to return if no rows were found.
     * @return mixed The row data, a specific column, or the default.
     */
    public function first(string|callable|null $key = null, mixed $default = null): mixed
    {
        $instance = clone $this;
        $result   = $instance->limit(limit: 1)->get();

        if (empty($result)) {
            return $default;
        }

        $firstRecord = $result[0];

        if ($key === null) {
            return $firstRecord;
        }

        if (is_callable(value: $key)) {
            return $key($firstRecord) ?? $default;
        }

        // We support "user.profile.name" style paths to reach deep into arrays.
        if (str_contains(haystack: $key, needle: '.')) {
            $keys  = explode(separator: '.', string: $key);
            $value = $firstRecord;

            foreach ($keys as $segment) {
                if (is_array(value: $value) && array_key_exists(key: $segment, array: $value)) {
                    $value = $value[$segment];
                } else {
                    return $default;
                }
            }

            return $value;
        }

        return $firstRecord[$key] ?? $default;
    }

    /**
     * Go to the database and fetch all matching records.
     *
     * -- intent:
     * This is the "Execution" step. It turns your PHP search blocks into 
     * real results.
     *
     * @return array<array-key, mixed> A collection of rows found.
     */
    public function get(): array
    {
        $instance = clone $this;

        if (method_exists(object_or_class: $instance, method: 'withSoftDeleteFilter')) {
            $instance = $instance->withSoftDeleteFilter();
        }

        $sql = $instance->grammar->compileSelect(state: $instance->state);

        return $instance->orchestrator->query(sql: $sql, bindings: $instance->state->getBindings());
    }

    /**
     * Create a brand new record in the database.
     *
     * @param array $values A map of columns and values (e.g., ['name' => 'Alice']).
     * @return bool True if the record was successfully created.
     */
    public function insert(array $values): bool
    {
        $clone        = clone $this;
        $clone->state = $this->state->withValues(values: $values);
        $sql          = $clone->grammar->compileInsert(state: $clone->state);

        return $clone->orchestrator->execute(
            sql: $sql,
            bindings: $clone->state->getBindings(),
            operation: $this->isDeferred ? 'INSERT' : null
        )->isSuccessful();
    }

    /**
     * Change existing records in the database.
     *
     * @param array $values New values for the columns you want to change.
     * @return bool True if the update was accepted.
     */
    public function update(array $values): bool
    {
        $instance = clone $this;

        $instance        = $instance->withSoftDeleteFilter();
        $instance->state = $instance->state->withValues(values: $values);
        $sql             = $instance->grammar->compileUpdate(state: $instance->state);

        return $instance->orchestrator->execute(
            sql: $sql,
            bindings: $instance->state->getBindings(),
            operation: $this->isDeferred ? 'UPDATE' : null
        )->isSuccessful();
    }

    /**
     * Completely remove records from the database.
     *
     * -- warning:
     * Be careful! Unless you are using "Soft Deletes", this is permanent.
     */
    public function delete(): bool
    {
        $instance = clone $this;

        if (method_exists(object_or_class: $instance, method: 'withSoftDeleteFilter')) {
            $instance = $instance->withSoftDeleteFilter();
        }

        $sql = $instance->grammar->compileDelete(state: $instance->state);

        return $instance->orchestrator->execute(
            sql: $sql,
            bindings: $instance->state->getBindings(),
            operation: $this->isDeferred ? 'DELETE' : null
        )->isSuccessful();
    }

    /**
     * Pull a single column's values from all matching rows into a flat list.
     *
     * -- example:
     * ->pluck('email') gives you ['alice@ex.com', 'bob@ex.com'].
     *
     * @param string      $value The column you want to extract.
     * @param string|null $key   If set, we use this column for the array keys.
     * @return array A list of values.
     */
    public function pluck(string $value, string|null $key = null): array
    {
        $columns = $key ? [$value, $key] : [$value];
        $results = $this->select(...$columns)->get();

        $pluck = [];
        foreach ($results as $result) {
            if ($key) {
                $pluck[$result[$key]] = $result[$value];
                continue;
            }
            $pluck[] = $result[$value];
        }

        return $pluck;
    }

    /**
     * Fetch just a single value from the first row.
     *
     * @param string $column  The specific column name.
     * @param mixed  $default Fallback if nothing found.
     * @return mixed The scalar value (string, int, etc).
     */
    public function value(string $column, mixed $default = null): mixed
    {
        $result = $this->first();

        return $result[$column] ?? $default;
    }

    /**
     * Count how many rows match your search.
     *
     * @param string $column Which column to count (default is '*' for any).
     * @return int The total number.
     */
    public function count(string $column = '*'): int
    {
        $instance        = clone $this;
        $instance->state = $instance->state->withColumns(columns: ["COUNT({$column}) as aggregate"]);
        $result          = $instance->first();

        return (int) ($result['aggregate'] ?? 0);
    }

    /**
     * Shortcut to find one specific record by its ID.
     *
     * @param mixed  $id     The ID value.
     * @param string $column The name of the ID field (defaults to 'id').
     * @return mixed The matching row map or null.
     */
    public function find(mixed $id, string $column = 'id'): mixed
    {
        return $this->where(column: $column, operator: '=', value: $id)->first();
    }

    /**
     * Get the internal state of the builder (the AST).
     */
    public function getState(): QueryState
    {
        return $this->state;
    }

    /**
     * Execute a group of database actions as a single "all or nothing" unit (Transaction).
     *
     * -- what "transaction" means in this context:
     * It's like a scientific experiment. You start a "test session" where 
     * you can make multiple changes. If everything goes right, we 
     * KEEP the results. If any single thing fails, we WIPE everything 
     * out as if it never happened.
     *
     * -- when it happens:
     * 1. A 'BEGIN' command is sent when the callback starts.
     * 2. All calls inside the callback happen as normal.
     * 3. A 'COMMIT' is sent only after the callback finishes successfully.
     *
     * -- common pitfall:
     * Remember that this is NOT a "Global Lock". Other users can still 
     * read from the database while your transaction is running! Also, 
     * if you perform non-database actions inside (like file deletions), 
     * they will NOT be undone if the transaction fails.
     *
     * @param callable $callback The block of code to run. It gets the builder as its first argument.
     * @return mixed Whatever your code block returns.
     */
    public function transaction(callable $callback): mixed
    {
        return $this->orchestrator->transaction(callback: fn() => $callback($this));
    }
}

=== QueryBuilder/Core/Executor/ExecutorInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Executor;

use Avax\Database\QueryBuilder\DTO\MutationResult;
use Avax\Database\Support\ExecutionScope;
use Throwable;

/**
 * technical contract defining the authoritative capabilities for the physical execution of database operations.
 *
 * -- intent:
 * Decouples the abstract builder logic from the technicalities of 
 * driver-level communication (PDO, etc.), ensuring that the system 
 * remained agnostic of the physical persistence mechanism while 
 * providing a consistent interface for retrieval and mutation.
 *
 * -- invariants:
 * - Implementations must handle the physical binding of secure tokens to statements.
 * - Every operation should support an optional technical ExecutionScope for correlation.
 * - Mutation results must be encapsulated in a standardized MutationResult DTO.
 *
 * -- boundaries:
 * - Does NOT perform SQL compilation (delegated to Grammar).
 * - Serves as the final technical bridge before the persistence driver level.
 */
interface ExecutorInterface
{
    /**
     * Coordinate the technical execution of a retrieval instruction (SELECT).
     *
     * -- intent:
     * Dispatches a pre-compiled retrieval instruction to the persistence 
     * driver and retrieves the resulting raw dataset.
     *
     * @param string              $sql      THE pre-compiled technical SQL retrieval string.
     * @param array               $bindings THE collection of secure tokens for parameterization.
     * @param ExecutionScope|null $scope    THE optional technical context for correlation and tracing.
     * @throws Throwable If a technical driver error or persistence connection failure occurs.
     * @return array<array-key, mixed> THE collection of raw data records retrieved.
     */
    public function query(
        string           $sql,
        array            $bindings = [],
        ?ExecutionScope  $scope = null
    ): array;

    /**
     * Coordinate the technical execution of a mutation instruction (INSERT/UPDATE/DELETE).
     *
     * -- intent:
     * Dispatches a pre-compiled modification instruction to the persistence 
     * engine and captures the resulting technical feedback.
     *
     * @param string              $sql      THE pre-compiled technical SQL mutation string.
     * @param array               $bindings THE collection of secure tokens for parameterization.
     * @param ExecutionScope|null $scope    THE optional technical context for correlation and tracing.
     * @throws Throwable If the technical modification fails or violates persistence constraints.
     * @return MutationResult A standardized DTO representing the outcome of the modification request.
     */
    public function execute(
        string           $sql,
        array            $bindings = [],
        ?ExecutionScope  $scope = null
    ): MutationResult;

    /**
     * Retrieve the authoritative technical identifier of the underlying persistence driver.
     *
     * -- intent:
     * Enables high-level components to adapt their behavior based on the specific 
     * characteristics and capabilities of the active persistence engine.
     *
     * @return string THE technical identifier of the driver (e.g., 'mysql').
     */
    public function getDriverName(): string;
}

=== QueryBuilder/Core/Executor/PDOExecutor.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Executor;

use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\QueryBuilder\DTO\MutationResult;
use Avax\Database\QueryBuilder\Exceptions\QueryException;
use Avax\Database\Support\ExecutionScope;
use Avax\Database\Events\EventBus;
use Avax\Database\Events\QueryExecuted;
use PDO;
use SensitiveParameter;
use Throwable;

/**
 * The "Hammer and Nails" (PDO Executor).
 */
final readonly class PDOExecutor implements ExecutorInterface
{
    /**
     * @param DatabaseConnection $connection
     * @param EventBus|null      $eventBus
     * @param string             $connectionName
     */
    public function __construct(
        private DatabaseConnection $connection,
        private ?EventBus           $eventBus = null,
        private string             $connectionName = 'default'
    ) {}

    /**
     * Execute a "Read" query (SELECT) and get the rows back.
     */
    public function query(
        string $sql,
        #[SensitiveParameter] array $bindings = [],
        ?ExecutionScope $scope = null
    ): array {
        $start = microtime(as_float: true);

        try {
            $statement = $this->getPdo()->prepare(query: $sql);
            $statement->execute(params: $bindings);
            $results = $statement->fetchAll();

            $this->dispatch(
                sql: $sql,
                bindings: $bindings,
                start: $start,
                scope: $scope,
                redactBindings: $this->shouldRedactBindings()
            );

            return $results;
        } catch (Throwable $e) {
            throw new QueryException(
                message: "Query execution failed: " . $e->getMessage(),
                sql: $sql,
                bindings: $bindings,
                previous: $e
            );
        }
    }

    private function getPdo(): PDO
    {
        return $this->connection->getConnection();
    }

    /**
     * Execute a "Change" query (INSERT/UPDATE/DELETE).
     */
    public function execute(
        string $sql,
        #[SensitiveParameter] array $bindings = [],
        ?ExecutionScope $scope = null
    ): MutationResult {
        $start = microtime(as_float: true);

        try {
            $statement = $this->getPdo()->prepare(query: $sql);
            $statement->execute(params: $bindings);

            $this->dispatch(
                sql: $sql,
                bindings: $bindings,
                start: $start,
                scope: $scope,
                redactBindings: $this->shouldRedactBindings()
            );

            return MutationResult::success(count: $statement->rowCount());
        } catch (Throwable $e) {
            throw new QueryException(
                message: "Execution failed: " . $e->getMessage(),
                sql: $sql,
                bindings: $bindings,
                previous: $e
            );
        }
    }

    private function dispatch(
        string $sql,
        #[SensitiveParameter] array $bindings,
        float $start,
        ?ExecutionScope $scope = null,
        bool $redactBindings = true
    ): void {
        if ($this->eventBus === null) {
            return;
        }

        $correlationId = $scope?->correlationId ?? ('ctx_' . bin2hex(string: random_bytes(length: 4)));

        $this->eventBus->dispatch(new QueryExecuted(
            sql: $sql,
            bindings: $bindings,
            timeMs: (microtime(as_float: true) - $start) * 1000,
            connectionName: $this->connectionName,
            correlationId: $correlationId,
            redactBindings: $redactBindings
        ));
    }

    private function shouldRedactBindings(): bool
    {
        $flag = getenv('DB_LOG_BINDINGS') ?: 'redacted';

        return strtolower(string: $flag) !== 'raw';
    }

    public function getDriverName(): string
    {
        return $this->getPdo()->getAttribute(attribute: PDO::ATTR_DRIVER_NAME);
    }
}

=== QueryBuilder/Core/Executor/QueryOrchestrator.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Executor;

use Avax\Database\Identity\IdentityMap;
use Avax\Database\QueryBuilder\DTO\MutationResult;
use Avax\Database\Support\ExecutionScope;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;
use RuntimeException;
use Throwable;

/**
 * The "Conductor" of the database operation.
 *
 * -- what is it?
 * If the `QueryBuilder` is the person writing the "To-Do" list, the 
 * `QueryOrchestrator` is the manager who decides WHEN and HOW that list 
 * gets executed.
 */
final class QueryOrchestrator
{
    /** @var bool */
    private bool $isPretending = false;

    /**
     * @param ExecutorInterface                $executor
     * @param TransactionManagerInterface|null $transactionManager
     * @param IdentityMap|null                 $identityMap
     * @param ExecutionScope|null              $scope
     */
    public function __construct(
        private ExecutorInterface                $executor,
        private TransactionManagerInterface|null $transactionManager = null,
        private IdentityMap|null                 $identityMap = null,
        private ?ExecutionScope                  $scope = null
    ) {
        $this->scope ??= ExecutionScope::fresh();
    }

    public function __clone()
    {
        if ($this->scope !== null) {
            $this->scope = clone $this->scope;
        }
    }

    /**
     * Switch the system into "Pretend" (Rehearsal) mode.
     */
    public function pretend(bool $value = true): void
    {
        $this->isPretending = $value;
    }

    /**
     * Ask the database for data (SELECT).
     */
    public function query(string $sql, array $bindings = []): array
    {
        if ($this->isPretending) {
            $this->logPretend(sql: $sql);

            return [];
        }

        return $this->executor->query(sql: $sql, bindings: $bindings, scope: $this->scope);
    }

    /**
     * Tell the database to change something (INSERT/UPDATE/DELETE).
     */
    public function execute(
        string      $sql,
        array|null  $bindings = null,
        string|null $operation = null
    ): MutationResult {
        $bindings ??= [];

        if ($this->isPretending) {
            $this->logPretend(sql: $sql);

            return MutationResult::success(count: 1);
        }

        if ($operation && $this->identityMap) {
            $this->identityMap->schedule(operation: $operation, sql: $sql, bindings: $bindings);

            return MutationResult::success(count: 1);
        }

        return $this->executor->execute(sql: $sql, bindings: $bindings, scope: $this->scope);
    }

    /**
     * Execute a block of logic inside a "Safety Bubble" (Transaction).
     */
    public function transaction(callable $callback): mixed
    {
        if (! $this->transactionManager) {
            throw new RuntimeException(message: "Transaction manager not available in Orchestrator.");
        }

        return $this->transactionManager->transaction(callback: function () use ($callback) {
            $result = $callback($this);

            if ($this->identityMap !== null) {
                $this->identityMap->execute();
            }

            return $result;
        });
    }

    public function getTransactionManager(): TransactionManagerInterface|null
    {
        return $this->transactionManager;
    }

    public function withIdentityMap(IdentityMap|null $map): self
    {
        $clone              = clone $this;
        $clone->identityMap = $map;

        return $clone;
    }

    public function withScope(ExecutionScope $scope): self
    {
        $clone        = clone $this;
        $clone->scope = $scope;

        return $clone;
    }

    public function getScope(): ExecutionScope
    {
        return $this->scope;
    }

    public function getIdentityMap(): IdentityMap|null
    {
        return $this->identityMap;
    }

    private function logPretend(string $sql): void
    {
        echo "\033[33m[DRY RUN]\033[0m SQL: {$sql}\n";
    }
}

=== QueryBuilder/Core/Grammar/BaseGrammar.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\AST\NestedWhereNode;
use Avax\Database\Query\AST\WhereNode;
use Avax\Database\Query\QueryState;
use Avax\Database\QueryBuilder\ValueObjects\Expression;
use RuntimeException;

/**
 * The "Foundation of Language" (Base Grammar).
 *
 * -- what is it?
 * This is the parent class for all SQL Grammars (MySQL, Postgres, etc.). 
 * It contains the "Common Rules" of SQL that almost all databases share. 
 * While MySQLGrammar handles backticks, this class handles the actual 
 * structure of a SELECT, INSERT, or UPDATE sentence.
 *
 * -- how to imagine it:
 * Think of "Latin" as the base for many European languages. BaseGrammar 
 * is the "Latin" of SQL — it defines the general structure of how 
 * sentences are built. Specific grammars (like MySQL) then add their 
 * own specific "Accents" or "Slang" (like backticks instead of double 
 * quotes).
 *
 * -- why this exists:
 * 1. Code Reuse: We don't want to rewrite the logic for building a `WHERE` 
 *    clause for every single database. This class does it once for everyone.
 * 2. Predictability: It ensures that no matter which database you use, the 
 *    QueryBuilder produces a structure that makes sense.
 * 3. Flexibility: By making this class `abstract`, we FORCE specific 
 *    databases to implement their own "Accents" (like how to wrap names).
 *
 * -- mental models:
 * - "Compiler": It "Compiles" an object representing a query (QueryState) 
 *    into a plain string of SQL.
 * - "Idempotent": Running the same compilation twice with the same input 
 *    will ALWAYS produce the exact same SQL output.
 */
abstract class BaseGrammar implements GrammarInterface
{
    /**
     * Build a full SELECT sentence from a query object.
     *
     * -- how it works:
     * It builds the sentence piece by piece:
     * 1. SELECT columns...
     * 2. FROM table...
     * 3. JOIN others...
     * 4. WHERE conditions...
     * ...and so on.
     *
     * @param QueryState $state The object containing all your query settings.
     * @return string The final SQL sentence.
     */
    public function compileSelect(QueryState $state): string
    {
        $components = [
            'select' => $this->compileColumns(state: $state),
            'from'   => $this->compileFrom(state: $state),
            'joins'  => $this->compileJoins(state: $state),
            'wheres' => $this->compileWheres(state: $state),
            'groups' => $this->compileGroups(state: $state),
            'orders' => $this->compileOrders(state: $state),
            'limit'  => $this->compileLimit(state: $state),
            'offset' => $this->compileOffset(state: $state),
        ];

        // We filter out empty strings and join the pieces with spaces.
        return implode(separator: ' ', array: array_filter(array: $components));
    }

    /**
     * Build the "SELECT column1, column2" part.
     */
    protected function compileColumns(QueryState $state): string
    {
        $select  = $state->distinct ? 'SELECT DISTINCT ' : 'SELECT ';
        $columns = array_map(callback: fn($c) => $this->wrap(value: $c), array: $state->columns);

        return $select . implode(separator: ', ', array: $columns);
    }

    /**
     * Build the "FROM table_name" part.
     */
    protected function compileFrom(QueryState $state): string
    {
        if ($state->from) {
            return 'FROM ' . $this->wrap(value: $state->from);
        }

        return '';
    }

    /**
     * Build all the JOIN parts (e.g., INNER JOIN users ON ...).
     */
    protected function compileJoins(QueryState $state): string
    {
        if (empty($state->joins)) {
            return '';
        }

        $sql = [];

        foreach ($state->joins as $node) {
            $type  = strtoupper(string: $node->type);
            $table = $this->wrap(value: $node->table);

            if ($node->type === 'cross') {
                $sql[] = "{$type} JOIN {$table}";
                continue;
            }

            // If we have a complex ON clause (like a nested condition).
            if ($node->clause !== null) {
                $onClause = $node->clause->toSql();
                if ($onClause !== '') {
                    $sql[] = "{$type} JOIN {$table} ON {$onClause}";
                } else {
                    $sql[] = "{$type} JOIN {$table}";
                }
                continue;
            }

            // Simple "column1 = column2" join.
            if ($node->first !== null && $node->second !== null) {
                $first    = $this->wrap(value: $node->first);
                $operator = $node->operator ?? '=';
                $second   = $this->wrap(value: $node->second);

                $sql[] = "{$type} JOIN {$table} ON {$first} {$operator} {$second}";
            }
        }

        return implode(separator: ' ', array: $sql);
    }

    /**
     * Build the filter part (WHERE column = ? AND ...).
     *
     * -- how it works:
     * It handles "Nested" filters by putting them in parentheses.
     * It also uses "?" placeholders for values to keep the SQL secure.
     */
    protected function compileWheres(QueryState $state): string
    {
        if (empty($state->wheres)) {
            return '';
        }

        $sql = [];
        foreach ($state->wheres as $i => $node) {
            $prefix  = $i === 0 ? 'WHERE ' : '';
            $boolean = $i === 0 ? '' : ($this->getWhereBoolean(node: $node) . ' ');

            // If this is a nested block: (condition1 OR condition2).
            if ($node instanceof NestedWhereNode) {
                $nestedSql = $this->compileWheres(state: $node->query->getState());
                if ($nestedSql !== '') {
                    $sql[] = $prefix . $boolean . '(' . ltrim(string: $nestedSql, characters: 'WHERE ') . ')';
                }
                continue;
            }

            if ($node instanceof WhereNode) {
                $column   = $this->wrap(value: $node->column);
                $operator = $node->operator;

                // Handle specialized null checks: IS NULL / IS NOT NULL.
                if ($node->type === 'Null') {
                    $sql[] = $prefix . $boolean . "{$column} {$operator}";
                    continue;
                }

                // Handle raw SQL provided by the user.
                if ($node->type === 'Raw') {
                    $sql[] = $prefix . $boolean . $node->column;
                    continue;
                }

                // Handle "IN" clauses: column IN (?, ?, ?).
                if (in_array(needle: $operator, haystack: ['IN', 'NOT IN']) && is_array(value: $node->value)) {
                    $count        = count(value: $node->value);
                    $placeholders = $count > 0 ? implode(separator: ', ', array: array_fill(start_index: 0, count: $count, value: '?')) : '';
                    $sql[]        = $prefix . $boolean . "{$column} {$operator} ({$placeholders})";
                    continue;
                }

                // Handle "BETWEEN" clauses: column BETWEEN ? AND ?.
                if (in_array(needle: $operator, haystack: ['BETWEEN', 'NOT BETWEEN']) && is_array(value: $node->value)) {
                    $sql[] = $prefix . $boolean . "{$column} {$operator} ? AND ?";
                    continue;
                }

                // Basic comparison: column = ?.
                $sql[] = $prefix . $boolean . "{$column} {$operator} ?";
            }
        }

        return implode(separator: ' ', array: array_filter(array: $sql));
    }

    /**
     * Build the "GROUP BY column1, column2" part.
     */
    protected function compileGroups(QueryState $state): string
    {
        if (empty($state->groups)) {
            return '';
        }

        $columns = array_map(callback: fn($column) => $this->wrap(value: $column), array: $state->groups);

        return 'GROUP BY ' . implode(separator: ', ', array: $columns);
    }

    /**
     * Build the "ORDER BY column DESC" part.
     */
    protected function compileOrders(QueryState $state): string
    {
        if (empty($state->orders)) {
            return '';
        }

        $orders = [];
        foreach ($state->orders as $node) {
            if ($node->type === 'Raw') {
                $orders[] = $node->sql ?? '';
                continue;
            }

            $column    = $this->wrap(value: $node->column);
            $direction = strtoupper(string: $node->direction);
            $orders[]  = "{$column} {$direction}";
        }

        if (empty($orders)) {
            return '';
        }

        return 'ORDER BY ' . implode(separator: ', ', array: $orders);
    }

    /**
     * Build the "LIMIT 10" part.
     */
    protected function compileLimit(QueryState $state): string
    {
        if ($state->limit) {
            return "LIMIT {$state->limit}";
        }

        return '';
    }

    /**
     * Build the "OFFSET 5" part.
     */
    protected function compileOffset(QueryState $state): string
    {
        if ($state->offset) {
            return "OFFSET {$state->offset}";
        }

        return '';
    }

    /**
     * Build a full INSERT sentence.
     */
    public function compileInsert(QueryState $state): string
    {
        $table   = $this->wrap(value: $state->from);
        $columns = implode(
            separator: ', ',
            array: array_map(
                callback: fn($c) => $this->wrap(value: $c),
                array: array_keys(array: $state->values)
            )
        );
        $values  = implode(
            separator: ', ',
            array: array_fill(
                start_index: 0,
                count: count(value: $state->values),
                value: '?'
            )
        );

        // We also collect the actual values to be sent with the query later.
        foreach ($state->values as $value) {
            $state->addBinding(value: $value);
        }

        return "INSERT INTO {$table} ({$columns}) VALUES ({$values})";
    }

    /**
     * Build a full UPDATE sentence.
     */
    public function compileUpdate(QueryState $state): string
    {
        $table = $this->wrap(value: $state->from);

        $sets = [];
        foreach ($state->values as $column => $value) {
            $sets[] = $this->wrap(value: $column) . ' = ?';
            $state->addBinding(value: $value);
        }

        $setClause = 'SET ' . implode(separator: ', ', array: $sets);
        $wheres    = $this->compileWheres(state: $state);

        return trim(string: "UPDATE {$table} {$setClause} {$wheres}");
    }

    /**
     * Build a full DELETE sentence.
     */
    public function compileDelete(QueryState $state): string
    {
        $table  = $this->wrap(value: $state->from);
        $wheres = $this->compileWheres(state: $state);

        return trim(string: "DELETE FROM {$table} {$wheres}");
    }

    /**
     * Placeholder for the UPSERT (Insert or Update) command.
     * 
     * -- intent:
     * This is a "Hook". Because every database does Upsert differently, 
     * the Base class can't do it. Children (like MySQLGrammar) must 
     * provide the implementation.
     */
    public function compileUpsert(QueryState $state, array $uniqueBy, array $update): string
    {
        throw new RuntimeException(message: "UPSERT is not supported by this database dialect.");
    }

    /**
     * Build the command to completely empty a table.
     */
    public function compileTruncate(string $table): string
    {
        return 'TRUNCATE ' . $this->wrap(value: $table);
    }

    /**
     * Build the command to delete a table if it exists.
     */
    public function compileDropIfExists(string $table): string
    {
        return 'DROP TABLE IF EXISTS ' . $this->wrap(value: $table);
    }

    /**
     * Build the command to create a new database.
     */
    public function compileCreateDatabase(string $name): string
    {
        return "CREATE DATABASE " . $this->wrap(value: $name);
    }

    /**
     * Build the command to delete an entire database.
     */
    public function compileDropDatabase(string $name): string
    {
        return "DROP DATABASE " . $this->wrap(value: $name);
    }

    /**
     * Provide a generic random sorting snippet.
     */
    public function compileRandomOrder(): string
    {
        return 'RANDOM()';
    }

    /**
     * Securely wrap column or table names in quotes.
     * 
     * -- why this exists:
     * To prevent "SQL Keyword Collisions". If you have a column named 
     * `order`, SQL will get confused unless we wrap it in quotes (`"order"`).
     */
    public function wrap(mixed $value): string
    {
        if ($value instanceof Expression) {
            return $value->getValue();
        }

        $value = (string) $value;

        if ($value === '*' || str_contains(haystack: $value, needle: '(')) {
            return $value;
        }

        // Handle names with dots (e.g., 'users.name').
        if (str_contains(haystack: $value, needle: '.')) {
            return implode(
                separator: '.',
                array: array_map(
                    callback: fn($segment) => $this->wrapSegment(segment: $segment),
                    array: explode(separator: '.', string: $value)
                )
            );
        }

        return $this->wrapSegment(segment: $value);
    }

    /**
     * Securely wrap a single part of a name (e.g., the 'users' bit).
     */
    protected function wrapSegment(string $segment): string
    {
        if ($segment === '*') {
            return $segment;
        }

        // Default is to use double quotes (") which is standard SQL.
        return '"' . str_replace(search: '"', replace: '""', subject: $segment) . '"';
    }

    /**
     * Get the boolean joiner (AND/OR) for a specific filter.
     */
    protected function getWhereBoolean(mixed $node): string
    {
        return $node->boolean ?? 'AND';
    }
}

=== QueryBuilder/Core/Grammar/GrammarInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\QueryState;

/**
 * Technical contract for translating logical QueryState into dialect-specific SQL SNAPSHOTS.
 *
 * -- intent:
 * Decouples the abstract query representation (projection, filters, joins) 
 * from the physical RDBMS dialects (MySQL, SQLite, etc.), allowing the 
 * system to support multiple database engines through specialized 
 * compiler implementations.
 *
 * -- invariants:
 * - Implementations must follow the established SQL standard while applying dialect-specific optimizations.
 * - Compilation must be strictly deterministic based on the provided QueryState.
 * - All technical identifiers must be securely wrapped to prevent keyword collisions.
 *
 * -- boundaries:
 * - Does NOT interact with the physical database connection (delegated to Executor).
 * - Does NOT perform parameter binding (handled by Connection via normalized placeholders).
 */
interface GrammarInterface
{
    /**
     * Coordinate the technical transformation of QueryState into a SELECT SQL statement.
     *
     * -- intent:
     * Compile a valid data retrieval instruction including projections, 
     * relationships, filters, aggregations, and ordering.
     *
     * @param QueryState $state The immutable container holding the current query metadata.
     * @return string THE compiled dialect-specific SQL SELECT string.
     */
    public function compileSelect(QueryState $state): string;

    /**
     * Coordinate the technical transformation of QueryState into an INSERT SQL statement.
     *
     * -- intent:
     * Compile a valid data creation instruction based on the provided mutation 
     * values within the state.
     *
     * @param QueryState $state The technical state containing the mutation payload.
     * @return string THE compiled dialect-specific SQL INSERT string.
     */
    public function compileInsert(QueryState $state): string;

    /**
     * Coordinate the technical transformation of QueryState into an UPDATE SQL statement.
     *
     * -- intent:
     * Compile a data modification instruction that applies specific value 
     * changes to records matching the state's filtering criteria.
     *
     * @param QueryState $state The technical state containing both mutation values and filters.
     * @return string THE compiled dialect-specific SQL UPDATE string.
     */
    public function compileUpdate(QueryState $state): string;

    /**
     * Coordinate the technical transformation of QueryState into a DELETE SQL statement.
     *
     * -- intent:
     * Compile a data removal instruction targeting records that satisfy 
     * the state's filtering criteria.
     *
     * @param QueryState $state The technical state defining the deletion boundary.
     * @return string THE compiled dialect-specific SQL DELETE string.
     */
    public function compileDelete(QueryState $state): string;

    /**
     * Coordinate the technical transformation of QueryState into an UPSERT SQL statement.
     *
     * -- intent:
     * Provide a dialect-safe mechanism for "Insert or Update on Conflict" 
     * operations, resolving row collisions based on specified unique columns.
     *
     * @param QueryState $state    The technical state containing the mutation payload.
     * @param array      $uniqueBy The collection of technical column identifiers used for conflict detection.
     * @param array      $update   The collection of technical column identifiers to be updated upon conflict.
     * @return string THE compiled dialect-specific SQL UPSERT/ON DUPLICATE KEY string.
     */
    public function compileUpsert(QueryState $state, array $uniqueBy, array $update): string;

    /**
     * Coordinate the technical generation of a TRUNCATE SQL statement.
     *
     * -- intent:
     * Provide a high-performance instruction for purging all records from 
     * a specific data source while bypassing individual row deletion triggers.
     *
     * @param string $table THE physical technical identifier of the database table.
     * @return string THE compiled dialect-specific SQL TRUNCATE string.
     */
    public function compileTruncate(string $table): string;

    /**
     * Coordinate the technical generation of a DROP TABLE IF EXISTS SQL statement.
     *
     * -- intent:
     * Provide a defensive destruction command for schema-level data sources.
     *
     * @param string $table THE physical technical identifier of the database table.
     * @return string THE compiled dialect-specific SQL DROP string.
     */
    public function compileDropIfExists(string $table): string;

    /**
     * Coordinate the technical generation of a CREATE DATABASE SQL statement.
     *
     * @param string $name THE physical technical identifier of the target database.
     * @return string THE compiled dialect-specific SQL CREATE DATABASE string.
     */
    public function compileCreateDatabase(string $name): string;

    /**
     * Coordinate the technical generation of a DROP DATABASE SQL statement.
     *
     * @param string $name THE physical technical identifier of the target database.
     * @return string THE compiled dialect-specific SQL DROP DATABASE string.
     */
    public function compileDropDatabase(string $name): string;

    /**
     * Retrieve the dialect-specific technical expression for random result set ordering.
     *
     * @return string THE technical SQL expression (e.g., 'RAND()' or 'RANDOM()').
     */
    public function compileRandomOrder(): string;

    /**
     * Coordinate the secure technical wrapping of a database identifier.
     *
     * -- intent:
     * Protects SQL structural integrity and prevents reserved keyword 
     * collisions by applying dialect-specific quote characters (e.g., backticks).
     *
     * @param mixed $value THE technical name (string) or an Expression object to be wrapped.
     * @return string THE securely wrapped technical SQL identifier.
     */
    public function wrap(mixed $value): string;
}

=== QueryBuilder/Core/Grammar/MySQLGrammar.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Core\Grammar;

use Avax\Database\Query\QueryState;
use Avax\Database\QueryBuilder\ValueObjects\Expression;
use Override;

/**
 * The "MySQL Translator" (Grammar).
 *
 * -- what is it?
 * This is a "Translator" that knows how to speak the MySQL language perfectly. 
 * While the `QueryBuilder` knows WHAT you want to do, the `MySQLGrammar` 
 * knows exactly HOW to say it in the specific syntax that MySQL understands.
 *
 * -- how to imagine it:
 * Think of an "Interpreter". You speak in high-level commands (like "I want 
 * to insert or update this user"), and the interpreter writes down the 
 * exact MySQL sentence (like "INSERT ... ON DUPLICATE KEY UPDATE").
 *
 * -- why this exists:
 * 1. Dialect Handling: Every database (MySQL, Postgres, SQLite) has slightly 
 *    different rules for quotes and special features. This class isolates all 
 *    the MySQL-specific quirks.
 * 2. Security (Quoting): It handles "Backticks" (`). Wrapping column names 
 *    in backticks prevents errors if you accidentally use a "Reserved Word" 
 *    (like calling a column `order` or `select`).
 * 3. Atomic Features: It implements MySQL's powerful "Upsert" (Insert or Update) 
 *    syntax, which allows the database to handle conflicts automatically.
 *
 * -- mental models:
 * - "Grammar": The set of rules for building valid sentences (SQL).
 * - "Backticks" (`): The special quotes used by MySQL to identify table 
 *    and column names correctly.
 */
final class MySQLGrammar extends BaseGrammar
{
    /**
     * Compile an UPSERT (Insert or Update) statement for MySQL.
     *
     * -- how to imagine it:
     * This is the "Change if exists" instruction. It tells MySQL: "Try to 
     * insert this row. But if you find someone with the same ID already 
     * there, just update these specific columns instead."
     *
     * @param QueryState $state    The instructions of what to insert.
     * @param array      $uniqueBy Ignored in MySQL (MySQL figures this out from your DB keys).
     * @param array      $update   The list of columns to change if a conflict happens.
     */
    #[Override]
    public function compileUpsert(QueryState $state, array $uniqueBy, array $update): string
    {
        $sql = $this->compileInsert(state: $state);
        $sql .= " ON DUPLICATE KEY UPDATE ";

        $updates = [];
        foreach ($update as $column) {
            $updates[] = $this->wrap(value: $column) . " = VALUES(" . $this->wrap(value: $column) . ")";
        }

        return $sql . implode(separator: ', ', array: $updates);
    }

    /**
     * Securely wrap column or table names in MySQL backticks.
     *
     * -- why do this?
     * This is the "Safety Quote". Without it, a table called `users.order` 
     * would break because `order` is a special MySQL command. By wrapping 
     * it as `` `users`.`order` ``, we tell MySQL: "This is a name, not a command."
     *
     * @param mixed $value The name (e.g., 'users.name').
     */
    #[Override]
    public function wrap(mixed $value): string
    {
        if ($value instanceof Expression) {
            return $value->getValue();
        }

        $value = (string) $value;

        // We don't wrap the asterisk (*) or functions with parentheses.
        if ($value === '*' || str_contains(haystack: $value, needle: '(')) {
            return $value;
        }

        // Handle names with dots (e.g., 'users.email').
        if (str_contains(haystack: $value, needle: '.')) {
            $segments = explode(separator: '.', string: $value);

            return implode(
                separator: '.',
                array: array_map(
                    callback: fn($segment) => $this->wrapSegment(segment: $segment),
                    array: $segments
                )
            );
        }

        return $this->wrapSegment(segment: $value);
    }

    /**
     * The internal "Backtick Printer" for a single name.
     */
    #[Override]
    protected function wrapSegment(string $segment): string
    {
        if ($segment === '*' || $segment === '') {
            return $segment;
        }

        // We wrap in backticks and handle escaping if the segment already contains a backtick.
        return '`' . str_replace(search: '`', replace: '``', subject: $segment) . '`';
    }

    /**
     * Get the MySQL snippet for random ordering.
     */
    #[Override]
    public function compileRandomOrder(): string
    {
        return 'RAND()';
    }

    /**
     * Build the command to completely empty a table.
     */
    #[Override]
    public function compileTruncate(string $table): string
    {
        return 'TRUNCATE TABLE ' . $this->wrap(value: $table);
    }

    /**
     * Build the command to delete a table if it exists.
     */
    #[Override]
    public function compileDropIfExists(string $table): string
    {
        return 'DROP TABLE IF EXISTS ' . $this->wrap(value: $table);
    }
}

=== QueryBuilder/DTO/MutationResult.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\DTO;

/**
 * The "Operation Receipt" (Mutation Result).
 *
 * -- what is it?
 * This is a simple report (DTO) that tells you what happened after an 
 * INSERT, UPDATE, or DELETE operation. It primarily tells you how many rows 
 * were changed.
 *
 * -- how to imagine it:
 * Think of a "Receipt" from a store. It doesn't give you the items, but 
 * it confirms the transaction happened and tells you exactly how many 
 * items were processed.
 *
 * -- why this exists:
 * 1. Consistency: Instead of returning a raw number (which is "Cold"), we 
 *    return this object which has helpful methods like `isSuccessful()`.
 * 2. Immutability: Once the receipt is printed, you can't change the 
 *    number of rows. This ensures the integrity of your reports.
 * 3. Clarity: It makes it obvious that you're looking at the result of 
 *    a "Mutation" (a change) rather than a search.
 *
 * -- mental models:
 * - "Mutation": Any operation that changes data (Insert, Update, Delete).
 * - "Affected Rows": The number of records that were actually touched or 
 *    created in the database.
 */
final readonly class MutationResult
{
    /**
     * @param int $affectedRows The total number of rows changed or created.
     */
    public function __construct(public int $affectedRows) {}

    /**
     * Create a success receipt with a specific count.
     *
     * @param int $count The number of rows touched (e.g., 5).
     */
    public static function success(int $count): self
    {
        return new self(affectedRows: $count);
    }

    /**
     * Create a receipt showing that nothing was changed.
     */
    public static function none(): self
    {
        return new self(affectedRows: 0);
    }

    /**
     * Was anything actually changed?
     *
     * @return bool True if at least one row was touched.
     */
    public function isSuccessful(): bool
    {
        return $this->affectedRows > 0;
    }

    /**
     * Get the final count of touched rows.
     */
    public function getAffectedRows(): int
    {
        return $this->affectedRows;
    }
}

=== QueryBuilder/Enums/Operator.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Enums;

/**
 * Domain-fluent enumeration of supported SQL comparison operators.
 *
 * -- intent: provide a type-safe way to reference logical comparison strings.
 */
enum Operator: string
{
    case EQUAL         = '=';
    case NOT_EQUAL     = '!=';
    case GREATER_THAN  = '>';
    case LESS_THAN     = '<';
    case GREATER_EQUAL = '>=';
    case LESS_EQUAL    = '<=';
    case LIKE          = 'LIKE';
    case NOT_LIKE      = 'NOT LIKE';
    case IN            = 'IN';
    case NOT_IN        = 'NOT IN';
}

=== QueryBuilder/Enums/QueryBuilderEnum.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Enums;

/**
 * Technical base class for all enumerations used within the QueryBuilder domain.
 *
 * -- intent: centralize common enum-specific utility methods.
 */
abstract class QueryBuilderEnum
{
    /**
     * Retrieve all defined values for the enumeration.
     *
     * -- intent: provide a programmatic way to list all valid enum cases.
     *
     * @return array
     */
    abstract public static function values() : array;
}

=== QueryBuilder/Exceptions/InvalidCriteriaException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;

/**
 * Triggered when the query builder receives malformed or dangerous criteria.
 *
 * -- intent: prevent SQL injection and logical errors at the DSL level.
 */
final class InvalidCriteriaException extends DatabaseException
{
    /**
     * Constructor capturing the problematic method and reason.
     *
     * -- intent: provide specific feedback on which builder method was misused.
     *
     * @param string $method Technical name of the builder method
     * @param string $reason Human-readable explanation of why the input is invalid
     */
    #[Override]
    public function __construct(
        private readonly string $method,
        string                  $reason
    )
    {
        parent::__construct(message: "Invalid criteria in [{$method}]: {$reason}");
    }

    /**
     * Retrieve the name of the method where the error originated.
     *
     * -- intent: pinpoint the logical source of the usage error.
     *
     * @return string
     */
    public function getMethod() : string
    {
        return $this->method;
    }
}



=== QueryBuilder/Exceptions/QueryException.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\Exceptions;

use Avax\Database\Exceptions\DatabaseException;
use Override;
use SensitiveParameter;
use Throwable;

/**
 * Specialized exception for failures occurring during SQL compilation or execution.
 *
 * -- intent: provide diagnostic context including the failing SQL and its parameter bindings.
 */
class QueryException extends DatabaseException
{
    /**
     * Constructor promoting diagnostic properties via PHP 8.3 features.
     *
     * -- intent: capture the full state of the failure for debugging and logging.
     *
     * @param string         $message  Technical failure description
     * @param string         $sql      The dialect-specific SQL string that failed
     * @param array          $bindings Secure parameter values used in the query
     * @param Throwable|null $previous The underlying driver exception
     */
    #[Override]
    public function __construct(
        string $message,
        private readonly string $sql,
        #[SensitiveParameter] private readonly array $rawBindings = [],
        Throwable|null $previous = null
    ) {
        $this->redactedBindings = $this->redactBindings(bindings: $this->rawBindings);
        parent::__construct(message: $message, code: 0, previous: $previous);
    }

    /**
     * Retrieve the failing SQL statement.
     *
     * -- intent: expose the problematic query for technical analysis.
     *
     * @return string
     */
    public function getSql(): string
    {
        return $this->sql;
    }

    /**
     * Retrieve the parameter bindings used with the failing statement.
     *
     * -- intent: expose the provided data values for debugging.
     *
     * @return array
     */
    public function getBindings(bool $redacted = true): array
    {
        return $redacted ? $this->redactedBindings : $this->rawBindings;
    }

    /**
     * Redact sensitive values from binding payloads.
     */
    private function redactBindings(array $bindings): array
    {
        return array_map(callback: static fn($value) => '[REDACTED]', array: $bindings);
    }

    /**
     * @var array Redacted bindings safe for diagnostics
     */
    private readonly array $redactedBindings;
}

=== QueryBuilder/Module.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder;

use Avax\Container\Containers\DependencyInjector as Container;
use Avax\Database\Connection\Contracts\DatabaseConnection;
use Avax\Database\Identity\IdentityMap;
use Avax\Database\Lifecycle\LifecycleInterface;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Database\QueryBuilder\Core\Executor\PDOExecutor;
use Avax\Database\QueryBuilder\Core\Grammar\MySQLGrammar;
use Avax\Database\Transaction\Contracts\TransactionManagerInterface;

/**
 * The "Sentence Builder" Feature (QueryBuilder Module).
 *
 * -- what is it?
 * This is the module that adds the `QueryBuilder` functionality to the 
 * database system. It's like adding a new "Chapter" or "Skill" to your 
 * application's brain.
 *
 * -- how to imagine it:
 * Think of it as an "App-within-an-App". When the database system starts 
 * up, this module is invited to the party. It brings along its tools: the 
 * "Grammar" (how to speak SQL), the "Executor" (how to run SQL), and the 
 * "Identity Map" (how to remember data).
 *
 * -- why this exists:
 * 1. Modular Design: If you don't need a Query Builder (maybe you only 
 *    use raw SQL), you could theoretically remove this module without 
 *    breaking the rest of the database system.
 * 2. Organization: It centralizes all the "Wiring" (Dependency Injection) 
 *    needed to make a QueryBuilder work. You don't have to manually connect 
 *    the Grammar to the Executor; the Module does it for you.
 * 3. Standardization: It follows the `LifecycleInterface` rulebook, so 
 *    it fits perfectly into the system's `boot()` and `shutdown()` process.
 *
 * -- mental models:
 * - "Wiring": Connecting different electronic components (Grammar, Executor) 
 *    so they work together as one device (QueryBuilder).
 * - "Singleton": A "Unique Tool". We only ever want ONE QueryBuilder instance 
 *    running to keep things consistent.
 */
final class Module implements LifecycleInterface
{
    /**
     * @param Container $container The "Toolbox" where the feature will store its recipes.
     */
    public function __construct(
        private readonly Container $container
    ) {}

    /**
     * Provide the "ID Card" (Metadata) for this feature.
     *
     * -- intent:
     * This is how the system recognizes this class as a valid Feature Module.
     */
    public static function declare(): array
    {
        return [
            'name'  => 'queryBuilder',
            'class' => self::class
        ];
    }

    /**
     * Set up the recipes for the QueryBuilder tools in the toolbox.
     *
     * -- intent:
     * We tell the system: "Whenever someone asks for a `QueryBuilder`, here 
     * is how you build one: connect the MySQL language (Grammar), the 
     * PDO engine (Executor), and the Identity Map together."
     */
    public function register(): void
    {
        $this->container->singleton(abstract: QueryBuilder::class, concrete: function ($c) {
            return new QueryBuilder(
                grammar: new MySQLGrammar(),
                executor: new PDOExecutor(connection: $c->get(id: DatabaseConnection::class)),
                transactionManager: $c->get(id: TransactionManagerInterface::class),
                identityMap: $c->get(id: IdentityMap::class)
            );
        });
    }

    /**
     * Optional "Wake up" logic.
     */
    public function boot(): void
    {
        // No additional boot logic required for query builder.
    }

    /**
     * Optional "Cleanup" logic.
     */
    public function shutdown(): void
    {
        // Shutdown logic if required.
    }
}

=== QueryBuilder/ValueObjects/Expression.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\QueryBuilder\ValueObjects;

use Stringable;

/**
 * Technical representation of a raw SQL expression which must bypass standard escaping.
 *
 * -- intent:
 * Provides a secure, intentional mechanism for developers to inject literal 
 * SQL fragments (e.g., function calls, complex math) into the builder 
 * while signaling to the Grammar that the content is trusted and pre-formatted.
 *
 * -- invariants:
 * - The object must be strictly immutable.
 * - The value must be returned as-is by the SQL compilation engine.
 * - Content is assumed to be safe/sanitized by the producer (Escape Hatch).
 *
 * -- boundaries:
 * - Does NOT perform character escaping or parameterization.
 * - Does NOT validate the syntactical correctness of the SQL fragment.
 */
final readonly class Expression implements Stringable
{
    /**
     * @param string $value The raw technical SQL fragment to be injected literally.
     */
    public function __construct(public string $value) {}

    /**
     * Retrieve the internal raw SQL instruction as a primitive string.
     *
     * -- intent:
     * Support seamless integration with string-based operations and 
     * concatenation during SQL compilation.
     *
     * @return string The raw SQL instruction.
     */
    public function __toString(): string
    {
        return $this->value;
    }

    /**
     * Retrieve the encapsulated raw SQL value.
     *
     * -- intent:
     * Provide an explicit getter for retrieving the raw instruction, 
     * typically consumed by the Grammar technician.
     *
     * @return string The raw SQL fragment.
     */
    public function getValue(): string
    {
        return $this->value;
    }
}

=== examples/transactional-flow.php ===
<?php

/**
 * Example: Transactional Flow with Execution Scope and Identity Map
 *
 * This example demonstrates:
 * - ExecutionScope for correlation tracking
 * - Transactional boundaries
 * - Deferred execution via Identity Map
 * - Query telemetry with binding redaction
 */

declare(strict_types=1);

use Avax\Database\Identity\IdentityMap;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Database\QueryBuilder\Core\Executor\PDOExecutor;
use Avax\Database\QueryBuilder\Core\Executor\QueryOrchestrator;
use Avax\Database\QueryBuilder\Core\Grammar\MySQLGrammar;
use Avax\Database\Support\ExecutionScope;
use Avax\Database\Transaction\TransactionManager;

// 1. Bootstrap the infrastructure
$pdo = new PDO('mysql:host=localhost;dbname=example', 'user', 'pass');
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

$grammar           = new MySQLGrammar();
$executor          = new PDOExecutor(pdo: $pdo, connectionName: 'primary');
$transactionMgr    = new TransactionManager(pdo: $pdo);
$orchestrator      = new QueryOrchestrator(
    executor: $executor,
    transactionManager: $transactionMgr
);

// 2. Create an execution scope for correlation tracking
$scope = ExecutionScope::fresh(correlationId: 'req_' . bin2hex(random_bytes(8)));

// 3. Initialize the Query Builder
$builder = new QueryBuilder(grammar: $grammar, orchestrator: $orchestrator->withScope(scope: $scope));

// 4. Execute within a transactional boundary
$builder->transaction(function (QueryBuilder $query) {

    // Standard INSERT
    $query->from(table: 'users')->insert(values: [
        'name'     => 'John Doe',
        'email'    => 'john@example.com',
        'password' => password_hash('secret', PASSWORD_BCRYPT), // This will be redacted in logs
    ]);

    // Deferred execution with Identity Map (batch optimization)
    $identityMap = new IdentityMap(orchestrator: $query->orchestrator);

    $deferredQuery = $query->deferred(identityMap: $identityMap);

    $deferredQuery->from(table: 'audit_log')->insert(values: ['action' => 'user_created']);
    $deferredQuery->from(table: 'audit_log')->insert(values: ['action' => 'email_sent']);

    // Flush deferred operations
    $identityMap->execute();

    // Safe raw SQL (validated by guardrails)
    $query->from(table: 'stats')
        ->selectRaw('COUNT(*) as total')
        ->get();
});

// 5. Observability: All queries dispatched QueryExecuted events with redacted bindings
// Check your logs to see:
// - correlation_id: req_xxxxx
// - bindings: ['[REDACTED]', '[REDACTED]', '[REDACTED]']
// - raw_bindings: (only if DB_LOG_BINDINGS=raw)

echo "Transaction completed successfully.\n";

=== tests/Connection/ConnectionPoolTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Connection;

use Avax\Database\Avax\Connection\Pool\ConnectionPool;
use Avax\Tests\TestCase;

class ConnectionPoolTest extends TestCase
{
    public function testConnectionPoolInitialization() : void
    {
        $pool = new ConnectionPool(
            ['connections' => ['mysql' => ['driver' => 'mysql']]]
        );

        $this->assertInstanceOf(ConnectionPool::class, $pool);
    }

    public function testPruneStaleConnections() : void
    {
        $pool = new ConnectionPool([]);

        // This is a unit test, so we can't easily test real connections
        // but we can verify the method exists and runs.
        $pool->pruneStaleConnections();
        $this->assertTrue(true);
    }
}

=== tests/Core/KernelTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Core;

use Avax\Database\Core\Container;
use Avax\Database\Core\EventBus;
use Avax\Database\Core\Registry;
use Avax\Database\Kernel;
use Avax\Tests\TestCase;

class KernelTest extends TestCase
{
    public function testKernelIsSingleton() : void
    {
        $instance1 = Kernel::getInstance();
        $instance2 = Kernel::getInstance();

        $this->assertSame($instance1, $instance2);
    }

    public function testKernelResolvesCoreServices() : void
    {
        $container = $this->kernel->getContainer();

        $this->assertInstanceOf(Container::class, $container->resolve('container'));
        $this->assertInstanceOf(Registry::class, $container->resolve('registry'));
        $this->assertInstanceOf(EventBus::class, $container->resolve('events'));
    }

    public function testKernelIsBootstrapped() : void
    {
        $container = $this->kernel->getContainer();

        $this->assertTrue($container->has('config'));
        $this->assertEquals('sqlite', $container->resolve('config')->get('database.default'));
    }
}

=== tests/Migration/MigrationTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Migration;

use Avax\Database\Modules\Migration\Blueprint;
use Avax\Database\Modules\Migration\TableRenderer;
use Avax\Tests\TestCase;

class MigrationTest extends TestCase
{
    public function testBlueprintGeneratesColumns() : void
    {
        $blueprint = new Blueprint('users');
        $blueprint->id();
        $blueprint->string('email');
        $blueprint->timestamps();

        $this->assertCount(4, $blueprint->getColumns());
    }

    public function testTableRendererGeneratesSQL() : void
    {
        $blueprint = new Blueprint('users');
        $blueprint->id();
        $blueprint->string('name');

        $sql = TableRenderer::renderCreate($blueprint);

        $this->assertStringContainsString('CREATE TABLE `users`', $sql);
        $this->assertStringContainsString('`id`', $sql);
        $this->assertStringContainsString('`name`', $sql);
    }
}

=== tests/QueryBuilder/BuilderTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests\Query;

use Avax\Database\Database;
use Avax\Database\Modules\Query\Builder\QueryBuilder;
use Avax\Database\Modules\Query\Query;
use Avax\Tests\TestCase;
use Override;
use Throwable;

class BuilderTest extends TestCase
{
    public function testBasicSelect() : void
    {
        $results = Query::table('users')->select('id', 'name')->get();

        $this->assertCount(1, $results);
        $this->assertEquals('John Doe', $results[0]['name']);
    }

    public function testWhereClauses() : void
    {
        $builder = Query::table('users')->where('id', 1)->orWhere('email', 'test@example.com');

        $this->assertInstanceOf(QueryBuilder::class, $builder);
    }

    public function testJoins() : void
    {
        $builder = Query::table('users')
            ->join('posts', 'users.id', '=', 'posts.user_id')
            ->select('users.name', 'posts.title');

        $this->assertInstanceOf(QueryBuilder::class, $builder);
    }

    public function testAggregates() : void
    {
        $count = Query::table('users')->count();

        $this->assertSame(1, $count);
    }

    /**
     * @throws Throwable
     */
    #[Override]
    protected function setUp() : void
    {
        parent::setUp();

        // Create the users table for testing
        Database::schema()->create('users', function ($table) {
            $table->id();
            $table->string('name');
            $table->string('email');
            $table->timestamps();
        });

        // Seed some data
        Database::table('users')->insert(['name' => 'John Doe', 'email' => 'john@example.com']);
    }
}

=== tests/Stress/PoolStressTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Tests\Stress;

use Avax\Database\Avax\Connection\Pool\ConnectionPool;
use Avax\Database\Avax\Connection\Pool\PooledConnectionAuthority;
use PDO;
use PHPUnit\Framework\TestCase;

/**
 * Stress test: Verify pool correctly handles rapid acquire/release cycles.
 */
final class PoolStressTest extends TestCase
{
    /**
     * Test: 100 rapid acquire/release cycles without slot leakage.
     */
    public function test_pool_handles_rapid_acquire_release(): void
    {
        $factory = fn() => new PDO('sqlite::memory:');
        $pool = new ConnectionPool(factory: $factory, maxSize: 5);

        // Simulate 100 rapid requests
        for ($i = 0; $i < 100; $i++) {
            $authority = $pool->acquire();
            $this->assertInstanceOf(PooledConnectionAuthority::class, $authority);

            $connection = $authority->borrow();
            $this->assertInstanceOf(PDO::class, $connection->getConnection());

            // Explicit release (simulating end of request)
            unset($connection);
            unset($authority);
        }

        // Verify pool is still healthy
        $this->assertTrue(true, 'Pool survived 100 cycles');
    }

    /**
     * Test: Concurrent slot usage respects max pool size.
     */
    public function test_pool_respects_max_size(): void
    {
        $factory = fn() => new PDO('sqlite::memory:');
        $pool = new ConnectionPool(factory: $factory, maxSize: 3);

        $authorities = [];
        $connections = [];

        // Acquire max slots
        for ($i = 0; $i < 3; $i++) {
            $authorities[$i] = $pool->acquire();
            $connections[$i] = $authorities[$i]->borrow();
        }

        // Fourth acquire should create a new connection (pool exhausted)
        $fourthAuth = $pool->acquire();
        $this->assertInstanceOf(PooledConnectionAuthority::class, $fourthAuth);

        // Cleanup
        unset($connections);
        unset($authorities);
        unset($fourthAuth);

        $this->assertTrue(true, 'Pool correctly handled slot exhaustion');
    }

    /**
     * Test: Exception during connection usage doesn't leak slot.
     */
    public function test_pool_releases_slot_on_exception(): void
    {
        $factory = fn() => new PDO('sqlite::memory:');
        $pool = new ConnectionPool(factory: $factory, maxSize: 2);

        try {
            $authority = $pool->acquire();
            $connection = $authority->borrow();

            // Simulate exception during usage
            throw new \RuntimeException('Simulated failure');
        } catch (\RuntimeException $e) {
            // Expected
        }

        // Slot should be released via __destruct
        // Verify pool is still usable
        $newAuthority = $pool->acquire();
        $this->assertInstanceOf(PooledConnectionAuthority::class, $newAuthority);
    }
}

=== tests/TestCase.php ===
<?php

declare(strict_types=1);

namespace Avax\Tests;

use Avax\Database\Kernel;
use PHPUnit\Framework\TestCase as BaseTestCase;

abstract class TestCase extends BaseTestCase
{
    protected Kernel $kernel;

    protected function setUp() : void
    {
        parent::setUp();

        $this->kernel = Kernel::getInstance();
        $this->kernel->bootstrap([
                                     'database' => [
                                         'default'     => 'sqlite',
                                         'connections' => [
                                             'sqlite' => [
                                                 'driver'   => 'sqlite',
                                                 'database' => ':memory:',
                                                 'prefix'   => '',
                                             ]
                                         ]
                                     ]
                                 ]);
    }

    protected function tearDown() : void
    {
        $this->kernel->shutdown();
        parent::tearDown();
    }
}

=== tests/Unit/CriticalPathTest.php ===
<?php

declare(strict_types=1);

namespace Avax\Database\Tests\Unit;

use Avax\Database\Identity\IdentityMap;
use Avax\Database\QueryBuilder\Core\Builder\QueryBuilder;
use Avax\Database\QueryBuilder\Core\Executor\PDOExecutor;
use Avax\Database\QueryBuilder\Core\Executor\QueryOrchestrator;
use Avax\Database\QueryBuilder\Core\Grammar\MySQLGrammar;
use Avax\Database\Transaction\TransactionManager;
use PDO;
use PHPUnit\Framework\TestCase;

/**
 * Critical path test: Pool lifecycle, Transaction rollback, Security redaction.
 */
final class CriticalPathTest extends TestCase
{
    private PDO $pdo;

    protected function setUp(): void
    {
        $this->pdo = new PDO('sqlite::memory:');
        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $this->pdo->exec('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)');
    }

    /**
     * Test: Transaction rollback on inner failure.
     */
    public function test_transaction_rollback_on_failure(): void
    {
        $grammar = new MySQLGrammar();
        $executor = new PDOExecutor(pdo: $this->pdo, connectionName: 'test');
        $transactionMgr = new TransactionManager(pdo: $this->pdo);
        $orchestrator = new QueryOrchestrator(executor: $executor, transactionManager: $transactionMgr);
        $builder = new QueryBuilder(grammar: $grammar, orchestrator: $orchestrator);

        try {
            $builder->transaction(function (QueryBuilder $query) {
                $query->from(table: 'users')->insert(values: ['name' => 'Alice', 'email' => 'alice@test.com']);

                // Force an exception
                throw new \Exception('Simulated failure');
            });
        } catch (\Exception $e) {
            // Expected
        }

        // Verify rollback: no records should exist
        $count = $builder->from(table: 'users')->count();
        $this->assertSame(0, $count, 'Transaction should have rolled back');
    }

    /**
     * Test: Identity Map deferred execution.
     */
    public function test_identity_map_defers_execution(): void
    {
        $grammar = new MySQLGrammar();
        $executor = new PDOExecutor(pdo: $this->pdo, connectionName: 'test');
        $orchestrator = new QueryOrchestrator(executor: $executor);
        $identityMap = new IdentityMap(orchestrator: $orchestrator);
        $builder = new QueryBuilder(grammar: $grammar, orchestrator: $orchestrator->withIdentityMap(map: $identityMap));

        $deferred = $builder->deferred(identityMap: $identityMap);
        $deferred->from(table: 'users')->insert(values: ['name' => 'Bob', 'email' => 'bob@test.com']);

        // Before flush: no records
        $count = $builder->from(table: 'users')->count();
        $this->assertSame(0, $count);

        // After flush: record exists
        $identityMap->execute();
        $count = $builder->from(table: 'users')->count();
        $this->assertSame(1, $count);
    }

    /**
     * Test: QueryException never exposes raw bindings by default.
     */
    public function test_query_exception_redacts_bindings_by_default(): void
    {
        $grammar = new MySQLGrammar();
        $executor = new PDOExecutor(pdo: $this->pdo, connectionName: 'test');
        $orchestrator = new QueryOrchestrator(executor: $executor);
        $builder = new QueryBuilder(grammar: $grammar, orchestrator: $orchestrator);

        try {
            // Invalid SQL to trigger exception
            $builder->from(table: 'nonexistent')->insert(values: ['secret' => 'password123']);
        } catch (\Avax\Database\QueryBuilder\Exceptions\QueryException $e) {
            $bindings = $e->getBindings(); // Default redacted
            $this->assertSame(['[REDACTED]'], $bindings);

            $rawBindings = $e->getBindings(redacted: false); // Explicit opt-in
            $this->assertSame(['password123'], $rawBindings);
        }
    }
}

