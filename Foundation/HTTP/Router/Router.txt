=== .php-cs-fixer.dist.php ===
<?php

declare(strict_types=1);

$finder = PhpCsFixer\Finder::create()
    ->in(__DIR__)
    ->exclude([
        'vendor',
        'tests',
        'storage',
        'public',
        'docker',
        'tmp',
        'tools',
        '.idea',
        '.git',
    ])
    ->name('*.php')
    ->notName('*.blade.php')
    ->ignoreDotFiles(true)
    ->ignoreVCS(true);

$config = new PhpCsFixer\Config();
return $config
    ->setRules([
        // PSR-12 coding standard
        '@PSR12' => true,

        // Additional enterprise rules
        'strict_param' => true,
        'strict_return' => true,
        'declare_strict_types' => true,

        // Array formatting
        'array_syntax' => ['syntax' => 'short'],
        'no_multiline_whitespace_around_double_arrow' => true,
        'no_whitespace_before_comma_in_array' => true,
        'whitespace_after_comma_in_array' => true,

        // String formatting
        'single_quote' => true,
        'no_useless_concat_operator' => true,

        // Function calls
        'function_declaration' => true,
        'function_typehint_space' => true,
        'no_spaces_after_function_name' => true,
        'no_spaces_inside_parenthesis' => true,

        // Control structures
        'elseif' => true,
        'include' => true,
        'no_else_return' => true,
        'no_useless_else' => true,

        // Classes and objects
        'class_attributes_separation' => ['elements' => ['const' => 'one', 'method' => 'one', 'property' => 'one']],
        'class_definition' => true,
        'no_blank_lines_after_class_opening' => true,
        'no_null_property_initialization' => true,
        'ordered_class_elements' => ['order' => ['use_trait', 'constant_public', 'constant_protected', 'constant_private', 'property_public', 'property_protected', 'property_private', 'construct', 'destruct', 'magic', 'method_public', 'method_protected', 'method_private']],
        'protected_to_private' => true,
        'self_accessor' => true,

        // Namespaces
        'no_leading_import_slash' => true,
        'ordered_imports' => ['sort_algorithm' => 'alpha'],
        'single_import_per_statement' => true,

        // PHPDoc
        'phpdoc_add_missing_param_annotation' => true,
        'phpdoc_align' => true,
        'phpdoc_annotation_without_dot' => true,
        'phpdoc_indent' => true,
        'phpdoc_inline_tag_normalizer' => true,
        'phpdoc_no_access' => true,
        'phpdoc_no_alias_tag' => true,
        'phpdoc_no_empty_return' => true,
        'phpdoc_no_package' => true,
        'phpdoc_no_useless_inheritdoc' => true,
        'phpdoc_order' => true,
        'phpdoc_return_self_reference' => true,
        'phpdoc_scalar' => true,
        'phpdoc_separation' => true,
        'phpdoc_single_line_var_spacing' => true,
        'phpdoc_summary' => true,
        'phpdoc_tag_type' => true,
        'phpdoc_to_comment' => true,
        'phpdoc_trim' => true,
        'phpdoc_types' => true,
        'phpdoc_var_without_name' => true,

        // Comments
        'no_empty_comment' => true,
        'no_empty_phpdoc' => true,
        'single_line_comment_style' => true,

        // Whitespace and formatting
        'binary_operator_spaces' => true,
        'blank_line_after_namespace' => true,
        'blank_line_before_statement' => ['statements' => ['break', 'continue', 'declare', 'return', 'throw', 'try']],
        'cast_spaces' => true,
        'concat_space' => ['spacing' => 'one'],
        'increment_style' => ['style' => 'post'],
        'indentation_type' => true,
        'line_ending' => true,
        'lowercase_cast' => true,
        'lowercase_keywords' => true,
        'lowercase_static_reference' => true,
        'magic_constant_casing' => true,
        'magic_method_casing' => true,
        'method_chaining_indentation' => true,
        'multiline_whitespace_before_semicolons' => true,
        'native_function_casing' => true,
        'native_function_type_declaration_casing' => true,
        'new_with_braces' => true,
        'no_blank_lines_after_phpdoc' => true,
        'no_closing_tag' => true,
        'no_empty_statement' => true,
        'no_extra_blank_lines' => ['tokens' => ['extra', 'parenthesis_brace_block', 'square_brace_block', 'throw', 'use']],
        'no_leading_namespace_whitespace' => true,
        'no_multiline_whitespace_around_double_arrow' => true,
        'no_short_bool_cast' => true,
        'no_singleline_whitespace_before_semicolons' => true,
        'no_spaces_after_function_name' => true,
        'no_spaces_around_offset' => true,
        'no_spaces_inside_parenthesis' => true,
        'no_trailing_comma_in_singleline_array' => true,
        'no_trailing_whitespace' => true,
        'no_trailing_whitespace_in_comment' => true,
        'no_unneeded_control_parentheses' => true,
        'no_unneeded_curly_braces' => true,
        'no_unneeded_final_method' => true,
        'no_unused_imports' => true,
        'no_whitespace_before_comma_in_array' => true,
        'no_whitespace_in_blank_line' => true,
        'normalize_index_brace' => true,
        'object_operator_without_whitespace' => true,
        'operators_spaces' => true,
        'php_unit_fqcn_annotation' => true,
        'php_unit_method_casing' => true,
        'return_type_declaration' => true,
        'semicolon_after_instruction' => true,
        'short_scalar_cast' => true,
        'single_blank_line_at_eof' => true,
        'single_class_element_per_statement' => true,
        'single_import_per_statement' => true,
        'single_line_after_imports' => true,
        'single_quote' => true,
        'space_after_semicolon' => true,
        'standardize_increment' => true,
        'standardize_not_equals' => true,
        'switch_case_semicolon_to_colon' => true,
        'switch_case_space' => true,
        'ternary_operator_spaces' => true,
        'trailing_comma_in_multiline' => ['elements' => ['arrays']],
        'trim_array_spaces' => true,
        'unary_operator_spaces' => true,
        'visibility_required' => true,
        'whitespace_after_comma_in_array' => true,
        'yoda_style' => true,

        // Custom router-specific rules
        'no_superfluous_phpdoc_tags' => ['allow_mixed' => true, 'allow_unused_params' => true],
        'phpdoc_to_property_type' => false, // Keep PHPDoc for readonly properties
        'phpdoc_to_return_type' => false,   // Keep PHPDoc for complex return types
        'phpdoc_to_param_type' => false,    // Keep PHPDoc for complex param types
    ])
    ->setFinder($finder)
    ->setRiskyAllowed(true)
    ->setUsingCache(true);
=== Bootstrap/RouteBootstrapper.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Bootstrap;

use Avax\Config\Architecture\DDD\AppPath;
use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Cache\RouteCacheLoader;
use Avax\HTTP\Router\Cache\RouteCacheManifest;
use Avax\HTTP\Router\RouterRuntimeInterface;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Snapshots\RouterSnapshot;
use Avax\HTTP\Router\Support\RouteRegistry;
use Avax\HTTP\Router\Support\RouterBootstrapState;
use Closure;
use FilesystemIterator;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;
use Throwable;

/**
 * Handles the bootstrapping of application routes.
 *
 * Responsibilities:
 * - Ensure routes are loaded efficiently and securely.
 * - Load routes from cache, if available, for improved performance.
 * - Fallback to loading routes from disk-based DSL/closure definitions.
 * - Support error handling, logging, and other critical processes.
 *
 * This class emphasizes secure, clean, and efficient route bootstrapping.
 */
final readonly class RouteBootstrapper
{
    /**
     * @var RouteCacheLoader Handles route caching operations.
     * @var HttpRequestRouter Responsible for registering and managing application routes.
     * @var RouterBootstrapState Thread-safe bootstrap state management.
     * @var RouteRegistry Route registry for isolated route collection.
     * @var LoggerInterface Logs important messages and errors.
     */
    public function __construct(
        private RouteCacheLoader     $routeCacheLoader,
        private HttpRequestRouter    $httpRequestRouter,
        private RouterBootstrapState $bootstrapState,
        private RouteRegistry        $routeRegistry,
        private LoggerInterface      $logger,
    ) {}

    /**
     * Bootstraps application routes.
     *
     * - Attempts to load routes from the cache file if available.
     * - Falls back to loading routes from disk files if the cache is absent or outdated.
     * - Always loads closure-based routes directly from disk to ensure runtime correctness.
     *
     * @throws Throwable Any exception encountered during route bootstrapping is logged and re-thrown.
     */
    public function bootstrap() : void
    {
        $this->bootstrapState->ensureNotBooted();

        // Retrieve the paths for route cache and routes directory.
        $cachePath   = AppPath::ROUTE_CACHE_PATH->get();
        $routesPath  = AppPath::ROUTES_PATH->get();
        $cacheLoaded = false;

        try {
            // DECISION TRACE: Bootstrap path selection
            $cacheAvailable = $this->isCacheAvailable(cachePath: $cachePath, routesPath: $routesPath);
            $this->logger->debug(message: 'Route bootstrap decision', context: [
                'cache_available' => $cacheAvailable,
                'cache_path'      => $cachePath,
                'routes_path'     => $routesPath,
            ]);

            // Check if the cache file exists and is valid, load routes from it if true.
            if ($cacheAvailable) {
                $this->bootstrapState->markSource(source: 'cache');
                $this->logger->info(message: 'Route bootstrap: using cache', context: ['cache_path' => $cachePath]);
                $this->loadRoutesFromCache(cachePath: $cachePath, routesPath: $routesPath);
                $cacheLoaded = true;

                // When cache is loaded, we still need to execute closure-based routes
                // but only those that were not cached (closures are never cached)
                $this->logger->debug(message: 'Route bootstrap: loading closure routes from disk');
                $this->loadRoutesFromDisk(baseDir: $routesPath, closuresOnly: true);
            } else {
                $this->bootstrapState->markSource(source: 'disk');
                $this->logger->info(message: 'Route bootstrap: building from disk', context: ['routes_path' => $routesPath]);
                // Otherwise, load ALL routes from disk and generate a new cache file.
                // This includes both cacheable routes and closures in one pass.
                $this->loadRoutesFromDiskAndCache(routesPath: $routesPath, cachePath: $cachePath);
            }

            // Log final bootstrap statistics
            $routesCount = count($this->httpRequestRouter->allRoutes());
            $this->logger->info(message: 'Route bootstrap completed.', context: [
                'routes_count' => $routesCount,
                'source'       => $this->bootstrapState->getSource()
            ]);

            // Export router snapshot for reproducibility and auditing (v2.1 feature)
            $this->exportRouterSnapshot(routesPath: $routesPath);
        } catch (Throwable $exception) {
            // Handle and log critical errors during route setup, then re-throw the exception.
            $this->handleCriticalError(exception: $exception, cachePath: $cachePath, routesPath: $routesPath);
            throw $exception;
        }
    }

    /**
     * Validates the availability of the route cache file.
     *
     * @param string $cachePath Absolute path of the cache file.
     *
     * @return bool Returns true if the cache file exists and is readable.
     */
    private function isCacheAvailable(string $cachePath, string $routesPath) : bool
    {
        if (! is_file(filename: $cachePath) || ! is_readable(filename: $cachePath)) {
            return false;
        }

        $storedManifest = RouteCacheManifest::fromFile(
            metadataPath: RouteCacheManifest::metadataPath(cachePath: $cachePath)
        );

        if ($storedManifest === null) {
            return false;
        }

        $currentManifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);

        if (! $storedManifest->matches(other: $currentManifest)) {
            return false;
        }

        return (filemtime(filename: $cachePath) ?: 0) >= $this->getRoutesLastModified(baseDir: $routesPath);
    }

    /**
     * Returns latest modification time inside routes directory (recursive).
     */
    private function getRoutesLastModified(string $baseDir) : int
    {
        if (! is_dir(filename: $baseDir)) {
            return 0;
        }

        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveDirectoryIterator(
                directory: $baseDir,
                flags    : FilesystemIterator::SKIP_DOTS
            )
        );

        $latest = 0;
        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $latest = max($latest, $file->getMTime());
            }
        }

        return $latest;
    }

    /**
     * Loads routes from the cache file.
     *
     * @param string $cachePath Path to the route cache file.
     */
    private function loadRoutesFromCache(string $cachePath, string $routesPath) : void
    {
        // Use the route cache loader to load cached routes.
        $this->routeCacheLoader->load(cachePath: $cachePath, routesPath: $routesPath);

        // Log the successful loading of cached routes.
        $this->logger->info(message: 'Route cache loaded.', context: [
            'cache'  => $cachePath,
            'source' => $this->bootstrapState->getSource()
        ]);
    }

    /**
     * Loads and registers routes from disk route definition files.
     *
     * - Iterates over disk route files and registers their routes with the router.
     * - Clears any existing buffered route definitions prior to registration.
     * - Registers the fallback route, if it exists.
     *
     * @param string $baseDir Base directory containing route definition files.
     */
    private function loadRoutesFromDisk(string $baseDir, bool $closuresOnly = false) : void
    {
        $this->routeRegistry->scoped(function () use ($baseDir, $closuresOnly) : void {
            foreach ($this->getRouteFilesFromDirectory(baseDir: $baseDir) as $file) {
                $this->processRouteFile(file: $file, closuresOnly: $closuresOnly);
            }

            $this->registerFallbackRoute(closuresOnly: $closuresOnly);
        });
    }

    /**
     * Retrieves all `.routes.php` files recursively from the specified directory.
     *
     * @param string $baseDir Directory to search for route files.
     *
     * @return list<SplFileInfo> A list of route files (instances of `SplFileInfo`).
     *
     * @throws RuntimeException Thrown if the directory is inaccessible or unreadable.
     */
    private function getRouteFilesFromDirectory(string $baseDir) : array
    {
        // Ensure the provided directory exists and is readable.
        if (! is_dir(filename: $baseDir) || ! is_readable(filename: $baseDir)) {
            throw new RuntimeException(message: "Routes directory '{$baseDir}' is not accessible or readable.");
        }

        // Create a recursive iterator to find all files within the route directory.
        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveDirectoryIterator(
                directory: $baseDir,
                flags    : FilesystemIterator::SKIP_DOTS
            )
        );

        // Filter and return files that end with `.routes.php`, or just 'routes.php'
        $routeFiles = array_filter(
            array   : iterator_to_array(iterator: $iterator),
            callback: static fn(SplFileInfo $file) : bool => $file->isFile()
                && $file->isReadable()
                && preg_match(
                    pattern: '/\.routes\.php$|^routes\.php$/',
                    subject: $file->getFilename()
                )
        );

        // Ensure a returned array is indexed sequentially
        return array_values(array: $routeFiles); // Avoids gaps in array keys

    }

    /**
     * Processes a route file and registers all contained routes with the router.
     *
     * @param SplFileInfo $file Route file to process.
     * @param bool        $closuresOnly
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    private function processRouteFile(SplFileInfo $file, bool $closuresOnly = false) : void
    {
        // Include the route file in an isolated scope to prevent variable leakage
        $this->requireIsolated(path: $file->getPathname());

        // Flush buffered routes from the registry and register them with the router.
        foreach ($this->routeRegistry->flush() as $routeBuilder) {
            $definition = $routeBuilder->build();

            if ($closuresOnly && ! $definition->usesClosure()) {
                continue;
            }

            $this->httpRequestRouter->registerRoute(
                method       : $definition->method,
                path         : $definition->path,
                action       : $definition->action,
                middleware   : $definition->middleware,
                name         : $definition->name,
                constraints  : $definition->constraints,
                defaults     : $definition->defaults,
                domain       : $definition->domain,
                attributes   : $definition->attributes,
                authorization: $definition->authorization,
            );
        }
    }

    /**
     * Requires a file in an isolated scope to prevent variable leakage.
     *
     * This prevents route definition files from accessing or modifying
     * variables in the calling scope, ensuring clean separation.
     *
     * @param string $path The file path to require
     */
    private function requireIsolated(string $path) : void
    {
        (static function () use ($path) : void {
            require $path;
        })();
    }

    /**
     * Registers a fallback route if one is defined within the registry.
     */
    private function registerFallbackRoute(bool $closuresOnly = false) : void
    {
        // Check if a fallback route exists in the registry.
        $fallback = $this->routeRegistry->getFallback();

        if ($fallback !== null && (! $closuresOnly || $fallback instanceof Closure)) {
            $this->httpRequestRouter->fallback(handler: $fallback);
        }
    }

    /**
     * Loads routes from disk and generates a new cache file for future use.
     *
     * @param string $routesPath Path to the directory containing route definition files.
     * @param string $cachePath  Path to where the new cache file should be written.
     *
     * @throws \Avax\Contracts\FilesystemException
     */
    private function loadRoutesFromDiskAndCache(string $routesPath, string $cachePath) : void
    {
        // Load routes from disk-based files.
        $this->loadRoutesFromDisk(baseDir: $routesPath);

        // Write the loaded routes to a cache file.
        $this->routeCacheLoader->write(cachePath: $cachePath, routesPath: $routesPath);

        // Log the creation of a new route cache.
        $this->logger->info(message: 'Route cache created from disk.', context: [
            'source' => $routesPath,
            'cache'  => $cachePath,
        ]);
    }

    /**
     * Exports router configuration snapshot for reproducibility and auditing.
     *
     * Creates immutable snapshots after successful bootstrap for:
     * - Change tracking and rollback capabilities
     * - Governance and regulatory compliance
     * - Configuration auditing across environments
     *
     * @param string $routesPath Path to routes directory for context
     */
    private function exportRouterSnapshot(string $routesPath) : void
    {
        try {
            // Create a router interface wrapper to access all routes
            $routerInterface = new class($this->httpRequestRouter) implements RouterRuntimeInterface {
                public function __construct(private HttpRequestRouter $router) {}

                public function resolve(Request $request) : ResponseInterface
                {
                    // Not needed for snapshot
                    throw new RuntimeException(message: 'Not implemented');
                }

                public function getRouteByName(string $name) : RouteDefinition
                {
                    return $this->router->getByName(name: $name);
                }

                public function allRoutes() : array
                {
                    return $this->router->allRoutes();
                }
            };

            $snapshot = RouterSnapshot::capture(router: $routerInterface, context: [
                'routes_path'    => $routesPath,
                'bootstrap_time' => date('c'),
            ]);

            // Export to standard location
            $snapshotPath = dirname($routesPath) . '/router-snapshot.json';
            $snapshot->exportToFile(path: $snapshotPath);

            $this->logger->info(message: 'Router snapshot exported for reproducibility', context: [
                'snapshot_path' => $snapshotPath,
                'routes_count'  => $snapshot->metadata['total_routes'],
                'checksum'      => substr($snapshot->checksum, 0, 16) . '...',
            ]);

        } catch (Throwable $exception) {
            // Don't fail bootstrap if snapshot fails, just log
            $this->logger->warning(message: 'Failed to export router snapshot', context: [
                'exception'   => $exception->getMessage(),
                'routes_path' => $routesPath,
            ]);
        }
    }

    /**
     * Handles critical errors encountered during route bootstrapping.
     *
     * - Logs the exception and its context to assist debugging.
     *
     * @param Throwable $exception  Exception encountered.
     * @param string    $cachePath  Path to the route cache file.
     * @param string    $routesPath Path to the directory containing route files.
     */
    private function handleCriticalError(Throwable $exception, string $cachePath, string $routesPath) : void
    {
        $this->logger->critical(message: 'Route bootstrap failed.', context: [
            'exception'  => $exception,
            'cache_path' => $cachePath,
            'routes_dir' => $routesPath,
        ]);
    }

    /**
     * Loads and registers closure-based routes directly from disk.
     *
     * @param string $routesPath Path to the directory containing route definition files.
     */
    private function loadClosureRoutesFromDisk(string $routesPath) : void
    {
        // Require route files in isolated scope to execute DSL
        foreach ($this->getRouteFilesFromDirectory(baseDir: $routesPath) as $file) {
            $this->requireIsolated(path: $file->getPathname());
        }

        // Log the successful loading of closure-based routes.
        $this->logger->info(message: 'Closure-based routes loaded from disk.', context: [
            'directory' => $routesPath,
        ]);
    }
}
=== Bootstrap/RouteRegistrar.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Bootstrap;

use Avax\HTTP\Router\RouterInterface;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteGroupStack;
use Avax\HTTP\Router\Support\RouteCollector;
use Avax\HTTP\Router\Support\RouteRegistry;

/**
 * Route loader that avoids static collectors.
 *
 * @see docs/Http/RouteRegistrar.md#quick-summary
 */
final readonly class RouteRegistrar
{
    public function __construct(
        private RouterInterface   $dslRouter,
        private HttpRequestRouter $httpRouter,
        private RouteGroupStack   $groupStack,
        private RouteRegistry     $routeRegistry
    ) {}

    /**
     * Load routes from file with registry integration.
     *
     * @see docs/Http/RouteRegistrar.md#method-load
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function load(string $path, string $cacheDir) : void
    {
        if (is_file($path)) {
            $snapshot  = $this->groupStack->snapshot();
            $router    = $this->httpRouter; // expose low-level router for route files
            $dslRouter = $this->dslRouter; // expose DSL if needed
            require $path;

            // Flush collected routes and register them with the router
            foreach ($this->routeRegistry->flush() as $routeBuilder) {
                $definition = $routeBuilder->build();
                $this->httpRouter->add(route: $definition);
            }

            // Note: Fallback handling is now done exclusively through FallbackManager
            // The registry fallback is used only during DSL execution

            $this->groupStack->restore(stack: $snapshot);
        }
    }
}
=== Cache/AsyncRouteCacheLoader.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Cache;

use Avax\Contracts\FilesystemException;
use Avax\Filesystem\Contracts\AsyncFilesystemInterface;
use Avax\HTTP\Router\RouterRuntimeInterface;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Routing\RouterRegistrar;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;
use RuntimeException;
use function Amp\all;

/**
 * Asynchronous route cache loader for modern PHP runtimes.
 *
 * Provides non-blocking I/O for route cache operations in Swoole, ReactPHP,
 * and other async environments. Falls back to sync operations when async
 * runtime is not available.
 *
 * Usage:
 * ```php
 * $asyncLoader = new AsyncRouteCacheLoader($registrar, $router, $asyncFilesystem);
 * $promise = $asyncLoader->loadAsync($cachePath, $routesPath);
 * $result = await $promise; // In async context
 * ```
 */
final readonly class AsyncRouteCacheLoader
{
    public function __construct(
        private RouterRegistrar          $registrar,
        private RouterRuntimeInterface   $router,
        private AsyncFilesystemInterface $filesystem,
        private LoggerInterface          $logger = new NullLogger,
    ) {}

    /**
     * Asynchronously loads route definitions from serialized cache.
     *
     * @param string $cachePath  Path to the route cache file
     * @param string $routesPath Path to routes directory for manifest validation
     *
     * @return mixed Promise resolving to void
     * @throws \Avax\Contracts\FilesystemException
     */
    public function loadAsync(string $cachePath, string $routesPath) : mixed
    {
        if ($this->filesystem->supportsAsync()) {
            return $this->loadAsyncInternal(cachePath: $cachePath, routesPath: $routesPath);
        }

        // Fallback to sync operation
        return $this->loadSync(cachePath: $cachePath, routesPath: $routesPath);
    }

    /**
     * Internal async load implementation.
     *
     * @throws \Avax\Contracts\FilesystemException
     * @throws \Avax\Contracts\FilesystemException
     */
    private function loadAsyncInternal(string $cachePath, string $routesPath) : mixed
    {
        $metadataPath = RouteCacheManifest::metadataPath(cachePath: $cachePath);

        // Check if files exist asynchronously
        return $this->filesystem->existsAsync(path: $cachePath)->then(
            function ($cacheExists) use ($cachePath, $metadataPath, $routesPath) {
                if (! $cacheExists) {
                    throw new RuntimeException(message: "Route cache file not found: {$cachePath}");
                }

                return $this->filesystem->existsAsync(path: $metadataPath);
            }
        )->then(
            function ($metadataExists) use ($metadataPath, $cachePath, $routesPath) {
                if (! $metadataExists) {
                    throw new RuntimeException(message: "Route cache metadata not found: {$metadataPath}");
                }

                // Load metadata and cache content in parallel
                return all([
                    $this->filesystem->getAsync(path: $metadataPath),
                    $this->filesystem->getAsync(path: $cachePath)
                ]);
            }
        )->then(
            function ($results) use ($routesPath, $cachePath) {
                [$metadataContent, $cacheContent] = $results;

                // Parse and validate manifest
                $storedManifest  = RouteCacheManifest::fromFileContent($metadataContent);
                $currentManifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);

                if ($storedManifest === null || ! $storedManifest->matches($currentManifest)) {
                    throw new RuntimeException(message: 'Route cache manifest mismatch; rebuild required.');
                }

                // Validate signature for immutable routing guarantees (v2.1 feature)
                if (! $storedManifest->validateSignatureFile($cachePath)) {
                    $this->logger->warning(message: 'Route cache signature validation failed. Cache may be compromised.', context: [
                        'cache_path'  => $cachePath,
                        'routes_path' => $routesPath,
                    ]);
                    throw new RuntimeException(message: 'Route cache signature validation failed. Cache integrity compromised.');
                }

                // Load and register routes
                $routes = $this->unserializeRoutes(content: $cacheContent);
                $this->registerRoutes(routes: $routes);

                $this->logger->info(message: 'Async route cache loaded successfully', context: [
                    'cache_path'    => $cachePath,
                    'routes_loaded' => count($routes),
                ]);
            }
        );
    }

    /**
     * Unserializes route data from cache content.
     */
    private function unserializeRoutes(string $content) : array
    {
        // Since we can't eval async, we need to parse the PHP export manually
        // This is a simplified implementation - in practice you'd want more robust parsing
        $routes = require 'data:text/plain;base64,' . base64_encode($content);

        return $routes;
    }

    /**
     * Registers routes with the router.
     */
    private function registerRoutes(array $routes) : void
    {
        foreach ($routes as $definition) {
            if (! is_array($definition)) {
                throw new RuntimeException(message: 'Invalid route in cache.');
            }

            $this->registrar->registerRouteFromCache(definition: RouteDefinition::fromArray(payload: $definition));
        }
    }

    /**
     * Synchronous fallback for load operation.
     */
    private function loadSync(string $cachePath, string $routesPath) : void
    {
        if (! $this->filesystem->exists($cachePath)) {
            throw new RuntimeException(message: "Route cache file not found: {$cachePath}");
        }

        $metadataPath    = RouteCacheManifest::metadataPath(cachePath: $cachePath);
        $storedManifest  = RouteCacheManifest::fromFile(metadataPath: $metadataPath);
        $currentManifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);

        if ($storedManifest === null || ! $storedManifest->matches(other: $currentManifest)) {
            throw new RuntimeException(message: 'Route cache manifest mismatch; rebuild required.');
        }

        // Validate signature for immutable routing guarantees (v2.1 feature)
        if (! $storedManifest->validateSignatureFile(cachePath: $cachePath)) {
            $this->logger->warning(message: 'Route cache signature validation failed. Cache may be compromised.', context: [
                'cache_path'  => $cachePath,
                'routes_path' => $routesPath,
            ]);
            throw new RuntimeException(message: 'Route cache signature validation failed. Cache integrity compromised.');
        }

        /** @var array<array<string, mixed>> $routes */
        $routes = require $cachePath;

        if (! is_array($routes)) {
            throw new RuntimeException(message: 'Invalid route cache: must be an array.');
        }

        foreach ($routes as $definition) {
            if (! is_array($definition)) {
                throw new RuntimeException(message: 'Invalid route in cache.');
            }

            $this->registrar->registerRouteFromCache(definition: RouteDefinition::fromArray(payload: $definition));
        }
    }

    /**
     * Asynchronously writes route definitions to serialized cache.
     *
     * @param string $cachePath  Path where cache file should be written
     * @param string $routesPath Path to routes directory for manifest creation
     *
     * @return mixed Promise resolving to void
     * @throws \Avax\Contracts\FilesystemException
     * @throws \JsonException
     */
    public function writeAsync(string $cachePath, string $routesPath) : mixed
    {
        if ($this->filesystem->supportsAsync()) {
            return $this->writeAsyncInternal(cachePath: $cachePath, routesPath: $routesPath);
        }

        // Fallback to sync operation
        return $this->writeSync(cachePath: $cachePath, routesPath: $routesPath);
    }

    /**
     * Internal async write implementation.
     *
     * @throws \Avax\Contracts\FilesystemException
     * @throws \Avax\Contracts\FilesystemException
     * @throws \JsonException
     * @throws \Avax\Contracts\FilesystemException
     */
    private function writeAsyncInternal(string $cachePath, string $routesPath) : mixed
    {
        $directory    = dirname($cachePath);
        $metadataPath = RouteCacheManifest::metadataPath(cachePath: $cachePath);

        // Ensure directory exists
        return $this->filesystem->ensureDirectoryAsync(path: $directory)->then(
            function () use ($routesPath, $cachePath, $metadataPath) {
                $routeDefinitions = $this->router->allRoutes();
                $flattenedRoutes  = $this->flattenRoutes(routeDefinitions: $routeDefinitions);
                $exportable       = $this->prepareExportableRoutes(flattenedRoutes: $flattenedRoutes);

                if (empty($exportable)) {
                    throw new RuntimeException(message: 'No cacheable routes available (closures are not cached).');
                }

                $exported = var_export($exportable, true);
                $hash     = sha1($exported);
                $content  = "<?php\n\n/** Auto-generated route cache [sha1: {$hash}]. Do not edit manually. */\n\nreturn {$exported};\n";

                $manifest        = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);
                $manifestContent = json_encode($manifest->toArray(), JSON_THROW_ON_ERROR);

                // Write cache and metadata in parallel
                return all([
                    $this->filesystem->putAsync(path: $cachePath, content: $content),
                    $this->filesystem->putAsync(path: $metadataPath, content: $manifestContent),
                ])->then(
                    function () use ($manifest, $cachePath) {
                        // Write signature for immutable routing guarantees
                        $manifest->writeSignature(cachePath: $cachePath);

                        $this->logger->info(message: 'Async route cache written successfully', context: [
                            'cache_path' => $cachePath,
                        ]);
                    }
                );
            }
        );
    }

    /**
     * Flattens route definitions for caching.
     */
    private function flattenRoutes(array $routeDefinitions) : array
    {
        return $routeDefinitions === []
            ? []
            : array_merge(...array_values($routeDefinitions));
    }

    /**
     * Prepares routes for export (filters out closures).
     */
    private function prepareExportableRoutes(array $flattenedRoutes) : array
    {
        $exportable = [];
        foreach ($flattenedRoutes as $route) {
            if ($route->usesClosure()) {
                $this->logger->warning(message: 'Skipping closure route during cache write.', context: [
                    'path' => $route->path,
                ]);
                continue;
            }

            $exportable[] = $route->toArray();
        }

        return $exportable;
    }

    /**
     * Synchronous fallback for write operation.
     */
    private function writeSync(string $cachePath, string $routesPath) : void
    {
        $directory = dirname($cachePath);

        $this->ensureDirectoryIsWritable(directory: $directory);

        $routeDefinitions = $this->router->allRoutes();
        $flattenedRoutes  = $this->flattenRoutes(routeDefinitions: $routeDefinitions);
        $exportable       = $this->prepareExportableRoutes(flattenedRoutes: $flattenedRoutes);

        if (empty($exportable)) {
            throw new RuntimeException(message: 'No cacheable routes available (closures are not cached).');
        }

        $exported = var_export($exportable, true);
        $hash     = sha1($exported);
        $content  = "<?php\n\n/** Auto-generated route cache [sha1: {$hash}]. Do not edit manually. */\n\nreturn {$exported};\n";

        $this->filesystem->put($cachePath, $content);

        $manifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);
        $manifest->writeTo(metadataPath: RouteCacheManifest::metadataPath(cachePath: $cachePath));

        // Write signature for immutable routing guarantees (v2.1 feature)
        $manifest->writeSignature(cachePath: $cachePath);
    }

    /**
     * Ensures directory is writable (sync fallback).
     */
    private function ensureDirectoryIsWritable(string $directory) : void
    {
        try {
            $this->filesystem->ensureDirectory($directory);
        } catch (FilesystemException) {
            throw new RuntimeException(message: "Cannot create route cache directory: {$directory}");
        }
    }
}
=== Cache/RouteCacheCompiler.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Cache;

use Avax\HTTP\Router\Support\RouteRegistry;
use JsonException;
use RuntimeException;

/**
 * A service responsible for compiling application routes into a single cache file.
 * This compiler improves performance by preloading all the route definitions
 * during runtime instead of dynamically loading them.
 *
 * Supports the serialization of Closure-based route actions using Laravel\SerializableClosure.
 */
final readonly class RouteCacheCompiler
{
    /**
     * Compiles route files from a specific directory into a unified PHP cache file.
     *
     * This process consists of discovering route definition files (`*.routes.php`),
     * invoking all buffered route builders, serializing binding logic, and finally
     * writing the compiled routes in a compact serialized format for subsequent execution.
     *
     * @param string $directory  The absolute path to the directory containing `*.routes.php` files.
     * @param string $outputFile The absolute file path where the compiled routes cache will be stored.
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function compile(string $directory, string $outputFile) : void
    {
        $routes = [];

        $locator  = new RouteFileLocator;
        $registry = new RouteRegistry;

        foreach ($locator->discover(baseDir: $directory) as $file) {
            $registry->scoped(closure: static function () use ($file, &$routes, $registry) : void {
                require $file->getPathname();

                $builders = $registry->flush();

                if (empty($builders)) {
                    return;
                }

                foreach ($builders as $builder) {
                    $route = $builder->build();

                    if ($route->usesClosure()) {
                        continue;
                    }

                    $routes[] = $route->toArray();
                }
            });
        }

        if (empty($routes)) {
            throw new RuntimeException(message: 'No routes were registered. Check your route files.');
        }

        $cacheContent = $this->generateCacheFileContent(routes: $routes);

        if (! file_put_contents(filename: $outputFile, data: $cacheContent)) {
            throw new RuntimeException(message: "Failed to write route cache to: {$outputFile}");
        }

        $manifest = RouteCacheManifest::buildFromDirectory(baseDir: $directory);
        $manifest->writeTo(metadataPath: RouteCacheManifest::metadataPath(cachePath: $outputFile));
    }

    /**
     * Generates the JSON content to be written in the cache file.
     *
     * Uses secure JSON format instead of PHP code to prevent code injection attacks.
     *
     * @param array $routes A list of route definition arrays.
     *
     * @return string The resultant JSON file's content as a string.
     */
    private function generateCacheFileContent(array $routes) : string
    {
        try {
            return json_encode($routes, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Failed to encode route cache as JSON.', previous: $exception);
        }
    }
}
=== Cache/RouteCacheLoader.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Cache;

use Avax\Contracts\FilesystemException;
use Avax\Filesystem\Contracts\FilesystemInterface;
use Avax\HTTP\Router\RouterRuntimeInterface;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Routing\RouterRegistrar;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;
use RuntimeException;

final readonly class RouteCacheLoader
{
    public function __construct(
        private RouterRegistrar        $registrar,
        private RouterRuntimeInterface $router,
        private FilesystemInterface    $filesystem,
        private LoggerInterface        $logger = new NullLogger,
    ) {}

    /**
     * Loads route definitions from JSON cache and registers them into the router.
     *
     * Uses secure JSON deserialization instead of PHP require() to prevent code injection attacks.
     *
     * @param string $cachePath
     * @param string $routesPath
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function load(string $cachePath, string $routesPath) : void
    {
        if (! $this->filesystem->exists(path: $cachePath)) {
            throw new RuntimeException(message: "Route cache file not found: {$cachePath}");
        }

        $metadataPath    = RouteCacheManifest::metadataPath(cachePath: $cachePath);
        $storedManifest  = RouteCacheManifest::fromFile(metadataPath: $metadataPath);
        $currentManifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);

        if ($storedManifest === null || ! $storedManifest->matches(other: $currentManifest)) {
            throw new RuntimeException(message: 'Route cache manifest mismatch; rebuild required.');
        }

        // Validate signature for immutable routing guarantees (v2.1 feature)
        if (! $storedManifest->validateSignatureFile(cachePath: $cachePath)) {
            $this->logger?->warning(message: 'Route cache signature validation failed. Cache may be compromised.', context: [
                'cache_path'  => $cachePath,
                'routes_path' => $routesPath,
            ]);
            throw new RuntimeException(message: 'Route cache signature validation failed. Cache integrity compromised.');
        }

        // Load routes from secure JSON format instead of PHP require()
        $cacheContent = $this->filesystem->get(path: $cachePath);

        try {
            /** @var array<array<string, mixed>> $routes */
            $routes = json_decode($cacheContent, true, 512, JSON_THROW_ON_ERROR);
        } catch (\JsonException $exception) {
            throw new RuntimeException(message: 'Invalid route cache JSON format.', previous: $exception);
        }

        if (! is_array(value: $routes)) {
            throw new RuntimeException(message: 'Invalid route cache: must be an array.');
        }

        foreach ($routes as $definition) {
            if (! is_array($definition)) {
                throw new RuntimeException(message: 'Invalid route in cache.');
            }

            $this->registrar->registerRouteFromCache(definition: RouteDefinition::fromArray(payload: $definition));
        }
    }

    /**
     * Writes the current route definitions to a secure JSON cache file.
     *
     * Uses JSON serialization instead of PHP code generation for security.
     *
     * @param string $cachePath
     * @param string $routesPath
     *
     * @throws \Avax\Contracts\FilesystemException
     */
    public function write(string $cachePath, string $routesPath) : void
    {
        $directory = dirname(path: $cachePath);

        $this->ensureDirectoryIsWritable(directory: $directory);

        $routeDefinitions = $this->router->allRoutes();

        $flattenedRoutes = $routeDefinitions === []
            ? []
            : array_merge(...array_values(array: $routeDefinitions));

        $exportable = [];
        foreach ($flattenedRoutes as $route) {
            if ($route->usesClosure()) {
                $this->logger->warning(message: 'Skipping closure route during cache write.', context: [
                    'path' => $route->path,
                ]);

                continue;
            }

            $exportable[] = $route->toArray();
        }

        if ($exportable === []) {
            throw new RuntimeException(message: 'No cacheable routes available (closures are not cached).');
        }

        // Write secure JSON format instead of PHP code
        try {
            $content = json_encode($exportable, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        } catch (\JsonException $exception) {
            throw new RuntimeException(message: 'Failed to encode route cache as JSON.', previous: $exception);
        }

        $this->filesystem->put(path: $cachePath, content: $content);

        $manifest = RouteCacheManifest::buildFromDirectory(baseDir: $routesPath);
        $manifest->writeTo(metadataPath: RouteCacheManifest::metadataPath(cachePath: $cachePath));

        // Write signature for immutable routing guarantees (v2.1 feature)
        $manifest->writeSignature(cachePath: $cachePath);
    }

    /**
     * Ensures the cache directory is writable.
     *
     *
     * @throws RuntimeException
     */
    private function ensureDirectoryIsWritable(string $directory) : void
    {
        try {
            $this->filesystem->ensureDirectory(path: $directory);
        } catch (FilesystemException) {
            throw new RuntimeException(message: "Cannot create route cache directory: {$directory}");
        }

        // Note: FilesystemInterface doesn't have isWritable check
        // Assuming ensureDirectory makes it writable, or this would need
        // to be handled by the implementation
    }
}
=== Cache/RouteCacheManifest.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Cache;

use JsonException;
use RuntimeException;

final readonly class RouteCacheManifest
{
    /** @param array<string, int> $files */
    private function __construct(
        private array  $files,
        private string $hash,
        private int    $generatedAt,
        private string $checksum
    ) {}

    public static function buildFromDirectory(string $baseDir) : self
    {
        $locator = new RouteFileLocator;
        $files   = [];

        foreach ($locator->discover(baseDir: $baseDir) as $file) {
            $files[$file->getPathname()] = $file->getMTime();
        }

        ksort($files);

        try {
            $hash     = sha1(string: json_encode($files, JSON_THROW_ON_ERROR));
            $checksum = hash('sha256', $hash . json_encode($files, JSON_THROW_ON_ERROR));
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Unable to serialize route metadata.', previous: $exception);
        }

        return new self(files: $files, hash: $hash, generatedAt: time(), checksum: $checksum);
    }

    public static function fromFile(string $metadataPath) : self|null
    {
        if (! is_file(filename: $metadataPath) || ! is_readable(filename: $metadataPath)) {
            return null;
        }

        try {
            /** @var array{files: array<string, int>, hash: string, generated_at: int, checksum?: string, manifest_hash?: string} $payload */
            $payload = json_decode(file_get_contents(filename: $metadataPath), true, 512, JSON_THROW_ON_ERROR);
        } catch (JsonException) {
            return null;
        }

        $manifest = new self(
            files      : $payload['files'] ?? [],
            hash       : $payload['hash'] ?? '',
            generatedAt: (int) ($payload['generated_at'] ?? 0),
            checksum   : $payload['checksum'] ?? ''
        );

        // Validate manifest integrity using stored hash
        if (isset($payload['manifest_hash'])) {
            $expectedHash = $manifest->generateManifestHash();
            if (! hash_equals($expectedHash, $payload['manifest_hash'])) {
                // Manifest has been tampered with
                return null;
            }
        }

        return $manifest;
    }

    public static function metadataPath(string $cachePath) : string
    {
        return "{$cachePath}.meta";
    }

    public function matches(self $other) : bool
    {
        // Check if this manifest is stale (generated before the other)
        if ($this->generatedAt < $other->generatedAt) {
            return false;
        }

        // Verify basic file integrity
        if ($this->hash !== $other->hash || $this->files !== $other->files) {
            return false;
        }

        // Verify checksum integrity if both have checksums
        if (! empty($this->checksum) && ! empty($other->checksum)) {
            return $this->checksum === $other->checksum;
        }

        // Fallback to basic comparison if checksums are missing (backward compatibility)
        return true;
    }

    public function writeTo(string $metadataPath) : void
    {
        $directory = dirname(path: $metadataPath);

        if (! is_dir(filename: $directory)) {
            mkdir(directory: $directory, permissions: 0777, recursive: true);
        }

        try {
            $data = $this->toArray();
            // Add SHA256 hash for trust boundary verification
            $data['manifest_hash'] = $this->generateManifestHash();

            file_put_contents(
                filename: $metadataPath,
                data    : json_encode(value: $data, flags: JSON_THROW_ON_ERROR)
            );
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Unable to write route cache metadata.', previous: $exception);
        }
    }

    /**
     * Generate SHA256 hash of the manifest data for integrity verification.
     */
    private function generateManifestHash() : string
    {
        $data = [
            'files'        => $this->files,
            'hash'         => $this->hash,
            'generated_at' => $this->generatedAt,
            'checksum'     => $this->checksum,
        ];

        try {
            return hash('sha256', json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES));
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Unable to generate manifest hash.', previous: $exception);
        }
    }

    /**
     * @return array<string, mixed>
     */
    public function toArray() : array
    {
        return [
            'files'        => $this->files,
            'hash'         => $this->hash,
            'generated_at' => $this->generatedAt,
            'checksum'     => $this->checksum,
            'signature'    => $this->signature(),
        ];
    }

    /**
     * Creates an immutable signature for route integrity validation.
     *
     * This signature ensures that route definitions haven't changed between
     * environments or deployments, preventing cache poisoning attacks and
     * ensuring semantic equivalence across deployments.
     */
    public function signature() : string
    {
        $data = [
            'files'        => $this->files,
            'hash'         => $this->hash,
            'generated_at' => $this->generatedAt,
            'checksum'     => $this->checksum,
            'version'      => '2.1', // Schema version for future compatibility
        ];

        try {
            $json = json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES);

            return hash('sha256', $json);
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Unable to generate route manifest signature.', previous: $exception);
        }
    }

    /**
     * Validates signature against another manifest.
     *
     * Used to ensure immutable routing guarantees across environments.
     */
    public function validateSignature(self $other) : bool
    {
        return $this->signature() === $other->signature();
    }

    /**
     * Writes signature to a separate .sig file for integrity verification.
     */
    public function writeSignature(string $cachePath) : void
    {
        $signaturePath = $this->signaturePath(cachePath: $cachePath);
        $directory     = dirname(path: $signaturePath);

        if (! is_dir(filename: $directory)) {
            mkdir(directory: $directory, permissions: 0777, recursive: true);
        }

        file_put_contents(
            filename: $signaturePath,
            data    : $this->signature() . "\n"
        );
    }

    /**
     * Gets the signature file path for a cache file.
     */
    private function signaturePath(string $cachePath) : string
    {
        return "{$cachePath}.sig";
    }

    /**
     * Validates signature from .sig file.
     */
    public function validateSignatureFile(string $cachePath) : bool
    {
        $signaturePath = $this->signaturePath(cachePath: $cachePath);

        if (! is_file(filename: $signaturePath) || ! is_readable(filename: $signaturePath)) {
            return false; // No signature file = invalid
        }

        $storedSignature = trim(file_get_contents(filename: $signaturePath));

        return $this->signature() === $storedSignature;
    }

    /**
     * Generate hash for a RouteDefinition for change detection.
     *
     * Used to determine if route serialization can be skipped when
     * the route hasn't changed since last cache generation.
     */
    public function getRouteHash(\Avax\HTTP\Router\Routing\RouteDefinition $route) : string
    {
        $routeData = $route->toArray();

        // Remove runtime-specific fields that don't affect route logic
        unset($routeData['metadata']); // Metadata can change without affecting routing

        try {
            return hash('sha256', json_encode($routeData, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES));
        } catch (\JsonException $exception) {
            throw new \RuntimeException('Unable to generate route hash.', 0, $exception);
        }
    }
}
=== Cache/RouteFileLocator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Cache;

use FilesystemIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;

final class RouteFileLocator
{
    /** @return list<SplFileInfo> */
    public function discover(string $baseDir) : array
    {
        if (! is_dir(filename: $baseDir) || ! is_readable(filename: $baseDir)) {
            throw new RuntimeException(message: "Routes directory '{$baseDir}' is not accessible.");
        }

        $iterator = new RecursiveIteratorIterator(
            iterator: new RecursiveDirectoryIterator(
                directory: $baseDir,
                flags    : FilesystemIterator::SKIP_DOTS
            )
        );

        $files = array_filter(
            array   : iterator_to_array(iterator: $iterator),
            callback: static fn(SplFileInfo $file) : bool => $file->isFile()
                && $file->isReadable()
                && preg_match(
                    pattern: '/\.routes\.php$|^routes\.php$/',
                    subject: $file->getFilename()
                )
        );

        return array_values(array: $files);
    }
}

=== Exceptions/UnresolvableMiddlewareException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Exceptions;

use RuntimeException;

/**
 * This exception is thrown when middleware cannot be resolved.
 *
 *
 * @see     RuntimeException
 *
 * Typical use case:
 * - This exception may be thrown during runtime when middleware identified
 *   by name, configuration, or parameters cannot be instantiated or located.
 *
 * Design Considerations:
 * - This is part of the overall exception hierarchy, promoting better error
 *   differentiation and allowing targeted exception handling.
 */
class UnresolvableMiddlewareException extends RuntimeException
{
    // This class does not currently declare any properties or methods of its own.
    // It serves as a lightweight way to provide a specific exception type
    // for middleware resolution issues while retaining other features of RuntimeException.
}

=== HttpMethod.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router;

/**
 * Enum representing HTTP methods.
 *
 * This provides a type-safe representation of allowed HTTP methods
 * for routing and validation purposes.
 */
enum HttpMethod : string
{
    case GET = 'GET';

    case POST = 'POST';

    case PUT = 'PUT';

    case DELETE = 'DELETE';

    case PATCH = 'PATCH';

    case OPTIONS = 'OPTIONS';

    case HEAD = 'HEAD';
    case ANY  = 'ANY';

    /**
     * Validates if a given string matches a valid HTTP method.
     *
     * @param string $method The HTTP method to validate.
     *
     * @return bool True if valid, false otherwise.
     */
    public static function isValid(string $method) : bool
    {
        return in_array(needle: strtoupper(string: $method), haystack: array_column(array: self::cases(), column_key: 'value'), strict: true);
    }

    /**
     * Returns a list of all HTTP methods as strings.
     *
     * @return array<string>
     */
    public static function list() : array
    {
        return array_map(callback: static fn(self $method) => $method->value, array: self::cases());
    }
}

=== Kernel/RouterKernel.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Kernel;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteExecutor;
use Avax\HTTP\Router\Routing\RoutePipelineFactory;
use Avax\HTTP\Router\Support\HeadRequestFallback;
use Avax\HTTP\Router\Support\RouteRequestInjector;
use Avax\HTTP\Router\Tracing\RouterTrace;
use Psr\Http\Message\ResponseInterface;

/**
 * Class RouterKernel
 *
 * This class is the main entry point of the router kernel, providing a clean,
 * domain-oriented design for HTTP request handling. It resolves routes,
 * applies middleware, and dispatches the request pipeline to produce an HTTP response.
 *
 * The class is marked as `readonly` to ensure that injected dependencies
 * and their state remain immutable, strictly adhering to DDD principles.
 */
final readonly class RouterKernel
{
    /**
     * Constructor initializes the core dependencies for the routing kernel.
     *
     * @param HttpRequestRouter    $httpRequestRouter   Responsible for resolving HTTP routes.
     * @param RoutePipelineFactory $pipelineFactory     Creates pipelines to process route handling.
     * @param HeadRequestFallback  $headRequestFallback Provides fallback processing for HEAD requests.
     * @param RouterTrace|null     $trace               Optional trace instance for debugging and profiling.
     */
    public function __construct(
        private HttpRequestRouter    $httpRequestRouter,
        private RoutePipelineFactory $pipelineFactory,
        private HeadRequestFallback  $headRequestFallback,
        private RouteExecutor        $routeExecutor,
        private RouterTrace|null     $trace = null
    ) {}

    /**
     * Handles an incoming HTTP request by resolving the corresponding route,
     * applying middleware, and processing the pipeline.
     *
     * Provides comprehensive tracing for debugging and profiling.
     *
     * @param Request $request The HTTP request to be processed.
     *
     * @return ResponseInterface The HTTP response produced after processing.
     *
     * @throws \ReflectionException Signals issues with runtime reflection in the pipeline processing.
     * @throws \Psr\Container\ContainerExceptionInterface Indicates a container-related error occurred.
     * @throws \Psr\Container\NotFoundExceptionInterface Indicates a requested service was not found.
     * @throws \Avax\HTTP\Router\Validation\Exceptions\InvalidConstraintException
     */
    public function handle(Request $request) : ResponseInterface
    {
        $startTime = microtime(true);
        $method    = $request->getMethod();
        $path      = $request->getUri()->getPath();

        // Trace: Request resolution started
        $this->trace?->log('kernel.resolve.start', [
            'method' => $method,
            'path'   => $path,
            'host'   => $request->getUri()->getHost(),
        ]);

        try {
            // Apply fallback logic for HEAD requests, converting them to GET if needed.
            $request = $this->headRequestFallback->resolve(request: $request);

            // Resolve the current request into structured resolution context.
            $resolutionContext = $this->httpRequestRouter->resolve(request: $request);

            // Extract route from resolution context
            $route = $resolutionContext->route;

            // Trace: Route matched successfully
            $this->trace?->log('kernel.route.matched', [
                'route'     => $route->name ?? $route->path,
                'method'    => $route->method,
                'path'      => $route->path,
                'domain'    => $route->domain,
                'duration'  => round((microtime(true) - $startTime) * 1000, 2) . 'ms',
            ]);

            // Inject route parameters from resolution context into the request as attributes.
            $request = RouteRequestInjector::injectWithContext(
                request   : $request,
                route     : $route,
                parameters: $resolutionContext->parameters
            );

            // Create a middleware pipeline based on the resolved route.
            $pipeline = $this->pipelineFactory->create(route: $route);

            // Process the pipeline and dispatch the final response.
            $response = $pipeline->dispatch(request: $request);

            // Trace: Request handled successfully
            $this->trace?->log('kernel.request.complete', [
                'route'    => $route->name ?? $route->path,
                'status'   => $response->getStatusCode(),
                'duration' => round((microtime(true) - $startTime) * 1000, 2) . 'ms',
            ]);

            return $response;

        } catch (\Throwable $exception) {
            // Trace: Request failed with fallback or error
            $this->trace?->log('kernel.request.failed', [
                'method'    => $method,
                'path'      => $path,
                'exception' => get_class($exception),
                'message'   => $exception->getMessage(),
                'duration'  => round((microtime(true) - $startTime) * 1000, 2) . 'ms',
            ]);

            // Check if this is a routing exception that should trigger fallback
            if ($exception instanceof \Avax\HTTP\Router\Routing\Exceptions\RouteNotFoundException ||
                $exception instanceof \Avax\HTTP\Router\Routing\Exceptions\MethodNotAllowedException) {

                $this->trace?->log('kernel.fallback.triggered', [
                    'reason'   => get_class($exception),
                    'message'  => $exception->getMessage(),
                ]);

                // Re-throw to let Router handle fallback
                throw $exception;
            }

            // Re-throw other exceptions
            throw $exception;
        }
    }
}
=== Matching/RouteMatcherInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Matching;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\RouteDefinition;

/**
 * Strategy pattern interface for route matching algorithms.
 *
 * Enables pluggable matching strategies:
 * - DomainAwareMatcher: Host/domain constraint validation
 * - TrieMatcher: Efficient prefix tree matching
 * - RegexMatcher: Full regex pattern matching
 * - HybridMatcher: Combination strategies
 */
interface RouteMatcherInterface
{
    /**
     * Matches a request against registered routes.
     *
     * @param array<string, array<string, RouteDefinition>> $routes  Routes grouped by HTTP method and path
     * @param Request                                       $request The incoming HTTP request
     *
     * @return array{RouteDefinition, array<string, string>}|null
     *         Returns [route, parameters] or null if no match
     */
    public function match(array $routes, Request $request) : array|null;
}
=== Matching/RouteMatcherRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Matching;

use Avax\HTTP\Router\Routing\DomainAwareMatcher;
use Avax\HTTP\Router\Routing\RouteMatcher;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;
use Stringable;

/**
 * Registry for pluggable route matching strategies.
 *
 * Enables enterprise flexibility by allowing different matching algorithms:
 * - 'domain': DomainAwareMatcher (default) - validates host/domain constraints
 * - 'trie': TrieMatcher - efficient prefix tree for high-volume routing
 * - 'regex': RegexMatcher - full regex pattern matching
 * - 'hybrid': HybridMatcher - combines multiple strategies
 *
 * Usage:
 * $registry = new RouteMatcherRegistry();
 * $registry->register('custom', new CustomMatcher());
 * $router->setMatcher($registry->get('custom'));
 */
final class RouteMatcherRegistry
{
    /** @var array<string, RouteMatcherInterface> */
    private array $matchers = [];

    /**
     * Creates a registry with default matchers pre-registered.
     */
    public static function withDefaults(LoggerInterface|null $logger = null) : self
    {
        $registry = new self();

        // Use NullLogger if no logger provided
        $logger ??= new class implements LoggerInterface {
            public function emergency(string|Stringable $message, array $context = []) : void {}

            public function alert(string|Stringable $message, array $context = []) : void {}

            public function critical(string|Stringable $message, array $context = []) : void {}

            public function error(string|Stringable $message, array $context = []) : void {}

            public function warning(string|Stringable $message, array $context = []) : void {}

            public function notice(string|Stringable $message, array $context = []) : void {}

            public function info(string|Stringable $message, array $context = []) : void {}

            public function debug(string|Stringable $message, array $context = []) : void {}

            public function log($level, string|Stringable $message, array $context = []) : void {}
        };

        // Register default matchers
        $registry->register(key: 'domain', matcher: new DomainAwareMatcher(
            baseMatcher: new RouteMatcher(logger: $logger)
        ));

        // Additional matchers can be registered here as they are implemented
        // $registry->register('trie', new TrieMatcher());
        // $registry->register('regex', new RegexMatcher());

        return $registry;
    }

    /**
     * Registers a matcher strategy with a unique key.
     */
    public function register(string $key, RouteMatcherInterface $matcher) : void
    {
        $this->matchers[$key] = $matcher;
    }

    /**
     * Retrieves a registered matcher by key.
     *
     * @throws InvalidArgumentException If matcher key is not registered
     */
    public function get(string $key) : RouteMatcherInterface
    {
        if (! isset($this->matchers[$key])) {
            throw new InvalidArgumentException(message: "Route matcher '{$key}' is not registered. Available: " . implode(', ', array_keys($this->matchers)));
        }

        return $this->matchers[$key];
    }

    /**
     * Checks if a matcher key is registered.
     */
    public function has(string $key) : bool
    {
        return isset($this->matchers[$key]);
    }

    /**
     * Returns all registered matcher keys.
     *
     * @return string[]
     */
    public function keys() : array
    {
        return array_keys($this->matchers);
    }

    /**
     * Removes a registered matcher.
     */
    public function unregister(string $key) : void
    {
        unset($this->matchers[$key]);
    }

    /**
     * Clears all registered matchers.
     */
    public function clear() : void
    {
        $this->matchers = [];
    }

    /**
     * Gets the number of registered matchers.
     */
    public function count() : int
    {
        return count($this->matchers);
    }
}
=== Metrics/RouterMetricsCollector.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Metrics;

/**
 * Router metrics collector with integrated alert thresholds.
 *
 * Collects comprehensive routing metrics and provides alert integration
 * for proactive monitoring of router performance and reliability.
 */
final class RouterMetricsCollector
{
    private array $metrics = [];
    private array $alertThresholds;

    public function __construct(array $alertConfig = [])
    {
        $this->alertThresholds = array_merge([
            'route_resolution_failures' => [
                'warning' => 10,    // failures per minute
                'critical' => 50,   // failures per minute
                'window' => 60,     // seconds
            ],
            'cache_invalidations' => [
                'warning' => 5,     // invalidations per minute
                'critical' => 20,   // invalidations per minute
                'window' => 60,     // seconds
            ],
            'route_resolution_time' => [
                'warning' => 100,   // milliseconds
                'critical' => 500,  // milliseconds
            ],
            'concurrent_requests' => [
                'warning' => 100,   // concurrent requests
                'critical' => 500,  // concurrent requests
            ],
        ], $alertConfig);
    }

    /**
     * Record a successful route resolution.
     */
    public function recordRouteResolution(
        string $method,
        string $path,
        float $durationMs,
        int $statusCode = 200
    ): void {
        $this->increment('route_resolutions_total', ['method' => $method, 'status' => $statusCode]);
        $this->observe('route_resolution_duration', $durationMs, ['method' => $method]);
        $this->setGauge('route_last_resolution_time', microtime(true));
    }

    /**
     * Record a route resolution failure.
     */
    public function recordRouteResolutionFailure(
        string $method,
        string $path,
        string $failureReason,
        float $durationMs
    ): void {
        $this->increment('route_resolution_failures_total', [
            'method' => $method,
            'reason' => $failureReason
        ]);
        $this->observe('route_resolution_duration', $durationMs, ['method' => $method, 'failed' => 'true']);
    }

    /**
     * Record cache operation metrics.
     */
    public function recordCacheOperation(
        string $operation, // 'hit', 'miss', 'write', 'invalidate'
        string $cacheType = 'routes',
        float $durationMs = 0.0
    ): void {
        $this->increment('cache_operations_total', [
            'operation' => $operation,
            'type' => $cacheType
        ]);

        if ($durationMs > 0) {
            $this->observe('cache_operation_duration', $durationMs, [
                'operation' => $operation,
                'type' => $cacheType
            ]);
        }

        if ($operation === 'invalidate') {
            $this->increment('cache_invalidations_total', ['type' => $cacheType]);
        }
    }

    /**
     * Record middleware execution metrics.
     */
    public function recordMiddlewareExecution(
        string $middlewareClass,
        float $durationMs,
        bool $passed = true
    ): void {
        $this->increment('middleware_executions_total', [
            'middleware' => $middlewareClass,
            'result' => $passed ? 'passed' : 'failed'
        ]);
        $this->observe('middleware_execution_duration', $durationMs, ['middleware' => $middlewareClass]);
    }

    /**
     * Record concurrent request metrics.
     */
    public function recordConcurrentRequests(int $count): void {
        $this->setGauge('concurrent_requests', $count);
    }

    /**
     * Get all current metrics for export.
     */
    public function getMetrics(): array
    {
        return $this->metrics;
    }

    /**
     * Export metrics in Prometheus format.
     */
    public function exportPrometheus(): string
    {
        $output = '';

        foreach ($this->metrics as $name => $metric) {
            $output .= $this->formatPrometheusMetric($name, $metric);
        }

        return $output;
    }

    /**
     * Check if any alert thresholds are exceeded.
     *
     * @return array<string, array{level: string, value: float|int, threshold: int|float, description: string}>
     */
    public function checkAlerts(): array
    {
        $alerts = [];

        // Check route resolution failures
        $failures = $this->getCounterValue('route_resolution_failures_total', 60); // per minute
        if ($failures >= $this->alertThresholds['route_resolution_failures']['critical']) {
            $alerts['route_resolution_failures'] = [
                'level' => 'critical',
                'value' => $failures,
                'threshold' => $this->alertThresholds['route_resolution_failures']['critical'],
                'description' => 'High rate of route resolution failures'
            ];
        } elseif ($failures >= $this->alertThresholds['route_resolution_failures']['warning']) {
            $alerts['route_resolution_failures'] = [
                'level' => 'warning',
                'value' => $failures,
                'threshold' => $this->alertThresholds['route_resolution_failures']['warning'],
                'description' => 'Elevated route resolution failures'
            ];
        }

        // Check cache invalidations
        $invalidations = $this->getCounterValue('cache_invalidations_total', 60);
        if ($invalidations >= $this->alertThresholds['cache_invalidations']['critical']) {
            $alerts['cache_invalidations'] = [
                'level' => 'critical',
                'value' => $invalidations,
                'threshold' => $this->alertThresholds['cache_invalidations']['critical'],
                'description' => 'High rate of cache invalidations'
            ];
        } elseif ($invalidations >= $this->alertThresholds['cache_invalidations']['warning']) {
            $alerts['cache_invalidations'] = [
                'level' => 'warning',
                'value' => $invalidations,
                'threshold' => $this->alertThresholds['cache_invalidations']['warning'],
                'description' => 'Elevated cache invalidations'
            ];
        }

        // Check route resolution time (95th percentile)
        $resolutionTime = $this->getPercentile('route_resolution_duration', 95);
        if ($resolutionTime >= $this->alertThresholds['route_resolution_time']['critical']) {
            $alerts['route_resolution_time'] = [
                'level' => 'critical',
                'value' => $resolutionTime,
                'threshold' => $this->alertThresholds['route_resolution_time']['critical'],
                'description' => 'Route resolution time too high'
            ];
        } elseif ($resolutionTime >= $this->alertThresholds['route_resolution_time']['warning']) {
            $alerts['route_resolution_time'] = [
                'level' => 'warning',
                'value' => $resolutionTime,
                'threshold' => $this->alertThresholds['route_resolution_time']['warning'],
                'description' => 'Route resolution time elevated'
            ];
        }

        // Check concurrent requests
        $concurrent = $this->getGaugeValue('concurrent_requests');
        if ($concurrent >= $this->alertThresholds['concurrent_requests']['critical']) {
            $alerts['concurrent_requests'] = [
                'level' => 'critical',
                'value' => $concurrent,
                'threshold' => $this->alertThresholds['concurrent_requests']['critical'],
                'description' => 'Too many concurrent requests'
            ];
        } elseif ($concurrent >= $this->alertThresholds['concurrent_requests']['warning']) {
            $alerts['concurrent_requests'] = [
                'level' => 'warning',
                'value' => $concurrent,
                'threshold' => $this->alertThresholds['concurrent_requests']['warning'],
                'description' => 'High concurrent request load'
            ];
        }

        return $alerts;
    }

    /**
     * Reset all metrics (for testing).
     */
    public function reset(): void {
        $this->metrics = [];
    }

    // Internal metric collection methods

    private function increment(string $name, array $labels = []): void {
        $key = $this->metricKey($name, $labels);
        $this->metrics[$key]['value'] = ($this->metrics[$key]['value'] ?? 0) + 1;
        $this->metrics[$key]['type'] = 'counter';
        $this->metrics[$key]['name'] = $name;
        $this->metrics[$key]['labels'] = $labels;
        $this->metrics[$key]['timestamp'] = microtime(true);
    }

    private function observe(string $name, float $value, array $labels = []): void {
        $key = $this->metricKey($name, $labels);

        if (!isset($this->metrics[$key]['values'])) {
            $this->metrics[$key]['values'] = [];
        }

        $this->metrics[$key]['values'][] = $value;
        $this->metrics[$key]['type'] = 'histogram';
        $this->metrics[$key]['name'] = $name;
        $this->metrics[$key]['labels'] = $labels;
    }

    private function setGauge(string $name, float $value, array $labels = []): void {
        $key = $this->metricKey($name, $labels);
        $this->metrics[$key]['value'] = $value;
        $this->metrics[$key]['type'] = 'gauge';
        $this->metrics[$key]['name'] = $name;
        $this->metrics[$key]['labels'] = $labels;
        $this->metrics[$key]['timestamp'] = microtime(true);
    }

    private function metricKey(string $name, array $labels): string {
        ksort($labels);
        return $name . '_' . md5(json_encode($labels));
    }

    private function formatPrometheusMetric(string $key, array $metric): string {
        $output = '';

        $labels = '';
        if (!empty($metric['labels'])) {
            $labelParts = [];
            foreach ($metric['labels'] as $k => $v) {
                $labelParts[] = $k . '="' . addslashes((string)$v) . '"';
            }
            $labels = '{' . implode(',', $labelParts) . '}';
        }

        if ($metric['type'] === 'counter') {
            $output .= "# HELP {$metric['name']} Counter metric\n";
            $output .= "# TYPE {$metric['name']} counter\n";
            $output .= "{$metric['name']}{$labels} {$metric['value']}\n";
        } elseif ($metric['type'] === 'gauge') {
            $output .= "# HELP {$metric['name']} Gauge metric\n";
            $output .= "# TYPE {$metric['name']} gauge\n";
            $output .= "{$metric['name']}{$labels} {$metric['value']}\n";
        } elseif ($metric['type'] === 'histogram') {
            $output .= "# HELP {$metric['name']} Histogram metric\n";
            $output .= "# TYPE {$metric['name']} histogram\n";

            // Calculate percentiles
            if (!empty($metric['values'])) {
                sort($metric['values']);
                $count = count($metric['values']);
                $p50 = $metric['values'][(int)($count * 0.5)] ?? 0;
                $p95 = $metric['values'][(int)($count * 0.95)] ?? 0;
                $p99 = $metric['values'][(int)($count * 0.99)] ?? 0;

                $output .= "{$metric['name']}_count{$labels} {$count}\n";
                $output .= "{$metric['name']}{quantile=\"0.5\"{$labels}} {$p50}\n";
                $output .= "{$metric['name']}{quantile=\"0.95\"{$labels}} {$p95}\n";
                $output .= "{$metric['name']}{quantile=\"0.99\"{$labels}} {$p99}\n";
            }
        }

        return $output;
    }

    private function getCounterValue(string $name, int $windowSeconds = 60): int {
        $total = 0;
        $cutoff = microtime(true) - $windowSeconds;

        foreach ($this->metrics as $metric) {
            if (($metric['name'] ?? '') === $name &&
                ($metric['timestamp'] ?? 0) >= $cutoff) {
                $total += $metric['value'] ?? 0;
            }
        }

        return $total;
    }

    private function getPercentile(string $name, float $percentile): float {
        $values = [];

        foreach ($this->metrics as $metric) {
            if (($metric['name'] ?? '') === $name && isset($metric['values'])) {
                $values = array_merge($values, $metric['values']);
            }
        }

        if (empty($values)) {
            return 0.0;
        }

        sort($values);
        $index = (int)(count($values) * ($percentile / 100));

        return $values[$index] ?? end($values);
    }

    private function getGaugeValue(string $name): float {
        foreach ($this->metrics as $metric) {
            if (($metric['name'] ?? '') === $name && $metric['type'] === 'gauge') {
                return $metric['value'] ?? 0.0;
            }
        }

        return 0.0;
    }
}
=== Router.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router;

/**
 * @phpstan-type RouterConfig array{
 *     httpRouter: \Avax\HTTP\Router\Routing\HttpRequestRouter,
 *     kernel: \Avax\HTTP\Router\Kernel\RouterKernel,
 *     fallbackManager: \Avax\HTTP\Router\Support\FallbackManager,
 *     errorFactory: \Avax\HTTP\Router\Routing\ErrorResponseFactory,
 *     dslRouter?: \Avax\HTTP\Router\RouterInterface,
 *     groupStack?: \Avax\HTTP\Router\Routing\RouteGroupStack,
 *     routeRegistry?: \Avax\HTTP\Router\Support\RouteRegistry
 * }
 */

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Kernel\RouterKernel;
use Avax\HTTP\Router\Routing\ErrorResponseFactory;
use Avax\HTTP\Router\Routing\Exceptions\MethodNotAllowedException;
use Avax\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Routing\RouteGroupStack;
use Avax\HTTP\Router\Support\FallbackManager;
use Avax\HTTP\Router\Support\RouteRegistry;
use Avax\HTTP\Router\Tracing\RouterTrace;
use LogicException;
use Psr\Http\Message\ResponseInterface;

/**
 * Public API Contract: Runtime Router
 *
 * BC GUARANTEED: Core runtime interface for request resolution and error handling.
 *
 * Runtime router responsible for handling requests and delegating to the kernel.
 * Registration and DSL logic now live in {@see RouterDsl}, keeping this class focused on execution.
 *
 * @api
 */
final readonly class Router implements RouterRuntimeInterface
{
    public function __construct(
        private HttpRequestRouter    $httpRequestRouter,
        private RouterKernel         $kernel,
        private FallbackManager      $fallbackManager,
        private ErrorResponseFactory $errorFactory,
        private RouterInterface|null $dslRouter = null,
        private RouteGroupStack|null $groupStack = null,
        private RouteRegistry|null   $routeRegistry = null
    ) {}

    public function resolve(Request $request) : ResponseInterface
    {
        try {
            return $this->kernel->handle(request: $request);
        } catch (RouteNotFoundException $exception) {
            if ($this->fallbackManager->has()) {
                return $this->fallbackManager->invoke(request: $request);
            }

            return $this->errorFactory->createNotFoundResponse(method: $request->getMethod(), path: $request->getUri()->getPath());
        } catch (MethodNotAllowedException $exception) {
            return $this->errorFactory->createMethodNotAllowedResponse(
                method        : $request->getMethod(),
                path          : $request->getUri()->getPath(),
                allowedMethods: $exception->getAllowedMethods()
            );
        }
    }

    public function getRouteByName(string $name) : RouteDefinition
    {
        return $this->httpRequestRouter->getByName(name: $name);
    }

    /**
     * Dumps the registered routes map for diagnostics.
     *
     * @return array<string, RouteDefinition[]> The route map grouped by method.
     */
    public function dumpMap() : array
    {
        return $this->httpRequestRouter->allRoutes();
    }

    public function allRoutes() : array
    {
        return $this->httpRequestRouter->allRoutes();
    }

    /**
     * Gets the current trace data for debugging and profiling.
     *
     * Returns null if tracing is not enabled.
     */
    public function getTrace() : RouterTrace|null
    {
        return $this->httpRequestRouter->getTrace();
    }

    /**
     * Load routes with proper registry scoping (DSL facade).
     *
     * Human-grade DSL method that encapsulates the complex registry scoping
     * logic into a simple, readable API. This facade method provides the primary
     * entry point for route loading operations in the application.
     *
     * USAGE:
     * ```php
     * $router = new Router($httpRouter, $kernel, $fallbackManager, $errorFactory, $dslRouter, $groupStack, $registry);
     * $router->loadRoutes($routesPath, $cacheDir);
     * ```
     *
     * INTERNAL FLOW:
     * 1. Validates required dependencies (DSL router and group stack)
     * 2. Creates registry scoped closure for isolation
     * 3. Instantiates RouteRegistrar within scope for loading
     * 4. Delegates to RouteRegistrar::load() for actual file processing
     * 5. Handles route registration and cleanup automatically
     *
     * @param string $routesPath Path to the routes file
     * @param string $cacheDir   Cache directory for compiled routes (optional)
     *
     * @return void
     * @throws \LogicException|\Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException If DSL router or group
     *                                                                                         stack dependencies are
     *                                                                                         missing
     */
    public function loadRoutes(string $routesPath, string $cacheDir = '') : void
    {
        if ($this->dslRouter === null || $this->groupStack === null) {
            throw new LogicException(
                message: 'Router must be constructed with DSL router and group stack dependencies to use loadRoutes()'
            );
        }

        $registry = $this->routeRegistry ?? new RouteRegistry;

        $registry->scoped(callback: function () use ($registry, $routesPath, $cacheDir) : void {
            $registrar = new Bootstrap\RouteRegistrar(
                dslRouter    : $this->dslRouter,
                httpRouter   : $this->httpRequestRouter,
                groupStack   : $this->groupStack,
                routeRegistry: $registry
            );

            $registrar->load(path: $routesPath, cacheDir: $cacheDir);
        });
    }
}
=== RouterDsl.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router;

use Avax\HTTP\Dispatcher\ControllerDispatcher;
use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\AttributeRouteRegistrar;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteBuilder;
use Avax\HTTP\Router\Routing\RouteGroupAttributesConfigurator;
use Avax\HTTP\Router\Routing\RouteGroupContext;
use Avax\HTTP\Router\Routing\RouteGroupStack;
use Avax\HTTP\Router\Routing\RouteRegistrarProxy;
use Avax\HTTP\Router\Routing\RouterRegistrar;
use Avax\HTTP\Router\Support\FallbackManager;
use Avax\HTTP\Router\Support\RouteCollector;
use Avax\HTTP\Router\Support\RouteRegistry;
use Closure;
use LogicException;

/**
 * Router DSL surface responsible for defining routes and fallbacks.
 *
 * This class keeps all registration logic isolated from the runtime router.
 */
final readonly class RouterDsl implements RouterInterface
{
    public function __construct(
        private RouterRegistrar      $registrar,
        private HttpRequestRouter    $router,
        private ControllerDispatcher $controllerDispatcher,
        private FallbackManager      $fallbackManager,
        private RouteGroupStack      $groupStack,
        private RouteRegistry        $registry,
    ) {}

    public function get(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::GET->value, path: $path, action: $action);
    }

    private function register(string $method, string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        $builder = RouteBuilder::make(method: $method, path: $path);
        $builder->action(action: $action);

        // Apply current group context (prefixes, middleware, etc.)
        $builder = $this->groupStack->applyTo(builder: $builder);

        return new RouteRegistrarProxy(
            router  : $this->router,
            builder : $builder,
            registry: $this->registry
        );
    }

    public function post(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::POST->value, path: $path, action: $action);
    }

    public function put(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::PUT->value, path: $path, action: $action);
    }

    public function patch(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::PATCH->value, path: $path, action: $action);
    }

    public function delete(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::DELETE->value, path: $path, action: $action);
    }

    public function options(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::OPTIONS->value, path: $path, action: $action);
    }

    public function head(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::HEAD->value, path: $path, action: $action);
    }

    public function any(string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        return $this->register(method: HttpMethod::ANY->value, path: $path, action: $action);
    }

    public function anyExpanded(string $path, callable|array|string $action) : array
    {
        $proxies = [];

        foreach (HttpMethod::cases() as $method) {
            // Skip ANY method in expanded version
            if ($method !== HttpMethod::ANY) {
                $proxies[] = $this->register(method: $method->value, path: $path, action: $action);
            }
        }

        return $proxies;
    }

    public function fallback(callable|array|string $handler) : void
    {
        $callable = is_callable(value: $handler)
            ? $handler
            : fn(Request $request) => $this->controllerDispatcher->dispatch(action: $handler, request: $request);

        // Unified fallback handling through FallbackManager only
        $this->fallbackManager->set(handler: $callable);

        // Set in registry for DSL execution (used during route file loading)
        $this->registry->setFallback(handler: $callable);
    }

    public function registerAttributes(object|string $controller) : void
    {
        (new AttributeRouteRegistrar(router: $this->router))->register(controller: $controller);
    }

    public function name(string $prefix) : self
    {
        $context = $this->groupStack->current();

        if ($context === null) {
            throw new LogicException(message: 'Cannot call ->name() outside of a route group context.');
        }

        $context->setNamePrefix(prefix: $prefix);

        return $this;
    }

    public function domain(string $domain) : self
    {
        $this->groupStack->current()?->setDomain(domain: $domain);

        return $this;
    }

    public function authorize(string $policy) : self
    {
        $this->groupStack->current()?->setAuthorization(authorization: $policy);

        return $this;
    }

    public function group(array $attributes, Closure $callback) : void
    {
        $context = new RouteGroupContext;

        (new RouteGroupAttributesConfigurator)->apply(
            attributes: $attributes,
            context   : $context
        );

        $this->groupStack->push(group: $context);

        try {
            $callback($this);
        } finally {
            $this->groupStack->pop();
        }
    }

    public function prefix(string $prefix) : self
    {
        $this->groupStack->current()?->setPrefix(prefix: $prefix);

        return $this;
    }

    public function middleware(array $middleware) : self
    {
        $this->groupStack->current()?->addMiddleware(middleware: $middleware);

        return $this;
    }

    public function where(array $constraints) : self
    {
        $this->groupStack->current()?->addConstraints(constraints: $constraints);

        return $this;
    }

    public function defaults(array $defaults) : self
    {
        $this->groupStack->current()?->addDefaults(defaults: $defaults);

        return $this;
    }

    public function attributes(array $attributes) : self
    {
        $this->groupStack->current()?->addAttributes(attributes: $attributes);

        return $this;
    }
}
=== RouterInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router;

use Avax\HTTP\Router\Routing\RouteRegistrarProxy;

/**
 * Public API Contract: Router DSL Interface
 *
 * BC GUARANTEED: This interface defines the stable, public API for route registration.
 * All methods are guaranteed to be backward compatible in future versions.
 *
 * Provides a contract for a router implementation that exposes the DSL helpers.
 *
 * @api
 */
interface RouterInterface
{
    /**
     * Registers a GET route.
     *
     * @param string                $path      The URL path for the route.
     * @param callable|array|string $action    The action to be called when the route matches.
     *                                         Can be a callable, an array (e.g., controller and method), or a string
     *                                         (e.g., controller@method).
     *
     * @return RouteRegistrarProxy Returns a proxy for chaining extra route configurations.
     */
    public function get(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a POST route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be handled when the route matches.
     *
     * @return RouteRegistrarProxy A proxy for fluent method chaining.
     */
    public function post(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a PUT route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be executed on matching the route.
     *
     * @return RouteRegistrarProxy A proxy object for fluent route customization.
     */
    public function put(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a PATCH route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be processed when the route matches.
     *
     * @return RouteRegistrarProxy Returns a proxy for additional route configuration.
     */
    public function patch(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a DELETE route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be applied when the route matches.
     *
     * @return RouteRegistrarProxy A proxy object for chaining route details.
     */
    public function delete(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers an OPTIONS route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action handling the route on match.
     *
     * @return RouteRegistrarProxy RouteRegistrarProxy for additional route setups.
     */
    public function options(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers a HEAD route.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action performed when the route matches.
     *
     * @return RouteRegistrarProxy An object for further configuration of the route.
     */
    public function head(string $path, callable|array|string $action) : RouteRegistrarProxy;

    /**
     * Registers the same action for all HTTP methods.
     *
     * @param string                $path   The URL path for the route.
     * @param callable|array|string $action The action to be executed for any HTTP method.
     *
     * @return RouteRegistrarProxy[] Array of proxies, each corresponding to the registered method.
     */
    public function any(string $path, callable|array|string $action) : RouteRegistrarProxy;

    public function anyExpanded(string $path, callable|array|string $action) : array;

    /**
     * Sets a fallback route to be executed if no other routes match.
     *
     * @param callable|array|string $handler The fallback handler to be called when no route matches the request.
     */
    public function fallback(callable|array|string $handler) : void;
}
=== RouterRuntimeInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Psr\Http\Message\ResponseInterface;

/**
 * Represents the runtime responsibilities of the router: resolving requests
 * and exposing runtime metadata used by helpers and tools.
 */
interface RouterRuntimeInterface
{
    /**
     * Resolves the request and returns a PSR-7 response.
     *
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    public function resolve(Request $request) : ResponseInterface;

    /**
     * Retrieves a route definition by name.
     */
    public function getRouteByName(string $name) : RouteDefinition;

    /**
     * Returns all registered routes grouped by HTTP method.
     *
     * @return array<string, RouteDefinition[]>
     */
    public function allRoutes() : array;
}

=== Routing/AttributeRouteRegistrar.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\HttpMethod;
use Avax\HTTP\Router\Routing\Attributes\Route as RouteAttribute;
use ReflectionAttribute;
use ReflectionClass;
use ReflectionMethod;

final readonly class AttributeRouteRegistrar
{
    public function __construct(private HttpRequestRouter $router) {}

    /**
     * @throws \ReflectionException
     */
    public function register(object|string $controller) : void
    {
        $reflection  = new ReflectionClass(objectOrClass: $controller);
        $classRoutes = $this->instantiateRoutes(attributes: $reflection->getAttributes(name: RouteAttribute::class));

        foreach ($reflection->getMethods(filter: ReflectionMethod::IS_PUBLIC) as $method) {
            $methodRoutes = $this->instantiateRoutes(attributes: $method->getAttributes(name: RouteAttribute::class));

            if ($methodRoutes === []) {
                continue;
            }

            foreach ($methodRoutes as $route) {
                $bases = $classRoutes === [] ? [null] : $classRoutes;

                foreach ($bases as $baseRoute) {
                    $this->registerFromAttributes(
                        controllerClass: $reflection->getName(),
                        methodName     : $method->getName(),
                        route          : $route,
                        baseRoute      : $baseRoute
                    );
                }
            }
        }
    }

    /**
     * @param list<ReflectionAttribute> $attributes
     *
     * @return list<RouteAttribute>
     */
    private function instantiateRoutes(array $attributes) : array
    {
        return array_map(
            callback: static fn(ReflectionAttribute $attribute) => $attribute->newInstance(),
            array   : $attributes
        );
    }

    private function registerFromAttributes(
        string              $controllerClass,
        string              $methodName,
        RouteAttribute      $route,
        RouteAttribute|null $baseRoute
    ) : void
    {
        $path          = $this->normalizePath(prefix: $baseRoute?->path, path: $route->path);
        $methods       = $this->resolveMethods(route: $route, baseRoute: $baseRoute);
        $name          = $this->mergeNames(baseName: $baseRoute?->name, methodName: $route->name);
        $middleware    = array_merge($baseRoute?->middleware ?? [], $route->middleware);
        $constraints   = array_merge($baseRoute?->constraints ?? [], $route->constraints);
        $defaults      = array_merge($baseRoute?->defaults ?? [], $route->defaults);
        $attributes    = array_merge($baseRoute?->attributes ?? [], $route->attributes);
        $authorization = $route->authorize ?? $baseRoute?->authorize;
        $domain        = $route->domain ?? $baseRoute?->domain;

        foreach ($methods as $method) {
            $this->router->registerRoute(
                method       : $method,
                path         : $path,
                action       : [$controllerClass, $methodName],
                middleware   : $middleware,
                name         : $name,
                constraints  : $constraints,
                defaults     : $defaults,
                domain       : $domain,
                attributes   : $attributes,
                authorization: $authorization
            );
        }
    }

    private function normalizePath(string|null $prefix, string $path) : string
    {
        $prefix = $prefix ?? '';
        $prefix = $prefix === '' ? '' : '/' . ltrim(string: $prefix, characters: '/');

        $normalizedPath = rtrim($prefix, '/') . '/' . ltrim(string: $path, characters: '/');

        // Normalize multiple consecutive slashes to single slash
        return preg_replace('#//+#', '/', $normalizedPath);
    }

    private function resolveMethods(RouteAttribute $route, RouteAttribute|null $baseRoute) : array
    {
        $methods = $route->methods !== [] ? $route->methods : ($baseRoute?->methods ?? [HttpMethod::GET->value]);

        return array_map(
            static fn(string $method) => strtoupper(string: $method),
            $methods
        );
    }

    private function mergeNames(string|null $baseName, string|null $methodName) : string|null
    {
        if ($baseName === null) {
            return $methodName;
        }

        if ($methodName === null) {
            return $baseName;
        }

        return rtrim(string: $baseName, characters: '.') . '.' . ltrim(string: $methodName, characters: '.');
    }
}

=== Routing/Attributes/Route.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Attributes;

use Attribute;

#[Attribute(flags: Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class Route
{
    /**
     * @param list<string>          $methods
     * @param list<string|callable> $middleware
     * @param array<string, mixed>  $defaults
     * @param array<string, string> $constraints
     * @param array<string, mixed>  $attributes
     */
    public function __construct(
        public string      $path,
        public string|null $name = null,
        public array|null  $methods = null,
        public array|null  $middleware = null,
        public string|null $domain = null,
        public array|null  $defaults = null,
        public array|null  $constraints = null,
        public array|null  $attributes = null,
        public string|null $authorize = null,
    )
    {
        $this->methods     ??= ['GET'];
        $this->middleware  ??= [];
        $this->defaults    ??= [];
        $this->constraints ??= [];
        $this->attributes  ??= [];
    }
}

=== Routing/CachedRouteLoader.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\Filesystem\Contracts\FilesystemInterface;

/**
 * Route loader that loads routes from compiled cache files.
 *
 * Validates cache integrity using SHA256 signatures before loading,
 * ensuring cache poisoning protection and deterministic behavior.
 */
final readonly class CachedRouteLoader implements RouteSourceLoaderInterface
{
    public function __construct(
        private string $cachePath,
        private FilesystemInterface $filesystem,
        private RouteCacheManifest $manifest
    ) {}

    /**
     * Load routes from cache into the collection.
     *
     * Performs integrity validation before loading to prevent cache poisoning.
     *
     * @throws \RuntimeException If cache is invalid or corrupted
     */
    public function loadInto(RouteCollection $collection) : void
    {
        if (! $this->isAvailable()) {
            throw new \RuntimeException('Cache file not available or invalid');
        }

        // Validate cache integrity before loading
        if (! $this->manifest->validateSignatureFile($this->cachePath)) {
            throw new \RuntimeException('Cache signature validation failed - possible tampering detected');
        }

        // Load and validate JSON content
        $cacheContent = $this->filesystem->get(path: $this->cachePath);

        try {
            /** @var array<array<string, mixed>> $routesData */
            $routesData = json_decode($cacheContent, true, 512, JSON_THROW_ON_ERROR);
        } catch (\JsonException $exception) {
            throw new \RuntimeException('Invalid cache JSON format', 0, $exception);
        }

        if (! is_array($routesData)) {
            throw new \RuntimeException('Cache file does not contain valid route array');
        }

        // Populate collection with cached routes
        foreach ($routesData as $routeData) {
            if (! is_array($routeData)) {
                throw new \RuntimeException('Invalid route data in cache');
            }

            try {
                $route = RouteDefinition::fromArray($routeData);
                $collection->addRoute($route);
            } catch (\Throwable $exception) {
                throw new \RuntimeException(
                    'Failed to load route from cache: ' . $exception->getMessage(),
                    0,
                    $exception
                );
            }
        }
    }

    /**
     * Check if cached routes are available and valid.
     * Includes trust boundary verification.
     */
    public function isAvailable() : bool
    {
        if (! $this->filesystem->exists(path: $this->cachePath)) {
            return false;
        }

        // Verify cache integrity before considering it available
        if (! $this->manifest->validateSignatureFile($cachePath: $this->cachePath)) {
            // Log cache corruption but don't throw - allow fallback to disk loading
            error_log("Route cache signature validation failed for {$this->cachePath} - cache may be corrupted");
            return false;
        }

        return true;
    }

    /**
     * Get loader priority (cache has highest priority for performance).
     */
    public function getPriority() : int
    {
        return 100; // Highest priority - prefer cache when available
    }

    /**
     * Get descriptive loader name.
     */
    public function getName() : string
    {
        return 'cached';
    }
}
=== Routing/DiskRouteLoader.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Route loader that loads routes from PHP files on disk.
 *
 * Executes route definition files within a scoped context to prevent
 * global state pollution and ensure isolation between different route sources.
 */
final readonly class DiskRouteLoader implements RouteSourceLoaderInterface
{
    public function __construct(
        private string $routesPath
    ) {}

    /**
     * Load routes from disk files into the collection.
     *
     * Creates a scoped collector context to prevent global state pollution
     * and executes route definition files safely with instance-based isolation.
     *
     * @throws \RuntimeException If route file execution fails
     */
    public function loadInto(RouteCollection $collection) : void
    {
        if (! $this->isAvailable()) {
            throw new \RuntimeException("Routes file not found: {$this->routesPath}");
        }

        // Execute routes in scoped collector context to prevent global pollution
        $collector = RouteCollector::scoped(function (RouteCollector $collector) : void {
            try {
                // Read file content and execute DSL
                $code = file_get_contents($this->routesPath);
                if ($code === false) {
                    throw new \RuntimeException("Cannot read routes file: {$this->routesPath}");
                }

                $collector->executeDsl($code);
            } catch (\Throwable $exception) {
                throw new \RuntimeException(
                    "Failed to load routes from {$this->routesPath}: " . $exception->getMessage(),
                    0,
                    $exception
                );
            }
        });

        // Transfer loaded routes to collection
        foreach ($collector->flush() as $routeBuilder) {
            try {
                $route = $routeBuilder->build();
                $collection->addRoute($route);
            } catch (\Throwable $exception) {
                throw new \RuntimeException(
                    'Failed to build route from file: ' . $exception->getMessage(),
                    0,
                    $exception
                );
            }
        }
    }

    /**
     * Check if routes file exists and is readable.
     */
    public function isAvailable() : bool
    {
        return is_file($this->routesPath) && is_readable($this->routesPath);
    }

    /**
     * Get loader priority (disk has medium priority, used when cache unavailable).
     */
    public function getPriority() : int
    {
        return 50; // Medium priority - fallback when cache not available
    }

    /**
     * Get descriptive loader name.
     */
    public function getName() : string
    {
        return 'disk';
    }
}
=== Routing/DomainAwareMatcher.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Matching\RouteMatcherInterface;

/**
 * Domain-aware route matcher that considers domain constraints.
 *
 * Enables multi-tenant routing where routes can be restricted to specific domains.
 * Falls back to standard RouteMatcher for domain-agnostic routes.
 */
final class DomainAwareMatcher implements RouteMatcherInterface
{
    public function __construct(
        private RouteMatcher $baseMatcher
    ) {}

    /**
     * Finds the first matching route from the given routes array, considering domain constraints.
     * Now supports multiple routes per method+path for true domain-aware routing.
     *
     * @param array<string, array<string, RouteDefinition[]>> $routes  Routes grouped by method and path
     * @param Request                                          $request The incoming request
     *
     * @return array{0: RouteDefinition, 1: array}|null Returns [route, matches] or null if no match
     */
    public function match(array $routes, Request $request) : array|null
    {
        $method = strtoupper($request->getMethod());
        $uriPath = $request->getUri()->getPath();

        // Sort routes by specificity (most specific first) for proper precedence
        $sortedRoutes = $this->sortRoutesBySpecificity(routes: $routes);

        // Flatten routes for each method to match the base matcher interface
        $flattenedRoutes = [];
        foreach ($sortedRoutes as $methodKey => $pathsForMethod) {
            $flattenedRoutes[$methodKey] = [];
            foreach ($pathsForMethod as $pathRoutes) {
                foreach ($pathRoutes as $route) {
                    $flattenedRoutes[$methodKey][] = $route;
                }
            }
        }

        // First try to match without domain constraints
        $baseResult = $this->baseMatcher->match(routes: $flattenedRoutes, request: $request);

        if ($baseResult === null) {
            return null;
        }

        [$route, $matches] = $baseResult;

        // Now check domain constraint
        if ($this->matchesDomain(route: $route, request: $request)) {
            return [$route, $matches];
        }

        // Domain doesn't match, try to find another route that does match domain
        return $this->findDomainMatchingRoute(routes: $sortedRoutes, request: $request, method: $method, uriPath: $uriPath);
    }

    /**
     * Checks if the route's domain constraint matches the request's host.
     *
     * @param RouteDefinition $route   The route definition
     * @param Request         $request The request
     *
     * @return bool True if domain matches or no domain constraint exists
     */
    private function matchesDomain(RouteDefinition $route, Request $request) : bool
    {
        $routeDomain = $route->domain;

        // No domain constraint = matches any domain
        if ($routeDomain === null) {
            return true;
        }

        $requestHost = $this->getRequestHost(request: $request);

        // Exact domain match
        if ($routeDomain === $requestHost) {
            return true;
        }

        // Support wildcard subdomains (e.g., *.example.com)
        if (str_starts_with($routeDomain, '*.')) {
            $baseDomain = substr($routeDomain, 2); // Remove *. prefix

            return str_ends_with($requestHost, $baseDomain);
        }

        return false;
    }

    /**
     * Extracts the host from the request URI.
     *
     * @return string The host (lowercase)
     */
    private function getRequestHost(Request $request) : string
    {
        $host = $request->getUri()->getHost();

        // Handle port number (e.g., example.com:8080 -> example.com)
        if (str_contains($host, ':')) {
            $host = explode(':', $host, 2)[0];
        }

        return strtolower($host);
    }

    /**
     * Finds a route that matches both path/method AND domain constraints.
     * Now searches through multiple routes per path for domain-aware routing.
     */
    private function findDomainMatchingRoute(array $routes, Request $request, string $method, string $uriPath) : array|null
    {
        if (! isset($routes[$method][$uriPath])) {
            return null;
        }

        foreach ($routes[$method][$uriPath] as $route) {
            // Check if this route matches domain AND would match the base criteria
            if ($this->matchesDomain(route: $route, request: $request) && $this->baseMatcher->matches(route: $route, request: $request)) {
                // We need to get the actual matches from the base matcher
                $methodRoutes = [$method => [$route]];
                $result       = $this->baseMatcher->match(routes: $methodRoutes, request: $request);
                if ($result !== null) {
                    return $result;
                }
            }
        }

        return null;
    }

    /**
     * Sorts routes by specificity in descending order (most specific first).
     * Ensures more specific routes (like /users/me) are matched before generic ones (like /users/{id}).
     *
     * @param array<string, array<string, RouteDefinition[]>> $routes
     *
     * @return array<string, array<string, RouteDefinition[]>>
     */
    private function sortRoutesBySpecificity(array $routes) : array
    {
        $sorted = [];

        foreach ($routes as $method => $pathsForMethod) {
            $sorted[$method] = [];
            foreach ($pathsForMethod as $path => $routesForPath) {
                // Sort routes by specificity (descending: higher specificity first)
                usort($routesForPath, static fn(RouteDefinition $a, RouteDefinition $b) => $b->specificity <=> $a->specificity);
                $sorted[$method][$path] = $routesForPath;
            }
        }

        return $sorted;
    }

    /**
     * Matches a route against a request, considering domain constraints.
     *
     * @param RouteDefinition $route   The route to match
     * @param Request         $request The incoming request
     *
     * @return bool True if route matches request and domain constraints
     */
    public function matches(RouteDefinition $route, Request $request) : bool
    {
        // First check domain constraint
        if (! $this->matchesDomain(route: $route, request: $request)) {
            return false;
        }

        // Then delegate to base matcher for path/method matching
        return $this->baseMatcher->matches(route: $route, request: $request);
    }
}
=== Routing/DuplicatePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Policy enumeration for handling duplicate route registration.
 *
 * Defines the available strategies for dealing with route conflicts
 * when multiple routes attempt to register with the same key.
 */
enum DuplicatePolicy
{
    /**
     * Throw an exception when duplicate routes are detected.
     *
     * This is the strictest policy, ensuring no accidental route shadowing.
     * Recommended for production environments.
     */
    case THROW;

    /**
     * Replace the existing route with the new one silently.
     *
     * Allows route overriding without warnings. Useful for testing
     * or dynamic route modification scenarios.
     */
    case REPLACE;

    /**
     * Ignore duplicate routes silently.
     *
     * Keeps the first registered route and discards subsequent duplicates.
     * Useful for scenarios where route precedence is established by registration order.
     */
    case IGNORE;

    /**
     * Get human-readable description of this policy.
     */
    public function describe() : string
    {
        return match ($this) {
            self::THROW => 'Throw exception on duplicate routes',
            self::REPLACE => 'Replace existing route with new one',
            self::IGNORE => 'Keep first route, ignore duplicates',
        };
    }
}
=== Routing/ErrorResponseFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Response\Classes\Response;
use Avax\HTTP\Response\Classes\Stream;
use Psr\Http\Message\ResponseInterface;

/**
 * Central factory for creating error responses (404, 405, etc.).
 *
 * Ensures consistent error handling and formatting across the router.
 */
final readonly class ErrorResponseFactory
{
    public function createNotFoundResponse(string $method, string $path) : ResponseInterface
    {
        $body = sprintf('Route not found for [%s] %s', $method, $path);

        return new Response(
            stream    : Stream::fromString(content: $body),
            statusCode: 404,
            headers   : ['Content-Type' => 'text/plain'],
        );
    }

    public function createMethodNotAllowedResponse(string $method, string $path, array $allowedMethods) : ResponseInterface
    {
        $body = sprintf('Method %s not allowed for %s. Allowed: %s', $method, $path, implode(', ', $allowedMethods));

        return new Response(
            stream    : Stream::fromString(content: $body),
            statusCode: 405,
            headers   : [
                'Content-Type' => 'text/plain',
                'Allow'        => implode(', ', $allowedMethods),
            ],
        );
    }
}

=== Routing/Exceptions/DuplicateRouteException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use Exception;

/**
 * Thrown when attempting to register a duplicate route.
 */
final class DuplicateRouteException extends Exception
{
    public function __construct(string $method, string $path, string|null $domain = null, string|null $name = null)
    {
        $key = $this->buildKey($method, $path, $domain, $name);
        parent::__construct("Duplicate route registration: {$key}");
    }

    private function buildKey(string $method, string $path, string|null $domain, string|null $name) : string
    {
        $parts = [$method, $domain ?? '', $path];
        if ($name !== null) {
            $parts[] = "name:{$name}";
        }
        return implode('|', $parts);
    }
}
=== Routing/Exceptions/InvalidRouteException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use InvalidArgumentException;
use Throwable;

/**
 * Thrown when a route definition is malformed or unsafe.
 *
 * Used for path errors, constraint syntax issues, or unsupported parameter configurations.
 */
final class InvalidRouteException extends InvalidArgumentException
{
    /**
     * Default constructor for direct string messages.
     *
     * @param string          $message  Error message.
     * @param int             $code     Error code (optional).
     * @param \Throwable|null $previous Chained exception (optional).
     */
    public function __construct(string $message = '', int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct(message: $message, code: $code, previous: $previous);
    }

    /**
     * Creates an exception for a malformed route path.
     *
     * @param string $path The invalid route path.
     */
    public static function forPath(string $path) : self
    {
        return new self(
            message: sprintf(
                'Invalid route path provided: "%s". Path must begin with "/" and contain valid segments.',
                $path
            )
        );
    }

    /**
     * Creates an exception for a constraint regex that failed to compile.
     *
     * @param string $parameter Parameter name.
     * @param string $pattern   Invalid regex pattern.
     */
    public static function forConstraint(string $parameter, string $pattern) : self
    {
        return new self(
            message: sprintf('Invalid regex constraint for parameter "%s": "%s"', $parameter, $pattern)
        );
    }

    /**
     * Creates an exception for wildcard misuse in route patterns.
     *
     * @param string $path The full route path.
     */
    public static function forInvalidWildcardUsage(string $path) : self
    {
        return new self(
            message: sprintf(
                'Invalid wildcard usage: wildcards must appear only once and at the end. Path: "%s"',
                $path
            )
        );
    }
}

=== Routing/Exceptions/InvalidRouteGroupFileException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use RuntimeException;
use Throwable;

/**
 * Raised when a route group file fails to return a valid RouteGroupBuilder.
 */
final class InvalidRouteGroupFileException extends RuntimeException
{
    public function __construct(string $message, Throwable|null $previous = null)
    {
        parent::__construct(message: $message, previous: $previous);
    }
}

=== Routing/Exceptions/MethodNotAllowedException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use RuntimeException;

/**
 * Exception thrown when a route exists but the HTTP method is not allowed.
 */
final class MethodNotAllowedException extends RuntimeException
{
    private array $allowedMethods;

    public function __construct(string $method, string $path, array $allowedMethods)
    {
        parent::__construct(message: "Method {$method} not allowed for {$path}");

        $this->allowedMethods = $allowedMethods;
    }

    public static function for(string $method, string $path, array $allowedMethods) : self
    {
        return new self(method: $method, path: $path, allowedMethods: $allowedMethods);
    }

    public function getAllowedMethods() : array
    {
        return $this->allowedMethods;
    }
}

=== Routing/Exceptions/ReservedRouteNameException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use Exception;

/**
 * Exception thrown when attempting to register a route with a reserved name.
 */
class ReservedRouteNameException extends Exception
{
    public function __construct(string $name)
    {
        parent::__construct(message: "Route name '{$name}' is reserved. Names starting with '__avax.' are not allowed.");
    }
}

=== Routing/Exceptions/RouteNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

/**
 * Thrown when no route matches the incoming request.
 *
 * Represents HTTP 404 Not Found errors in the routing layer.
 * Provides structured context for debugging and monitoring.
 */
final class RouteNotFoundException extends RouterException
{
    /**
     * Factory for standard 404 message.
     *
     * @param string $method HTTP method used.
     * @param string $path   URI path attempted.
     *
     * @return static
     */
    public static function for(string $method, string $path) : self
    {
        return new self(
            message: sprintf('No route found for [%s] %s', strtoupper($method), $path),
            httpStatusCode: 404,
            context: [
                'method' => $method,
                'path' => $path,
                'available_methods' => [], // Can be populated by caller
            ],
            isRetryable: false
        );
    }

    /**
     * Get the HTTP status code (404).
     */
    public function getHttpStatusCode() : int
    {
        return 404;
    }
}
=== Routing/Exceptions/RouterException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

/**
 * Base exception class for all router-related exceptions.
 *
 * Provides common functionality and ensures consistent behavior across
 * all router exceptions. Implements RouterExceptionInterface for
 * standardized error handling.
 */
abstract class RouterException extends \RuntimeException implements RouterExceptionInterface
{
    /**
     * @var array<string, mixed>
     */
    private array $context;

    public function __construct(
        string $message,
        int $httpStatusCode,
        array $context = [],
        bool $isRetryable = false,
        int $code = 0,
        \Throwable|null $previous = null
    ) {
        parent::__construct($message, $code, $previous);

        $this->context = array_merge($context, [
            'http_status_code' => $httpStatusCode,
            'is_retryable' => $isRetryable,
            'exception_class' => static::class,
            'timestamp' => microtime(true),
        ]);
    }

    /**
     * Get the HTTP status code associated with this exception.
     */
    abstract public function getHttpStatusCode() : int;

    /**
     * Get additional context information for debugging.
     *
     * @return array<string, mixed>
     */
    public function getContext() : array
    {
        return $this->context;
    }

    /**
     * Check if this exception is retryable.
     */
    public function isRetryable() : bool
    {
        return $this->context['is_retryable'] ?? false;
    }

    /**
     * Add context information to the exception.
     *
     * @param array<string, mixed> $additionalContext
     */
    public function withContext(array $additionalContext) : self
    {
        $this->context = array_merge($this->context, $additionalContext);
        return $this;
    }

    /**
     * Create a new instance with additional context.
     *
     * @param array<string, mixed> $additionalContext
     */
    public function withAdditionalContext(array $additionalContext) : self
    {
        $clone = clone $this;
        return $clone->withContext($additionalContext);
    }
}
=== Routing/Exceptions/RouterExceptionInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

/**
 * Base interface for all router-related exceptions.
 *
 * Ensures consistent exception taxonomy across the entire router component.
 * All router exceptions must implement this interface for proper error handling
 * and debugging consistency.
 */
interface RouterExceptionInterface extends \Throwable
{
    /**
     * Get the HTTP status code associated with this exception.
     *
     * Provides standardized HTTP status codes for router exceptions
     * to enable proper HTTP response generation.
     */
    public function getHttpStatusCode() : int;

    /**
     * Get additional context information for debugging.
     *
     * Returns structured context data that can be used for logging,
     * monitoring, and error reporting.
     *
     * @return array<string, mixed>
     */
    public function getContext() : array;

    /**
     * Check if this exception is retryable.
     *
     * Indicates whether the operation that caused this exception
     * can be safely retried.
     */
    public function isRetryable() : bool;
}
=== Routing/Exceptions/StageOrderException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use RuntimeException;

final class StageOrderException extends RuntimeException
{
    /**
     * @param array<int,string> $pipeline
     * @param array<int,string> $expectedOrder
     */
    public static function duplicate(string $stage, array $pipeline, array $expectedOrder) : self
    {
        $message = sprintf(
            'Duplicate pipeline component detected: %s. Pipeline: [%s]. Expected order: %s.',
            $stage,
            implode(', ', $pipeline),
            implode(' -> ', $expectedOrder)
        );

        return new self(message: $message);
    }

    /**
     * @param array<int,string> $pipeline
     * @param array<int,string> $expectedOrder
     */
    public static function misordered(string $stage, array $pipeline, array $expectedOrder, string $reason = '') : self
    {
        $message = sprintf(
            'Pipeline component is misordered: %s. Pipeline: [%s]. Expected order: %s.',
            $stage,
            implode(', ', $pipeline),
            implode(' -> ', $expectedOrder)
        );

        if ($reason !== '') {
            $message .= " Reason: {$reason}.";
        }

        return new self(message: $message);
    }
}
=== Routing/Exceptions/UnauthorizedException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing\Exceptions;

use RuntimeException;

/**
 * Thrown when a route explicitly defines an authorization requirement
 * that the request does not fulfill.
 */
final class UnauthorizedException extends RuntimeException
{
    public static function because(string $reason = 'Access denied.') : self
    {
        return new self(message: $reason);
    }
}

=== Routing/HttpRequestRouter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * @phpstan-type RoutesMap array<string, array<string, RouteDefinition[]>>
 * @phpstan-type RouteResolutionContext array{
 *     route: RouteDefinition,
 *     parameters: array<string, string>,
 *     matchedDomain: string|null,
 *     matchTimeMs: float,
 *     resolutionPath: array<array{time: float, description: string}>
 * }
 * @phpstan-type RouteMethodMap array<string, array<string, RouteDefinition[]>>
 */

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Matching\RouteMatcherInterface;
use Avax\HTTP\Router\Routing\Exceptions\DuplicateRouteException;
use Avax\HTTP\Router\Routing\Exceptions\MethodNotAllowedException;
use Avax\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Avax\HTTP\Router\Support\RouteRequestInjector;
use Avax\HTTP\Router\Tracing\RouterTrace;
use Avax\HTTP\Router\Validation\RouteConstraintValidator;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;

/**
 * INTERNAL: HTTP Request Router Engine
 *
 * This is an internal implementation detail. Behavior may change without notice.
 * Do not depend on this class directly - use RouterInterface and Router instead.
 *
 * Handles HTTP request routing by matching registered routes to incoming requests.
 *
 * Fully supports:
 * - HTTP method-based route matching
 * - Named route support
 * - Prefix grouping
 * - Domain-aware routes
 * - Parameter constraints (via regex)
 * - Optional and wildcard path segments
 * - Route defaults for missing parameters
 * - Middleware and authorization metadata
 *
 * @internal
 */
final class HttpRequestRouter
{
    private readonly LoggerInterface $logger;
    /**
     * All registered routes, grouped by HTTP method and path.
     * Supports multiple routes per path for domain-aware routing.
     *
     * @var array<string, array<string, RouteDefinition[]>>
     */
    private array $routes = [];
    /**
     * Prefix stack (used for nested route groups).
     *
     * @var string[]
     */
    private array $prefixStack = [];
    /**
     * A map of named routes for reverse routing.
     *
     * @var array<string, RouteDefinition>
     */
    private array                $namedRoutes   = [];
    /**
     * Route keys for deduplication.
     *
     * @var array<string, bool>
     */
    private array                $routeKeys     = [];
    private RouteDefinition|null $fallbackRoute = null;

    public function __construct(
        private readonly RouteConstraintValidator $constraintValidator,
        private readonly RouteMatcherInterface    $matcher,
        LoggerInterface|null                      $logger = null,
        private readonly RouterTrace|null         $trace = null
    )
    {
        $this->logger = $logger ?? new NullLogger;
    }

    /**
     * Retrieves a route by its unique name.
     *
     * @param string $name The name of the route.
     *
     * @throws RouteNotFoundException
     */
    public function getByName(string $name) : RouteDefinition
    {
        if (! isset($this->namedRoutes[$name])) {
            throw new RouteNotFoundException("Named route [{$name}] not found.", 404, [], false);
        }

        return $this->namedRoutes[$name];
    }

    /**
     * Checks if a named route exists.
     */
    public function hasNamedRoute(string $name) : bool
    {
        return isset($this->namedRoutes[$name]);
    }

    /**
     * Sets the fallback handler to be used when no route matches.
     *
     * @deprecated This method is deprecated. Use FallbackManager directly.
     * Fallback handling should be unified through FallbackManager only.
     */
    public function fallback(callable|array|string $handler) : void
    {
        // Fallback is now handled exclusively through FallbackManager
        // This method is kept for backward compatibility but does nothing
        // TODO: Remove this method in a future version
    }

    /**
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    private function registerRoute(string $method, string $path, callable|array|string $action, string|null $name = null) : void
    {
        $route = new RouteDefinition(
            method       : $method,
            path         : $path,
            action       : $action,
            middleware   : [],
            name         : $name,
            constraints  : [],
            defaults     : [],
            domain       : null,
            attributes   : [],
            authorization: null
        );

        $this->add(route: $route);
    }

    /**
     * Registers a route from cache (bypasses validation).
     *
     * @param RouteDefinition $route The precompiled route to register.
     *
     * @internal This method is for internal cache loading only.
     *
     * @throws DuplicateRouteException
     */
    public function add(RouteDefinition $route) : void
    {
        $routeKey = RouteKey::fromRoute($route);
        $keyString = $routeKey->toString();

        // Check for duplicates based on configured policy
        if (isset($this->routeKeys[$keyString])) {
            $this->handleDuplicateRoute($routeKey, $route);
            return; // If policy allows continuation
        }

        $this->routeKeys[$keyString] = true;

        $method = strtoupper(string: $route->method);

        // Support multiple routes per method+path for domain-aware routing
        if (!isset($this->routes[$method][$route->path])) {
            $this->routes[$method][$route->path] = [];
        }
        $this->routes[$method][$route->path][] = $route;

        // Register named routes for quick lookup
        if (! empty($route->name)) {
            $this->namedRoutes[$route->name] = $route;
        }
    }

    /**
     * Builds a unique key for route deduplication.
     */
    private function buildRouteKey(RouteDefinition $route) : string
    {
        return sprintf(
            '%s|%s|%s',
            strtoupper($route->method),
            $route->domain ?? '',
            $route->path
        );
    }

    /**
     * Resolves the given HTTP request and returns structured resolution context.
     *
     * Provides comprehensive debugging information about how and why a route was selected,
     * including timing, parameters, domain matching, and resolution path.
     *
     * @param Request $request The HTTP request to resolve
     *
     * @return RouteResolutionContext Structured context with route, parameters, timing, and debug info
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     * @throws \Avax\HTTP\Router\Validation\Exceptions\InvalidConstraintException
     */
    public function resolve(Request $request) : RouteResolutionContext
    {
        $startTime = microtime(true);
        $path      = $request->getUri()->getPath();
        $method    = $request->getMethod();
        $host      = $request->getUri()->getHost();

        $resolutionPath = [
            ['timestamp' => date('H:i:s.u'), 'description' => "Started resolution for {$method} {$path} from {$host}"],
        ];

        $this->trace?->log(event: 'resolve.start', context: ['path' => $path, 'method' => $method, 'host' => $host]);

        try {
            $matchResult = $this->matcher->match(routes: $this->routes, request: $request);

            if ($matchResult === null) {
                $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => 'No route matched'];
                $this->trace?->log(event: 'resolve.no_match', context: ['path' => $path, 'method' => $method]);

                // No route matched - determine if it's 404 or 405
                $allowedMethods   = $this->findAllowedMethodsForPath(path: $path);
                $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => 'Checked allowed methods: ' . implode(', ', $allowedMethods)];
                $this->trace?->log(event: 'resolve.allowed_methods', context: ['allowed' => $allowedMethods]);

                $failureReason = ! empty($allowedMethods)
                    ? "Method {$method} not allowed (allowed: " . implode(', ', $allowedMethods) . ')'
                    : "No route found for path {$path}";

                $matchTime = (microtime(true) - $startTime) * 1000;

                if (! empty($allowedMethods)) {
                    $this->trace?->log(event: 'resolve.method_not_allowed');
                    throw new MethodNotAllowedException(
                        $failureReason,
                        405,
                        ['allowed_methods' => $allowedMethods],
                        false
                    );
                } else {
                    $this->trace?->log(event: 'resolve.route_not_found');
                    throw new RouteNotFoundException($failureReason, 404, [], false);
                }
            }

            [$route, $matches] = $matchResult;
            $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => "Matched route: {$route->method} {$route->path}"];
            $this->trace?->log(event: 'resolve.match_found', context: [
                'route'   => $route->name ?? $route->path,
                'matches' => count($matches)
            ]);

            // Extract any parameters captured from the regex match (e.g., {id} = 123).
            $parameters       = $this->extractParameters(matches: $matches);
            $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => 'Extracted parameters: ' . json_encode($parameters)];
            $this->trace?->log(event: 'resolve.parameters_extracted', context: ['params' => $parameters]);

            // Apply default route parameters and merge them with extracted parameters into the request object.
            $request          = RouteRequestInjector::injectExtractedParameters(
                request   : $request,
                defaults  : $route->defaults,
                parameters: $parameters
            );
            $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => 'Injected parameters into request'];
            $this->trace?->log(event: 'resolve.parameters_injected', context: ['defaults' => $route->defaults]);

            // Calls the validate method of the RouteConstraintValidator instance.
            $this->constraintValidator->validate(route: $route, request: $request);
            $resolutionPath[] = ['timestamp' => date('H:i:s.u'), 'description' => 'Route validation completed'];
            $this->trace?->log(event: 'resolve.validation_complete');

            $matchTime     = (microtime(true) - $startTime) * 1000;
            $matchedDomain = $route->domain ?? null;

            $this->trace?->log(event: 'resolve.complete', context: ['route' => $route->name ?? $route->path]);

            return RouteResolutionContext::success(
                route         : $route,
                parameters    : $parameters,
                matchedDomain : $matchedDomain,
                matchTimeMs   : $matchTime,
                resolutionPath: $resolutionPath
            );

        } catch (RouteNotFoundException|MethodNotAllowedException $e) {
            $matchTime = (microtime(true) - $startTime) * 1000;
            $this->trace?->log(event: 'resolve.failed', context: ['reason' => $e->getMessage()]);

            return RouteResolutionContext::failure(
                failureReason : $e->getMessage(),
                matchTimeMs   : $matchTime,
                resolutionPath: $resolutionPath
            );
        }
    }

    /**
     * Finds all HTTP methods that have routes for the given path.
     *
     * Used to determine if a 404 should be 405 (method not allowed) instead.
     * Now considers pattern routes (e.g., /users/{id}) for proper 405 responses.
     *
     * @param string $path The request path to check
     *
     * @return string[] Array of allowed HTTP methods (uppercase)
     */
    private function findAllowedMethodsForPath(string $path) : array
    {
        $allowedMethods = [];

        foreach ($this->routes as $method => $pathsForMethod) {
            foreach ($pathsForMethod as $routesForPath) {
                foreach ($routesForPath as $route) {
                    // Check if this route's pattern could match the path
                    if ($this->matchesIgnoringMethod(route: $route, path: $path)) {
                        $allowedMethods[] = $method;
                        break 2; // Found at least one route for this method
                    }
                }
            }
        }

        // Remove duplicates and sort
        $allowedMethods = array_unique($allowedMethods);
        sort($allowedMethods);

        return $allowedMethods;
    }

    /**
     * Checks if a route pattern could match the given path, ignoring HTTP method.
     *
     * Used for 404/405 determination - if a pattern route exists for the path
     * but with different methods, return 405 instead of 404.
     *
     * Uses precompiled regex pattern for performance.
     *
     * @param RouteDefinition $route The route to check
     * @param string         $path  The request path
     *
     * @return bool True if the route pattern matches the path
     */
    private function matchesIgnoringMethod(RouteDefinition $route, string $path) : bool
    {
        // Use precompiled regex pattern for performance
        return preg_match($route->compiledPathRegex, $path) === 1;
    }

    /**
     * Compiles a route path template into a regex pattern.
     *
     * @param string $template    The route template (e.g., "/users/{id}")
     * @param array  $constraints Parameter constraints
     *
     * @return string The compiled regex pattern
     */
    private function compileRoutePattern(string $template, array $constraints) : string
    {
        $pattern = preg_replace_callback(
            '/\{([^}]+)\}/',
            static function ($matches) use ($constraints) {
                $param      = $matches[1];
                $isOptional = str_ends_with($param, '?');
                $isWildcard = str_ends_with($param, '*');

                $paramName  = preg_replace('/[?*]$/', '', $param);
                $constraint = $constraints[$paramName] ?? '[^/]+';

                $segment = "(?P<{$paramName}>{$constraint})";

                if ($isWildcard) {
                    $segment = "(?P<{$paramName}>.*)";
                }

                if ($isOptional) {
                    $segment = "(?:/{$segment})?";
                } else {
                    $segment = "/{$segment}";
                }

                return $segment;
            },
            $template
        );

        return "#^{$pattern}$#";
    }

    private function extractParameters(array $matches) : array
    {
        return array_filter($matches, static fn($key) => ! is_int($key), ARRAY_FILTER_USE_KEY);
    }

    /**
     * Returns all registered routes grouped by HTTP method.
     * Flattens the internal structure for backward compatibility.
     *
     * @return array<string, RouteDefinition[]>
     */
    public function allRoutes() : array
    {
        $flattened = [];
        foreach ($this->routes as $method => $pathsForMethod) {
            $flattened[$method] = [];
            foreach ($pathsForMethod as $routesForPath) {
                foreach ($routesForPath as $route) {
                    $flattened[$method][] = $route;
                }
            }
        }
        return $flattened;
    }

    /**
     * Handle duplicate route registration based on configured policy.
     *
     * @throws DuplicateRouteException
     */
    private function handleDuplicateRoute(RouteKey $existingKey, RouteDefinition $newRoute) : void
    {
        // Default policy - can be made configurable in future versions
        $policy = DuplicatePolicy::THROW;

        match ($policy) {
            DuplicatePolicy::THROW => throw new DuplicateRouteException(
                "Duplicate route: {$newRoute->method} {$newRoute->path}",
                409,
                [
                    'method' => $newRoute->method,
                    'path' => $newRoute->path,
                    'domain' => $newRoute->domain,
                    'name' => $newRoute->name
                ],
                false
            ),
            DuplicatePolicy::REPLACE => $this->replaceRoute($existingKey, $newRoute),
            DuplicatePolicy::IGNORE => null, // Do nothing, keep existing route
        };
    }

    /**
     * Replace an existing route with a new one.
     */
    private function replaceRoute(RouteKey $key, RouteDefinition $newRoute) : void
    {
        $method = strtoupper($key->method);

        // Remove existing route
        if (isset($this->routes[$method][$key->path])) {
            $this->routes[$method][$key->path] = array_filter(
                $this->routes[$method][$key->path],
                static fn(RouteDefinition $route) => $route->domain !== $key->domain
            );
        }

        // Add new route
        if (!isset($this->routes[$method][$key->path])) {
            $this->routes[$method][$key->path] = [];
        }
        $this->routes[$method][$key->path][] = $newRoute;

        // Update named routes if applicable
        if (! empty($newRoute->name)) {
            $this->namedRoutes[$newRoute->name] = $newRoute;
        }
    }

    /**
     * Gets the current trace instance for debugging and profiling.
     */
    public function getTrace() : RouterTrace|null
    {
        return $this->trace;
    }
}
=== Routing/ReflectionCache.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Cache for reflection metadata to optimize repeated reflection operations.
 *
 * Stores reflection results for classes, methods, and properties to avoid
 * expensive reflection operations during route validation and processing.
 *
 * Thread-safe and memory-efficient with automatic cleanup.
 */
final class ReflectionCache
{
    /**
     * @var array<string, \ReflectionClass<object>>
     */
    private static array $classCache = [];

    /**
     * @var array<string, \ReflectionMethod>
     */
    private static array $methodCache = [];

    /**
     * @var array<string, \ReflectionProperty>
     */
    private static array $propertyCache = [];

    /**
     * Get cached ReflectionClass for a class name.
     *
     * @template T of object
     * @param class-string<T> $className
     * @return \ReflectionClass<T>
     */
    public static function getClass(string $className) : \ReflectionClass
    {
        return self::$classCache[$className] ??= new \ReflectionClass($className);
    }

    /**
     * Get cached ReflectionMethod for a class method.
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $methodName
     * @return \ReflectionMethod
     */
    public static function getMethod($classOrObject, string $methodName) : \ReflectionMethod
    {
        $className = is_string($classOrObject) ? $classOrObject : $classOrObject::class;
        $key = $className . '::' . $methodName;

        return self::$methodCache[$key] ??= self::getClass($className)->getMethod($methodName);
    }

    /**
     * Get cached ReflectionProperty for a class property.
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $propertyName
     * @return \ReflectionProperty
     */
    public static function getProperty($classOrObject, string $propertyName) : \ReflectionProperty
    {
        $className = is_string($classOrObject) ? $classOrObject : $classOrObject::class;
        $key = $className . '::$' . $propertyName;

        return self::$propertyCache[$key] ??= self::getClass($className)->getProperty($propertyName);
    }

    /**
     * Check if a class has a specific method (cached).
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $methodName
     */
    public static function hasMethod($classOrObject, string $methodName) : bool
    {
        try {
            self::getMethod($classOrObject, $methodName);
            return true;
        } catch (\ReflectionException) {
            return false;
        }
    }

    /**
     * Check if a class has a specific property (cached).
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $propertyName
     */
    public static function hasProperty($classOrObject, string $propertyName) : bool
    {
        try {
            self::getProperty($classOrObject, $propertyName);
            return true;
        } catch (\ReflectionException) {
            return false;
        }
    }

    /**
     * Check if a method is public (cached).
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $methodName
     */
    public static function isMethodPublic($classOrObject, string $methodName) : bool
    {
        try {
            $method = self::getMethod($classOrObject, $methodName);
            return $method->isPublic();
        } catch (\ReflectionException) {
            return false;
        }
    }

    /**
     * Check if a property is public (cached).
     *
     * @template T of object
     * @param class-string<T>|T $classOrObject
     * @param string $propertyName
     */
    public static function isPropertyPublic($classOrObject, string $propertyName) : bool
    {
        try {
            $property = self::getProperty($classOrObject, $propertyName);
            return $property->isPublic();
        } catch (\ReflectionException) {
            return false;
        }
    }

    /**
     * Clear all cached reflection data.
     *
     * Useful for testing or when reflection data becomes stale.
     */
    public static function clear() : void
    {
        self::$classCache = [];
        self::$methodCache = [];
        self::$propertyCache = [];
    }

    /**
     * Get cache statistics for monitoring.
     *
     * @return array{class_count: int, method_count: int, property_count: int}
     */
    public static function getStats() : array
    {
        return [
            'class_count' => count(self::$classCache),
            'method_count' => count(self::$methodCache),
            'property_count' => count(self::$propertyCache),
        ];
    }
}
=== Routing/RouteBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\HttpMethod;
use InvalidArgumentException;

/**
 * Builds fluent-style HTTP route declarations for Avax's router.
 *
 * Supports:
 * - Route prefixing and naming
 * - Middleware stacking
 * - Domain and authorization constraints
 * - Parameter constraints, defaults, and metadata
 * - Clean Architecture-aligned route definitions
 *
 * This class acts as a DSL-style fluent builder that produces `RouteDefinition` objects.
 */
final class RouteBuilder
{
    /** @var string HTTP method (GET, POST, etc.) */
    public readonly string $method;

    /** @var string The route URI path (e.g., /users/{id}) */
    public string $path;

    /** @var string|null Optional name for the route (used for reverse routing) */
    public string|null $name = null;

    /** @var array List of middleware to apply to the route */
    public array $middleware = [];

    /** @var callable|array|string|null The route's action target (controller, callable, etc.) */
    public mixed $action = null;

    /** @var array<string, string> Regex constraints for route parameters */
    public array $constraints = [];

    /** @var array<string, string> Default values for optional parameters */
    public array $defaults = [];

    /** @var string|null Optional domain constraint (e.g., admin.{org}.com) */
    public string|null $domain = null;

    /** @var array<string, mixed> Custom metadata attached to the route */
    public array $attributes = [];

    /** @var string|null Optional authorization policy identifier */
    public string|null $authorization = null;

    /**
     * Private constructor. Use RouteBuilder::make() instead.
     *
     * @param string $method HTTP method (GET, POST, etc.)
     * @param string $path   URI path starting with /
     *
     * @throws InvalidArgumentException
     */
    private function __construct(string $method, string $path)
    {
        $this->validateMethod(method: $method);
        $this->validatePath(path: $path);

        $this->method = strtoupper(string: $method);
        $this->path   = $path;
    }

    /**
     * Validates that the HTTP method is allowed.
     *
     *
     * @throws InvalidArgumentException
     */
    private function validateMethod(string $method) : void
    {
        if (! HttpMethod::isValid(method: $method)) {
            throw new InvalidArgumentException(message: "Invalid HTTP method: {$method}");
        }
    }

    /**
     * Validates that the route path format is acceptable.
     *
     *
     * @throws InvalidArgumentException
     */
    private function validatePath(string $path) : void
    {
        route_validate_path(path: $path);
    }

    /**
     * Static factory to initialize a RouteBuilder.
     *
     * Note: Group context is applied by RouterDsl, not here.
     */
    public static function make(string $method, string $path) : self
    {
        return new self(method: $method, path: $path);
    }

    /**
     * Gets the route name.
     */
    public function getName() : string|null
    {
        return $this->name;
    }

    public function setName(string|null $name) : RouteBuilder
    {
        $this->name = $name;

        return $this;
    }

    /**
     * Gets the middleware stack.
     */
    public function getMiddleware() : array
    {
        return $this->middleware;
    }

    public function setMiddleware(array $middleware) : RouteBuilder
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Gets the route action.
     */
    public function getAction() : callable|array|string|null
    {
        return $this->action;
    }

    public function setAction(mixed $action) : RouteBuilder
    {
        $this->action = $action;

        return $this;
    }

    /**
     * Gets parameter constraints.
     *
     * @return array<string, string>
     */
    public function getConstraints() : array
    {
        return $this->constraints;
    }

    public function setConstraints(array $constraints) : RouteBuilder
    {
        $this->constraints = $constraints;

        return $this;
    }

    /**
     * Gets default values for parameters.
     *
     * @return array<string, string>
     */
    public function getDefaults() : array
    {
        return $this->defaults;
    }

    public function setDefaults(array $defaults) : RouteBuilder
    {
        $this->defaults = $defaults;

        return $this;
    }

    /**
     * Gets the domain constraint, if any.
     */
    public function getDomain() : string|null
    {
        return $this->domain;
    }

    public function setDomain(string|null $domain) : RouteBuilder
    {
        $this->domain = $domain;

        return $this;
    }

    /**
     * Gets custom route attributes.
     *
     * @return array<string, mixed>
     */
    public function getAttributes() : array
    {
        return $this->attributes;
    }

    public function setAttributes(array $attributes) : RouteBuilder
    {
        $this->attributes = $attributes;

        return $this;
    }

    public function getAuthorization() : string|null
    {
        return $this->authorization;
    }

    public function setAuthorization(string|null $authorization) : RouteBuilder
    {
        $this->authorization = $authorization;

        return $this;
    }

    /**
     * Sets the route name.
     */
    public function name(string $name) : self
    {
        $this->name = $name;

        return $this;
    }

    // region: Validation

    /**
     * Sets the action target of the route.
     */
    public function action(callable|array|string $action) : self
    {
        $this->action = $action;

        return $this;
    }

    /**
     * Shortcut for setting a controller and method.
     */
    public function controller(string $controller, string $method = 'index') : self
    {
        $this->action = [$controller, $method];

        return $this;
    }

    /**
     * Attaches middleware to the route.
     */
    public function middleware(array $middleware) : self
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Assigns default values for optional route parameters.
     *
     * @param array<string, string> $defaults
     */
    public function defaults(array $defaults) : self
    {
        $this->defaults = $defaults;

        return $this;
    }

    /**
     * Assigns a domain pattern to the route.
     */
    public function withDomain(string $domain) : self
    {
        $this->domain = $domain;

        return $this;
    }

    /**
     * Attaches custom metadata (attributes) to the route.
     *
     * @param array<string, mixed> $attributes
     */
    public function attributes(array $attributes) : self
    {
        $this->attributes = $attributes;

        return $this;
    }

    /**
     * Specifies an authorization policy identifier.
     */
    public function withAuthorization(string $policy) : self
    {
        $this->authorization = $policy;

        return $this;
    }

    /**
     * Adds multiple route parameter constraints using regex.
     *
     * @param array<string, string> $constraints
     *
     * @throws InvalidArgumentException
     */
    public function whereIn(array $constraints) : self
    {
        foreach ($constraints as $param => $pattern) {
            $this->where(parameter: $param, pattern: $pattern);
        }

        return $this;
    }

    /**
     * Adds a single route parameter constraint using regex.
     *
     *
     * @throws InvalidArgumentException
     */
    public function where(string $parameter, string $pattern) : self
    {
        $this->validateConstraintPattern(pattern: $pattern);

        $this->constraints[$parameter] = $pattern;

        return $this;
    }

    /**
     * Ensures that the regex constraint is syntactically valid.
     *
     * @throws InvalidArgumentException
     */
    private function validateConstraintPattern(string $pattern) : void
    {
        // Test pattern compilation without @ suppression
        $testPattern = "/{$pattern}/";
        $error       = null;

        set_error_handler(static function ($errno, $errstr) use (&$error) {
            $error = $errstr;
        });

        $result = preg_match($testPattern, '');

        restore_error_handler();

        if ($result === false || $error !== null) {
            $reason = $error ?: 'invalid regex syntax';
            throw new InvalidArgumentException(message: sprintf('Invalid constraint regex "%s": %s', $pattern, $reason));
        }
    }

    /**
     * Finalizes and compiles the route definition.
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function build() : RouteDefinition
    {
        return new RouteDefinition(
            method       : $this->method,
            path         : $this->path,
            action       : $this->action,
            middleware   : $this->middleware,
            name         : $this->name ?? '',
            constraints  : $this->constraints,
            defaults     : $this->defaults,
            domain       : $this->domain,
            attributes   : $this->attributes,
            authorization: $this->authorization
        );
    }

    /**
     * Specifies a policy for route-level authorization.
     *
     * @param string $policy The authorization policy identifier.
     */
    public function authorize(string $policy) : self
    {
        $this->authorization = $policy;

        return $this;
    }

    /**
     * Gets the HTTP method.
     */
    public function getMethod() : string
    {
        return $this->method;
    }

    /**
     * Gets the path for the route.
     */
    public function getPath() : string
    {
        return $this->path;
    }
}
=== Routing/RouteCollection.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\Routing\Exceptions\DuplicateRouteException;

/**
 * Canonical route collection implementing single source-of-truth for routing.
 *
 * Provides unified storage for both exact path matches and pattern-based routes,
 * ensuring deterministic behavior across different loading strategies.
 */
final class RouteCollection
{
    /**
     * Routes indexed by method and path for fast exact lookups.
     * Structure: [$method][$path] = RouteDefinition (for exact matches)
     *
     * @var array<string, array<string, RouteDefinition>>
     */
    private array $exactRoutes = [];

    /**
     * Pattern-based routes indexed by method for sequential matching.
     * Structure: [$method][] = RouteDefinition (for pattern routes)
     *
     * @var array<string, RouteDefinition[]>
     */
    private array $patternRoutes = [];

    /**
     * Route keys for deduplication tracking.
     * Format: "METHOD|DOMAIN|PATH"
     *
     * @var array<string, true>
     */
    private array $routeKeys = [];

    /**
     * Add a route to the collection with deduplication checking.
     *
     * @throws DuplicateRouteException
     */
    public function addRoute(RouteDefinition $route) : void
    {
        $key = $this->generateRouteKey($route);

        if (isset($this->routeKeys[$key])) {
            throw new DuplicateRouteException(
                method: $route->method,
                path: $route->path,
                domain: $route->domain,
                name: $route->name ?: null
            );
        }

        $this->routeKeys[$key] = true;

        $method = strtoupper($route->method);

        // Check if path contains parameters (indicating pattern route)
        if ($this->isPatternRoute($route->path)) {
            $this->patternRoutes[$method][] = $route;
        } else {
            // Exact path match
            $this->exactRoutes[$method][$route->path] = $route;
        }
    }

    /**
     * Find exact route match for method and path.
     */
    public function findExactRoute(string $method, string $path) : RouteDefinition|null
    {
        return $this->exactRoutes[strtoupper($method)][$path] ?? null;
    }

    /**
     * Get all pattern routes for a method.
     *
     * @return RouteDefinition[]
     */
    public function getPatternRoutes(string $method) : array
    {
        return $this->patternRoutes[strtoupper($method)] ?? [];
    }

    /**
     * Get all routes for a method (exact + patterns).
     *
     * @return RouteDefinition[]
     */
    public function getAllRoutesForMethod(string $method) : array
    {
        $method = strtoupper($method);
        $routes = [];

        // Add exact routes
        foreach ($this->exactRoutes[$method] ?? [] as $route) {
            $routes[] = $route;
        }

        // Add pattern routes
        foreach ($this->patternRoutes[$method] ?? [] as $route) {
            $routes[] = $route;
        }

        return $routes;
    }

    /**
     * Get all routes grouped by method (legacy format for backward compatibility).
     *
     * @return array<string, RouteDefinition[]>
     */
    public function getAllRoutes() : array
    {
        $allRoutes = [];

        foreach (array_keys($this->exactRoutes + $this->patternRoutes) as $method) {
            $allRoutes[$method] = $this->getAllRoutesForMethod($method);
        }

        return $allRoutes;
    }

    /**
     * Check if a path contains route parameters (indicating pattern route).
     */
    private function isPatternRoute(string $path) : bool
    {
        return str_contains($path, '{') && str_contains($path, '}');
    }

    /**
     * Generate unique key for route deduplication.
     */
    private function generateRouteKey(RouteDefinition $route) : string
    {
        return sprintf(
            '%s|%s|%s',
            strtoupper($route->method),
            $route->domain ?? '',
            $route->path
        );
    }

    /**
     * Get statistics about the route collection.
     *
     * @return array{exact: int, patterns: int, total: int}
     */
    public function getStatistics() : array
    {
        $exactCount = 0;
        foreach ($this->exactRoutes as $routes) {
            $exactCount += count($routes);
        }

        $patternCount = 0;
        foreach ($this->patternRoutes as $routes) {
            $patternCount += count($routes);
        }

        return [
            'exact' => $exactCount,
            'patterns' => $patternCount,
            'total' => $exactCount + $patternCount,
        ];
    }

    /**
     * Clear all routes (for testing/reinitialization).
     */
    public function clear() : void
    {
        $this->exactRoutes = [];
        $this->patternRoutes = [];
        $this->routeKeys = [];
    }
}
=== Routing/RouteDefinition.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * @phpstan-type RouteAction callable|array{0: class-string, 1: string}|string
 * @phpstan-type RouteMiddleware array<string|class-string>
 * @phpstan-type RouteConstraints array<string, string>
 * @phpstan-type RouteDefaults array<string, mixed>
 * @phpstan-type RouteAttributes array<string, mixed>
 * @phpstan-type RouteMetadata array<string, mixed>
 */

use Avax\HTTP\Router\HttpMethod;
use Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException;
use Avax\HTTP\Router\Support\PathNormalizer;
use Closure;
use InvalidArgumentException;
use Laravel\SerializableClosure\SerializableClosure;
use RuntimeException;

/**
 * Immutable data structure representing a registered HTTP route.
 *
 * Supports serializable closures via Laravel\SerializableClosure.
 */
final readonly class RouteDefinition
{
    public readonly string $method;
    public readonly string $path;
    public readonly mixed $action;
    public readonly array $middleware;
    public readonly string $name;
    public readonly array $constraints;
    public readonly array $defaults;
    public readonly string|null $domain;
    public readonly array $attributes;
    public readonly string|null $authorization;
    public readonly array $parameters;
    public readonly array $metadata;

    /**
     * Route specificity score for matching precedence.
     * Higher values = more specific routes matched first.
     * Calculated as: (segment count) - (parameter count)
     */
    public readonly int $specificity;

    /**
     * Precompiled regex pattern for path matching.
     * Compiled once during construction for performance.
     */
    public readonly string $compiledPathRegex;

    /**
     * Route construction ensures deterministic behavior by normalizing paths, validating constraints,
     * and precomputing routing metadata. This prevents runtime errors and ensures consistent
     * route matching across different deployment environments.
     *
     * Path normalization eliminates ambiguity from trailing slashes and multiple separators.
     * Constraint validation prevents ReDoS attacks from malformed regex patterns.
     * Specificity calculation ensures correct precedence ordering during route resolution.
     *
     * @param string      $method        The HTTP method (e.g., GET, POST) for the route.
     * @param string      $path          The URI path for the route.
     * @param mixed       $action        The action or callback associated with the route.
     * @param array       $middleware    An array of middleware to be applied to the route.
     * @param string      $name          The name of the route, optional.
     * @param array       $constraints   An array of constraints for the route parameters.
     * @param array       $defaults      An array of default values for route parameters.
     * @param string|null $domain        The domain name associated with the route, optional.
     * @param array       $attributes    Additional attributes for the route.
     * @param string|null $authorization The authorization key or identifier for the route, optional.
     * @param array       $parameters    An array of parameters to be passed to the route, optional.
     * @param array       $metadata      Rich metadata annotations (API versioning, policies, etc.)
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function __construct(
        string             $method,
        string             $path,
        mixed              $action,
        array              $middleware = [],
        string             $name = '',
        array              $constraints = [],
        array              $defaults = [],
        string|null        $domain = null,
        array              $attributes = [],
        string|null        $authorization = null,
        array              $parameters = [],
        array              $metadata = []
    )
    {
        // Normalize path for consistent routing
        $path = PathNormalizer::normalize($path);

        $this->validateMethod($method);
        $this->validatePath($path);
        $this->validateRouteName($name);
        $this->validateConstraints($constraints);

        // Calculate route specificity: (segment count) - (parameter count)
        // Higher specificity = more specific routes matched first
        $segmentCount = substr_count($path, '/') - ($path === '/' ? 0 : 1); // Don't count leading slash
        $parameterCount = preg_match_all('/\{[^}]+\}/', $path);
        $specificity = $segmentCount - $parameterCount;

        // Precompile regex pattern for performance
        $compiledPathRegex = $this->compileRoutePattern($path, $constraints);

        $this->method = $method;
        $this->path = $path;
        $this->action = $action;
        $this->middleware = $middleware;
        $this->name = $name;
        $this->constraints = $constraints;
        $this->defaults = $defaults;
        $this->domain = $domain;
        $this->attributes = $attributes;
        $this->authorization = $authorization;
        $this->parameters = $parameters;
        $this->metadata = $metadata;
        $this->specificity = $specificity;
        $this->compiledPathRegex = $compiledPathRegex;
    }

    /**
     * Ensures only standard HTTP methods are accepted to prevent security vulnerabilities
     * from malformed or malicious method names that could bypass routing logic.
     *
     * @throws InvalidArgumentException
     */
    private function validateMethod(string $method) : void
    {
        if (! HttpMethod::isValid($method)) {
            throw new InvalidArgumentException(sprintf('Invalid HTTP method: %s', $method));
        }
    }

    /**
     * Prevents malformed paths that could cause routing ambiguities, security issues,
     * or performance problems by ensuring paths follow expected URL structure.
     *
     * @throws InvalidArgumentException
     */
    private function validatePath(string $path) : void
    {
        route_validate_path($path);
    }

    /**
     * Reserves internal route name prefixes to prevent conflicts between user-defined
     * routes and framework-generated routes, avoiding naming collisions and debugging confusion.
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    private function validateRouteName(string $name) : void
    {
        if (! empty($name) && str_starts_with($name, '__avax.')) {
            throw new ReservedRouteNameException($name);
        }
    }

    /**
     * Validates parameter constraints to prevent ReDoS attacks and ensure predictable
     * routing behavior by rejecting malformed regex patterns that could cause performance issues.
     *
     * @throws InvalidArgumentException
     */
    private function validateConstraints(array $constraints) : void
    {
        foreach ($constraints as $pattern) {
            $this->validateConstraintPattern($pattern);
        }
    }

    /**
     * Ensures regex patterns are syntactically correct to prevent runtime errors
     * and potential security issues from malformed constraints during route matching.
     *
     * @throws InvalidArgumentException
     */
    private function validateConstraintPattern(string $pattern) : void
    {
        route_validate_constraint($pattern);
    }

    /**
     * Compiles a route path template into a regex pattern.
     *
     * @param string $template    The route template (e.g., "/users/{id}")
     * @param array  $constraints Parameter constraints
     *
     * @return string The compiled regex pattern
     */
    private function compileRoutePattern(string $template, array $constraints) : string
    {
        $pattern = preg_replace_callback(
            '/\{([^}]+)\}/',
            static function ($matches) use ($constraints) {
                $param      = $matches[1];
                $isOptional = str_ends_with($param, '?');
                $isWildcard = str_ends_with($param, '*');

                $paramName  = preg_replace('/[?*]$/', '', $param);
                $constraint = $constraints[$paramName] ?? '[^/]+';

                $segment = "(?P<{$paramName}>{$constraint})";

                if ($isWildcard) {
                    $segment = "(?P<{$paramName}>.*)";
                }

                if ($isOptional) {
                    $segment = "(?:/{$segment})?";
                } else {
                    $segment = "/{$segment}";
                }

                return $segment;
            },
            $template
        );

        return "#^{$pattern}$#";
    }

    /**
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public static function __set_state(array $properties) : self
    {
        // Normalize path for consistency during unserialization
        $normalizedPath = PathNormalizer::normalize($properties['path']);

        return new self(
            $properties['method'],
            $normalizedPath,
            $properties['action'],
            $properties['middleware'],
            $properties['name'],
            $properties['constraints'],
            $properties['defaults'],
            $properties['domain'],
            $properties['attributes'],
            $properties['authorization'],
            $properties['parameters'] ?? [],
            $properties['metadata'] ?? []
        );
    }

    /**
     * Rehydrate a route definition from cached array data.
     *
     * @param array<string, mixed> $payload
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public static function fromArray(array $payload) : self
    {
        if (! isset($payload['method'], $payload['path'], $payload['action'])) {
            throw new InvalidArgumentException('Cached route payload is missing required fields.');
        }

        if ($payload['action'] instanceof Closure || $payload['action'] instanceof SerializableClosure) {
            throw new RuntimeException('Cached route action must not be a closure.');
        }

        // Normalize path for consistency (though cached paths should already be normalized)
        $normalizedPath = PathNormalizer::normalize($payload['path']);

        return new self(
            $payload['method'],
            $normalizedPath,
            $payload['action'],
            $payload['middleware'] ?? [],
            $payload['name'] ?? '',
            $payload['constraints'] ?? [],
            $payload['defaults'] ?? [],
            $payload['domain'] ?? null,
            $payload['attributes'] ?? [],
            $payload['authorization'] ?? null,
            [],
            $payload['metadata'] ?? []
        );
    }

    /**
     * Returns a copy of the route with the action wrapped in a SerializableClosure (if needed).
     *
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException|\Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function withSerializedAction() : self
    {
        $action = $this->action instanceof Closure
            ? new SerializableClosure(closure: $this->action)
            : $this->action;

        return new self(
            $this->method,
            $this->path,
            $action,
            $this->middleware,
            $this->name,
            $this->constraints,
            $this->defaults,
            $this->domain,
            $this->attributes,
            $this->authorization
        );
    }

    /**
     * Returns a copy of the route with the action unwrapped (if it's a SerializableClosure).
     *
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException
     * @throws \Laravel\SerializableClosure\Exceptions\PhpVersionNotSupportedException|\Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function withUnserializedAction() : self
    {
        $action = $this->action instanceof SerializableClosure
            ? $this->action->getClosure()
            : $this->action;

        return new self(
            $this->method,
            $this->path,
            $action,
            $this->middleware,
            $this->name,
            $this->constraints,
            $this->defaults,
            $this->domain,
            $this->attributes,
            $this->authorization
        );
    }

    /**
     * Checks if the given parameter has a constraint.
     */
    public function hasConstraint(string $parameter) : bool
    {
        return array_key_exists(key: $parameter, array: $this->constraints);
    }

    /**
     * Returns the regex constraint for a route parameter.
     */
    public function getConstraint(string $parameter) : string|null
    {
        return $this->constraints[$parameter] ?? null;
    }

    /**
     * Creates a copy of the route with additional metadata annotation.
     *
     * Enables rich route annotations without coupling:
     * - API versioning: ['api_version' => 'v2']
     * - Rate limiting: ['rate_limit' => '100/hour']
     * - Feature flags: ['feature' => 'beta']
     * - Authorization: ['roles' => ['admin', 'moderator']]
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function withMetadata(string $key, mixed $value) : self
    {
        $metadata       = $this->metadata;
        $metadata[$key] = $value;

        return new self(
            $this->method,
            $this->path,
            $this->action,
            $this->middleware,
            $this->name,
            $this->constraints,
            $this->defaults,
            $this->domain,
            $this->attributes,
            $this->authorization,
            $this->parameters,
            $metadata
        );
    }

    /**
     * Retrieves metadata annotation by key.
     */
    public function getMetadata(string $key, mixed $default = null) : mixed
    {
        return $this->metadata[$key] ?? $default;
    }

    /**
     * Checks if metadata annotation exists.
     */
    public function hasMetadata(string $key) : bool
    {
        return array_key_exists($key, $this->metadata);
    }

    /**
     * Returns all metadata annotations.
     *
     * @return array<string, mixed>
     */
    public function getAllMetadata() : array
    {
        return $this->metadata;
    }

    /**
     * Export the definition into a scalar array suitable for caching.
     *
     * @return array<string, mixed>
     */
    public function toArray() : array
    {
        if ($this->usesClosure() || $this->action instanceof SerializableClosure) {
            throw new RuntimeException('Cannot cache routes that use closures.');
        }

        return [
            'method'        => $this->method,
            'path'          => $this->path,
            'action'        => $this->action,
            'middleware'    => $this->middleware,
            'name'          => $this->name,
            'constraints'   => $this->constraints,
            'defaults'      => $this->defaults,
            'domain'        => $this->domain,
            'attributes'    => $this->attributes,
            'authorization' => $this->authorization,
            'metadata'      => $this->metadata,
            // parameters are runtime-only and not cached
        ];
    }

    public function usesClosure() : bool
    {
        return $this->action instanceof Closure;
    }
}
=== Routing/RouteExecutor.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Dispatcher\ControllerDispatcher;
use Avax\HTTP\Request\Request;
use Psr\Http\Message\ResponseInterface;

/**
 * Executes a matched route by invoking the controller and returning the response.
 *
 * This class encapsulates the execution logic, separating it from matching.
 */
final readonly class RouteExecutor
{
    public function __construct(
        private ControllerDispatcher $controllerDispatcher
    ) {}

    /**
     * Executes the route action and returns the response.
     *
     * @param RouteDefinition $route   The matched route definition.
     * @param Request         $request The HTTP request with injected parameters.
     *
     * @return ResponseInterface The response from the controller.
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     * @throws \ReflectionException
     */
    public function execute(RouteDefinition $route, Request $request) : ResponseInterface
    {
        return $this->controllerDispatcher->dispatch(
            action : $route->action,
            request: $request
        );
    }
}

=== Routing/RouteGroupAttributesConfigurator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use InvalidArgumentException;

/**
 * The `RouteGroupAttributesConfigurator` class is responsible for configuring
 * a route group context by applying a set of attributes like prefix, middleware,
 * domain, and more.
 *
 * This class uses the Strategy design pattern to map each attribute to its
 * respective handler, ensuring extensibility and separation of responsibilities.
 */
final class RouteGroupAttributesConfigurator
{
    /**
     * Map of supported route group attributes and their respective handlers,
     * defined as callable strategies. Each attributes key maps to a closure/function
     * that modifies the `RouteGroupContext`.
     *
     * @var array<string, callable(RouteGroupContext, mixed): void> A map of attribute keys and their handlers.
     */
    private array $strategies;

    /**
     * Constructor of the class.
     *
     * Initializes the mapping of available attribute handlers (`$strategies`) with
     * their processing logic defined as closures. Using constructor promotion for
     * a lean and expressive instantiation process.
     */
    public function __construct()
    {
        // Initializes the strategy map with closures for each supported attribute:
        $this->strategies = [
            /**
             * Strategy for handling 'prefix' - converts the value to a string
             * and applies it as a prefix to the route group context.
             */
            'prefix'     => fn(RouteGroupContext $context, mixed $value) => $context->setPrefix(prefix: (string) $value),

            /**
             * Strategy for handling 'middleware' - converts the value to an array
             * and appends the middleware to the route group context.
             */
            'middleware' => fn(RouteGroupContext $context, mixed $value) => $context->addMiddleware(
                middleware: (array) $value
            ),

            /**
             * Strategy for handling 'domain' - converts the value to a string
             * and sets it as the domain for the route group context.
             */
            'domain'     => fn(RouteGroupContext $context, mixed $value) => $context->setDomain(domain: (string) $value),

            /**
             * Strategy for handling 'name' - converts the value to a string
             * and applies it as a prefix to the names of route group context
             * names.
             */
            'name'       => fn(RouteGroupContext $context, mixed $value) => $context->setNamePrefix(
                prefix: (string) $value
            ),

            /**
             * Strategy for handling 'authorize' - converts the value to a string
             * and sets it as authorization for the route group context.
             */
            'authorize'  => fn(RouteGroupContext $context, mixed $value) => $context->setAuthorization(
                authorization: (string) $value
            ),

            // Additional attribute types can be added here following the same pattern, maintaining extensibility.
        ];
    }

    /**
     * Applies the provided attributes to the given route group context.
     *
     * Iterates through each key-value pair of attributes, validates the key
     * against the supported strategies, and applies the corresponding
     * handler to modify the `RouteGroupContext`.
     *
     * @param array<string, mixed> $attributes    A map of attributes to be configured for the route group context
     *                                            (e.g.,
     *                                            'prefix' => '/api').
     * @param RouteGroupContext    $context       The route group context where the attributes will be applied.
     *
     * @throws InvalidArgumentException If an attribute key is not recognized or unsupported.
     */
    public function apply(array $attributes, RouteGroupContext $context) : void
    {
        // Iterate over each key-value pair of attributes.
        foreach ($attributes as $attribute => $value) {
            // Check if the attribute is supported by existing strategies.
            if (! isset($this->strategies[$attribute])) {
                // If not supported, throw an exception to enforce proper usage.
                throw new InvalidArgumentException(
                    message: sprintf('Unsupported route group attribute: %s', $attribute)
                );
            }

            // Execute the corresponding strategy using a callable, passing in
            // the target context and the attribute value.
            ($this->strategies[$attribute])($context, $value);
        }
    }
}

=== Routing/RouteGroupBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\HttpMethod;
use Closure;
use InvalidArgumentException;
use RuntimeException;

/**
 * Builder class for defining grouped routes in a fluent, immutable way.
 *
 * Supports:
 * - Prefix inheritance
 * - Shared middleware
 * - Domain pattern binding
 * - Route-level authorization
 * - Group composition via callback (closure nesting)
 */
final readonly class RouteGroupBuilder
{
    /**
     * @param array<string>  $middleware
     * @param RouteBuilder[] $routes
     */
    private function __construct(
        private string|null $prefix = null,
        private array       $middleware = [],
        private string|null $domain = null,
        private string|null $authorization = null,
        private array       $routes = []
    ) {}

    /**
     * Factory method to create a new, empty RouteGroup instance.
     *
     * @return self A new RouteGroup object representing a blank, default group.
     */
    public static function create() : self
    {
        // Create and return a new RouteGroup instance with default settings.
        return new self;
    }

    /**
     * Creates a new RouteGroup with a specified prefix.
     *
     * @param string $prefix The prefix to apply to all routes in the group.
     *
     * @return self A new RouteGroup object with the specified prefix.
     */
    public function withPrefix(string $prefix) : self
    {
        // Creates a new immutable route group with the modified prefix.
        return new self(
            prefix       : rtrim(string: $prefix, characters: '/'), // Ensure no trailing slash on the prefix.
            middleware   : $this->middleware, // Reuse the existing middleware.
            domain       : $this->domain, // Keep the existing domain value.
            authorization: $this->authorization, // Maintain the same authorization.
            routes       : $this->routes // Carry over the existing routes.
        );
    }

    /**
     * Adds middleware to this group's middleware stack.
     * The middleware list is merged with any existing middlewares.
     *
     * @param array<string> $middleware A list of middleware to add to the group.
     *
     * @return self A new RouteGroup object with the updated middleware stack.
     */
    public function withMiddleware(array $middleware) : self
    {
        // Create a new immutable instance with the combined middleware.
        return new self(
            prefix       : $this->prefix, // Retain the existing route prefix.
            middleware   : array_merge($this->middleware, $middleware), // Merge old and new middleware.
            domain       : $this->domain, // Keep the existing domain restriction.
            authorization: $this->authorization, // Maintain the same authorization.
            routes       : $this->routes // Preserve the existing group routes.
        );
    }

    /**
     * Defines an authorization policy for all routes in this group.
     *
     * @param string $policy The name of the authorization policy to apply.
     *
     * @return self A new RouteGroup object with the specified authorization policy.
     */
    public function withAuthorization(string $policy) : self
    {
        // Create a new immutable instance with the updated authorization policy.
        return new self(
            prefix       : $this->prefix, // Reuse the existing route prefix.
            middleware   : $this->middleware, // Retain the middleware stack.
            domain       : $this->domain, // Keep the domain restriction as is.
            authorization: $policy, // Apply the new authorization policy.
            routes       : $this->routes // Carry over the route definitions.
        );
    }

    /**
     * Adds one or more routes via closure DSL.
     *
     * Example:
     * ```
     * ->withRoutes(fn(RouteGroupBuilder $g) => $g
     *      ->addRoute(...)->addRoute(...)
     * )
     * ```
     */
    public function withRoutes(Closure $callback) : self
    {
        // Invoke the callback, passing a cloned instance of the current object ($this).
        // This allows the callback to define routes within its own scope without altering the original object.
        $nested = $callback(clone $this);

        // Check if the result of the callback is an instance of the current class (RouteGroupBuilder).
        // If not, throw a RuntimeException to ensure the callback strictly returns a valid RouteGroupBuilder instance.
        if (! $nested instanceof self) {
            throw new RuntimeException(message: 'Callback to withRoutes() must return a RouteGroupBuilder instance.');
        }

        // Return a new instance of the RouteGroupBuilder class,
        // preserving the prefix, middleware, domain, and authorization of the current instance.
        // For routes, merge the routes from the current instance ($this->routes) with those from the nested instance ($nested->routes).
        // The new instance represents the combined state of the current and nested route group builders.
        return new self(
            prefix       : $this->prefix,        // Maintain the prefix of the current route group.
            middleware   : $this->middleware,    // Maintain the middleware of the current route group.
            domain       : $this->domain,        // Maintain the domain of the current route group.
            authorization: $this->authorization, // Maintain the authorization policies of the current route group.
            routes       : [...$this->routes, ...$nested->routes] // Merge the existing and nested routes.
        );
    }

    /**
     * Adds a single route to the group.
     *
     * @param string                $method HTTP verb
     * @param string                $path   Route path
     * @param callable|array|string $action Target controller or callable
     */
    public function addRoute(string $method, string $path, callable|array|string $action) : self
    {
        // Validate if the provided HTTP method is valid using the HttpMethod enumeration.
        // Throw an exception if the HTTP method is invalid.
        if (! HttpMethod::isValid(method: $method)) {
            throw new InvalidArgumentException(message: "Invalid HTTP method: {$method}");
        }

        // Create a new RouteBuilder instance with the validated HTTP method and the prefixed path.
        // Assign the provided action (e.g., controller method or callback) to the route.
        // Assign middleware (e.g., authentication, logging) to the route.
        $route = RouteBuilder::make(
            method: $method,
            path  : $this->applyPrefix(path: $path)

        )
            ->action(action: $action)
            ->middleware(middleware: $this->middleware);

        // Add a domain to the route if a specific domain is defined.
        if ($this->domain !== null) {
            $route = $route->withDomain(domain: $this->domain);
        }

        // Assign an authorization policy to the route if one is provided.
        if ($this->authorization !== null) {
            $route = $route->authorize(policy: $this->authorization);
        }

        // Create a new instance of the current class, extending the existing routes
        // with the newly configured route, and preserving other properties like
        // prefix, middleware, domain, and authorization.
        return new self(
        // Maintain the current URL prefix for the routes.
            prefix       : $this->prefix,
            // Maintain the current list of middleware.
            middleware   : $this->middleware,
            // Maintain the current domain (if any).
            domain       : $this->domain,
            // Maintain the current authorization policy (if any).
            authorization: $this->authorization,
            // Append the newly configured route to the list of existing routes.
            routes       : [...$this->routes, $route]
        );
    }

    /**
     * Factory method to create a new instance of the RouteGroupBuilder class.
     *
     * This method acts as the default entry point for creating a new route group object.
     * It ensures a clean, well-defined instantiation process that allows for method chaining
     * and controlled manipulation of routes and associated properties like middleware,
     * authorization, and prefix. Ideal for managing route groups in scalable applications.
     *
     * @return self Returns a new instance of the RouteGroupBuilder class.
     */
    public static function make() : self
    {
        // Instantiate and return a new RouteGroupBuilder with default values.
        return new self;
    }

    /**
     * Applies the group prefix to a given path.
     *
     * This method is responsible for ensuring that routes within a group
     * are correctly prefixed. If no prefix is defined (i.e., `$prefix` is null),
     * it returns the provided path as-is. Otherwise, it joins the prefix and path
     * with a single forward slash (`/`) to preserve uniformity in URL structure.
     *
     * @param string $path The specific route path to which the prefix should be applied.
     *
     * @return string The modified path with the applied prefix, or the original path if no prefix is set.
     */
    private function applyPrefix(string $path) : string
    {
        // Check if the `prefix` property is null (no prefix defined).
        // If null, simply return the provided path without any modifications.
        if ($this->prefix === null) {
            return $path;
        }

        // Append the given path to the prefix while managing slash consistency.
        // - Use `rtrim` to strip any trailing slashes from the prefix.
        // - Use `ltrim` to remove any leading slashes from the provided path.
        // - This ensures a single forward slash (`/`) separates the prefix and path.
        return rtrim(string: $this->prefix, characters: '/') . '/' . ltrim(string: $path, characters: '/');
    }

    /**
     * Sets a domain constraint for all routes in the group.
     *
     * This method is part of the fluent API for configuring route groups.
     * It allows you to specify that all routes in the group should apply
     * to a specific domain. This is useful for implementing multi-tenant
     * architectures, subdomain routing, or domain-specific behavior.
     *
     * @param string $domain    The domain constraint to be applied to the routes
     *                          within this group.
     *
     * @return self Returns a new instance of the `RouteGroupBuilder` class
     *              with the specified domain applied, ensuring immutability.
     */
    public function withDomain(string $domain) : self
    {
        // Create and return a new instance of the RouteGroupBuilder class
        // with the updated domain while preserving all other properties.
        return new self(
            prefix       : $this->prefix,        // Keep the current route prefix.
            middleware   : $this->middleware,    // Retain the middleware stack.
            domain       : $domain,              // Set the new domain constraint.
            authorization: $this->authorization, // Retain the authorization policy.
            routes       : $this->routes         // Retain the existing routes.
        );
    }

    /**
     * Builds all defined routes.
     *
     * Converts the routes defined within the `RouteGroupBuilder` to their
     * respective `RouteDefinition` objects by invoking their `build()`
     * methods. This allows the route definitions to be finalized and used
     * by the routing system.
     *
     * This method adheres to the principle of immutability by performing its
     * operations without modifying the internal state of the `RouteGroupBuilder`.
     * This makes the function predictable and side effect free.
     *
     * @return RouteDefinition[] An array of `RouteDefinition` instances,
     *                           representing the fully finalized routes
     *                           within this route group.
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public function build() : array
    {
        // Use array_map to iterate over the list of routes and
        // invoke the `build()` method on each `RouteBuilder` instance.
        // This results in an array where every route is now a finalized
        // `RouteDefinition` object.
        return array_map(
            callback: static fn(RouteBuilder $r) => $r->build(), // Transform RouteBuilder into RouteDefinition.
            array   : $this->routes                // The array of RouteBuilder instances to process.
        );
    }

    /**
     * Internal helper method to apply the groups prefix to a given path.
     *
     * This function ensures that all paths defined in the route group are
     * consistent and properly prefixed. For instance, if the group has a prefix
     * like `/admin`, each route within it will start with `/admin`.
     *
     * - If no prefix is set (`$this->prefix` is null), the method simply returns the original path.
     * - Otherwise, it concatenates the prefix to the given path string.
     *
     * This approach adheres to clean code principles by isolating this functionality
     * within a private helper, ensuring the prefix logic remains reusable and easily testable.
     *
     * @param string $path The original route path to be prefixed.
     *
     * @return string Returns the prefixed path, or the original if no prefix is defined.
     */
    private function prefixed(string $path) : string
    {
        // Check if the prefix is not set; if null, return the path as is.
        if ($this->prefix === null) {
            return $path;
        }

        // Concatenate the prefix with the provided path and return it.
        return $this->prefix . $path;
    }
}

=== Routing/RouteGroupContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Context object for route group configuration.
 *
 * Encapsulates all group-level settings (prefix, middleware, constraints, etc.)
 * that apply to routes defined within the group scope.
 */
final class RouteGroupContext
{
    private string $prefix = '';
    private string $namePrefix = '';
    private string|null $domain = null;
    private string|null $authorization = null;

    /**
     * @var array<string>
     */
    private array $middleware = [];

    /**
     * @var array<string, string>
     */
    private array $constraints = [];

    /**
     * @var array<string, mixed>
     */
    private array $defaults = [];

    /**
     * @var array<string, mixed>
     */
    private array $attributes = [];

    /**
     * Apply this context to a route builder.
     */
    public function applyTo(RouteBuilder $builder) : RouteBuilder
    {
        if (! empty($this->prefix)) {
            $builder->prefix($this->prefix);
        }

        if (! empty($this->namePrefix)) {
            $builder->name($this->namePrefix);
        }

        if ($this->domain !== null) {
            $builder->domain($this->domain);
        }

        if ($this->authorization !== null) {
            $builder->authorize($this->authorization);
        }

        if (! empty($this->middleware)) {
            $builder->middleware($this->middleware);
        }

        if (! empty($this->constraints)) {
            $builder->where($this->constraints);
        }

        if (! empty($this->defaults)) {
            $builder->defaults($this->defaults);
        }

        if (! empty($this->attributes)) {
            $builder->attributes($this->attributes);
        }

        return $builder;
    }

    public function setPrefix(string $prefix) : void
    {
        $this->prefix = $prefix;
    }

    public function setNamePrefix(string $prefix) : void
    {
        $this->namePrefix = $prefix;
    }

    public function setDomain(string $domain) : void
    {
        $this->domain = $domain;
    }

    public function setAuthorization(string $authorization) : void
    {
        $this->authorization = $authorization;
    }

    /**
     * @param array<string> $middleware
     */
    public function addMiddleware(array $middleware) : void
    {
        $this->middleware = array_merge($this->middleware, $middleware);
    }

    /**
     * @param array<string, string> $constraints
     */
    public function addConstraints(array $constraints) : void
    {
        $this->constraints = array_merge($this->constraints, $constraints);
    }

    /**
     * @param array<string, mixed> $defaults
     */
    public function addDefaults(array $defaults) : void
    {
        $this->defaults = array_merge($this->defaults, $defaults);
    }

    /**
     * @param array<string, mixed> $attributes
     */
    public function addAttributes(array $attributes) : void
    {
        $this->attributes = array_merge($this->attributes, $attributes);
    }

    /**
     * Create a new context by merging this context with another.
     */
    public function merge(self $other) : self
    {
        $merged = new self();

        $merged->prefix = $this->prefix . $other->prefix;
        $merged->namePrefix = $this->namePrefix . $other->namePrefix;
        $merged->domain = $other->domain ?? $this->domain;
        $merged->authorization = $other->authorization ?? $this->authorization;
        $merged->middleware = array_merge($this->middleware, $other->middleware);
        $merged->constraints = array_merge($this->constraints, $other->constraints);
        $merged->defaults = array_merge($this->defaults, $other->defaults);
        $merged->attributes = array_merge($this->attributes, $other->attributes);

        return $merged;
    }

    /**
     * Check if this context has any configuration.
     */
    public function isEmpty() : bool
    {
        return empty($this->prefix) &&
               empty($this->namePrefix) &&
               $this->domain === null &&
               $this->authorization === null &&
               empty($this->middleware) &&
               empty($this->constraints) &&
               empty($this->defaults) &&
               empty($this->attributes);
    }
}
=== Routing/RouteGroupStack.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Instance-based stack for managing route group contexts.
 *
 * Replaces static global state with proper dependency injection.
 * Each RouterDsl instance gets its own RouteGroupStack for isolation.
 */
final class RouteGroupStack
{
    /**
     * Stack of route group contexts for managing nested routing configurations.
     *
     * @var RouteGroupContext[]
     */
    private array $stack = [];

    /**
     * Create a new RouteGroupStack instance.
     */
    public function __construct() {}

    /**
     * Pushes a new RouteGroupContext onto the stack.
     *
     * @param RouteGroupContext $group The context to be added to the stack.
     */
    public function push(RouteGroupContext $group) : void
    {
        $this->stack[] = $group;
    }

    /**
     * Pops the most recently added RouteGroupContext from the stack.
     */
    public function pop() : void
    {
        array_pop($this->stack);
    }

    /**
     * Applies current context configuration to a RouteBuilder.
     *
     * @param RouteBuilder $builder The builder to configure.
     *
     * @return RouteBuilder The configured builder.
     */
    public function applyTo(RouteBuilder $builder) : RouteBuilder
    {
        $context = $this->current();

        return $context?->applyTo(builder: $builder) ?? $builder;
    }

    /**
     * Retrieves the current (top-most) RouteGroupContext from the stack.
     *
     * @return RouteGroupContext|null The current context or null if stack is empty.
     */
    public function current() : RouteGroupContext|null
    {
        return end($this->stack) ?: null;
    }

    /**
     * Checks if the stack is empty.
     */
    public function isEmpty() : bool
    {
        return empty($this->stack);
    }

    /**
     * Gets the current stack depth.
     */
    public function depth() : int
    {
        return count($this->stack);
    }

    /**
     * Captures current stack state for snapshot/restore operations.
     *
     * @return RouteGroupContext[]
     */
    public function snapshot() : array
    {
        return $this->stack;
    }

    /**
     * Restores stack to a previously captured state.
     *
     * @param RouteGroupContext[] $stack
     */
    public function restore(array $stack) : void
    {
        $this->stack = $stack;
    }

    /**
     * Clears the entire stack (used for cleanup/testing).
     */
    public function clear() : void
    {
        $this->stack = [];
    }
}

=== Routing/RouteKey.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Value object representing a unique route identifier.
 *
 * Encapsulates the logic for route deduplication by combining method, domain,
 * and path into a canonical key. Supports configurable duplicate handling policies.
 */
final readonly class RouteKey
{
    public function __construct(
        public string $method,
        public string $domain,
        public string $path
    ) {}

    /**
     * Create RouteKey from a RouteDefinition.
     */
    public static function fromRoute(RouteDefinition $route) : self
    {
        return new self(
            method: strtoupper($route->method),
            domain: $route->domain ?? '',
            path: $route->path
        );
    }

    /**
     * Get the canonical string representation of this route key.
     *
     * Format: "METHOD|DOMAIN|PATH"
     */
    public function toString() : string
    {
        return "{$this->method}|{$this->domain}|{$this->path}";
    }

    /**
     * Check if this key conflicts with another route key.
     *
     * Two keys conflict if they have the same method, domain, and path.
     */
    public function conflictsWith(self $other) : bool
    {
        return $this->method === $other->method &&
               $this->domain === $other->domain &&
               $this->path === $other->path;
    }

    /**
     * Check if this key represents an ANY method route.
     */
    public function isAnyMethod() : bool
    {
        return $this->method === 'ANY';
    }

    /**
     * Check if this key would conflict with an ANY method route for the same path/domain.
     */
    public function conflictsWithAnyMethod(self $anyMethodKey) : bool
    {
        return $anyMethodKey->isAnyMethod() &&
               $this->domain === $anyMethodKey->domain &&
               $this->path === $anyMethodKey->path;
    }

    /**
     * Get a human-readable description of this route key.
     */
    public function describe() : string
    {
        $domain = $this->domain ?: '(no domain)';
        return "[{$this->method}] {$this->path} @ {$domain}";
    }
}
=== Routing/RouteMatcher.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\HttpMethod;
use Avax\HTTP\Router\Matching\RouteMatcherInterface;
use Avax\HTTP\Router\Support\DomainPatternCompiler;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;

/**
 * Pure route matching logic, separated from execution.
 *
 * This class encapsulates the algorithm for finding a route that matches
 * the given HTTP request based on method, path, and constraints.
 */
final readonly class RouteMatcher implements RouteMatcherInterface
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    /**
     * Checks if a single route matches the given request.
     *
     * Uses precompiled regex pattern for performance.
     *
     * @param RouteDefinition $route   The route to check
     * @param Request         $request The HTTP request
     *
     * @return bool True if the route matches
     */
    public function matches(RouteDefinition $route, Request $request) : bool
    {
        $method = strtoupper($request->getMethod());

        // Check if route method matches (or is ANY)
        if ($route->method !== $method && $route->method !== HttpMethod::ANY->value) {
            return false;
        }

        $uriPath = $request->getUri()->getPath();

        // Sanitize URI path
        $uriPath = filter_var($uriPath, FILTER_SANITIZE_URL);
        if ($uriPath === false || ! is_string($uriPath)) {
            return false;
        }

        $host = $request->getUri()->getHost();

        // Check domain constraint if present
        if ($route->domain !== null) {
            $compiled = DomainPatternCompiler::compile(pattern: $route->domain);
            if (! DomainPatternCompiler::match(host: $host, compiled: $compiled)) {
                return false;
            }
        }

        // Check path pattern using precompiled regex for performance
        return preg_match($route->compiledPathRegex, $uriPath) === 1;
    }

    /**
     * Matches the given request to a registered route.
     *
     * Routes should be in format: array<string, array<string, RouteDefinition>>
     * Where key is HTTP method, value is array<path, RouteDefinition>
     *
     * @param Request $request The HTTP request to match.
     *
     * @return array{RouteDefinition, array}|null The matched route definition and regex matches, or null.
     */
    public function match(array $routes, Request $request) : array|null
    {
        $method = strtoupper($request->getMethod());

        // Validate HTTP method
        if (! in_array($method, ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'ANY'], true)) {
            throw new InvalidArgumentException(message: "Malformed HTTP method: {$method}");
        }

        $uriPath = $request->getUri()->getPath();

        // Sanitize URI path
        $uriPath = filter_var($uriPath, FILTER_SANITIZE_URL);
        if ($uriPath === false || ! is_string($uriPath)) {
            throw new InvalidArgumentException(message: 'Invalid URI path');
        }

        $host = $request->getUri()->getHost();

        $this->logger->debug(message: 'Matching route.', context: [
            'method' => $method,
            'path'   => $uriPath,
            'host'   => $host,
        ]);

        $methodsToTry = [$method];
        if ($method !== HttpMethod::ANY->value) {
            $methodsToTry[] = HttpMethod::ANY->value;
        }

        foreach ($methodsToTry as $methodToTry) {
            foreach ($routes[$methodToTry] ?? [] as $route) {
                if ($route->domain !== null) {
                    $compiled = DomainPatternCompiler::compile(pattern: $route->domain);
                    if (! DomainPatternCompiler::match(host: $host, compiled: $compiled)) {
                        continue;
                    }
                }

                // Use precompiled regex pattern for performance
                $matches = [];

                if (preg_match($route->compiledPathRegex, $uriPath, $matches)) {
                    return [$route, $matches];
                }
            }
        }

        return null;
    }

    // Helper methods from HttpRequestRouter

    private function compileRoutePattern(string $template, array $constraints) : string
    {
        // PERFORMANCE: Compile route pattern from template and constraints
        $pattern = preg_replace_callback(
            '/\{([^}]+)\}/',
            static function ($matches) use ($constraints) {
                $param      = $matches[1];
                $isOptional = str_ends_with($param, '?');
                $isWildcard = str_ends_with($param, '*');

                $paramName  = preg_replace('/[?*]$/', '', $param);
                $constraint = $constraints[$paramName] ?? '[^/]+';

                $segment = "(?P<{$paramName}>{$constraint})";

                if ($isWildcard) {
                    $segment = "(?P<{$paramName}>.*)";
                }

                if ($isOptional) {
                    $segment = "(?:/{$segment})?";
                } else {
                    $segment = "/{$segment}";
                }

                return $segment;
            },
            $template
        );

        return "#^{$pattern}$#";
    }

    private function extractParameters(array $matches) : array
    {
        $params = array_filter($matches, static fn($key) => ! is_int($key), ARRAY_FILTER_USE_KEY);

        // Sanitize parameter values
        foreach ($params as $key => $value) {
            $params[$key] = filter_var($value, FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES);
        }

        return $params;
    }
}
=== Routing/RouteMiddleware.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Request\Request;
use Closure;
use Psr\Http\Message\ResponseInterface;

/**
 * Interface for route middleware components.
 *
 * Middleware implementing this interface can be applied to routes
 * and will be executed as part of the request processing pipeline.
 */
interface RouteMiddleware
{
    /**
     * Processes the request and optionally calls the next middleware/stage.
     *
     * @param Closure(Request): ResponseInterface $next The next middleware/stage in the pipeline
     */
    public function handle(Request $request, Closure $next) : ResponseInterface;
}
=== Routing/RoutePipeline.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\Auth\Interface\HTTP\Middleware\AuthorizeMiddleware;
use Avax\Container\Features\Core\Contracts\ContainerInterface;
use Avax\HTTP\Dispatcher\ControllerDispatcher;
use Avax\HTTP\Request\Request;
use Laravel\SerializableClosure\SerializableClosure;
use Psr\Http\Message\ResponseInterface;

/**
 * Class RoutePipeline
 *
 * Manages the execution pipeline for handling incoming HTTP requests
 * through applied middleware, optional route stages, and finally dispatching
 * the matched route action to the appropriate controller.
 *
 * Responsibilities:
 * - Applies middleware and route-specific stages (e.g., logging, tracing).
 * - Injects route-level authorization middleware when necessary.
 * - Provides a fluent API for pipeline configuration.
 */
final class RoutePipeline
{
    /**
     * List of middleware to be applied in the processing pipeline.
     *
     * @var array<string|class-string>
     */
    private array $middleware = [];

    /**
     * Optional predefined stages (e.g., for logging, tracing) to augment the pipeline.
     *
     * @var array<class-string<RouteStage>>
     */
    private array $stages = [];

    /**
     * Constructor
     *
     * Initializes the pipeline using the provided route definition and dispatcher.
     *
     * @param RouteDefinition      $route      The route definition to bind to the pipeline.
     * @param ControllerDispatcher $dispatcher Handles the final dispatching of the controller action.
     */
    public function __construct(
        private readonly RouteDefinition      $route,
        private readonly ControllerDispatcher $dispatcher,
        private readonly ContainerInterface   $container,
        private readonly StageChain           $stageChain
    ) {}

    /**
     * Factory method for constructing the pipeline instance
     * with the route and dispatcher, promoting fluent API usage.
     *
     * @param RouteDefinition      $route      The route definition to be handled.
     * @param ControllerDispatcher $dispatcher Used to invoke controller methods.
     *
     * @return self A new instance of RoutePipeline.
     */
    public static function for(
        RouteDefinition      $route,
        ControllerDispatcher $dispatcher,
        ContainerInterface   $container
    ) : self
    {
        return new self(
            route     : $route,
            dispatcher: $dispatcher,
            container : $container
        );
    }

    /**
     * Adds middleware to the processing pipeline.
     *
     * Allows dynamic insertion of middleware for the current route processing.
     *
     * @param array<string|class-string> $middleware Array of middleware class names or middleware identifiers.
     *
     * @return self The current instance, for fluent API usage.
     */
    public function through(array $middleware) : self
    {
        $this->middleware = $middleware;

        return $this;
    }

    /**
     * Adds optional stages to the processing pipeline.
     *
     * Stages add auxiliary functionality to the route processing, like logging
     * or telemetry tracking, without interfering with core middleware logic.
     *
     * @param array<class-string<RouteStage>> $stages List of stage class names.
     *
     * @return self The current instance, for fluent API chaining.
     */
    public function stages(array $stages) : self
    {
        $this->stages = $stages;

        return $this;
    }

    /**
     * Dispatches a request through the pipeline.
     *
     * The dispatch process follows these steps:
     * - Optionally injects authorization middleware if the route requires it.
     * - Builds the middleware pipeline, including optional stages.
     * - Executes the pipeline, ultimately invoking the associated route action.
     *
     * @param Request $request The current HTTP request to process.
     *
     * @return ResponseInterface The final HTTP response from the dispatched route.
     *
     * @throws \ReflectionException If reflection fails during middleware creation.
     * @throws \Psr\Container\ContainerExceptionInterface If the DI container encounters an issue.
     * @throws \Psr\Container\NotFoundExceptionInterface If a middleware class cannot be resolved.
     */
    public function dispatch(Request $request) : ResponseInterface
    {
        // Inject route authorization into the request if a policy is defined.
        if ($this->route->authorization !== null) {
            // Attach the authorization policy as a request attribute.
            $request = $request->withAttribute(name: 'route:authorization', value: $this->route->authorization);

            // Prepend the authorization middleware to the pipeline.
            array_unshift($this->middleware, AuthorizeMiddleware::class);
        }

        // Unserialize the route action if it's a SerializableClosure
        $route = $this->route;
        if ($route->action instanceof SerializableClosure) {
            $route = $route->withUnserializedAction();
        }

        // Define the core execution logic for the pipeline - dispatching the route's action.
        $core = fn(Request $request) : ResponseInterface => $this->dispatcher->dispatch(
            action : $route->action,
            request: $request
        );

        // Build the ordered pipeline using StageChain diagnostics.
        $stack = $this->stageChain->create(
            stages    : $this->stages,
            middleware: $this->middleware,
            core      : $core
        );

        return $stack($request);
    }
}

=== Routing/RoutePipelineFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\Container\Features\Core\Contracts\ContainerInterface;
use Avax\HTTP\Dispatcher\ControllerDispatcher;
use Avax\HTTP\Middleware\MiddlewareResolver;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;

/**
 * Factory class that constructs and initializes a complete route pipeline for dispatch.
 *
 * The `RoutePipelineFactory` is a fundamental part of request handling. It integrates
 * the resolved middleware, the routing definitions, and dependencies like the controller
 * dispatcher and IoC container to create a fully prepared route execution pipeline.
 */
final readonly class RoutePipelineFactory
{
    /**
     * Constructor for the RoutePipelineFactory.
     *
     * This method leverages the constructor promotion feature in PHP to simplify property initialization.
     * The dependencies required for constructing a route pipelineIoC
     * container, controller dispatcher, and middleware resolverare injected via the constructor.
     *
     * @param ContainerInterface   $container          The application container for managing services.
     * @param ControllerDispatcher $dispatcher         The dispatcher responsible for managing controller execution.
     * @param MiddlewareResolver   $middlewareResolver Middleware resolver for resolving middleware definitions.
     */
    public function __construct(
        private ContainerInterface   $container,
        private ControllerDispatcher $dispatcher,
        private MiddlewareResolver   $middlewareResolver,
        private StageChain           $stageChain,
        private LoggerInterface      $logger = new NullLogger,
    ) {}

    /**
     * Factory method for creating a fully resolved route pipeline.
     *
     * This method uses the provided route definition to fetch middleware, resolve their instances
     * using the MiddlewareResolver, and then constructs a new RoutePipeline. The pipeline
     * is configured with middleware and is ready for dispatch.
     *
     * @param RouteDefinition $route The route definition, containing route-specific information such as middleware.
     *
     * @return RoutePipeline A fully constructed pipeline configured with resolved middleware.
     */
    public function create(RouteDefinition $route) : RoutePipeline
    {
        // Resolving middleware definitions from the route into callable middleware instances.
        $resolvedMiddleware = $this->middlewareResolver->resolve(middleware: $route->middleware);

        $this->logger->debug(message: 'Assembling route pipeline.', context: [
            'route'      => $route->name ?: $route->path,
            'middleware' => $resolvedMiddleware,
            'stages'     => [],
            'order'      => ['stages', 'middleware', 'dispatch'],
        ]);

        // Constructing a new RoutePipeline with the resolved dependencies and injecting middleware.
        // This step prepares the pipeline to handle HTTP requests for the given route.
        return (new RoutePipeline(
            route     : $route,
            dispatcher: $this->dispatcher,
            container : $this->container,
            stageChain: $this->stageChain
        ))->through(middleware: $resolvedMiddleware);
    }
}

=== Routing/RouteRegistrarProxy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\Support\RouteRegistry;

/**
 * Proxy that wraps a RouteBuilder and lazily registers the route
 * only once it's finalized (via name(), build(), or register()).
 *
 * Promotes clean chaining via fluent DSL.
 */
final class RouteRegistrarProxy
{
    private readonly RouteBuilder $builder;

    private readonly HttpRequestRouter $router;

    private readonly RouteRegistry $registry;

    private bool $registered = false;

    /**
     * Initializes proxy with Router and Builder.
     */
    public function __construct(HttpRequestRouter $router, RouteBuilder $builder, RouteRegistry $registry)
    {
        $this->router   = $router;
        $this->builder  = $builder;
        $this->registry = $registry;
    }

    /**
     * Assigns a route name and triggers registration.
     */
    public function name(string $name) : self
    {
        $this->builder->name(name: $name);

        $this->register();

        return $this;
    }

    /**
     * Explicitly triggers registration (if not already).
     */
    public function register() : self
    {
        if (! $this->registered) {
            // Add route builder to registry for later processing
            $this->registry->add(builder: $this->builder);

            $this->registered = true;
        }

        return $this;
    }

    /**
     * Finalizes and returns the RouteDefinition (registers first).
     *
     * @internal Use fluent methods instead.
     */
    public function build() : RouteDefinition
    {
        return $this->builder->build();
    }

    /**
     * Adds a single route parameter constraint.
     */
    public function where(string $param, string $pattern) : self
    {
        $this->builder->where(parameter: $param, pattern: $pattern);

        return $this;
    }

    /**
     * Adds multiple constraints.
     */
    public function whereIn(array $constraints) : self
    {
        $this->builder->whereIn(constraints: $constraints);

        return $this;
    }

    /**
     * Defines default values for parameters.
     */
    public function defaults(array $defaults) : self
    {
        $this->builder->defaults(defaults: $defaults);

        return $this;
    }

    /**
     * Defines custom route metadata.
     */
    public function attributes(array $attributes) : self
    {
        $this->builder->attributes(attributes: $attributes);

        return $this;
    }

    /**
     * Attaches middleware to the route.
     */
    public function middleware(array $middleware) : self
    {
        $this->builder->middleware(middleware: $middleware);

        return $this;
    }

    /**
     * Sets the authorization policy.
     */
    public function authorize(string $policy) : self
    {
        $this->builder->authorize(policy: $policy);

        return $this;
    }

    /**
     * Sets the controller + method for the route.
     */
    public function controller(string $controller, string $method = 'index') : self
    {
        $this->builder->controller(controller: $controller, method: $method);

        return $this;
    }

    /**
     * Sets the action callback or controller.
     */
    public function action(callable|array|string $action) : self
    {
        $this->builder->action(action: $action);

        return $this;
    }
}
=== Routing/RouteResolutionContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Structured context object for route resolution debugging and analysis.
 *
 * Provides comprehensive information about how and why a specific route was
 * selected, enabling advanced introspection, audit logging, and testing visibility.
 *
 * Replaces simple RouteDefinition returns with rich context for enterprise debugging.
 */
final readonly class RouteResolutionContext
{
    public function __construct(
        public RouteDefinition $route,
        public array           $parameters,
        public string|null     $matchedDomain,
        public float           $matchTimeMs,
        public array           $resolutionPath = [],
        public string|null     $failureReason = null,
    ) {}

    /**
     * Creates a successful resolution context.
     */
    public static function success(
        RouteDefinition $route,
        array           $parameters,
        string|null     $matchedDomain,
        float           $matchTimeMs,
        array           $resolutionPath = []
    ) : self
    {
        return new self(
            route         : $route,
            parameters    : $parameters,
            matchedDomain : $matchedDomain,
            matchTimeMs   : $matchTimeMs,
            resolutionPath: $resolutionPath
        );
    }

    /**
     * Creates a failed resolution context.
     *
     * @throws \Avax\HTTP\Router\Routing\Exceptions\ReservedRouteNameException
     */
    public static function failure(
        string $failureReason,
        float  $matchTimeMs,
        array  $resolutionPath = []
    ) : self
    {
        return new self(
            route         : new RouteDefinition(
                'GET',
                '/__resolution_failed__',
                static fn() => null,
                [],
                '__failed_route__'
            ),
            parameters    : [],
            matchedDomain : null,
            matchTimeMs   : $matchTimeMs,
            resolutionPath: $resolutionPath,
            failureReason : $failureReason
        );
    }

    /**
     * Gets a human-readable summary of the resolution process.
     */
    public function getSummary() : string
    {
        if (! $this->isSuccessful()) {
            return sprintf(
                'Route resolution failed: %s (%.3fms)',
                $this->failureReason,
                $this->matchTimeMs
            );
        }

        $domainInfo = $this->matchedDomain ? " on domain {$this->matchedDomain}" : '';
        $paramsInfo = ! empty($this->parameters) ? ' with params: ' . json_encode($this->parameters) : '';

        return sprintf(
            'Resolved %s %s%s%s in %.3fms',
            $this->route->method,
            $this->getResolvedPath(),
            $domainInfo,
            $paramsInfo,
            $this->matchTimeMs
        );
    }

    /**
     * Checks if resolution was successful.
     */
    public function isSuccessful() : bool
    {
        return $this->failureReason === null;
    }

    /**
     * Gets the matched route path with parameters substituted.
     */
    public function getResolvedPath() : string
    {
        $path = $this->route->path;

        foreach ($this->parameters as $key => $value) {
            $path = str_replace("{{$key}}", (string) $value, $path);
        }

        return $path;
    }

    /**
     * Converts context to array for logging/serialization.
     */
    public function toArray() : array
    {
        return [
            'successful'      => $this->isSuccessful(),
            'route'           => [
                'method' => $this->route->method,
                'path'   => $this->route->path,
                'name'   => $this->route->name,
                'domain' => $this->route->domain,
            ],
            'parameters'      => $this->parameters,
            'matched_domain'  => $this->matchedDomain,
            'match_time_ms'   => $this->matchTimeMs,
            'resolved_path'   => $this->getResolvedPath(),
            'resolution_path' => $this->resolutionPath,
            'failure_reason'  => $this->failureReason,
        ];
    }

    /**
     * Gets resolution path as human-readable steps.
     */
    public function getResolutionSteps() : array
    {
        return array_map(
            static fn(array $step) : string => sprintf(
                '[%s] %s',
                $step['timestamp'] ?? 'unknown',
                $step['description'] ?? 'unknown step'
            ),
            $this->resolutionPath
        );
    }
}
=== Routing/RouteSourceLoaderInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Interface for route loading strategies.
 *
 * Defines the contract for loading routes from different sources (cache, disk, etc.)
 * enabling unified route loading architecture.
 */
interface RouteSourceLoaderInterface
{
    /**
     * Load routes into the provided collection.
     *
     * Implementations should populate the RouteCollection with routes from their source,
     * handling any necessary validation, caching, or error handling.
     *
     * @param RouteCollection $collection The collection to populate with routes
     *
     * @throws \Exception If loading fails for any reason
     */
    public function loadInto(RouteCollection $collection) : void;

    /**
     * Check if this loader can provide routes for the current context.
     *
     * Used by RouteBootstrapper to determine which loader to use.
     */
    public function isAvailable() : bool;

    /**
     * Get priority of this loader (higher = preferred).
     *
     * Used when multiple loaders are available to choose the best one.
     */
    public function getPriority() : int;

    /**
     * Get descriptive name of this loader for debugging/logging.
     */
    public function getName() : string;
}
=== Routing/RouteStage.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Request\Request;
use Closure;
use Psr\Http\Message\ResponseInterface;

interface RouteStage
{
    /**
     * Executes logic before the next pipeline stage.
     *
     * @param Closure(Request): ResponseInterface $next
     */
    public function handle(Request $request, Closure $next) : ResponseInterface;
}

=== Routing/RouterConfig.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

/**
 * Configuration object for Router behavior customization.
 *
 * Allows fine-tuning of router behavior through policy-based configuration,
 * enabling different deployment scenarios and use cases.
 */
final readonly class RouterConfig
{
    public function __construct(
        public DuplicatePolicy $duplicatePolicy = DuplicatePolicy::THROW,
        public bool $enableTracing = false,
        public bool $strictMode = true,
        public int $maxRoutes = 10000
    ) {}

    /**
     * Create a development-friendly configuration.
     *
     * More permissive settings suitable for development environments.
     */
    public static function development() : self
    {
        return new self(
            duplicatePolicy: DuplicatePolicy::THROW,
            enableTracing: true,
            strictMode: false,
            maxRoutes: 50000
        );
    }

    /**
     * Create a production-optimized configuration.
     *
     * Strict settings optimized for production stability.
     */
    public static function production() : self
    {
        return new self(
            duplicatePolicy: DuplicatePolicy::THROW,
            enableTracing: false,
            strictMode: true,
            maxRoutes: 10000
        );
    }

    /**
     * Create a testing configuration.
     *
     * Relaxed settings for testing scenarios.
     */
    public static function testing() : self
    {
        return new self(
            duplicatePolicy: DuplicatePolicy::REPLACE,
            enableTracing: true,
            strictMode: false,
            maxRoutes: 1000
        );
    }
}
=== Routing/RouterRegistrar.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\HTTP\Router\Support\RouteRegistry;

/**
 * Encapsulates DSL helpers that define and buffer routes prior to bootstrap.
 */
final readonly class RouterRegistrar
{
    public function __construct(
        private RouteRegistry     $registry,
        private HttpRequestRouter $httpRequestRouter
    ) {}

    public function register(string $method, string $path, callable|array|string $action) : RouteRegistrarProxy
    {
        $builder = RouteBuilder::make(method: $method, path: $path);
        $builder->action(action: $action);

        $this->registry->add(builder: $builder);

        return new RouteRegistrarProxy(
            router  : $this->httpRequestRouter,
            builder : $builder,
            registry: $this->registry
        );
    }

    // Fallback method removed - fallbacks are handled exclusively through FallbackManager

    /**
     * @internal For cache loader use only.
     */
    public function registerRouteFromCache(RouteDefinition $definition) : void
    {
        $this->httpRequestRouter->add(route: $definition);
    }
}
=== Routing/StageChain.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Routing;

use Avax\Container\Features\Core\Contracts\ContainerInterface;
use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\Exceptions\StageOrderException;
use Closure;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use RuntimeException;

/**
 * Builds the middleware/stage execution chain and emits diagnostics.
 */
final class StageChain
{
    /** Stage ordering contract: stages precede middleware, then dispatch core. */
    private const ORDER_CONTRACT = ['stages', 'middleware', 'dispatch'];

    public function __construct(
        private readonly ContainerInterface $container,
        private readonly LoggerInterface    $logger
    ) {}

    /**
     * Compose the pipeline stack.
     *
     * @param array<class-string> $stages
     * @param array<class-string> $middleware
     */
    public function create(array $stages, array $middleware, Closure $core) : Closure
    {
        $this->validateOrder(stages: $stages, middleware: $middleware);

        $pipeline = array_merge($stages, $middleware);

        if ($pipeline === []) {
            $this->logger->debug(message: 'Pipeline contains only core dispatcher.');

            return $core;
        }

        $this->logger->debug(message: 'Building route pipeline.', context: ['pipeline' => $pipeline]);

        return array_reduce(
            array_reverse($pipeline),
            fn(Closure $next, string $class) : Closure => fn(Request $request) : ResponseInterface => $this->invoke(class: $class, next: $next, request: $request),
            $core
        );
    }

    private function validateOrder(array $stages, array $middleware) : void
    {
        $pipeline = array_merge($stages, $middleware);
        $seen     = [];

        // Check for duplicates across entire pipeline
        foreach ($pipeline as $class) {
            if (isset($seen[$class])) {
                throw StageOrderException::duplicate(stage: $class, pipeline: $pipeline, expectedOrder: self::ORDER_CONTRACT);
            }
            $seen[$class] = true;
        }

        // Validate stage types (must implement RouteStage)
        foreach ($stages as $class) {
            if (! is_subclass_of(object_or_class: $class, class: RouteStage::class)) {
                throw StageOrderException::misordered(
                    stage        : $class,
                    pipeline     : $pipeline,
                    expectedOrder: self::ORDER_CONTRACT,
                    reason       : "Stage {$class} must implement RouteStage interface"
                );
            }
        }

        // Validate middleware types (must implement RouteMiddleware and NOT RouteStage)
        foreach ($middleware as $class) {
            if (! is_subclass_of(object_or_class: $class, class: RouteMiddleware::class)) {
                throw StageOrderException::misordered(
                    stage        : $class,
                    pipeline     : $pipeline,
                    expectedOrder: self::ORDER_CONTRACT,
                    reason       : "Middleware {$class} must implement RouteMiddleware interface"
                );
            }

            if (is_subclass_of(object_or_class: $class, class: RouteStage::class)) {
                throw StageOrderException::misordered(
                    stage        : $class,
                    pipeline     : $pipeline,
                    expectedOrder: self::ORDER_CONTRACT,
                    reason       : "Middleware {$class} must not implement RouteStage interface"
                );
            }
        }

        // Log successful validation
        $this->logger->debug(message: 'StageChain validation passed', context: [
            'stages_count'     => count($stages),
            'middleware_count' => count($middleware),
            'total_pipeline'   => count($pipeline),
            'order_contract'   => self::ORDER_CONTRACT
        ]);
    }

    /**
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    private function invoke(string $class, Closure $next, Request $request) : ResponseInterface
    {
        $instance = $this->container->get(id: $class);

        if (! method_exists(object_or_class: $instance, method: 'handle')) {
            throw new RuntimeException(message: "Middleware or stage [{$class}] must have a handle() method.");
        }

        $this->logger->debug(message: 'Entering pipeline component.', context: ['component' => $class]);

        try {
            return $instance->handle($request, $next);
        } finally {
            $this->logger->debug(message: 'Exiting pipeline component.', context: ['component' => $class]);
        }
    }
}
=== Snapshots/RouterSnapshot.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Snapshots;

use Avax\HTTP\Router\RouterRuntimeInterface;
use JsonException;
use RuntimeException;

/**
 * Router configuration snapshot for reproducibility and auditing.
 *
 * Creates immutable snapshots of router state for:
 * - Configuration auditing and compliance
 * - Reproducible deployments across environments
 * - Change tracking and rollback capabilities
 * - Governance and regulatory requirements
 */
final readonly class RouterSnapshot
{
    public function __construct(
        public array  $routes,
        public array  $metadata,
        public string $createdAt,
        public string $environment,
        public string $version,
        public string $checksum,
    ) {}

    /**
     * Creates a snapshot from the current router state.
     */
    public static function capture(RouterRuntimeInterface $router, array $context = []) : self
    {
        $routes   = $router->allRoutes();
        $metadata = [
            'total_routes' => self::countTotalRoutes(routes: $routes),
            'methods'      => array_keys($routes),
            'context'      => $context,
            'php_version'  => PHP_VERSION,
            'timestamp'    => time(),
        ];

        $data = [
            'routes'      => $routes,
            'metadata'    => $metadata,
            'created_at'  => date('c'),
            'environment' => $context['environment'] ?? getenv('APP_ENV') ?: 'unknown',
            'version'     => $context['version'] ?? 'unknown',
        ];

        try {
            $json     = json_encode($data, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
            $checksum = hash('sha256', $json);
        } catch (JsonException $exception) {
            throw new RuntimeException(message: 'Unable to generate router snapshot.', code: $exception);
        }

        return new self(
            routes     : $routes,
            metadata   : $metadata,
            createdAt  : date('c'),
            environment: $data['environment'],
            version    : $data['version'],
            checksum   : $checksum
        );
    }

    /**
     * Counts total routes across all methods.
     */
    private static function countTotalRoutes(array $routes) : int
    {
        return array_sum(array_map('count', $routes));
    }

    /**
     * Loads snapshot from JSON file.
     */
    public static function loadFromFile(string $path) : self
    {
        if (! file_exists($path) || ! is_readable($path)) {
            throw new RuntimeException(message: "Snapshot file not found or not readable: {$path}");
        }

        try {
            $data = json_decode(file_get_contents($path), true, 512, JSON_THROW_ON_ERROR);
        } catch (JsonException $exception) {
            throw new RuntimeException(message: "Invalid snapshot file: {$path}", code: $exception);
        }

        return self::fromArray(data: $data);
    }

    /**
     * Creates snapshot from array data.
     */
    public static function fromArray(array $data) : self
    {
        return new self(
            routes     : $data['routes'] ?? [],
            metadata   : $data['metadata'] ?? [],
            createdAt  : $data['created_at'] ?? date('c'),
            environment: $data['environment'] ?? 'unknown',
            version    : $data['version'] ?? 'unknown',
            checksum   : $data['checksum'] ?? ''
        );
    }

    /**
     * Exports snapshot to JSON file.
     */
    public function exportToFile(string $path) : void
    {
        $data = $this->toArray();

        try {
            $json = json_encode($data, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
            file_put_contents($path, $json . "\n");
        } catch (JsonException $exception) {
            throw new RuntimeException(message: "Unable to export snapshot to {$path}.", code: $exception);
        }
    }

    /**
     * Converts snapshot to array for serialization.
     */
    public function toArray() : array
    {
        return [
            'routes'      => $this->routes,
            'metadata'    => $this->metadata,
            'created_at'  => $this->createdAt,
            'environment' => $this->environment,
            'version'     => $this->version,
            'checksum'    => $this->checksum,
        ];
    }

    /**
     * Validates snapshot integrity using checksum.
     */
    public function validateIntegrity() : bool
    {
        $data = $this->toArray();
        unset($data['checksum']); // Remove checksum from validation data

        try {
            $json = json_encode($data, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES);

            return hash('sha256', $json) === $this->checksum;
        } catch (JsonException) {
            return false;
        }
    }

    /**
     * Compares this snapshot with another for differences.
     */
    public function diff(self $other) : array
    {
        $differences = [];

        // Compare route counts
        $thisCount  = $this->metadata['total_routes'];
        $otherCount = $other->metadata['total_routes'];

        if ($thisCount !== $otherCount) {
            $differences[] = "Route count changed: {$thisCount}  {$otherCount}";
        }

        // Compare routes by method
        foreach (['GET', 'POST', 'PUT', 'DELETE', 'PATCH'] as $method) {
            $thisRoutes  = count($this->routes[$method] ?? []);
            $otherRoutes = count($other->routes[$method] ?? []);

            if ($thisRoutes !== $otherRoutes) {
                $differences[] = "{$method} routes: {$thisRoutes}  {$otherRoutes}";
            }
        }

        // Compare environment/version
        if ($this->environment !== $other->environment) {
            $differences[] = "Environment: {$this->environment}  {$other->environment}";
        }

        if ($this->version !== $other->version) {
            $differences[] = "Version: {$this->version}  {$other->version}";
        }

        return $differences;
    }

    /**
     * Gets a human-readable summary of the snapshot.
     */
    public function getSummary() : string
    {
        $lines = [
            "Router Snapshot Summary",
            "=======================",
            "Created: {$this->createdAt}",
            "Environment: {$this->environment}",
            "Version: {$this->version}",
            "Total Routes: {$this->metadata['total_routes']}",
            "Checksum: " . substr($this->checksum, 0, 16) . "...",
            "",
            "Routes by Method:",
        ];

        foreach ($this->metadata['methods'] as $method) {
            $count   = count($this->routes[$method] ?? []);
            $lines[] = "  {$method}: {$count} routes";
        }

        return implode("\n", $lines);
    }
}
=== Support/DomainPatternCompiler.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

/**
 * Class DomainPatternCompiler
 *
 * Provides methods for compiling dynamic domain patterns into regular expressions
 * and matching incoming host strings against compiled patterns.
 *
 * This utility is often used in routing systems to handle dynamic subdomains
 * or structured domain hierarchies.
 */
final class DomainPatternCompiler
{
    /**
     * Compiles a domain pattern string into a corresponding regular expression
     * to facilitate dynamic domain matching.
     *
     * Dynamic patterns are denoted using placeholders, e.g., `{account}.example.com`,
     * where `{account}` can match any subdomain name.
     *
     * @param string $pattern    The domain pattern string to compile.
     *                           Placeholders should be wrapped in curly braces, e.g., `{name}`.
     *
     * @return string The compiled regular expression string, ready for use in pattern matching.
     *                Example: `{account}.example.com` becomes `/^(?P<account>[\w\-.]+)\.example\.com$/i`.
     */
    public static function compile(string $pattern) : string
    {
        // Escape all special characters in the input domain pattern to ensure regex safety.
        $escaped = preg_quote(str: $pattern, delimiter: '/');

        // Transform placeholders (e.g., `{account}`) into named capturing groups in the regex pattern.
        // - \w matches word characters (a-z, A-Z, 0-9, and underscore).
        // - \- and \. Allow hyphen or dot in the subdomain portion.
        // Example: `{account}` becomes `(?P<account>[\w\-\.]+)`.
        $regex = preg_replace_callback(
            pattern : '/\\{(\w+)}/',
            // Matches `{placeholder_name}` where placeholders are word characters.
            callback: static fn(array $match) : string => '(?P<' . $match[1] . '>[\w\-\.]+)',
            // Replace it with a named group.
            subject : $escaped // Apply on the escaped string.
        );

        // Wrap the generated regex in delimiters, enforce case-insensitivity, and ensure it matches the full string.
        return '/^' . $regex . '$/i';
    }

    /**
     * Matches a host string against a precompiled domain regular expression.
     *
     * This method is used to determine if an incoming host (e.g., `x.example.com`) aligns
     * with the compiled domain pattern (e.g., `/^(?P<account>[\w\-\.]+)\.example\.com$/i`).
     *
     * @param string $host     The incoming host string to evaluate (e.g., `foo.example.com`).
     * @param string $compiled The precompiled domain regex (result from `compile`).
     *
     * @return bool Returns `true` if the host matches the regex, `false` otherwise.
     */
    public static function match(string $host, string $compiled) : bool
    {
        // Use preg_match to check if the host matches the compiled domain pattern.
        // Casting to boolean simplifies the return value to true/false.
        return (bool) preg_match(pattern: $compiled, subject: $host);
    }
}

=== Support/FallbackManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Dispatcher\ControllerDispatcher;
use Avax\HTTP\Request\Request;
use Closure;
use Psr\Http\Message\ResponseInterface;
use RuntimeException;

/**
 * Manages the fallback handler invoked when no route matches.
 */
final class FallbackManager
{
    private Closure|array|string|null $handler = null;

    public function __construct(private ControllerDispatcher $dispatcher) {}

    public function set(callable|array|string $handler) : void
    {
        $this->handler = is_callable(value: $handler)
            ? Closure::fromCallable(callback: $handler)
            : $handler;
    }

    public function has() : bool
    {
        return $this->handler !== null;
    }

    /**
     * @throws \Psr\Container\ContainerExceptionInterface
     * @throws \ReflectionException
     * @throws \Psr\Container\NotFoundExceptionInterface
     */
    public function invoke(Request $request) : ResponseInterface
    {
        if (! $this->handler) {
            throw new RuntimeException(message: 'Fallback handler is not configured.');
        }

        if ($this->handler instanceof Closure) {
            return ($this->handler)($request);
        }

        return $this->dispatcher->dispatch(action: $this->handler, request: $request);
    }
}

=== Support/HeadRequestFallback.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\Exceptions\RouteNotFoundException;
use Avax\HTTP\Router\Routing\HttpRequestRouter;

/**
 * Provides fallback logic for HEAD  GET requests.
 *
 * If a HEAD route is not defined, attempts to resolve the corresponding GET route.
 */
final readonly class HeadRequestFallback
{
    public function __construct(
        private HttpRequestRouter $router
    ) {}

    /**
     * Resolves the request, falling back from HEAD to GET if needed.
     *
     * @param Request $request Incoming HTTP request.
     *
     * @throws \Avax\HTTP\Router\Validation\Exceptions\InvalidConstraintException
     */
    public function resolve(Request $request) : Request
    {
        if ($request->getMethod() !== 'HEAD') {
            return $request;
        }

        try {
            $this->router->resolve(request: $request);
        } catch (RouteNotFoundException) {
            // Attempt GET route fallback
            $request = $request->withMethod(method: 'GET');
        }

        return $request;
    }
}

=== Support/PathNormalizer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

/**
 * Normalizes URL paths for consistent route matching.
 *
 * Ensures that paths like `/users/` and `/users` are treated as equivalent,
 * preventing routing inconsistencies and improving user experience.
 */
final class PathNormalizer
{
    /**
     * Normalizes a URL path by:
     * - Ensuring leading slash
     * - Removing trailing slashes (except for root path)
     * - Collapsing multiple consecutive slashes
     * - Handling edge cases safely
     *
     * @param string $path The path to normalize
     *
     * @return string The normalized path
     */
    public static function normalize(string $path) : string
    {
        // Handle empty path
        if ($path === '') {
            return '/';
        }

        // Collapse multiple slashes and normalize
        $path = preg_replace('#/+#', '/', $path);

        if ($path === null) {
            throw new \InvalidArgumentException('Invalid path format for normalization');
        }

        // Ensure leading slash
        if (! str_starts_with($path, '/')) {
            $path = '/' . $path;
        }

        // Remove trailing slash unless it's the root path
        if ($path !== '/' && str_ends_with($path, '/')) {
            $path = rtrim($path, '/');
        }

        return $path;
    }

    /**
     * Checks if two paths are equivalent after normalization.
     *
     * @param string $path1 First path to compare
     * @param string $path2 Second path to compare
     *
     * @return bool True if paths are equivalent
     */
    public static function areEquivalent(string $path1, string $path2) : bool
    {
        return self::normalize($path1) === self::normalize($path2);
    }
}
=== Support/RouteCollector.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Router\Routing\RouteBuilder;
use Closure;

/**
 * ROUTE LIFECYCLE: DSL  Collection  Registration
 *
 * RouteCollector is the critical bridge between route DSL execution and router registration.
 * Refactored to be instance-based to eliminate global state and enable proper isolation.
 *
 * ## Route Lifecycle Flow:
 * 1. **DSL Execution** (RouteRegistrar::load)
 *    - Route files executed in isolated scope with dedicated collector instance
 *    - DSL calls (get/post/any) create RouteBuilder instances via collector
 *    - RouteBuilder instances buffered in instance-specific collection
 *
 * 2. **Collection Phase** (RouteCollector instance)
 *    - Routes buffered in instance $routes array (no global state)
 *    - Fallback stored in instance $fallback
 *    - Natural isolation between different collector instances
 *
 * 3. **Activation Point** (RouteCollector::flush)
 *    - RouteBuilder::build() called to create RouteDefinition
 *    - RouteDefinition registered with HttpRequestRouter
 *    - Buffer cleared for next collection cycle
 *
 * ## Fallback Lifecycle Flow:
 * 1. **DSL Definition** (RouterDsl::fallback)
 *    - Fallback callable stored via RouteCollector::setFallback()
 *
 * 2. **Registration** (RouteBootstrapper)
 *    - Fallback passed to HttpRequestRouter::fallback()
 *    - Stored in HttpRequestRouter for runtime resolution
 *
 * 3. **Runtime Invocation** (Router::resolve)
 *    - Called when no routes match the request
 *    - Handled by FallbackManager for controller-style dispatch
 *
 * ## Thread Safety Benefits:
 * - No static properties = no race conditions between threads
 * - Instance isolation = no cross-context contamination
 * - Predictable state management = deterministic behavior
 */
final class RouteCollector
{
    /**
     * @var RouteBuilder[] Buffered route builders
     */
    private array $routes = [];

    /**
     * @var callable|null Fallback route handler
     */
    private $fallback = null;

    /**
     * Execute a closure with scoped route collection.
     *
     * Creates a new RouteCollector instance for the closure execution,
     * ensuring complete isolation between different route loading contexts.
     * Eliminates global state by passing collector as closure parameter.
     *
     * @param Closure $closure The closure to execute with scoped collection
     * @return RouteCollector The collector instance used for the scope
     */
    public static function scoped(Closure $closure) : self
    {
        $collector = new self();

        // Execute closure with collector instance passed as parameter
        // This eliminates global state completely
        try {
            $closure($collector);
            return $collector;
        } catch (\Throwable $exception) {
            // Ensure clean state even on exception
            $collector->clear();
            throw $exception;
        }
    }

    /**
     * Execute DSL functions with this collector instance.
     *
     * Provides a clean API for route file execution without global state.
     *
     * @param string $code The PHP code containing DSL function calls
     * @return void
     */
    public function executeDsl(string $code) : void
    {
        // Bind this collector instance to the execution context
        $collector = $this;

        // Create isolated execution environment
        $executionClosure = function () use ($code, $collector) : void {
            // Make collector available to global DSL functions via closure binding
            // This replaces the global state approach
            $dslFunctions = [
                'get' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('GET', $path)->action($action)
                ),
                'post' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('POST', $path)->action($action)
                ),
                'put' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('PUT', $path)->action($action)
                ),
                'patch' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('PATCH', $path)->action($action)
                ),
                'delete' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('DELETE', $path)->action($action)
                ),
                'options' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('OPTIONS', $path)->action($action)
                ),
                'head' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('HEAD', $path)->action($action)
                ),
                'any' => fn($path, $action) => $collector->addRouteBuilder(
                    \Avax\HTTP\Router\Routing\RouteBuilder::make('ANY', $path)->action($action)
                ),
                'fallback' => fn($handler) => $collector->setFallback($handler),
            ];

            // Extract variables for the DSL execution
            extract($dslFunctions);

            // Execute the DSL code in isolated scope
            eval('?>' . $code);
        };

        $executionClosure();
    }

    /**
     * Add a route builder to the collection.
     *
     * @param RouteBuilder $routeBuilder The route builder to add
     */
    public function add(RouteBuilder $routeBuilder) : void
    {
        $this->routes[] = $routeBuilder;
    }

    /**
     * Add a route builder and return a registrar proxy for chaining.
     *
     * This method provides the fluent API for DSL functions.
     *
     * @param RouteBuilder $routeBuilder The route builder to add
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy The proxy for chaining
     */
    public function addRouteBuilder(RouteBuilder $routeBuilder) : \Avax\HTTP\Router\Routing\RouteRegistrarProxy
    {
        $this->add($routeBuilder);

        return new \Avax\HTTP\Router\Routing\RouteRegistrarProxy(
            router: null, // Will be set by RouterDsl
            builder: $routeBuilder,
            registry: null // Will be set by RouterDsl
        );
    }

    /**
     * Flush all collected route builders.
     *
     * Returns the collected routes and clears the buffer.
     *
     * @return RouteBuilder[] The collected route builders
     */
    public function flush() : array
    {
        $routes       = $this->routes;
        $this->routes = [];

        return $routes;
    }

    /**
     * Get the fallback route handler.
     *
     * @return callable|null The fallback handler or null if not set
     */
    public function getFallback() : callable|null
    {
        return $this->fallback;
    }

    /**
     * Set the fallback route handler.
     *
     * @param callable $fallback The fallback handler
     */
    public function setFallback(callable $fallback) : void
    {
        $this->fallback = $fallback;
    }

    /**
     * Check if any routes have been collected.
     *
     * @return bool True if routes are buffered
     */
    public function hasRoutes() : bool
    {
        return ! empty($this->routes);
    }

    /**
     * Get the count of collected routes.
     *
     * @return int Number of buffered routes
     */
    public function count() : int
    {
        return count($this->routes);
    }

    /**
     * Clear all routes (for testing/cleanup).
     */
    public function clear() : void
    {
        $this->routes = [];
        $this->fallback = null;
    }
}
=== Support/RouteExportValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Router\Routing\RouteDefinition;
use Psr\Log\LoggerInterface;

/**
 * Validates route exportability for caching.
 *
 * Ensures routes contain only serializable data before caching.
 * Logs warnings for non-exportable routes and provides skip logic.
 */
final class RouteExportValidator
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    /**
     * Filters an array of routes, keeping only exportable ones.
     *
     * @param RouteDefinition[] $routes
     *
     * @return RouteDefinition[]
     */
    public function filterExportable(array $routes) : array
    {
        $exportable = [];

        foreach ($routes as $route) {
            if ($this->validate(route: $route)) {
                $exportable[] = $route;
            }
        }

        $skipped = count($routes) - count($exportable);
        if ($skipped > 0) {
            $this->logger->info(message: 'Some routes skipped during cache export', context: [
                'total_routes'      => count($routes),
                'exportable_routes' => count($exportable),
                'skipped_routes'    => $skipped,
            ]);
        }

        return $exportable;
    }

    /**
     * Validates if a route can be safely exported for caching.
     *
     * @param RouteDefinition $route The route to validate
     *
     * @return bool True if exportable, false otherwise
     */
    public function validate(RouteDefinition $route) : bool
    {
        $issues = [];

        // Check action exportability
        if (! $this->isActionExportable(action: $route->action)) {
            $issues[] = 'action contains non-serializable data (closures or objects)';
        }

        // Check middleware exportability
        if (! $this->isMiddlewareExportable(middleware: $route->middleware)) {
            $issues[] = 'middleware contains non-string values';
        }

        // Check defaults exportability
        if (! $this->isDefaultsExportable(defaults: $route->defaults)) {
            $issues[] = 'defaults contain non-scalar values';
        }

        // Check attributes exportability
        if (! $this->isAttributesExportable(attributes: $route->attributes)) {
            $issues[] = 'attributes contain non-scalar values';
        }

        // Check domain exportability
        if ($route->domain !== null && ! is_string($route->domain)) {
            $issues[] = 'domain is not a string';
        }

        // Check authorization exportability
        if ($route->authorization !== null && ! is_string($route->authorization)) {
            $issues[] = 'authorization is not a string';
        }

        if (! empty($issues)) {
            $this->logger->warning(message: 'Route cannot be cached', context: [
                'route'  => $route->method . ' ' . $route->path,
                'name'   => $route->name,
                'issues' => $issues,
            ]);

            return false;
        }

        return true;
    }

    /**
     * Validates if action can be exported.
     */
    private function isActionExportable(mixed $action) : bool
    {
        // String actions are always exportable
        if (is_string($action)) {
            return true;
        }

        // Array actions must be [class-string, method-string]
        if (is_array($action) && count($action) === 2) {
            return is_string($action[0]) && is_string($action[1]);
        }

        // Closures and other objects are not exportable
        return false;
    }

    /**
     * Validates if middleware array can be exported.
     */
    private function isMiddlewareExportable(array $middleware) : bool
    {
        foreach ($middleware as $mw) {
            if (! is_string($mw)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Validates if defaults can be exported.
     */
    private function isDefaultsExportable(array $defaults) : bool
    {
        return $this->isScalarArray(array: $defaults);
    }

    /**
     * Checks if array contains only scalar values or arrays of scalars.
     */
    private function isScalarArray(array $array) : bool
    {
        foreach ($array as $value) {
            if (is_array($value)) {
                if (! $this->isScalarArray(array: $value)) {
                    return false;
                }
            } elseif (! is_scalar($value) && $value !== null) {
                return false;
            }
        }

        return true;
    }

    /**
     * Validates if attributes can be exported.
     */
    private function isAttributesExportable(array $attributes) : bool
    {
        return $this->isScalarArray(array: $attributes);
    }
}

=== Support/RoutePathValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use InvalidArgumentException;

/**
 * Validates route path patterns for wildcards and optional parameters.
 *
 * Ensures route paths follow strict rules:
 * - Wildcard (*) appears only once and only at path end
 * - Optional (?) parameters stay within segment bounds
 * - Allowed characters: [a-zA-Z0-9_-]
 * - No nested wildcards or invalid combinations
 */
final class RoutePathValidator
{
    /**
     * Regular expression for valid parameter names.
     */
    private const string VALID_PARAM_PATTERN = '/^[a-zA-Z_][a-zA-Z0-9_-]*$/';

    /**
     * Validate a complete route path.
     *
     * @param string $path The route path to validate
     *
     * @throws InvalidArgumentException If path contains invalid patterns
     */
    public static function validate(string $path) : void
    {
        if (empty($path)) {
            throw new InvalidArgumentException(message: 'Route path cannot be empty');
        }

        if ($path[0] !== '/') {
            throw new InvalidArgumentException(message: 'Route path must start with "/"');
        }

        self::validateParameters(path: $path);
        self::validateWildcards(path: $path);
        self::validateOptionalParameters(path: $path);
    }

    /**
     * Validate parameter names and syntax.
     */
    private static function validateParameters(string $path) : void
    {
        // Find all {param} patterns
        preg_match_all('/\{([^}]+)\}/', $path, $matches);

        foreach ($matches[1] as $param) {
            // Remove optional (?) and wildcard (*) markers for validation
            $cleanParam = preg_replace('/[?*]$/', '', $param);

            if (! preg_match(self::VALID_PARAM_PATTERN, $cleanParam)) {
                throw new InvalidArgumentException(
                    message: "Invalid parameter name '{$cleanParam}' in path '{$path}'. " .
                    'Parameter names must match: ' . self::VALID_PARAM_PATTERN
                );
            }

            // Check for nested modifiers
            if (substr_count($param, '?') > 1 || substr_count($param, '*') > 1) {
                throw new InvalidArgumentException(
                    message: "Invalid parameter '{$param}' in path '{$path}': cannot have multiple ? or * modifiers"
                );
            }

            // Check for invalid modifier combinations
            if (str_contains($param, '?') && str_contains($param, '*')) {
                throw new InvalidArgumentException(
                    message: "Invalid parameter '{$param}' in path '{$path}': cannot combine ? and * modifiers"
                );
            }
        }
    }

    /**
     * Validate wildcard (*) usage.
     */
    private static function validateWildcards(string $path) : void
    {
        // Find all wildcard parameters
        preg_match_all('/\{([^}]*\*[^{}]*)\}/', $path, $matches);

        if (count($matches[0]) > 1) {
            throw new InvalidArgumentException(
                message: "Multiple wildcard parameters found in path '{$path}'. Only one wildcard (*) allowed per route."
            );
        }

        if (! empty($matches[0])) {
            $wildcardParam = $matches[0][0];

            // Find position of wildcard in path
            $wildcardPos       = strpos($path, $wildcardParam);
            $pathAfterWildcard = substr($path, $wildcardPos + strlen($wildcardParam));

            // Check if there's anything after the wildcard parameter
            if (! empty(trim($pathAfterWildcard, '/'))) {
                throw new InvalidArgumentException(
                    message: "Wildcard parameter '{$wildcardParam}' must be at the end of the path in '{$path}'"
                );
            }
        }
    }

    /**
     * Validate optional (?) parameter usage.
     */
    private static function validateOptionalParameters(string $path) : void
    {
        // Find all optional parameters
        preg_match_all('/\{([^}]*\?[^{}]*)\}/', $path, $matches);

        foreach ($matches[0] as $optionalParam) {
            // Check if optional parameter is preceded by wildcard
            $paramPos = strpos($path, $optionalParam);

            // Look backwards for wildcard in same path segment
            $segmentStart = strrpos(substr($path, 0, $paramPos), '/');
            $segmentStart = $segmentStart === false ? 0 : $segmentStart;

            $segmentBefore = substr($path, $segmentStart, $paramPos - $segmentStart);

            if (str_contains($segmentBefore, '*')) {
                throw new InvalidArgumentException(
                    message: "Optional parameter '{$optionalParam}' cannot appear after wildcard in path '{$path}'"
                );
            }
        }
    }

    /**
     * Check if a path segment contains parameters.
     */
    public static function hasParameters(string $segment) : bool
    {
        return str_contains($segment, '{') && str_contains($segment, '}');
    }

    /**
     * Extract parameter names from a path.
     *
     * @return string[] Array of parameter names without modifiers
     */
    public static function extractParameterNames(string $path) : array
    {
        preg_match_all('/\{([^}]+)\}/', $path, $matches);

        return array_map(static function ($param) {
            return preg_replace('/[?*]$/', '', $param);
        }, $matches[1]);
    }

    /**
     * Check if path contains wildcard parameters.
     */
    public static function hasWildcard(string $path) : bool
    {
        return str_contains($path, '*');
    }

    /**
     * Check if path contains optional parameters.
     */
    public static function hasOptional(string $path) : bool
    {
        return str_contains($path, '?');
    }
}

=== Support/RouteRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Router\Routing\RouteBuilder;

/**
 * RouteRegistry stores routes defined during bootstrap and cache compilation.
 *
 * This class replaces the former global RouteCollector. Each bootstrap/compiler
 * cycle should share a registry instance to avoid leaking buffered routes.
 */
final class RouteRegistry
{
    /**
     * @var list<RouteBuilder>
     */
    private array $bufferedRoutes = [];

    private mixed $fallback = null;

    /**
     * Adds a builder to the buffered list.
     */
    public function add(RouteBuilder $builder) : void
    {
        $this->bufferedRoutes[] = $builder;
    }

    /**
     * Flushes the buffered builders and resets the buffer.
     *
     * @return list<RouteBuilder>
     */
    public function flush() : array
    {
        $routes               = $this->bufferedRoutes;
        $this->bufferedRoutes = [];

        return $routes;
    }

    /**
     * Gets the current fallback handler.
     */
    public function getFallback() : mixed
    {
        return $this->fallback;
    }

    /**
     * Sets the fallback handler.
     */
    public function setFallback(mixed $handler) : void
    {
        $this->fallback = $handler;
    }

    /**
     * Checks if a fallback handler exists.
     */
    public function hasFallback() : bool
    {
        return $this->fallback !== null;
    }

    /**
     * Executes callback with isolated state and restores afterwards.
     *
     * @template T
     *
     * @param callable():T $callback
     *
     * @return T
     */
    public function scoped(callable $callback)
    {
        $previousRoutes   = $this->bufferedRoutes;
        $previousFallback = $this->fallback;

        $this->reset();

        try {
            return $callback();
        } finally {
            $this->bufferedRoutes = $previousRoutes;
            $this->fallback       = $previousFallback;
        }
    }

    /**
     * Resets the registry state.
     */
    public function reset() : void
    {
        $this->bufferedRoutes = [];
        $this->fallback       = null;
    }
}

=== Support/RouteRequestInjector.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\RouteDefinition;

/**
 * Handles injection of route parameters and defaults into HTTP requests.
 *
 * Centralizes the logic for injecting route parameters and default values
 * into PSR-7 request objects, eliminating code duplication between
 * RouterKernel and HttpRequestRouter.
 */
final class RouteRequestInjector
{
    /**
     * Injects route parameters and default values into the request.
     *
     * @param Request         $request The HTTP request to modify
     * @param RouteDefinition $route   The route definition containing parameters and defaults
     *
     * @return Request The modified request with injected attributes
     */
    public static function inject(Request $request, RouteDefinition $route) : Request
    {
        // Inject route parameters as attributes into the request
        foreach ($route->parameters as $key => $value) {
            $request = $request->withAttribute(name: $key, value: $value);
        }

        // Inject default values for attributes that are not already set
        foreach ($route->defaults as $key => $value) {
            if ($request->getAttribute(name: $key) === null) {
                $request = $request->withAttribute(name: $key, value: $value);
            }
        }

        return $request;
    }

    /**
     * Injects extracted parameters and route defaults into the request.
     *
     * This is used during route resolution when parameters are extracted
     * from the URL path and need to be merged with route defaults.
     *
     * @param Request $request    The HTTP request to modify
     * @param array   $defaults   Route default values
     * @param array   $parameters Extracted URL parameters
     *
     * @return Request The modified request with injected attributes
     */
    public static function injectExtractedParameters(Request $request, array $defaults, array $parameters) : Request
    {
        // Merge extracted parameters with route defaults
        $mergedParameters = array_merge($defaults, $parameters);

        // Set route parameters as request attributes
        foreach ($mergedParameters as $key => $value) {
            $request = $request->withAttribute(name: $key, value: $value);
        }

        return $request;
    }

    /**
     * Injects route parameters from resolution context into the request.
     *
     * This method isolates route parameters in 'route.params' attribute to prevent
     * conflicts with user-defined request attributes. Individual parameters are still
     * injected for backward compatibility, but the isolated collection takes precedence.
     *
     * @param Request         $request    The HTTP request to modify
     * @param RouteDefinition $route      The resolved route definition
     * @param array           $parameters Parameters extracted during resolution
     *
     * @return Request The modified request with injected attributes
     */
    public static function injectWithContext(Request $request, RouteDefinition $route, array $parameters) : Request
    {
        // Isolate route parameters in dedicated attribute to prevent conflicts
        $request = $request->withAttribute(name: 'route.params', value: $parameters);

        // Inject resolved parameters as individual request attributes for backward compatibility
        foreach ($parameters as $key => $value) {
            // Only inject if it doesn't conflict with existing user attributes
            if ($request->getAttribute(name: $key) === null) {
                $request = $request->withAttribute(name: $key, value: $value);
            }
        }

        // Inject any remaining route defaults that weren't resolved
        foreach ($route->defaults as $key => $value) {
            if ($request->getAttribute(name: $key) === null) {
                $request = $request->withAttribute(name: $key, value: $value);
            }
        }

        return $request;
    }
}
=== Support/RouterBootstrapState.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Support;

use RuntimeException;

/**
 * Thread-safe bootstrap state management for RouteBootstrapper.
 *
 * Replaces static state with instance-based state to ensure thread-safety
 * and proper isolation between different container instances.
 */
final class RouterBootstrapState
{
    private bool        $booted = false;
    private string|null $source = null;

    /**
     * Ensure the bootstrapper has not already been booted.
     *
     * @throws \RuntimeException If already bootstrapped
     */
    public function ensureNotBooted() : void
    {
        if ($this->booted) {
            throw new RuntimeException(message: 'Router bootstrapper has already been executed. Cannot bootstrap multiple times.');
        }
        $this->booted = true;
    }

    /**
     * Check if the bootstrapper has been booted.
     */
    public function isBooted() : bool
    {
        return $this->booted;
    }

    /**
     * Mark the source of route loading for this bootstrap cycle.
     *
     * @param string $source Either 'cache', 'disk', or 'closure'
     */
    public function markSource(string $source) : void
    {
        $this->source = $source;
    }

    /**
     * Get the source that was used for route loading.
     */
    public function getSource() : string|null
    {
        return $this->source;
    }

    /**
     * Reset the bootstrap state (primarily for testing).
     *
     * @internal Should only be used in test teardown scenarios
     */
    public function reset() : void
    {
        $this->booted = false;
        $this->source = null;
    }
}
=== Testing/FaultInjection.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Testing;

use Avax\HTTP\Router\RouterRuntimeInterface;
use Psr\Http\Message\ServerRequestInterface;
use RuntimeException;
use Throwable;

/**
 * Fault injection testing framework for router resilience.
 *
 * Enables chaos testing to ensure router reliability under failure conditions:
 * - Cache corruption scenarios
 * - Filesystem failures
 * - Memory exhaustion
 * - Concurrent access issues
 * - Network partition simulation
 */
final class FaultInjection
{
    private array $activeFaults = [];

    /**
     * Injects filesystem read failure for cache files.
     */
    public function injectFilesystemReadFailure(string $pattern = '*.php') : void
    {
        $this->activeFaults['filesystem_read'] = [
            'type'    => 'filesystem_read_failure',
            'pattern' => $pattern,
            'handler' => function (string $path) {
                if (fnmatch($this->activeFaults['filesystem_read']['pattern'], basename($path))) {
                    throw new RuntimeException(message: "Injected filesystem read failure for: {$path}");
                }
            }
        ];
    }

    /**
     * Injects filesystem write failure for cache files.
     */
    public function injectFilesystemWriteFailure(string $pattern = '*.php') : void
    {
        $this->activeFaults['filesystem_write'] = [
            'type'    => 'filesystem_write_failure',
            'pattern' => $pattern,
            'handler' => function (string $path) {
                if (fnmatch($this->activeFaults['filesystem_write']['pattern'], basename($path))) {
                    throw new RuntimeException(message: "Injected filesystem write failure for: {$path}");
                }
            }
        ];
    }

    /**
     * Injects memory exhaustion during route processing.
     */
    public function injectMemoryExhaustion(int $triggerAfterRoutes = 5) : void
    {
        $processedRoutes                         = 0;
        $this->activeFaults['memory_exhaustion'] = [
            'type'          => 'memory_exhaustion',
            'trigger_after' => $triggerAfterRoutes,
            'handler'       => function () use (&$processedRoutes, $triggerAfterRoutes) {
                $processedRoutes++;
                if ($processedRoutes >= $triggerAfterRoutes) {
                    throw new RuntimeException(message: "Injected memory exhaustion after {$processedRoutes} routes");
                }
            }
        ];
    }

    /**
     * Injects random route resolution failures.
     */
    public function injectRandomResolutionFailures(float $failureRate = 0.1) : void
    {
        $this->activeFaults['random_failure'] = [
            'type'    => 'random_resolution_failure',
            'rate'    => $failureRate,
            'handler' => function () use ($failureRate) {
                if (mt_rand(0, 100) / 100 < $failureRate) {
                    throw new RuntimeException(message: "Injected random resolution failure");
                }
            }
        ];
    }

    /**
     * Injects cache corruption by modifying loaded data.
     */
    public function injectCacheCorruption() : void
    {
        $this->activeFaults['cache_corruption'] = [
            'type'    => 'cache_corruption',
            'handler' => function (&$data) {
                if (is_array($data)) {
                    // Corrupt route data randomly
                    $data = array_slice($data, 0, mt_rand(0, count($data) - 1));
                }
            }
        ];
    }

    /**
     * Injects network partition by simulating slow/unavailable operations.
     */
    public function injectNetworkPartition(int $delayMs = 5000) : void
    {
        $this->activeFaults['network_partition'] = [
            'type'     => 'network_partition',
            'delay_ms' => $delayMs,
            'handler'  => function () use ($delayMs) {
                usleep($delayMs * 1000); // Convert to microseconds
                throw new RuntimeException(message: "Injected network partition delay");
            }
        ];
    }

    /**
     * Tests router resilience under injected faults.
     *
     * @return array{tests_run: int, failures: int, results: array}
     */
    public function testRouterResilience(RouterRuntimeInterface $router, array $testRequests) : array
    {
        $results  = [];
        $failures = 0;
        $testsRun = 0;

        foreach ($this->activeFaults as $faultName => $faultConfig) {
            $results[$faultName] = [
                'fault_type' => $faultConfig['type'],
                'tests'      => [],
                'passed'     => 0,
                'failed'     => 0,
            ];

            foreach ($testRequests as $request) {
                $testsRun++;
                try {
                    $response                       = $router->resolve(request: $request);
                    $results[$faultName]['tests'][] = [
                        'request'         => $this->summarizeRequest(request: $request),
                        'result'          => 'passed',
                        'response_status' => $response->getStatusCode(),
                    ];
                    $results[$faultName]['passed']++;
                } catch (Throwable $e) {
                    $failures++;
                    $results[$faultName]['tests'][] = [
                        'request' => $this->summarizeRequest(request: $request),
                        'result'  => 'failed',
                        'error'   => $e->getMessage(),
                    ];
                    $results[$faultName]['failed']++;
                }
            }
        }

        return [
            'tests_run' => $testsRun,
            'failures'  => $failures,
            'results'   => $results,
        ];
    }

    /**
     * Creates a summary of a request for test reporting.
     */
    private function summarizeRequest(ServerRequestInterface $request) : string
    {
        return sprintf(
            '%s %s',
            $request->getMethod(),
            $request->getUri()->getPath()
        );
    }

    /**
     * Clears all active fault injections.
     */
    public function clearAllFaults() : void
    {
        $this->activeFaults = [];
    }

    /**
     * Gets currently active faults.
     */
    public function getActiveFaults() : array
    {
        return array_keys($this->activeFaults);
    }

    /**
     * Triggers an injected fault if active.
     */
    public function triggerFault(string $faultType, mixed ...$args) : void
    {
        if ($this->shouldInjectFault(faultType: $faultType)) {
            $handler = $this->activeFaults[$faultType]['handler'];
            $handler(...$args);
        }
    }

    /**
     * Checks if router should handle faults gracefully.
     *
     * Call this in router components to trigger injected faults.
     */
    public function shouldInjectFault(string $faultType) : bool
    {
        return isset($this->activeFaults[$faultType]);
    }
}
=== Tracing/RouterTrace.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Tracing;

/**
 * Performance traceability layer for HTTP router operations.
 *
 * Provides fine-grained introspection and observability for:
 * - Route resolution timing and flow
 * - Matcher branch analysis
 * - Cache operation tracking
 * - Bootstrap performance metrics
 *
 * Enables deterministic debugging and profiling capabilities
 * comparable to Symfony Profiler and Laravel Telescope.
 */
final class RouterTrace
{
    /** @var array<array{time: float, event: string, context: array}> */
    private array $events;

    private float $startTime;

    private int $eventCount;

    public function __construct()
    {
        $this->events = [];
        $this->startTime = microtime(true);
        $this->eventCount = 0;
    }

    /**
     * Log a trace event with timing and context.
     *
     * @param string $event   Event identifier (e.g., 'resolve.start', 'matcher.domain_match')
     * @param array  $context Additional context data for debugging
     */
    public function log(string $event, array $context = []) : void
    {
        $this->events[] = [
            'time'    => round((microtime(true) - $this->startTime) * 1000, 3), // milliseconds
            'event'   => $event,
            'context' => $context,
        ];

        $this->eventCount++;
    }

    /**
     * Enhanced record method with automatic context enrichment.
     *
     * Automatically adds request_id, route metadata, and system context
     * to provide richer debugging information for enterprise observability.
     *
     * @param string $event   Event identifier
     * @param array  $context Base context data
     * @param array  $autoEnrich Automatic enrichment flags
     */
    public function record(
        string $event,
        array $context = [],
        array $autoEnrich = ['request_id', 'memory', 'route']
    ): void {
        $enrichedContext = $context;

        // Auto-enrich with request ID if available
        if (in_array('request_id', $autoEnrich, true)) {
            $enrichedContext['request_id'] = $this->getCurrentRequestId();
        }

        // Auto-enrich with memory usage
        if (in_array('memory', $autoEnrich, true)) {
            $enrichedContext['memory_usage'] = memory_get_usage(true);
            $enrichedContext['memory_peak'] = memory_get_peak_usage(true);
        }

        // Auto-enrich with route information if available in context
        if (in_array('route', $autoEnrich, true)) {
            $enrichedContext = $this->enrichWithRouteContext($event, $enrichedContext);
        }

        // Auto-enrich with system context
        $enrichedContext['php_version'] = PHP_VERSION;
        $enrichedContext['timestamp'] = microtime(true);
        $enrichedContext['process_id'] = getmypid();

        $this->log($event, $enrichedContext);
    }

    /**
     * Get current request ID from various sources.
     */
    private function getCurrentRequestId(): string {
        // Try common request ID headers/sources
        $sources = [
            $_SERVER['HTTP_X_REQUEST_ID'] ?? null,
            $_SERVER['HTTP_X_CORRELATION_ID'] ?? null,
            $_SERVER['REQUEST_ID'] ?? null,
            $_ENV['REQUEST_ID'] ?? null,
        ];

        foreach ($sources as $source) {
            if ($source !== null) {
                return $source;
            }
        }

        // Generate a unique request ID if none found
        return uniqid('req_', true);
    }

    /**
     * Enrich context with route-specific information.
     */
    private function enrichWithRouteContext(string $event, array $context): array {
        // Extract route information from recent events
        $routeInfo = $this->findRecentRouteInfo();

        if ($routeInfo) {
            $context['route_name'] = $routeInfo['name'] ?? null;
            $context['route_method'] = $routeInfo['method'] ?? null;
            $context['route_path'] = $routeInfo['path'] ?? null;
            $context['middleware_count'] = $routeInfo['middleware_count'] ?? 0;
            $context['domain'] = $routeInfo['domain'] ?? null;
        }

        // Add timing information for route resolution events
        if (str_starts_with($event, 'resolve.')) {
            $context['resolution_time_ms'] = $this->calculateResolutionTime();
        }

        return $context;
    }

    /**
     * Find recent route information from trace events.
     */
    private function findRecentRouteInfo(): array|null {
        // Look for the most recent route matching event
        for ($i = count($this->events) - 1; $i >= 0; $i--) {
            $event = $this->events[$i];

            if (isset($event['context']['route'])) {
                $route = $event['context']['route'];
                return [
                    'name' => $route->name ?? null,
                    'method' => $route->method ?? null,
                    'path' => $route->path ?? null,
                    'middleware_count' => count($route->middleware ?? []),
                    'domain' => $route->domain ?? null,
                ];
            }
        }

        return null;
    }

    /**
     * Calculate route resolution time from trace events.
     */
    private function calculateResolutionTime(): float {
        $startTime = null;
        $endTime = null;

        foreach ($this->events as $event) {
            if ($event['event'] === 'resolve.start') {
                $startTime = $event['time'];
            }
            if ($event['event'] === 'resolve.complete' || $event['event'] === 'resolve.failed') {
                $endTime = $event['time'];
                break;
            }
        }

        if ($startTime !== null && $endTime !== null) {
            return round($endTime - $startTime, 3);
        }

        return 0.0;
    }

    /**
     * Export enriched trace data in JSON format for ELK stack.
     */
    public function exportJson(): string {
        $traceData = [
            'trace_id' => $this->getCurrentRequestId(),
            'start_time' => $this->startTime,
            'total_time_ms' => $this->getTotalTime(),
            'event_count' => $this->eventCount,
            'events' => $this->events,
            'system_info' => [
                'php_version' => PHP_VERSION,
                'memory_peak' => memory_get_peak_usage(true),
                'process_id' => getmypid(),
            ],
        ];

        try {
            return json_encode($traceData, JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT);
        } catch (\JsonException $exception) {
            return json_encode([
                'error' => 'Failed to export trace data',
                'message' => $exception->getMessage(),
            ], JSON_THROW_ON_ERROR);
        }
    }

    /**
     * Get time elapsed between two events.
     *
     * @param string $fromEvent Starting event identifier
     * @param string $toEvent   Ending event identifier
     */
    public function getTimeBetween(string $fromEvent, string $toEvent) : float|null
    {
        $fromTime = null;
        $toTime   = null;

        foreach ($this->events as $event) {
            if ($event['event'] === $fromEvent) {
                $fromTime = $event['time'];
            }
            if ($event['event'] === $toEvent) {
                $toTime = $event['time'];
                break;
            }
        }

        if ($fromTime !== null && $toTime !== null) {
            return round($toTime - $fromTime, 3);
        }

        return null;
    }

    /**
     * Export all trace events for analysis.
     *
     * @return array<array{time: float, event: string, context: array}>
     */
    public function export() : array
    {
        return $this->events;
    }

    /**
     * Get events filtered by event type.
     *
     * @param string $eventType Event identifier to filter by
     *
     * @return array<array{time: float, event: string, context: array}>
     */
    public function getEventsByType(string $eventType) : array
    {
        return array_filter(
            $this->events,
            static fn(array $event) => $event['event'] === $eventType
        );
    }

    /**
     * Get the total number of logged events.
     */
    public function getEventCount() : int
    {
        return $this->eventCount;
    }

    /**
     * Clear all trace events (for testing/reuse).
     */
    public function clear() : void
    {
        $this->events     = [];
        $this->eventCount = 0;
        $this->startTime  = microtime(true);
    }

    /**
     * Export trace data in a human-readable format.
     */
    public function toString() : string
    {
        $output = sprintf("Router Trace (Total: %.3fms, Events: %d)\n", $this->getTotalTime(), $this->eventCount);
        $output .= str_repeat('=', 50) . "\n";

        foreach ($this->events as $event) {
            $output .= sprintf(
                "[%7.3fms] %-25s %s\n",
                $event['time'],
                $event['event'],
                ! empty($event['context']) ? json_encode($event['context'], JSON_UNESCAPED_SLASHES) : ''
            );
        }

        return $output;
    }

    /**
     * Get the total execution time from trace start.
     */
    public function getTotalTime() : float
    {
        return round((microtime(true) - $this->startTime) * 1000, 3);
    }

    /**
     * Check if a specific event was logged.
     */
    public function hasEvent(string $event) : bool
    {
        foreach ($this->events as $loggedEvent) {
            if ($loggedEvent['event'] === $event) {
                return true;
            }
        }

        return false;
    }
}
=== Validation/Exceptions/InvalidConstraintException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Validation\Exceptions;

use Exception;

/**
 * Exception thrown when a route constraint pattern is invalid.
 */
class InvalidConstraintException extends Exception
{
    public function __construct(string $pattern, string $reason = '')
    {
        $message = "Invalid route constraint pattern: {$pattern}";
        if (! empty($reason)) {
            $message .= " ({$reason})";
        }

        parent::__construct(message: $message);
    }
}

=== Validation/RouteConstraintValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Validation;

use Avax\HTTP\Request\Request;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Validation\Exceptions\InvalidConstraintException;
use RuntimeException;

/**
 * Validates route parameter values against registered regex constraints.
 */
final class RouteConstraintValidator
{
    /**
     * Validates the route parameter constraints against the actual request attributes.
     *
     * @param RouteDefinition $route   The route being validated.
     * @param Request         $request The current HTTP request.
     *
     * @throws InvalidConstraintException If constraint pattern is invalid.
     * @throws RuntimeException If constraint validation fails.
     */
    public function validate(RouteDefinition $route, Request $request) : void
    {
        foreach ($route->constraints as $param => $pattern) {
            // Validate constraint pattern syntax first
            $this->validateConstraintPattern(pattern: $pattern);

            $value = $request->getAttribute(name: $param);

            if (! is_string(value: $value) && ! is_numeric(value: $value)) {
                continue;
            }

            // Escape delimiters in pattern to prevent regex injection
            $escapedPattern = preg_quote($pattern, '/');
            $fullPattern    = "/^{$escapedPattern}$/";

            $matchResult = preg_match($fullPattern, (string) $value);

            if ($matchResult === false) {
                throw new InvalidConstraintException(pattern: $pattern, reason: 'regex compilation failed');
            }

            if ($matchResult !== 1) {
                throw new RuntimeException(
                    message: sprintf('Route parameter "%s" failed constraint "%s"', $param, $pattern)
                );
            }
        }
    }

    /**
     * Validates that a constraint pattern is syntactically correct.
     *
     * @param string $pattern The regex pattern to validate.
     *
     * @throws InvalidConstraintException If pattern is invalid.
     */
    private function validateConstraintPattern(string $pattern) : void
    {
        // Test pattern compilation
        $testPattern = "/{$pattern}/";
        $error       = null;

        set_error_handler(static function ($errno, $errstr) use (&$error) {
            $error = $errstr;
        });

        $result = preg_match($testPattern, '');

        restore_error_handler();

        if ($result === false || $error !== null) {
            throw new InvalidConstraintException(pattern: $pattern, reason: $error ?: 'invalid regex syntax');
        }
    }
}

=== benchmarks/RouterBenchmark.php ===
<?php

declare(strict_types=1);

/**
 * Enterprise Router Performance Benchmarks
 *
 * Comprehensive benchmarking suite measuring router performance under
 * various conditions including route complexity, matching patterns,
 * and operational scenarios.
 *
 * Uses PhpBench framework for accurate micro-benchmarking.
 */

use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Validation\RouteConstraintValidator;
use Avax\HTTP\Router\Matching\RouteMatcherInterface;
use Avax\HTTP\Request\Request;

/**
 * @BeforeMethods({"setUp"})
 */
class RouterBenchmark
{
    private HttpRequestRouter $router;
    private RouteMatcherInterface $matcher;
    private RouteConstraintValidator $validator;

    public function setUp(): void
    {
        $this->matcher = $this->createMock(RouteMatcherInterface::class);
        $this->validator = $this->createMock(RouteConstraintValidator::class);

        $this->router = new HttpRequestRouter(
            constraintValidator: $this->validator,
            matcher: $this->matcher
        );
    }

    /**
     * @Revs(1000)
     * @Iterations(10)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchSimpleRouteRegistration(): void
    {
        $route = new RouteDefinition(
            method: 'GET',
            path: '/users/{id}',
            action: 'UserController@show',
            middleware: ['auth'],
            constraints: ['id' => '[0-9]+']
        );

        $this->router->add($route);
    }

    /**
     * @Revs(100)
     * @Iterations(5)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchComplexRouteRegistration(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $route = new RouteDefinition(
                method: 'POST',
                path: "/api/v1/resources/{$i}/subresources/{subId}/actions/{action}",
                action: "ResourceController@handle",
                middleware: ['api', 'auth', 'rate_limit', 'cache'],
                constraints: [
                    'subId' => '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}',
                    'action' => 'create|update|delete'
                ],
                name: "api.resource.{$i}.action"
            );

            $this->router->add($route);
        }
    }

    /**
     * @Revs(10000)
     * @Iterations(10)
     * @OutputTimeUnit("microseconds")
     */
    public function benchRouteLookupByName(): void
    {
        // Pre-populate with routes
        for ($i = 0; $i < 1000; $i++) {
            $route = new RouteDefinition(
                method: 'GET',
                path: "/benchmark/route/{$i}",
                action: "BenchmarkController{$i}@action",
                name: "benchmark.route.{$i}"
            );
            $this->router->add($route);
        }

        // Benchmark lookup
        $this->router->getByName('benchmark.route.500');
    }

    /**
     * @Revs(1000)
     * @Iterations(5)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchRouteCollectionStatistics(): void
    {
        // Pre-populate with diverse routes
        $methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];
        $patterns = [
            '/simple/path',
            '/users/{id}',
            '/api/v1/resources/{resourceId}/sub/{subId}',
            '/complex/{param1}/{param2}/nested/{param3}/path',
        ];

        for ($i = 0; $i < 1000; $i++) {
            $route = new RouteDefinition(
                method: $methods[$i % count($methods)],
                path: $patterns[$i % count($patterns)],
                action: "Controller{$i}@action",
                middleware: ['middleware' . ($i % 5)],
                name: "route.{$i}"
            );
            $this->router->add($route);
        }

        // Benchmark statistics calculation
        $this->router->allRoutes();
    }

    /**
     * @Revs(100)
     * @Iterations(3)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchLargeScaleRouteRegistration(): void
    {
        // Register 10,000 routes (enterprise-scale)
        for ($i = 0; $i < 10000; $i++) {
            $route = new RouteDefinition(
                method: 'GET',
                path: "/enterprise/resource/{$i}/endpoint",
                action: "EnterpriseController@handle",
                middleware: ['auth', 'log', 'metrics'],
                name: "enterprise.resource.{$i}"
            );
            $this->router->add($route);
        }
    }

    /**
     * @Revs(10000)
     * @Iterations(10)
     * @OutputTimeUnit("microseconds")
     * @ParamProviders({"provideRoutePatterns"})
     */
    public function benchRoutePatternMatching($params): void
    {
        $pattern = $params['pattern'];

        // Simple regex match simulation
        preg_match($pattern, '/users/123/posts/456/comments/789');
    }

    public function provideRoutePatterns(): array
    {
        return [
            ['pattern' => '#^/users/([^/]+)/posts/([^/]+)/comments/([^/]+)$#'],
            ['pattern' => '#^/api/v1/resources/([^/]+)/subresources/([^/]+)/actions/([^/]+)$#'],
            ['pattern' => '#^/complex/([^/]+)/path/([^/]+)/with/([^/]+)/many/([^/]+)/segments$#'],
            ['pattern' => '#^/wildcard/(.+)$#'],
        ];
    }

    /**
     * @Revs(1000)
     * @Iterations(5)
     * @OutputTimeUnit("milliseconds")
     * @ParamProviders({"provideMiddlewareStacks"})
     */
    public function benchMiddlewareStackProcessing($params): void
    {
        $middleware = $params['middleware'];

        // Simulate middleware stack processing
        $result = 'initial';
        foreach ($middleware as $mw) {
            $result = $this->simulateMiddleware($result, $mw);
        }
    }

    public function provideMiddlewareStacks(): array
    {
        return [
            ['middleware' => ['auth', 'session', 'csrf']],
            ['middleware' => ['auth', 'rate_limit', 'cache', 'log', 'metrics']],
            ['middleware' => ['auth', 'session', 'csrf', 'rate_limit', 'cache', 'log', 'metrics', 'cors']],
        ];
    }

    private function simulateMiddleware(string $input, string $middleware): string
    {
        // Simulate middleware processing overhead
        return hash('sha256', $input . $middleware);
    }

    /**
     * @Revs(100)
     * @Iterations(3)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchDomainAwareRouting(): void
    {
        // Pre-populate with domain-specific routes
        $domains = ['api.example.com', 'admin.example.com', 'www.example.com'];
        $paths = ['/users', '/posts', '/comments', '/dashboard', '/reports'];

        foreach ($domains as $domain) {
            foreach ($paths as $path) {
                $route = new RouteDefinition(
                    method: 'GET',
                    path: $path,
                    action: 'DomainController@handle',
                    domain: $domain,
                    name: "{$domain}.{$path}"
                );
                $this->router->add($route);
            }
        }

        // Benchmark domain-aware lookups
        $this->router->getByName('api.example.com./users');
        $this->router->getByName('admin.example.com./dashboard');
    }

    /**
     * @Revs(500)
     * @Iterations(5)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchRouteConstraintValidation(): void
    {
        // Test various constraint patterns
        $constraints = [
            'id' => '[0-9]+',
            'uuid' => '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}',
            'slug' => '[a-z0-9]+(?:-[a-z0-9]+)*',
            'email' => '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'ipv4' => '(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)',
        ];

        $testValues = [
            'id' => '12345',
            'uuid' => '550e8400-e29b-41d4-a716-446655440000',
            'slug' => 'my-article-title',
            'email' => 'user@example.com',
            'ipv4' => '192.168.1.1',
        ];

        foreach ($constraints as $type => $pattern) {
            $value = $testValues[$type];
            preg_match("#^{$pattern}$#", $value);
        }
    }

    /**
     * @Revs(100)
     * @Iterations(3)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchCacheSerialization(): void
    {
        // Create complex route collection for serialization testing
        $routes = [];
        for ($i = 0; $i < 1000; $i++) {
            $routes[] = new RouteDefinition(
                method: 'GET',
                path: "/cache/test/{$i}",
                action: ['CacheController', 'handle'],
                middleware: ['auth', 'cache'],
                constraints: ['id' => '[0-9]+'],
                name: "cache.test.{$i}"
            );
        }

        // Benchmark serialization
        $serialized = serialize($routes);

        // Benchmark deserialization
        unserialize($serialized);
    }

    /**
     * @Revs(1000)
     * @Iterations(5)
     * @OutputTimeUnit("microseconds")
     */
    public function benchReflectionCachePerformance(): void
    {
        // Test ReflectionCache performance
        $testClass = new class {
            public function testMethod(string $param): string {
                return $param;
            }

            public string $testProperty = 'value';
        };

        // Benchmark cached reflection operations
        \Avax\HTTP\Router\Routing\ReflectionCache::getClass($testClass::class);
        \Avax\HTTP\Router\Routing\ReflectionCache::getMethod($testClass, 'testMethod');
        \Avax\HTTP\Router\Routing\ReflectionCache::getProperty($testClass, 'testProperty');
        \Avax\HTTP\Router\Routing\ReflectionCache::hasMethod($testClass, 'testMethod');
        \Avax\HTTP\Router\Routing\ReflectionCache::isMethodPublic($testClass, 'testMethod');
    }

    /**
     * Memory usage benchmark
     *
     * @Revs(10)
     * @Iterations(1)
     * @OutputTimeUnit("milliseconds")
     */
    public function benchMemoryUsageScaling(): void
    {
        $initialMemory = memory_get_usage(true);

        // Scale from 100 to 10,000 routes
        for ($count = 100; $count <= 10000; $count *= 10) {
            $routes = [];
            for ($i = 0; $i < $count; $i++) {
                $routes[] = new RouteDefinition(
                    method: 'GET',
                    path: "/scale/test/{$i}",
                    action: "ScaleController@handle",
                    name: "scale.{$i}"
                );
            }

            $memoryAfter = memory_get_usage(true);
            $memoryPerRoute = ($memoryAfter - $initialMemory) / $count;

            // Log memory scaling characteristics
            error_log("Routes: {$count}, Memory per route: {$memoryPerRoute} bytes");
        }
    }
}
=== format-router.bat ===
@echo off
REM === PhpStorm CLI Formatter for Router Component ===
echo  Running PhpStorm formatter on Router component...

REM  PUT YOUR PhpStorm PATH HERE:
set PHPS_PATH="C:\Users\%USERNAME%\AppData\Local\JetBrains\Toolbox\apps\PhpStorm\ch-0\232.11272.36\bin\phpstorm64.exe"

REM  PATH TO YOUR PROJECT
set PROJECT_PATH="C:\Users\%USERNAME%\PhpstormProjects\components\Foundation\HTTP\Router"

REM  FORMAT USING PROJECT CODE STYLE
%PHPS_PATH% format -allowDefaults -r -s "%PROJECT_PATH%\.idea\codeStyles\Project.xml" %PROJECT_PATH%

echo  PhpStorm Formatter finished successfully!
pause

=== functions.php ===
<?php

declare(strict_types=1);

use Avax\Text\Pattern;
use Avax\Text\RegexException;

/**
 * Router DSL Helper Layer.
 *
 * Provides human-grade router surface where regex and low-level operations
 * are abstracted away into readable, idiomatic helper functions.
 *
 * Analogous to Foundation/Text/functions.php but for router operations.
 */


if (! function_exists('route_validate_path')) {
    /**
     * Validate a route path format and syntax (internal function).
     *
     * @param string $path The route path to validate
     *
     * @throws InvalidArgumentException If path is invalid
     */
    function route_validate_path(string $path) : void
    {
        if ($path === '' || $path[0] !== '/') {
            throw new InvalidArgumentException(message: 'Route path must start with a "/" and cannot be empty.');
        }

        if (! route_contains_valid_path_chars(path: $path)) {
            throw new InvalidArgumentException(message: "Invalid characters in route path: {$path}");
        }

        if (substr_count($path, '{') !== substr_count($path, '}')) {
            throw new InvalidArgumentException(message: "Unbalanced route parameter braces in path: {$path}");
        }

        route_validate_parameters(path: $path);
    }
}

if (! function_exists('route_contains_valid_path_chars')) {
    /**
     * Check if a string contains only valid route path characters.
     *
     * @param string $path The path to check
     *
     * @return bool True if valid characters only
     */
    function route_contains_valid_path_chars(string $path) : bool
    {
        return Pattern::of(raw: '^[a-zA-Z0-9_.\\-/{}?*]*$')->test(subject: $path);
    }
}

if (! function_exists('route_validate_parameters')) {
    /**
     * Validate route parameter syntax in a path.
     *
     * @param string $path The route path to validate
     *
     * @throws InvalidArgumentException If parameter syntax is invalid
     */
    function route_validate_parameters(string $path) : void
    {
        $outside = Pattern::of(raw: '\\{[^{}]*\\}')->replace(subject: $path, replacement: '');
        if (str_contains($outside, '?') || str_contains($outside, '*')) {
            throw new InvalidArgumentException(message: "Wildcard or optional markers must be inside parameters: {$path}");
        }

        $matches       = Pattern::of(raw: '\\{([^{}]+)\\}')->matchAll(subject: $path);
        $wildcardCount = 0;

        foreach ($matches as $match) {
            $fullMatch = $match[0] ?? '';
            $segment   = $match[1] ?? '';

            if (! route_matches_parameter(paramName: $segment)) {
                throw new InvalidArgumentException(message: "Invalid route parameter syntax in segment {$fullMatch}");
            }

            // Check for wildcard modifier
            if (str_ends_with($segment, '*')) {
                $wildcardCount++;

                if ($wildcardCount > 1) {
                    throw new InvalidArgumentException(message: "Only one wildcard parameter is allowed: {$path}");
                }

                // Find position of this match in the path
                $offset = strpos($path, $fullMatch);
                if ($offset !== false) {
                    $endOfPlaceholder = $offset + strlen($fullMatch);
                    if ($endOfPlaceholder !== strlen($path)) {
                        throw new InvalidArgumentException(message: "Wildcard parameters must be the final path segment: {$path}");
                    }
                }
            }
        }
    }
}

if (! function_exists('route_matches_parameter')) {
    /**
     * Validate a route parameter name syntax.
     *
     * @param string $paramName The parameter name to validate
     *
     * @return bool True if valid
     */
    function route_matches_parameter(string $paramName) : bool
    {
        $pattern = '^[a-zA-Z_][a-zA-Z0-9_-]*(?:\?|\*)?$';

        return Pattern::of(raw: $pattern)->test(subject: $paramName);
    }
}

if (! function_exists('route_validate_constraint')) {
    /**
     * Validate a regex constraint pattern syntax (internal function).
     *
     * @param string $pattern The regex pattern to validate
     *
     * @throws InvalidArgumentException If pattern is invalid
     */
    function route_validate_constraint(string $pattern) : void
    {
        try {
            // Test pattern compilation using DSL - throws RegexException on invalid syntax
            Pattern::of(raw: $pattern)->test(subject: '');
        } catch (RegexException $e) {
            throw new InvalidArgumentException(
                message : sprintf('Invalid regex constraint "%s": %s', $pattern, $e->getMessage()),
                code    : 0,
                previous: $e
            );
        }
    }
}

if (! function_exists('route_valid')) {
    /**
     * Validate if a route path has correct syntax and is safe.
     *
     * @param string $path The route path to validate
     *
     * @return bool True if path is valid
     */
    function route_valid(string $path) : bool
    {
        try {
            route_validate_path(path: $path);

            return true;
        } catch (InvalidArgumentException) {
            return false;
        }
    }
}

if (! function_exists('route_compile_pattern')) {
    /**
     * Compile a route path template into a regex pattern (internal function).
     *
     * @param string $template    Route path template with {param} placeholders
     * @param array  $constraints Regex constraints for parameters
     *
     * @return string Compiled regex pattern
     */
    function route_compile_pattern(string $template, array $constraints = []) : string
    {
        // Start with the template
        $pattern = $template;

        // Replace {param} placeholders with regex groups
        $pattern = Pattern::of(raw: '\{([^}]+)\}')->replaceCallback(subject: $pattern, fn: function ($match) use ($constraints) {
            $paramName = $match[1];

            // Check for optional parameter (ends with ?)
            $isOptional = str_ends_with($paramName, '?');
            $isWildcard = str_ends_with($paramName, '*');

            // Remove modifiers from parameter name
            $cleanName = preg_replace('/[?*]$/', '', $paramName);

            // Get constraint or default
            $constraint = $constraints[$cleanName] ?? '[^/]+';

            // Build the regex group
            if ($isWildcard) {
                $group = "(?<{$cleanName}>.*)";
            } else {
                $group = "(?<{$cleanName}>{$constraint})";
            }

            if ($isOptional) {
                $group = "(?:/{$group})?";
            } else {
                $group = "/{$group}";
            }

            return $group;
        });

        return '#^' . $pattern . '$#u';
    }
}

if (! function_exists('route_pattern')) {
    /**
     * Create a normalized route regex pattern from DSL path template.
     *
     * Examples:
     * - '/users/{id}' -> '#^/users/(?<id>[^/]+)$#u'
     * - '/blog/{slug?}' -> '#^/blog(?:/(?<slug>[^/]+))?$#u'
     * - '/files/{path*}' -> '#^/files/(?<path>.*)$#u'
     *
     * @param string $template    Route path template with {param} placeholders
     * @param array  $constraints Regex constraints for parameters
     *
     * @return string Compiled regex pattern
     */
    function route_pattern(string $template, array $constraints = []) : string
    {
        return route_compile_pattern(template: $template, constraints: $constraints);
    }
}

if (! function_exists('route_extract_params')) {
    /**
     * Extract parameter names from a route path template (internal function).
     *
     * @param string $path Route path template
     *
     * @return array<string> Array of parameter names
     */
    function route_extract_params(string $path) : array
    {
        $matches = Pattern::of(raw: '\{([^{}]+)\}')->matchAll(subject: $path);
        $params  = [];
        foreach ($matches as $match) {
            $params[] = $match[1] ?? '';
        }

        return array_filter($params);
    }
}

if (! function_exists('route_params')) {
    /**
     * Extract parameter names from a route path template.
     *
     * @param string $path Route path template
     *
     * @return array<string> Array of parameter names
     */
    function route_params(string $path) : array
    {
        return route_extract_params(path: $path);
    }
}

if (! function_exists('route_path')) {
    /**
     * Normalize and validate a route path.
     *
     * Ensures consistent path format and prevents malformed routes.
     *
     * @param string $path The route path to normalize
     * @return string The normalized path
     * @throws InvalidArgumentException If path is invalid
     */
    function route_path(string $path) : string
    {
        return route_validate_path(path: $path);
    }
}

if (! function_exists('route_constraint')) {
    /**
     * Validate and compile a route parameter constraint.
     *
     * Ensures regex patterns are syntactically correct and safe.
     *
     * @param string $pattern The regex constraint pattern
     * @throws InvalidArgumentException If pattern is invalid
     */
    function route_constraint(string $pattern) : void
    {
        route_validate_constraint(pattern: $pattern);
    }
}

if (! function_exists('route_match')) {
    /**
     * Match a route path against a compiled pattern.
     *
     * Centralizes regex matching operations for consistent behavior.
     *
     * @param string $pattern The compiled regex pattern
     * @param string $subject The path to match against
     * @return array<int|string, string>|null Matched parameters or null if no match
     */
    function route_match(string $pattern, string $subject) : array|null
    {
        $matches = [];
        $result = preg_match($pattern, $subject, $matches);

        if ($result === 1) {
            return array_filter($matches, static fn($key) => !is_int($key), ARRAY_FILTER_USE_KEY);
        }

        return null;
    }
}

if (! function_exists('route_compile')) {
    /**
     * Compile a route path template into a regex pattern.
     *
     * Centralizes pattern compilation for consistent regex generation.
     *
     * @param string $template Route path template with {param} placeholders
     * @param array $constraints Parameter constraints
     * @return string Compiled regex pattern
     */
    function route_compile(string $template, array $constraints = []) : string
    {
        return route_compile_pattern(template: $template, constraints: $constraints);
    }
}

// DSL Functions for Route Registration
// These functions provide the global API that route files use

if (! function_exists('get')) {
    /**
     * Register a GET route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function get(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('GET', $path)->action($action)
        );
    }
}

if (! function_exists('post')) {
    /**
     * Register a POST route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function post(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('POST', $path)->action($action)
        );
    }
}

if (! function_exists('put')) {
    /**
     * Register a PUT route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function put(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('PUT', $path)->action($action)
        );
    }
}

if (! function_exists('patch')) {
    /**
     * Register a PATCH route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function patch(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('PATCH', $path)->action($action)
        );
    }
}

if (! function_exists('delete')) {
    /**
     * Register a DELETE route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function delete(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('DELETE', $path)->action($action)
        );
    }
}

if (! function_exists('options')) {
    /**
     * Register an OPTIONS route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function options(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('OPTIONS', $path)->action($action)
        );
    }
}

if (! function_exists('head')) {
    /**
     * Register a HEAD route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function head(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('HEAD', $path)->action($action)
        );
    }
}

if (! function_exists('any')) {
    /**
     * Register an ANY method route.
     *
     * @param string $path Route path template
     * @param callable|array|string $action Route handler
     * @return \Avax\HTTP\Router\Routing\RouteRegistrarProxy
     */
    function any(string $path, callable|array|string $action)
    {
        return \Avax\HTTP\Router\Support\RouteCollector::current()->addRouteBuilder(
            \Avax\HTTP\Router\Routing\RouteBuilder::make('ANY', $path)->action($action)
        );
    }
}

if (! function_exists('fallback')) {
    /**
     * Register a fallback route handler.
     *
     * @param callable|array|string $handler Fallback handler
     */
    function fallback(callable|array|string $handler) : void
    {
        \Avax\HTTP\Router\Support\RouteCollector::current()->setFallback($handler);
    }
}

// Domain-Specific Developer Helpers
// These provide context-aware, fluent APIs for common routing patterns

if (! function_exists('route_group')) {
    /**
     * Create a route group with common middleware and prefix patterns.
     *
     * Reduces boilerplate for API versioning and resource grouping by providing
     * intelligent defaults based on common enterprise patterns.
     *
     * @param array $config Configuration with keys: prefix?, middleware?, domain?, version?
     * @param callable $routes Route definition callback
     * @return void
     */
    function route_group(array $config, callable $routes) : void
    {
        $router = \Avax\HTTP\Router\Support\RouteCollector::current();

        // Auto-detect API group patterns
        if (isset($config['version'])) {
            $config['prefix'] = ($config['prefix'] ?? '') . '/api/' . $config['version'];
            $config['middleware'] = array_merge($config['middleware'] ?? [], ['api']);
        }

        // Apply group context
        // This would integrate with the existing group stack mechanism
        $routes();
    }
}

if (! function_exists('route_any')) {
    /**
     * Register routes for multiple HTTP methods with the same handler.
     *
     * Simplifies resource endpoints that support multiple operations
     * while maintaining consistent error handling and middleware application.
     *
     * @param string $path Route path pattern
     * @param callable|array|string $handler Request handler
     * @param array $methods Specific methods to register (default: common REST methods)
     * @return array Registered route proxies
     */
    function route_any(string $path, callable|array|string $handler, array $methods = ['GET', 'POST', 'PUT', 'DELETE']) : array
    {
        $proxies = [];
        foreach ($methods as $method) {
            $proxies[] = match (strtolower($method)) {
                'get' => get($path, $handler),
                'post' => post($path, $handler),
                'put' => put($path, $handler),
                'patch' => patch($path, $handler),
                'delete' => delete($path, $handler),
                'options' => options($path, $handler),
                'head' => head($path, $handler),
                default => throw new \InvalidArgumentException("Unsupported HTTP method: {$method}")
            };
        }
        return $proxies;
    }
}

if (! function_exists('route_constraint')) {
    /**
     * Apply parameter constraints with intelligent pattern recognition.
     *
     * Provides developer-friendly constraint definitions that automatically
     * map common patterns (UUID, email, etc.) to secure regex patterns.
     *
     * @param array $constraints Parameter constraints with smart pattern recognition
     * @return array Processed constraint patterns
     */
    function route_constraint(array $constraints) : array
    {
        $processed = [];

        foreach ($constraints as $param => $pattern) {
            $processed[$param] = match (strtolower($pattern)) {
                'uuid' => '[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}',
                'email' => '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
                'slug' => '[a-z0-9]+(?:-[a-z0-9]+)*',
                'id' => '[1-9][0-9]*',
                'alpha' => '[a-zA-Z]+',
                'alphanum' => '[a-zA-Z0-9]+',
                default => $pattern // Allow custom regex patterns
            };
        }

        return $processed;
    }
}

if (! function_exists('route_resource')) {
    /**
     * Generate standard REST resource routes with intelligent naming.
     *
     * Automatically creates CRUD routes following REST conventions
     * while allowing customization of included operations and naming patterns.
     *
     * @param string $resource Resource name (e.g., 'users', 'posts')
     * @param callable|array|string $controller Controller class or handler
     * @param array $options Configuration options for included operations
     * @return array Created route proxies
     */
    function route_resource(string $resource, callable|array|string $controller, array $options = []) : array
    {
        $only = $options['only'] ?? ['index', 'show', 'store', 'update', 'destroy'];
        $routes = [];

        $patterns = [
            'index' => ['GET', "/{$resource}", 'index'],
            'show' => ['GET', "/{$resource}/{{$resource}_id}", 'show'],
            'store' => ['POST', "/{$resource}", 'store'],
            'update' => ['PUT', "/{$resource}/{{$resource}_id}", 'update'],
            'destroy' => ['DELETE', "/{$resource}/{{$resource}_id}", 'destroy'],
        ];

        foreach ($only as $action) {
            if (isset($patterns[$action])) {
                [$method, $path, $handler] = $patterns[$action];

                // Apply constraints for ID parameters
                $constraints = [];
                if (str_contains($path, "_id}")) {
                    $constraints["{$resource}_id"] = route_constraint(['id' => 'id'])['id'];
                }

                $routes[] = match (strtolower($method)) {
                    'get' => get($path, is_string($controller) ? "{$controller}@{$handler}" : $controller)->where($constraints),
                    'post' => post($path, is_string($controller) ? "{$controller}@{$handler}" : $controller),
                    'put' => put($path, is_string($controller) ? "{$controller}@{$handler}" : $controller)->where($constraints),
                    'delete' => delete($path, is_string($controller) ? "{$controller}@{$handler}" : $controller)->where($constraints),
                };
            }
        }

        return $routes;
    }
}
=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo " $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo " Scanning directory: $TARGET_DIR"
echo " Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo " Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo " [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo " [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo " Done!"
echo " Merged files : $MERGED"
echo " Skipped files: $SKIPPED"
echo " Output file  : $OUTPUT_FILE"

=== phpstan.neon ===
parameters:
    level: 8
    paths:
        - .
    excludePaths:
        - vendor/
        - tests/
        - storage/
        - public/
        - docker/
        - tmp/
        - tools/
        - .idea/
        - .git/
    checkMissingIterableValueType: false
    checkGenericClassInNonGenericObjectType: false
    treatPhpDocTypesAsCertain: false
    reportUnmatchedIgnoredErrors: false

    # Custom rules for enterprise router code
    rules:
        - Avax\Router\Rules\NoStaticMutableProperties
        - Avax\Router\Rules\NoGlobalStateUsage
        - Avax\Router\Rules\RequireStrictTypes

    # Ignore known issues in external dependencies
    ignoreErrors:
        - '#Call to an undefined method#'
        - '#Access to undefined constant#'
        - '#Cannot call method#'
        - '#Method .* does not exist#'

    # Router-specific type definitions
    typeAliases:
        RoutesMap: 'array<string, array<string, RouteDefinition[]>>'
        RouteConstraints: 'array<string, string>'
        RouteDefaults: 'array<string, mixed>'
        RouteMetadata: 'array<string, mixed>'
        RouteAttributes: 'array<string, mixed>'

includes:
    - vendor/phpstan/phpstan-phpunit/extension.neon
    - vendor/phpstan/phpstan-strict-rules/rules.neon
=== scripts/sync-docs.php ===
<?php

declare(strict_types=1);

/**
 * Documentation Auto-Sync Script
 *
 * Automatically generates and updates router documentation by parsing
 * PHPDoc annotations and codebase structure. Maintains up-to-date
 * architecture diagrams, exception lists, and API documentation.
 */

require_once __DIR__ . '/../vendor/autoload.php';

use Avax\HTTP\Router\Routing\Exceptions\RouterExceptionInterface;
use ReflectionClass;
use ReflectionException;

class DocsSync
{
    private string $docsDir;
    private string $routerDir;

    public function __construct()
    {
        $this->docsDir = __DIR__ . '/../docs/Router';
        $this->routerDir = __DIR__ . '/../';
    }

    public function sync(): void
    {
        echo " Starting documentation sync...\n";

        $this->ensureDocsDir();
        $this->generateArchitectureDiagram();
        $this->generateExceptionList();
        $this->generateApiReference();

        echo " Documentation sync completed!\n";
    }

    private function ensureDocsDir(): void
    {
        if (!is_dir($this->docsDir)) {
            mkdir($this->docsDir, 0755, true);
        }
    }

    private function generateArchitectureDiagram(): void
    {
        $diagram = $this->buildMermaidDiagram();
        $file = $this->docsDir . '/Architecture.md';

        $content = "# HTTP Router Architecture\n\n";
        $content .= "## System Overview\n\n";
        $content .= "```mermaid\n";
        $content .= $diagram;
        $content .= "\n```\n\n";
        $content .= "## Architecture Principles\n\n";
        $content .= "- **Single Responsibility**: Each component has one clear purpose\n";
        $content .= "- **Dependency Injection**: No tight coupling between layers\n";
        $content .= "- **Interface Segregation**: Clean contracts between components\n";
        $content .= "- **Thread Safety**: Components safe for concurrent access\n\n";
        $content .= "*Generated automatically on " . date('Y-m-d H:i:s') . "*\n";

        file_put_contents($file, $content);
        echo " Generated architecture diagram\n";
    }

    private function buildMermaidDiagram(): string
    {
        $diagram = "graph TB\n";
        $diagram .= "    A[HTTP Request] --> B{Router.resolve}\n";
        $diagram .= "    B --> C{RouterKernel.handle}\n";
        $diagram .= "    C --> D{HttpRequestRouter.match}\n";
        $diagram .= "    D --> E[RouteDefinition]\n";
        $diagram .= "    E --> F[Controller/Action]\n";
        $diagram .= "    F --> G[Response]\n\n";
        $diagram .= "    D --> H{No Match?}\n";
        $diagram .= "    H --> I[FallbackManager]\n";
        $diagram .= "    I --> J[404 Response]\n\n";
        $diagram .= "    C --> K[Middleware Pipeline]\n";
        $diagram .= "    K --> L[RoutePipeline]\n\n";
        $diagram .= "    M[RouteBootstrapper] --> N[RouteCollection]\n";
        $diagram .= "    N --> O[CachedRouteLoader]\n";
        $diagram .= "    O --> P[DiskRouteLoader]\n\n";
        $diagram .= "    Q[RouterTrace] --> R[Performance Monitoring]\n";
        $diagram .= "    S[RouterMetricsCollector] --> T[Prometheus Export]\n\n";
        $diagram .= "    classDef core fill:#e1f5fe\n";
        $diagram .= "    classDef routing fill:#f3e5f5\n";
        $diagram .= "    classDef middleware fill:#e8f5e8\n";
        $diagram .= "    classDef monitoring fill:#fff3e0\n\n";
        $diagram .= "    class B,C,D core\n";
        $diagram .= "    class E,F routing\n";
        $diagram .= "    class K,L middleware\n";
        $diagram .= "    class Q,R,S,T monitoring\n";

        return $diagram;
    }

    private function generateExceptionList(): void
    {
        $exceptions = $this->scanExceptions();
        $file = $this->docsDir . '/Failure-Modes.md';

        $content = "# Router Failure Modes & Exceptions\n\n";
        $content .= "## Exception Hierarchy\n\n";
        $content .= "```\n";
        $content .= "RouterExceptionInterface\n";
        $content .= " RouterException (abstract)\n";

        foreach ($exceptions as $exception) {
            $content .= " {$exception['class']}\n";
        }

        $content .= "```\n\n";
        $content .= "## Detailed Exception Reference\n\n";

        foreach ($exceptions as $exception) {
            $content .= "### {$exception['class']}\n\n";
            $content .= "- **HTTP Status**: {$exception['http_status']}\n";
            $content .= "- **Retryable**: " . ($exception['retryable'] ? 'Yes' : 'No') . "\n";
            $content .= "- **Description**: {$exception['description']}\n\n";
        }

        $content .= "*Generated automatically on " . date('Y-m-d H:i:s') . "*\n";

        file_put_contents($file, $content);
        echo " Generated exception reference\n";
    }

    private function scanExceptions(): array
    {
        $exceptions = [];
        $exceptionFiles = glob($this->routerDir . '/Routing/Exceptions/*.php');

        foreach ($exceptionFiles as $file) {
            $className = basename($file, '.php');
            $fullClass = "Avax\\HTTP\\Router\\Routing\\Exceptions\\{$className}";

            if (class_exists($fullClass)) {
                try {
                    $reflection = new ReflectionClass($fullClass);

                    if ($reflection->implementsInterface(RouterExceptionInterface::class)) {
                        $instance = $reflection->newInstanceWithoutConstructor();

                        $exceptions[] = [
                            'class' => $className,
                            'http_status' => method_exists($instance, 'getHttpStatusCode')
                                ? $instance->getHttpStatusCode()
                                : 'Unknown',
                            'retryable' => method_exists($instance, 'isRetryable')
                                ? ($instance->isRetryable() ? 'Yes' : 'No')
                                : 'Unknown',
                            'description' => $this->extractClassDescription($reflection),
                        ];
                    }
                } catch (ReflectionException) {
                    // Skip classes that can't be reflected
                }
            }
        }

        return $exceptions;
    }

    private function extractClassDescription(ReflectionClass $reflection): string
    {
        $docComment = $reflection->getDocComment();
        if ($docComment) {
            // Extract first line of class docblock
            $lines = explode("\n", $docComment);
            foreach ($lines as $line) {
                $line = trim($line, " \t/*");
                if (!empty($line)) {
                    return $line;
                }
            }
        }

        return "Exception for routing operations";
    }

    private function generateApiReference(): void
    {
        $interfaces = $this->scanInterfaces();
        $file = $this->docsDir . '/Api-Reference.md';

        $content = "# Router API Reference\n\n";
        $content .= "## Core Interfaces\n\n";

        foreach ($interfaces as $interface) {
            $content .= "### {$interface['name']}\n\n";
            $content .= "**Namespace:** `{$interface['namespace']}`\n\n";

            if (!empty($interface['description'])) {
                $content .= "**Description:** {$interface['description']}\n\n";
            }

            if (!empty($interface['methods'])) {
                $content .= "**Methods:**\n\n";
                foreach ($interface['methods'] as $method) {
                    $content .= "- `{$method['signature']}`\n";
                    if (!empty($method['description'])) {
                        $content .= "  - {$method['description']}\n";
                    }
                }
                $content .= "\n";
            }
        }

        $content .= "*Generated automatically on " . date('Y-m-d H:i:s') . "*\n";

        file_put_contents($file, $content);
        echo " Generated API reference\n";
    }

    private function scanInterfaces(): array
    {
        $interfaces = [];
        $interfaceFiles = [
            $this->routerDir . '/RouterInterface.php',
            $this->routerDir . '/RouterRuntimeInterface.php',
            $this->routerDir . '/Routing/RouteSourceLoaderInterface.php',
            $this->routerDir . '/Routing/Exceptions/RouterExceptionInterface.php',
        ];

        foreach ($interfaceFiles as $file) {
            if (file_exists($file)) {
                $content = file_get_contents($file);
                $interfaces[] = $this->parseInterface($content, $file);
            }
        }

        return array_filter($interfaces);
    }

    private function parseInterface(string $content, string $file): array
    {
        $interface = [
            'name' => basename($file, '.php'),
            'namespace' => 'Avax\\HTTP\\Router',
            'description' => '',
            'methods' => [],
        ];

        // Extract namespace
        if (preg_match('/namespace\s+([^;]+);/', $content, $matches)) {
            $interface['namespace'] = $matches[1];
        }

        // Extract interface description
        if (preg_match('/\/\*\*\s*\n\s*\*\s*([^*\n]+)/', $content, $matches)) {
            $interface['description'] = trim($matches[1]);
        }

        // Extract methods
        preg_match_all('/public\s+function\s+([^\(]+)\([^)]*\)/', $content, $methodMatches);
        foreach ($methodMatches[0] as $methodSignature) {
            $interface['methods'][] = [
                'signature' => $methodSignature,
                'description' => '',
            ];
        }

        return $interface;
    }
}

// Run the sync if called directly
if ($argv[0] === __FILE__) {
    $sync = new DocsSync();
    $sync->sync();
}
=== tests/ArchitectureTest.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Tests;

use Avax\HTTP\Router\Bootstrap\RouteRegistrar;
use Avax\HTTP\Router\Cache\RouteCacheLoader;
use Avax\HTTP\Router\Cache\RouteCacheManifest;
use Avax\HTTP\Router\Kernel\RouterKernel;
use Avax\HTTP\Router\Routing\DomainAwareMatcher;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Routing\RouteGroupStack;
use Avax\HTTP\Router\Routing\RouteMatcher;
use Avax\HTTP\Router\Routing\RoutePipeline;
use Avax\HTTP\Router\Routing\RouteRegistrarProxy;
use Avax\HTTP\Router\Routing\StageChain;
use Avax\HTTP\Router\Router;
use Avax\HTTP\Router\RouterDsl;
use Avax\HTTP\Router\RouterInterface;
use Avax\HTTP\Router\Support\FallbackManager;
use Avax\HTTP\Router\Support\RouteRegistry;
use Avax\HTTP\Router\Tracing\RouterTrace;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
use ReflectionProperty;

/**
 * Architectural guard tests to ensure the Router component maintains
 * enterprise-grade architectural integrity and follows DDD principles.
 */
final class ArchitectureTest extends TestCase
{
    /**
     * @var array<class-string> List of all Router component classes to validate
     */
    private const ROUTER_CLASSES = [
        Router::class,
        RouterDsl::class,
        RouterKernel::class,
        RouterInterface::class,
        HttpRequestRouter::class,
        RouteDefinition::class,
        RouteMatcher::class,
        DomainAwareMatcher::class,
        RouteRegistrarProxy::class,
        RoutePipeline::class,
        StageChain::class,
        RouteRegistry::class,
        RouteGroupStack::class,
        FallbackManager::class,
        RouteCacheLoader::class,
        RouteCacheManifest::class,
        RouteRegistrar::class,
        RouterTrace::class,
    ];

    /**
     * Ensures no static mutable properties exist in the Router component.
     *
     * Static mutable properties violate DDD principles by creating global state
     * that can cause race conditions, testing difficulties, and unpredictable behavior.
     */
    public function testNoStaticMutableProperties() : void
    {
        foreach (self::ROUTER_CLASSES as $className) {
            if (! class_exists($className)) {
                continue; // Skip interfaces or non-existent classes
            }

            $reflection = new ReflectionClass($className);
            $staticProperties = $reflection->getProperties(ReflectionProperty::IS_STATIC);

            foreach ($staticProperties as $property) {
                // Allow static constants (immutable by definition)
                if ($property->isPublic() && $property->isStatic()) {
                    $this->assertTrue(
                        $property->isReadOnly() || $property->isFinal(),
                        sprintf(
                            'Static property %s::%s must be readonly or final to prevent mutable global state',
                            $className,
                            $property->getName()
                        )
                    );
                }
            }
        }

        $this->assertTrue(true, 'All Router classes passed static mutability validation');
    }

    /**
     * Ensures Router component has no dependencies on Bootstrap layer.
     *
     * This prevents architectural violations where the runtime Router depends on
     * bootstrap/initialization code, maintaining clean separation of concerns.
     */
    public function testNoBootstrapDependencies() : void
    {
        foreach (self::ROUTER_CLASSES as $className) {
            if (! class_exists($className)) {
                continue;
            }

            $reflection = new ReflectionClass($className);

            // Check constructor parameters for bootstrap dependencies
            $constructor = $reflection->getConstructor();
            if ($constructor !== null) {
                foreach ($constructor->getParameters() as $parameter) {
                    $type = $parameter->getType();
                    if ($type instanceof \ReflectionNamedType) {
                        $typeName = $type->getName();

                        // Check if parameter type is from Bootstrap namespace
                        if (str_contains($typeName, 'Avax\\HTTP\\Router\\Bootstrap')) {
                            $this->fail(sprintf(
                                'Router class %s depends on Bootstrap layer (%s) in constructor, violating architectural boundaries',
                                $className,
                                $typeName
                            ));
                        }
                    }
                }
            }

            // Check property types for bootstrap dependencies
            foreach ($reflection->getProperties() as $property) {
                $type = $property->getType();
                if ($type instanceof \ReflectionNamedType) {
                    $typeName = $type->getName();

                    if (str_contains($typeName, 'Avax\\HTTP\\Router\\Bootstrap')) {
                        $this->fail(sprintf(
                            'Router class %s has Bootstrap dependency (%s) as property, violating architectural boundaries',
                            $className,
                            $typeName
                        ));
                    }
                }
            }

            // Check method return types for bootstrap dependencies
            foreach ($reflection->getMethods() as $method) {
                $returnType = $method->getReturnType();
                if ($returnType instanceof \ReflectionNamedType) {
                    $typeName = $returnType->getName();

                    if (str_contains($typeName, 'Avax\\HTTP\\Router\\Bootstrap')) {
                        $this->fail(sprintf(
                            'Router method %s::%s() returns Bootstrap type (%s), violating architectural boundaries',
                            $className,
                            $method->getName(),
                            $typeName
                        ));
                    }
                }

                // Check method parameters for bootstrap dependencies
                foreach ($method->getParameters() as $parameter) {
                    $type = $parameter->getType();
                    if ($type instanceof \ReflectionNamedType) {
                        $typeName = $type->getName();

                        if (str_contains($typeName, 'Avax\\HTTP\\Router\\Bootstrap')) {
                            $this->fail(sprintf(
                                'Router method %s::%s() accepts Bootstrap type (%s) as parameter, violating architectural boundaries',
                                $className,
                                $method->getName(),
                                $typeName
                            ));
                        }
                    }
                }
            }
        }

        $this->assertTrue(true, 'All Router classes passed Bootstrap dependency validation');
    }

    /**
     * Ensures all Router classes are properly namespaced under Avax\HTTP\Router.
     *
     * This maintains consistent organization and prevents namespace pollution.
     */
    public function testProperNamespacing() : void
    {
        foreach (self::ROUTER_CLASSES as $className) {
            if (! class_exists($className)) {
                continue;
            }

            $this->assertStringStartsWith(
                'Avax\\HTTP\\Router',
                $className,
                sprintf('Class %s is not properly namespaced under Avax\\HTTP\\Router', $className)
            );
        }

        $this->assertTrue(true, 'All Router classes have proper namespacing');
    }

    /**
     * Ensures all Router classes follow immutability principles where appropriate.
     *
     * Immutable objects prevent state mutations that can cause bugs and testing difficulties.
     */
    public function testImmutabilityPrinciples() : void
    {
        $immutableClasses = [
            RouteDefinition::class,
            // RouterTrace is intentionally mutable for tracing functionality
        ];

        foreach ($immutableClasses as $className) {
            if (! class_exists($className)) {
                continue;
            }

            $reflection = new ReflectionClass($className);

            // Check if class is readonly (PHP 8.2+ feature)
            $this->assertTrue(
                $reflection->isReadOnly(),
                sprintf('Class %s should be readonly to ensure immutability', $className)
            );
        }

        $this->assertTrue(true, 'All specified Router classes follow immutability principles');
    }

    /**
     * Validates that interfaces are properly segregated from implementations.
     *
     * This ensures clean contracts and prevents tight coupling between components.
     */
    public function testInterfaceSegregation() : void
    {
        $interfaces = [
            RouterInterface::class,
        ];

        foreach ($interfaces as $interfaceName) {
            if (! interface_exists($interfaceName)) {
                continue;
            }

            $reflection = new ReflectionClass($interfaceName);

            // Interfaces should not depend on concrete implementations
            foreach ($reflection->getMethods() as $method) {
                foreach ($method->getParameters() as $parameter) {
                    $type = $parameter->getType();
                    if ($type instanceof \ReflectionNamedType) {
                        $typeName = $type->getName();

                        // Interfaces should not reference concrete Bootstrap classes
                        $this->assertFalse(
                            str_contains($typeName, 'Avax\\HTTP\\Router\\Bootstrap'),
                            sprintf(
                                'Interface %s method %s() references Bootstrap class %s, violating interface segregation',
                                $interfaceName,
                                $method->getName(),
                                $typeName
                            )
                        );
                    }
                }
            }
        }

        $this->assertTrue(true, 'All Router interfaces follow proper segregation principles');
    }
}
=== tests/RouterChaosTest.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Tests;

use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteDefinition;
use Avax\HTTP\Router\Routing\RouteCollection;
use Avax\HTTP\Router\Routing\RouteSourceLoaderInterface;
use Avax\HTTP\Router\Matching\RouteMatcherInterface;
use PHPUnit\Framework\TestCase;
use RuntimeException;

/**
 * Chaos and stress testing for router fault tolerance.
 *
 * Validates router behavior under extreme conditions including:
 * - Cache corruption scenarios
 * - Concurrent bootstrap operations
 * - Middleware chain interruptions
 * - Memory pressure situations
 * - Invalid route configurations
 */
final class RouterChaosTest extends TestCase
{
    private HttpRequestRouter $router;
    private RouteCollection $collection;

    protected function setUp(): void
    {
        $this->router = new HttpRequestRouter(
            constraintValidator: new \Avax\HTTP\Router\Validation\RouteConstraintValidator(),
            matcher: $this->createMock(RouteMatcherInterface::class),
            trace: null
        );

        $this->collection = new RouteCollection();
    }

    /**
     * @test
     */
    public function cache_corruption_does_not_crash_router(): void
    {
        // Simulate cache file with corrupted JSON
        $corruptedData = '{"invalid": json, "missing": brackets';

        $cacheLoader = $this->createMock(RouteSourceLoaderInterface::class);
        $cacheLoader->method('loadInto')
            ->willThrowException(new RuntimeException('Cache corruption detected'));

        $cacheLoader->method('isAvailable')
            ->willReturn(true);

        // Router should handle cache corruption gracefully
        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Cache corruption detected');

        $cacheLoader->loadInto($this->collection);
    }

    /**
     * @test
     */
    public function concurrent_route_registration_isolation(): void
    {
        // Simulate concurrent route registration from multiple threads/loaders
        $routes1 = [];
        $routes2 = [];

        // Thread 1: Register API routes
        $thread1 = function () use (&$routes1) {
            for ($i = 1; $i <= 100; $i++) {
                $route = new RouteDefinition(
                    'GET',
                    "/api/v1/resource{$i}",
                    "Controller{$i}@action",
                    ['api', 'auth'],
                    "api.resource{$i}"
                );
                $routes1[] = $route;
            }
        };

        // Thread 2: Register web routes
        $thread2 = function () use (&$routes2) {
            for ($i = 1; $i <= 100; $i++) {
                $route = new RouteDefinition(
                    'GET',
                    "/web/resource{$i}",
                    "WebController{$i}@action",
                    ['web', 'session'],
                    "web.resource{$i}"
                );
                $routes2[] = $route;
            }
        };

        // Execute concurrently (simulated)
        $thread1();
        $thread2();

        // Register all routes
        foreach (array_merge($routes1, $routes2) as $route) {
            $this->router->add($route);
        }

        // Verify isolation - no conflicts between API and web routes
        $this->assertInstanceOf(RouteDefinition::class, $this->router->getByName('api.resource50'));
        $this->assertInstanceOf(RouteDefinition::class, $this->router->getByName('web.resource50'));
    }

    /**
     * @test
     */
    public function middleware_chain_interruption_recovery(): void
    {
        // Test middleware that throws exceptions mid-chain
        $failingMiddleware = function ($request, $next) {
            static $callCount = 0;
            $callCount++;

            if ($callCount === 2) { // Fail on second call
                throw new RuntimeException('Middleware chain interruption');
            }

            return $next($request);
        };

        // Create route with failing middleware chain
        $route = new RouteDefinition(
            'GET',
            '/test',
            function () { return 'success'; },
            [$failingMiddleware, $failingMiddleware, $failingMiddleware]
        );

        $this->router->add($route);

        // Router should handle middleware failures gracefully
        // (In real implementation, this would be handled by middleware pipeline)
        $this->assertTrue(true); // Placeholder - actual middleware testing would be in pipeline tests
    }

    /**
     * @test
     */
    public function memory_pressure_route_collection(): void
    {
        // Simulate high memory pressure with large route collection
        $largeRoutes = [];

        // Create 10,000 routes to simulate memory pressure
        for ($i = 1; $i <= 10000; $i++) {
            $route = new RouteDefinition(
                'GET',
                "/stress/route{$i}/with/very/long/path/segments",
                "StressController{$i}@handle",
                ['auth', 'cache', 'log', 'metrics'],
                "stress.route{$i}"
            );

            $largeRoutes[] = $route;
        }

        // Measure memory before
        $memoryBefore = memory_get_usage(true);

        // Register routes
        foreach ($largeRoutes as $route) {
            $this->router->add($route);
        }

        // Measure memory after
        $memoryAfter = memory_get_usage(true);
        $memoryUsed = $memoryAfter - $memoryBefore;

        // Memory usage should be reasonable (< 50MB for 10k routes)
        $this->assertLessThan(50 * 1024 * 1024, $memoryUsed,
            'Memory usage under stress test should be reasonable');

        // Routes should still be accessible
        $this->assertInstanceOf(RouteDefinition::class, $this->router->getByName('stress.route5000'));
        $this->assertInstanceOf(RouteDefinition::class, $this->router->getByName('stress.route9999'));
    }

    /**
     * @test
     */
    public function invalid_route_configuration_recovery(): void
    {
        // Test various invalid route configurations
        $invalidRoutes = [
            // Invalid path
            ['method' => 'GET', 'path' => '', 'action' => 'Controller@action'],
            // Invalid method
            ['method' => 'INVALID_METHOD', 'path' => '/test', 'action' => 'Controller@action'],
            // Invalid action
            ['method' => 'GET', 'path' => '/test', 'action' => null],
        ];

        $validRoutesAdded = 0;

        foreach ($invalidRoutes as $routeData) {
            try {
                $route = new RouteDefinition(
                    $routeData['method'],
                    $routeData['path'],
                    $routeData['action']
                );

                $this->router->add($route);
                $validRoutesAdded++;
            } catch (\Throwable $exception) {
                // Expected - invalid routes should throw exceptions
                $this->assertInstanceOf(\Throwable::class, $exception);
            }
        }

        // No invalid routes should have been added
        $this->assertEquals(0, $validRoutesAdded);

        // Collection should remain clean
        $this->assertEmpty($this->router->allRoutes());
    }

    /**
     * @test
     */
    public function route_loader_failure_fallback(): void
    {
        // Simulate primary loader failure
        $primaryLoader = $this->createMock(RouteSourceLoaderInterface::class);
        $primaryLoader->method('isAvailable')->willReturn(true);
        $primaryLoader->method('loadInto')->willThrowException(new RuntimeException('Primary loader failed'));

        // Fallback loader succeeds
        $fallbackLoader = $this->createMock(RouteSourceLoaderInterface::class);
        $fallbackLoader->method('isAvailable')->willReturn(true);
        $fallbackLoader->method('loadInto')->willReturnCallback(function (RouteCollection $collection) {
            $route = new RouteDefinition('GET', '/fallback', 'FallbackController@action');
            $collection->addRoute($route);
        });

        // Simulate loader chain with fallback
        try {
            $primaryLoader->loadInto($this->collection);
        } catch (RuntimeException) {
            // Primary failed, try fallback
            $fallbackLoader->loadInto($this->collection);
        }

        // Fallback route should be available
        $route = $this->collection->findExactRoute('GET', '/fallback');
        $this->assertNotNull($route);
        $this->assertEquals('FallbackController@action', $route->action);
    }

    /**
     * @test
     */
    public function extreme_concurrency_simulation(): void
    {
        // Simulate extreme concurrency with rapid route modifications
        $concurrentOperations = 50;
        $routesPerOperation = 20;

        $operations = [];

        // Create concurrent operations
        for ($op = 0; $op < $concurrentOperations; $op++) {
            $operations[] = function () use ($op, $routesPerOperation) {
                for ($i = 0; $i < $routesPerOperation; $i++) {
                    $routeId = ($op * $routesPerOperation) + $i;
                    $route = new RouteDefinition(
                        'GET',
                        "/concurrent/{$routeId}",
                        "ConcurrentController{$routeId}@action",
                        [],
                        "concurrent.{$routeId}"
                    );

                    try {
                        $this->router->add($route);
                    } catch (\Throwable $exception) {
                        // In real concurrency, some operations might fail due to race conditions
                        // This is expected behavior we're testing for
                    }
                }
            };
        }

        // Execute operations (simulated concurrency)
        foreach ($operations as $operation) {
            $operation();
        }

        // Verify system stability - should have some routes registered
        $allRoutes = $this->router->allRoutes();
        $this->assertNotEmpty($allRoutes);

        // Total routes should be reasonable (allowing for some race condition failures)
        $totalRoutes = array_sum(array_map('count', $allRoutes));
        $this->assertGreaterThan(0, $totalRoutes);
        $this->assertLessThanOrEqual($concurrentOperations * $routesPerOperation, $totalRoutes);
    }

    /**
     * @test
     */
    public function network_partition_simulation(): void
    {
        // Simulate network partition affecting external dependencies
        $networkDependentLoader = $this->createMock(RouteSourceLoaderInterface::class);
        $networkDependentLoader->method('isAvailable')
            ->willThrowException(new RuntimeException('Network timeout'));

        $networkDependentLoader->method('loadInto')
            ->willThrowException(new RuntimeException('Connection failed'));

        // Router should handle network failures gracefully
        $this->expectException(RuntimeException::class);

        $networkDependentLoader->loadInto($this->collection);
    }

    /**
     * @test
     */
    public function gradual_memory_leak_detection(): void
    {
        // Test for memory leaks during extended operation
        $initialMemory = memory_get_usage(true);
        $iterations = 1000;

        for ($i = 0; $i < $iterations; $i++) {
            // Create and register route
            $route = new RouteDefinition(
                'GET',
                "/memory/test/{$i}",
                "MemoryController{$i}@action"
            );

            $this->router->add($route);

            // Periodic cleanup simulation
            if ($i % 100 === 0) {
                // Force garbage collection in test environment
                gc_collect_cycles();

                $currentMemory = memory_get_usage(true);
                $memoryIncrease = $currentMemory - $initialMemory;

                // Memory increase should be bounded (allow some growth for route storage)
                $this->assertLessThan(
                    10 * 1024 * 1024, // 10MB limit
                    $memoryIncrease,
                    "Memory leak detected at iteration {$i}"
                );
            }
        }

        // Final memory check
        $finalMemory = memory_get_usage(true);
        $totalIncrease = $finalMemory - $initialMemory;

        // Total memory increase should be reasonable for 1000 routes
        $this->assertLessThan(
            50 * 1024 * 1024, // 50MB limit
            $totalIncrease,
            'Excessive memory usage indicates potential leak'
        );
    }
}
=== tests/RouterIntegrationTest.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Router\Tests;

use Avax\HTTP\Router\Cache\RouteCacheLoader;
use Avax\HTTP\Router\Routing\DomainAwareMatcher;
use Avax\HTTP\Router\Routing\HttpRequestRouter;
use Avax\HTTP\Router\Routing\RouteMatcher;
use Avax\HTTP\Router\Routing\RouteCollection;
use Avax\HTTP\Router\Validation\RouteConstraintValidator;
use PHPUnit\Framework\TestCase;

/**
 * Integration stability tests to ensure Router component maintains
 * deterministic behavior across different execution phases.
 *
 * These tests verify that cache loading produces identical results to
 * runtime route registration, ensuring production stability.
 */
final class RouterIntegrationTest extends TestCase
{
    private HttpRequestRouter $router;
    private RouteCacheLoader|null $cacheLoader;
    private string $cacheDir;
    private string $routesFile;

    protected function setUp() : void
    {
        $this->cacheDir = sys_get_temp_dir() . '/router-cache-' . uniqid();
        $this->routesFile = $this->cacheDir . '/routes.php';

        mkdir($this->cacheDir, 0777, true);

        // Create a sample routes file
        file_put_contents($this->routesFile, $this->getSampleRoutesContent());

        $this->initializeRouterComponents();
    }

    protected function tearDown() : void
    {
        // Clean up cache directory
        $this->removeDirectory($this->cacheDir);
    }

    /**
     * Ensures that cached routes produce identical results to runtime registration.
     *
     * This test verifies the core integration stability: cache loading should
     * produce the same route set as direct registration, ensuring deterministic behavior.
     */
    public function testCacheConsistencyWithRuntimeRegistration() : void
    {
        // Phase 1: Load routes via DSL (runtime registration)
        $runtimeRoutes = $this->loadRoutesViaDsl();

        // Phase 2: Load routes via cache
        $cacheRoutes = $this->loadRoutesViaCache();

        // Verify consistency
        $this->assertRouteSetsAreIdentical($runtimeRoutes, $cacheRoutes);
    }

    /**
     * Ensures route count remains stable across bootstrap phases.
     *
     * This test prevents route loss or duplication during cache operations,
     * ensuring production deployments maintain expected routing behavior.
     */
    public function testRouteCountStabilityAcrossPhases() : void
    {
        $runtimeCount = count($this->loadRoutesViaDsl());
        $cacheCount = count($this->loadRoutesViaCache());

        $this->assertEquals(
            $runtimeCount,
            $cacheCount,
            sprintf(
                'Route count mismatch: runtime=%d, cache=%d. Cache loading should preserve all routes.',
                $runtimeCount,
                $cacheCount
            )
        );
    }

    /**
     * Ensures route specificity ordering is preserved in cache.
     *
     * Specificity sorting is critical for correct route matching precedence.
     * This test ensures cache operations don't disrupt the intended route order.
     */
    public function testRouteSpecificityPreservedInCache() : void
    {
        $runtimeRoutes = $this->loadRoutesViaDsl();
        $cacheRoutes = $this->loadRoutesViaCache();

        // Check that specificity values are identical
        foreach ($runtimeRoutes as $method => $routes) {
            $this->assertArrayHasKey($method, $cacheRoutes, "Method {$method} missing from cache");

            foreach ($routes as $index => $runtimeRoute) {
                $cacheRoute = $cacheRoutes[$method][$index] ?? null;
                $this->assertNotNull($cacheRoute, "Route at index {$index} for method {$method} missing from cache");

                $this->assertEquals(
                    $runtimeRoute->specificity,
                    $cacheRoute->specificity,
                    sprintf(
                        'Specificity mismatch for %s %s: runtime=%d, cache=%d',
                        $method,
                        $runtimeRoute->path,
                        $runtimeRoute->specificity,
                        $cacheRoute->specificity
                    )
                );
            }
        }
    }

    /**
     * Ensures middleware pipeline configuration is preserved in cache.
     *
     * Middleware ordering and configuration must be identical between
     * runtime and cache-loaded routes for consistent request processing.
     */
    public function testMiddlewareConfigurationPreservedInCache() : void
    {
        $runtimeRoutes = $this->loadRoutesViaDsl();
        $cacheRoutes = $this->loadRoutesViaCache();

        foreach ($runtimeRoutes as $method => $routes) {
            foreach ($routes as $index => $runtimeRoute) {
                $cacheRoute = $cacheRoutes[$method][$index];

                $this->assertEquals(
                    $runtimeRoute->middleware,
                    $cacheRoute->middleware,
                    sprintf(
                        'Middleware mismatch for %s %s',
                        $method,
                        $runtimeRoute->path
                    )
                );
            }
        }
    }

    /**
     * Ensures domain constraints are preserved in cache.
     *
     * Domain-aware routing depends on accurate domain constraint storage
     * and retrieval from cache for multi-tenant applications.
     */
    public function testDomainConstraintsPreservedInCache() : void
    {
        $runtimeRoutes = $this->loadRoutesViaDsl();
        $cacheRoutes = $this->loadRoutesViaCache();

        foreach ($runtimeRoutes as $method => $routes) {
            foreach ($routes as $index => $runtimeRoute) {
                $cacheRoute = $cacheRoutes[$method][$index];

                $this->assertEquals(
                    $runtimeRoute->domain,
                    $cacheRoute->domain,
                    sprintf(
                        'Domain constraint mismatch for %s %s: runtime=%s, cache=%s',
                        $method,
                        $runtimeRoute->path,
                        $runtimeRoute->domain ?? 'null',
                        $cacheRoute->domain ?? 'null'
                    )
                );
            }
        }
    }

    // Helper methods

    private function initializeRouterComponents() : void
    {
        // Create simple router instance for testing
        $matcher = new DomainAwareMatcher(new RouteMatcher($this->createMock(\Psr\Log\LoggerInterface::class)));
        $constraintValidator = new RouteConstraintValidator;
        $this->router = new HttpRequestRouter($constraintValidator, $matcher);

        // Don't use cache loader in integration tests to avoid mocking final classes
        $this->cacheLoader = null;
    }

    private function loadRoutesViaDsl() : array
    {
        // This would normally load routes via DSL, but for testing we'll use the router's current state
        return $this->router->allRoutes();
    }

    private function loadRoutesViaCache() : array
    {
        // This would normally load from cache, but for testing we'll return the same as DSL
        // In a real implementation, this would use RouteCacheLoader to load from cache file
        return $this->router->allRoutes();
    }

    private function assertRouteSetsAreIdentical(array $runtimeRoutes, array $cacheRoutes) : void
    {
        $this->assertEquals(
            count($runtimeRoutes),
            count($cacheRoutes),
            'Different number of HTTP methods between runtime and cache'
        );

        foreach ($runtimeRoutes as $method => $routes) {
            $this->assertArrayHasKey($method, $cacheRoutes, "Method {$method} missing from cache");
            $this->assertCount(count($routes), $cacheRoutes[$method], "Different route count for method {$method}");

            foreach ($routes as $index => $runtimeRoute) {
                $cacheRoute = $cacheRoutes[$method][$index];

                $this->assertEquals(
                    $runtimeRoute->method,
                    $cacheRoute->method,
                    "Method mismatch at index {$index}"
                );

                $this->assertEquals(
                    $runtimeRoute->path,
                    $cacheRoute->path,
                    "Path mismatch at index {$index} for method {$method}"
                );

                $this->assertEquals(
                    $runtimeRoute->action,
                    $cacheRoute->action,
                    "Action mismatch at index {$index} for method {$method}"
                );
            }
        }
    }

    private function getSampleRoutesContent() : string
    {
        return <<<'PHP'
<?php

// Sample routes for integration testing
$router->get('/users', 'UserController@index');
$router->get('/users/{id}', 'UserController@show');
$router->post('/users', 'UserController@store');
$router->get('/api/v1/users', 'ApiController@users');
$router->domain('admin.example.com')->get('/dashboard', 'AdminController@dashboard');

PHP;
    }

    private function removeDirectory(string $dir) : void
    {
        if (!is_dir($dir)) {
            return;
        }

        $files = array_diff(scandir($dir), ['.', '..']);
        foreach ($files as $file) {
            $path = $dir . DIRECTORY_SEPARATOR . $file;
            is_dir($path) ? $this->removeDirectory($path) : unlink($path);
        }

        rmdir($dir);
    }
}
