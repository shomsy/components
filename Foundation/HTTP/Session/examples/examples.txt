=== 01-basic-operations.php ===
<?php

/**
 * Example 01: Basic Operations & Lifecycle
 *
 * ğŸ§  Theory:
 * Think of a session like a small notebook that your app keeps for each user.
 * In that notebook you can write things you want to remember between requests:
 * their name, their cart items, their preferences.
 *
 * Without a session, every HTTP request is â€œnewâ€ and â€œforgetfulâ€.
 * The server does not remember who you are from one page to the next.
 *
 * A session fixes that.
 * It gives you a safe place to store small pieces of data per user.
 *
 * ğŸ›¡ï¸ Real-world scenario:
 * - A user logs in once, but stays logged in across many pages.
 * - A user adds items to a shopping cart and sees them on the checkout page.
 * - A user changes a setting (dark mode on), and it stays that way.
 *
 * The session is the memory that makes all of this possible.
 *
 * âš™ï¸ In practice (what we do here):
 * - We start the session (open the notebook for this user).
 * - We write values: put data into the notebook.
 * - We read values: get data back later.
 * - We check if data exists.
 * - We remove data or clear everything when we are done.
 *
 * âœ… Result:
 * You will see how to:
 * - remember a user's name,
 * - update it,
 * - forget it,
 * - and finally destroy the whole session when it is no longer needed.
 *
 * ğŸ“˜ Vocabulary:
 * - Session: the userâ€™s personal notebook that the server keeps.
 * - Start: opening the notebook for this user.
 * - ID: a secret â€œnotebook numberâ€ that tells which notebook belongs to which user.
 * - Put: writing something into the notebook.
 * - Get: reading something from the notebook.
 * - Forget: erasing one note from the notebook.
 * - Flush: erasing everything in the notebook.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/**
 * Note: This example uses the actual Session API
 * as defined in SessionInterface / SessionContract
 * (start, id, put, get, has, forget, flush, destroy).
 * It is intended to be copy-pasteable against the
 * real implementation, not pseudo-code.
 */
/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

// ğŸ§  Step 1: Start the session lifecycle
//
// Think of this as: â€œopen the notebook for this userâ€.
// If the notebook is already open, this call simply ensures it is ready.
$session->start();

// Get the current session ID (the notebook number).
$sessionId = $session->id();

echo "Session started with ID: {$sessionId}\n\n";

// ğŸ§  Step 2: Basic put() and get()
//
// Think of [put('name', 'Alice')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:69:4-81:5) like writing â€œname = Aliceâ€ into the notebook.
// Later you can ask: â€œwhat is name?â€ using get('name').

// Store a simple value.
$session->put('name', 'Alice');

// Read it back.
$name = $session->get('name');

echo "Stored name: {$name}\n"; // Alice

// ğŸ§  Step 3: has() â€” does this note exist?
//
// [has('name')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:96:4-106:5) answers: â€œDoes the notebook contain a value called name?â€
// It returns true or false.
if ($session->has('name')) {
    echo "We have a name stored in the session.\n";
}

// ğŸ§  Step 4: Updating values
//
// Calling put() again with the same key simply overwrites the old value.
// Think of it like crossing out the old value and writing a new one.

$session->put('name', 'Bob');
echo "Updated name: " . $session->get('name') . "\n"; // Bob

// ğŸ§  Step 5: forget() â€” remove a single value
//
// [forget('name')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:108:4-118:5) means: erase just this one line from the notebook.
// Other notes stay untouched.

$session->forget('name');

echo "After forget('name'):\n";
var_dump([
    'has_name' => $session->has('name'),   // false
    'name'     => $session->get('name'),   // null
]);

// ğŸ§  Step 6: put multiple values
//
// You can treat the session like a small key-value store
// for different pieces of user data.

$session->put('user_id', 42);
$session->put('role', 'admin');
$session->put('theme', 'dark');

echo "\nCurrent session data snapshot:\n";
var_dump([
    'user_id' => $session->get('user_id'),
    'role'    => $session->get('role'),
    'theme'   => $session->get('theme'),
]);

// ğŸ§  Step 7: flush() â€” clear everything
//
// [flush()](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:130:4-138:5) means: erase the whole notebook for this user.
// After this, it is as if the user never had a session.

$session->flush();

echo "\nAfter flush():\n";
var_dump([
    'user_id' => $session->get('user_id'), // null
    'role'    => $session->get('role'),    // null
    'theme'   => $session->get('theme'),   // null
]);

// ğŸ§  Step 8: destroy() â€” end the lifecycle
//
// Think of `destroy()` as:
//  - close the notebook,
//  - throw it away,
//  - tell the browser that this session is no longer valid.
//
// This is often used on logout.

$session->destroy();

echo "\nSession destroyed. ID is now: " . $session->id() . "\n";
// Depending on your implementation, this may be an empty string
// or a fresh ID after regeneration.


=== 02-scopes-and-namespaces.php ===
<?php

/**
 * Example 02: Scopes & Namespaces (for())
 *
 * ğŸ§  Theory:
 * Think of your session like a big closet ğŸ§³ that your app uses to store information.
 * Inside that closet, you can have many shelves â€” one for login data, one for a shopping cart,
 * one for user preferences, one for temporary messages.
 *
 * Each shelf has a name â€” and you decide what goes on it.
 *
 * The method `for('something')` is how you open one of those shelves.
 * Itâ€™s like saying: "Hey session, I want to work on the *auth shelf* now."
 *
 * That shelf becomes a *scope* â€” a small, private area inside the session where
 * all the keys you store live under that group.
 *
 * ğŸ’¡ Why it matters:
 * Without scopes, all your session data gets mixed in one big messy drawer.
 * With scopes, you can keep things clean and separate â€” no name collisions,
 * no confusion between modules, and easier debugging.
 *
 * Example:
 * - `for('auth')->put('token', '123')` saves under: `auth.token`
 * - `for('cart')->put('items', [...])` saves under: `cart.items`
 *
 * Each `for()` call opens a *namespace* â€” a logical box inside the session.
 * It doesnâ€™t create a new session, it just organizes your data.
 *
 * ğŸ›¡ï¸ Real-world scenario:
 * Imagine your app has three parts:
 * - "auth" â†’ handles login
 * - "cart" â†’ handles shopping
 * - "ui"   â†’ handles user preferences
 *
 * Each of these can store their own data in the same session safely:
 * - Auth can store token, roles, last login.
 * - Cart can store selected items, total, coupon.
 * - UI can store theme, language, layout.
 *
 * With scopes, they all live in the same closet â€” but on their own shelves.
 *
 * âš™ï¸ In practice:
 * - Use `for('auth')` when you work with login/session tokens.
 * - Use `for('cart')` for shopping data.
 * - Use `for('ui')` for user preferences.
 * - You can chain it with other features like `secure()` or `ttl()`.
 *
 * ğŸ“˜ Vocabulary:
 * - Scope: A named section of the session, like a labeled box or shelf.
 * - Namespace: A prefix added to all keys inside a scope.
 * - Collision: When two parts of code accidentally use the same key.
 * - Isolation: Keeping different session data separate.
 * - Chaining: Combining multiple modifiers in one line (e.g. `for()->secure()->ttl()`).
 *
 * âœ… Result:
 * You get clean, organized, easy-to-manage session data.
 * Each part of your app keeps its own data on its own shelf â€” no mixing, no overwriting.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$session->start();

echo "=== Example 02: Scopes & Namespaces ===\n\n";

// ğŸ§  Think of `$session` as the big closet where all your appâ€™s memory lives.
//
// Each `for('something')` is like opening a labeled box inside that closet.
//
// Letâ€™s create three different scopes (auth, cart, ui):
$auth = $session->for('auth');
$cart = $session->for('cart');
$ui   = $session->for('ui');

// ---------------------------------------------------------------------------
// ğŸ‘› AUTH SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores all authentication data.
//
// Think of it like a "login box" â€” only login-related data goes here.
//
$auth->put('token', 'user-token-abc123');
$auth->put('roles', ['user', 'editor']);
$auth->put('last_login', time());

// You can read them later:
$token = $auth->get('token');
echo "ğŸ” Token from auth scope: {$token}\n";

// ---------------------------------------------------------------------------
// ğŸ›’ CART SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores shopping cart data.
//
// Think of it like a "basket box" â€” where all userâ€™s items go.
//
$cart->put('items', ['T-shirt', 'Sneakers', 'Cap']);
$cart->put('total', 89.97);

// Read them later:
$items = implode(', ', $cart->get('items'));
$total = $cart->get('total');

echo "ğŸ›ï¸ Cart has: {$items} (Total: \\${$total})\n";

// ---------------------------------------------------------------------------
// ğŸ¨ UI SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores user preferences (theme, language, etc.)
//
// Think of it like a "settings box" â€” where the app remembers how you like things.
//
$ui->put('theme', 'dark');
$ui->put('language', 'en');

echo "ğŸ¨ UI theme: {$ui->get('theme')} | Language: {$ui->get('language')}\n";

// ---------------------------------------------------------------------------
// ğŸ§© UNDERSTANDING WHAT HAPPENS INTERNALLY
// ---------------------------------------------------------------------------
//
// Each scope automatically prefixes its data.
// So if we looked inside the raw session storage, weâ€™d see something like:
//
//   auth.token       => "user-token-abc123"
//   auth.roles       => ["user", "editor"]
//   auth.last_login  => 1702239123
//   cart.items       => ["T-shirt", "Sneakers", "Cap"]
//   cart.total       => 89.97
//   ui.theme         => "dark"
//   ui.language      => "en"
//
// ğŸ’¡ Think of it like a JSON structure:
//
// {
//   "auth": { "token": "...", "roles": [...], "last_login": ... },
//   "cart": { "items": [...], "total": ... },
//   "ui":   { "theme": "dark", "language": "en" }
// }
//
// All organized. All separate. All neat.
//
// ---------------------------------------------------------------------------
// âš™ï¸ YOU CAN EVEN CHAIN OTHER FEATURES
// ---------------------------------------------------------------------------
//
// For example, letâ€™s make our "auth" box secure and short-lived:
//
// ğŸ’¬ Think of it like this:
// "This is my login shelf. Lock it with encryption and make it forget
// everything after 15 minutes."
//
$session
    ->for('auth')
    ->secure()
    ->ttl(900)
    ->put('token', 'secure-jwt-xyz');

// ---------------------------------------------------------------------------
// âœ… RESULT
// ---------------------------------------------------------------------------
//
// - "auth" shelf keeps login info (secure, temporary)
// - "cart" shelf keeps shopping data
// - "ui" shelf keeps design preferences
// - Everything is isolated and easy to manage
//
// ğŸ’¡ Think of for('auth') like saying:
// "Open the login shelf â€” I only want to work there."
// ğŸ’¡ Think of for('cart') like saying:
// "Now open the shopping shelf."
// ğŸ’¡ Think of for('ui') like saying:
// "Open the preferences shelf."
//
// Each box keeps its own stuff.
// No more collisions. No more mess.

=== 03-security-and-encryption.php ===
<?php

/**
 * Example 03: Security & Encryption
 *
 * ğŸ§  Theory:
 * Think of your session like a small backpack that your app carries for each user.
 * Inside that backpack you can put important things: tokens, IDs, preferences.
 *
 * But there is a problem:
 * If someone steals the backpack, they can see everything inside.
 * That means they could pretend to be the user, or read secret data.
 *
 * Encryption is like putting everything inside a locked box
 * before you put it into the backpack.
 * The box can only be opened with a secret key that only your app knows.
 *
 * So even if an attacker steals the backpack,
 * all they see is a locked box with random-looking data.
 * They cannot read it, they cannot change it in a useful way.
 *
 * ğŸ›¡ï¸ Real-world scenario:
 * Imagine a user logs into an online banking app.
 * The app stores a session token that proves "this user is authenticated".
 * If that token is stored in plain text and someone steals it,
 * they can log in as that user without knowing the password.
 *
 * With encryption:
 * - The token is stored in an encrypted form.
 * - Even if someone dumps the session storage or intercepts the data,
 *   they only see garbage they cannot use.
 *
 * âš™ï¸ In practice (what we do here):
 * - We configure the Session Component with encryption enabled.
 * - We tell the Session: "for this area, always encrypt data before saving".
 * - We store a token with a time limit, so it auto-expires after 15 minutes.
 *
 * âœ… Result:
 * Your app can safely store sensitive values (tokens, emails, IDs)
 * without exposing them in plain text.
 * Even if the storage (filesystem, Redis, database) is leaked,
 * the attacker cannot simply read or reuse the data.
 *
 * ğŸ“˜ Vocabulary:
 * - Encryption: turning readable data into unreadable text using a secret key.
 * - Decryption: turning that unreadable text back into the original value.
 * - Secret key: a private value only your app knows, used to lock/unlock data.
 * - Token: a small piece of data that proves "who you are" to the app.
 * - TTL (Time To Live): how long data is allowed to live before it disappears.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$jwt = 'header.payload.signature'; // pretend this is a real JWT from your auth system

// ğŸ§  Explanation of the chain below:
//
// Think of `$session` like a helper that knows how to store data safely.
//
// `for('auth')`
//   Think of this like saving data in a box called "auth".
//   All login/authentication data goes into this one box,
//   so it does not mix with other things like "cart" or "preferences".
//
// `secure()`
//   This means: "Before you save anything in this box, lock it."
//   The data will be encrypted using a secret key.
//   Even if someone opens the storage, they only see random characters,
//   not the real value.
//
// `ttl(900)`
//   TTL means "time to live".
//   `ttl(900)` means: keep this data for 900 seconds (15 minutes), then delete it.
//   Think of it like a message that self-destructs after 15 minutes.
//   This is perfect for short-lived tokens.
//
// `put('token', $jwt)`
//   This means: "Save a value under the name token."
//   Here `$jwt` is your login or access token.
//   Combined with `secure()` and `ttl(900)`,
//   it becomes an encrypted, temporary token.
//
// âœ… Result:
//   The user's token is:
//   - stored only inside the "auth" area,
//   - encrypted so nobody can read it from raw storage,
//   - automatically removed after 15 minutes.
//

$session
    ->for('auth')
    ->secure()
    ->ttl(900)
    ->put('token', $jwt);

// Later in the request, or in the next request, you can read it back:
//
// Think of `get('token')` like opening the "auth" box
// and asking: "Do we still have the token for this user?"

$token = $session->for('auth')->get('token');

var_dump([
    'stored_token_value' => $token,
]);

=== 04-ttl-and-expiring-data.php ===
<?php

/**
 * Example 04: TTL & Autoâ€‘Expiring Data
 *
 * ğŸ§  Theory:
 * Think of TTL (Time To Live) like a small timer â±ï¸ attached to a piece of data.
 * When the timer runs out, the data disappears automatically.
 *
 * Without TTL, everything you put into the session stays there
 * until the session ends or you remove it manually.
 *
 * That is fine for some things (like a userâ€™s name),
 * but dangerous or noisy for others (like oneâ€‘time codes, OTPs, magic links).
 *
 * TTL lets you store temporary data in a safe way:
 * - Oneâ€‘time login codes
 * - Password reset tokens
 * - Email verification links
 * - Shortâ€‘lived â€œremember this only for a few minutesâ€ flags
 *
 * ğŸ›¡ï¸ Realâ€‘world scenario:
 * Imagine you send a user a 6â€‘digit code by SMS for login.
 * You want that code to work only for a short time (e.g. 5 minutes).
 *
 * With TTL you can say:
 * - â€œStore this code, but delete it automatically after 300 seconds.â€
 * - Even if you forget to clean it up, the system does it for you.
 *
 * âš™ï¸ In practice (what we do here):
 * - We store an OTP code with a TTL of 300 seconds (5 minutes).
 * - We try to read it before and after the TTL window.
 * - We see that after the TTL passes, the value is gone (null).
 *
 * âœ… Result:
 * You learn how to attach a â€œselfâ€‘destruct timerâ€ to session values,
 * so sensitive or temporary data does not live longer than it should.
 *
 * ğŸ“˜ Vocabulary:
 * - TTL (Time To Live): how long a value is allowed to exist before it is removed.
 * - OTP (Oneâ€‘Time Password): a short code used once and then discarded.
 * - Expiry: the moment when data becomes invalid and is removed.
 * - Window: the time period during which the data is still valid.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$session->start();

echo "=== Example 04: TTL & Autoâ€‘Expiring Data ===\n\n";

// Let's say we generate a oneâ€‘time code for login:
$otp = '739214';

// ğŸ§  Explanation of the chain:
//
// Think of `$session` as the place where we temporarily remember this code.
//
// `for('auth')`
//   Think of this like a small box labeled "auth".
//   We keep all authenticationâ€‘related data in this box.
//
// `ttl(300)`
//   Means: "keep this value for 300 seconds (5 minutes), then delete it".
//   Think of it like a sticker that says: "throw this away in 5 minutes".
//
// `put('otp', $otp)`
//   Means: "store the OTP code under the name otp inside this box".
//
// âœ… Result:
//   We store a oneâ€‘time code that automatically disappears after 5 minutes.

$session
    ->for('auth')
    ->ttl(300)
    ->put('otp', $otp);

echo "Stored OTP in session (valid for 5 minutes): {$otp}\n";

// Immediately after storing, we can read it:
$currentOtp = $session->for('auth')->get('otp');
echo "Current OTP from session: " . var_export($currentOtp, true) . "\n";

// In a real app, some time passes here (user types the code, submits formâ€¦)
// For the sake of example, imagine this is a later request:

// ğŸ§  Check if OTP still exists before validating:
//
// If get('otp') returns null, it probably expired or was already used.
$otpFromSession = $session->for('auth')->get('otp');

if ($otpFromSession === null) {
    echo "OTP is no longer available (it may have expired or been used).\n";
} else {
    echo "OTP is still valid: {$otpFromSession}\n";
}

// In your real verification logic, you would compare user input with $otpFromSession
// and, on success, you would typically remove it:
//
//   $session->for('auth')->forget('otp');
//
// Even if you forget to call forget(), TTL will clean it up after 300 seconds.

=== 05-flash-messages.php ===
<?php
/**
 * Example 05: Flash Messages & Validation
 *
 * ğŸ§  Theory:
 * Flash messages are like sticky notes between two pages of your app ğŸ“„.
 *
 * They carry short pieces of information â€” like success, warnings, or errors â€”
 * from one request to the next, and then disappear automatically.
 *
 * Think of them as little messengers that deliver a message once,
 * then vanish forever ğŸ•Šï¸.
 *
 * ğŸ’¡ Why use Flash?
 * When your app redirects (like after submitting a form),
 * the next page doesnâ€™t know what happened before.
 * Flash messages help your app â€œremember just enoughâ€ to show:
 * - validation errors,
 * - confirmation messages,
 * - old input values.
 *
 * ğŸ› ï¸ Flash message methods:
 * - `success()` â†’ show a â€œyay!â€ message for successful actions
 * - `error()` â†’ show what went wrong (like validation errors)
 * - `info()` â†’ neutral notes or status
 * - `warning()` â†’ gentle alerts or cautions
 * - `add()` â†’ generic â€œset a custom flash keyâ€
 * - `now()` â†’ show message immediately (same request)
 * - `get()` â†’ read & delete message
 *
 * ğŸ§© Real-world scenario:
 * Imagine a user submits a form but forgets to fill something.
 * You validate it, find errors, and redirect back to the form.
 *
 * With Flash:
 * - You can store the validation errors and userâ€™s old input temporarily.
 * - On the next request, you show those messages in the view.
 *
 * ğŸ’¬ Think of it like:
 * â€œIâ€™ll write a quick note for the next page to read,
 * then throw it away once itâ€™s seen.â€
 */

use Avax\HTTP\Session\Session;

// Get the session instance (e.g. via DI container or singleton)
$session = Session::getInstance();

// ---------------------------------------------------------------------------
// ğŸ§  1. FORM VALIDATION FAILS
// ---------------------------------------------------------------------------
//
// Letâ€™s simulate a failed form submission â€” for example,
// the user forgot to enter an email or used a weak password.
//
$errors = [
    'email'    => 'Email is required.',
    'password' => 'Password must be at least 8 characters.',
];

// ğŸ’¡ Think of add('errors', $errors) like writing a small envelope
// and putting all error messages inside â€” it will be delivered
// to the *next* request.
//
$session->flash()->add('errors', $errors);

// ğŸ’¬ Similarly, we can flash the old input,
// so the form can refill itself automatically.
//
$session->flash()->add('old_input', $_POST);

// ğŸ§¾ We can also flash a success-style message for later:
$session->flash()->success('Your profile has been updated successfully.');

// ğŸ’¬ And maybe show something immediately (this request only):
$session->flash()->now('info', 'You are currently editing your profile.');

// ---------------------------------------------------------------------------
// ğŸ”„ 2. NEXT REQUEST (AFTER REDIRECT)
// ---------------------------------------------------------------------------
//
// Now imagine the user is redirected back to the form.
// On the next page load, the view can retrieve what was flashed.
//
$errors   = $session->flash()->get('errors', []);
$oldInput = $session->flash()->get('old_input', []);

// ğŸ’¬ Think of get('errors') like opening that envelope from your past self.
// Once you read it, the envelope disappears â€” no duplicates, no stale data.
//
$successMessage = $session->flash()->get('success');

// ---------------------------------------------------------------------------
// ğŸ§© 3. SHOWING FLASH DATA IN THE VIEW
// ---------------------------------------------------------------------------
//
// This part would normally live in your view layer (e.g., Twig or Blade).
// Weâ€™ll just simulate it with simple echo statements.
//
if ($successMessage) {
    echo "<div class='alert alert-success'>{$successMessage}</div>";
}

if ($errors) {
    echo "<div class='alert alert-danger'>";
    echo "<strong>Validation failed:</strong><br>";
    foreach ($errors as $field => $message) {
        echo "- {$field}: {$message}<br>";
    }
    echo "</div>";
}

// ğŸ’¡ Think of it like this:
// The â€œsuccessâ€ note was for the next page only.
// The â€œerrorsâ€ and â€œold_inputâ€ were carried here,
// then automatically erased once shown.
//
// On the next refresh, all of these will be gone â€” clean slate! âœ¨

// ---------------------------------------------------------------------------
// ğŸ§¹ 4. CLEARING FLASH
// ---------------------------------------------------------------------------
//
// You can also manually clear all flash data if needed.
//
$session->flash()->clear();

// ---------------------------------------------------------------------------
// âœ… RESULT
// ---------------------------------------------------------------------------
//
// - Flash is your appâ€™s one-request memory.
// - â€œadd()â€ â†’ set temporary data for the next page.
// - â€œsuccess()/error()/info()/warning()â€ â†’ quick helpers.
// - â€œget()â€ â†’ read and delete.
// - â€œnow()â€ â†’ show immediately (this request only).
// - â€œclear()â€ â†’ erase all flash data.
//
// ğŸ’¡ Think of Flash as the app whispering to itself between pages:
// â€œJust remember this message until tomorrow â€” then forget it.â€ ğŸŒ™
//

=== 06-events-and-hooks.php ===
<?php
/**
 * Example 06: Events & Hooks (Simplified for Everyone)
 *
 * ğŸ§  Theory:
 * When something happens inside the Session system (like saving or deleting data),
 * it can â€œshoutâ€ that information to anyone who wants to listen.
 *
 * These shouts are called â€œeventsâ€.
 * The people listening are called â€œlistenersâ€.
 *
 * Imagine your Session is a person in a busy kitchen ğŸ³:
 * - When they finish cooking (store data), they shout â€œDinnerâ€™s ready!â€
 * - When they clean the table (delete data), they shout â€œTable cleared!â€
 * Other cooks (listeners) can then react, like:
 * - One writes the meal to a logbook (â€œAuditâ€)
 * - Another counts how many meals were made today (â€œMetricsâ€)
 *
 * Events are not just for fun â€” they make your Session *observable*.
 * You can track, log, and respond to everything that happens.
 */

use Avax\HTTP\Session\Session;

// Get the Session instance
$session = Session::getInstance();

/**
 * === Step 1: Listening to events ===
 *
 * â€œListenâ€ means: do something when this event happens.
 */

$session->events()->listen('stored', function (array $data) {
    echo "[Event: stored] You saved '{$data['key']}' in your session.\n";
});

$session->events()->listen('deleted', function (array $data) {
    echo "[Event: deleted] You deleted '{$data['key']}' from your session.\n";
});

// === Step 2: Triggering events ===
// Each of these will automatically "shout" (dispatch) an event.
$session->put('username', 'John'); // triggers â€œstoredâ€
$session->forget('username');      // triggers â€œdeletedâ€


/**
 * === Step 3: Understanding setMode() ===
 *
 * Normally, events happen immediately (synchronously).
 * That means â€” when you save something, the event runs right away.
 *
 * But sometimes, you donâ€™t want to slow things down.
 * For example, logging or analytics can wait until after the page loads.
 *
 * Thatâ€™s where `setMode()` comes in!
 *
 * It changes *when and how* your events are delivered.
 *
 * ğŸ§© Think of it like sending a message:
 * - SYNC: You call your friend and talk right now.
 * - ASYNC_MEMORY: You leave them a sticky note â€” theyâ€™ll read it later.
 * - ASYNC_FILE: You write it down in a notebook â€” theyâ€™ll read it tomorrow.
 * - ASYNC_REDIS: You post it to a group chat â€” everyone will get it instantly.
 *
 * So, if your event just logs something to a file or database,
 * itâ€™s usually better to run it *asynchronously* (in the background)
 * so your user doesnâ€™t have to wait.
 */

// ğŸ§  Example: make events async (run later)
$session->events()->setMode('ASYNC_MEMORY');

$session->events()->listen('stored', function (array $data) {
    echo "[ASYNC Event: stored] I'll write '{$data['key']}' to a log file *after* the page loads.\n";
});

$session->put('settings', ['theme' => 'dark']); // event queued, not run immediately!

echo "Page is rendering...\n";

/**
 * ğŸ” Output explanation:
 * Youâ€™ll first see: â€œPage is rendering...â€
 * Then, after the script finishes, PHP will run your async listeners.
 * So the â€œ[ASYNC Event: stored] ...â€ message appears *after* the response ends.
 *
 * ğŸ’¡ Why? Because async events use a shutdown handler â€”
 * they collect events in memory and process them when PHP is done.
 *
 * This is great for performance:
 * - The user doesnâ€™t wait for logs or analytics
 * - The app feels faster
 * - You can handle thousands of events without slowing anything down
 *
 * ğŸ› ï¸ Tip:
 * In production, you might switch to:
 *   - ASYNC_FILE â†’ if you want logs written to disk
 *   - ASYNC_REDIS â†’ if you want events shared between multiple servers
 *
 * For example:
 *   $session->events()->setMode('ASYNC_REDIS');
 *   // Now all servers see the same events in real time
 */


/**
 * === Step 4: Combine everything together ===
 *
 * You can mix sync and async listeners freely:
 * - Sync â†’ for critical stuff (security, policy enforcement)
 * - Async â†’ for optional stuff (analytics, audit)
 *
 * Example:
 */
$session->events()->setMode('SYNC'); // switch back to instant mode

$session->events()->listen('stored', function (array $data) {
    echo "[SECURITY] Immediately verified '{$data['key']}' integrity.\n";
});

$session->events()->setMode('ASYNC_MEMORY'); // back to async for logs
$session->events()->listen('stored', function (array $data) {
    echo "[LOG] Queued '{$data['key']}' for audit logging.\n";
});

$session->put('user_id', 101);


/**
 * ğŸ§  Summary:
 * - setMode('SYNC') â†’ run listeners right away (instant reaction)
 * - setMode('ASYNC_MEMORY') â†’ run them later (after response ends)
 * - setMode('ASYNC_FILE') â†’ save events to disk (persistent queue)
 * - setMode('ASYNC_REDIS') â†’ send to Redis (shared queue for multi-server apps)
 *
 * ğŸ’¬ In simple words:
 * setMode() controls *when* the session â€œtellsâ€ its story.
 * You decide if it should speak now, whisper later, or write a note for others.
 */

=== 07-audit-and-metrics.php ===
<?php
/**
 * Example 07: Audit & Metrics
 *
 * ğŸ§  Theory:
 * The â€œAuditâ€ and â€œMetricsâ€ features help you **see and understand**
 * whatâ€™s really happening inside your Session system.
 *
 * Think of your session as a â€œblack boxâ€ ğŸ“¦ â€” you store, update, and delete data,
 * but without these tools, youâ€™d have no idea *when*, *how often*, or *by whom*.
 *
 * - ğŸ§¾ **Audit** keeps a historical log of what happened (like a journal).
 * - ğŸ“Š **Metrics** counts and measures actions (like a dashboard).
 *
 * Together, they make your Session *observable* â€” you can monitor, detect issues,
 * measure performance, and catch unusual activity in real time.
 *
 * ğŸ’¡ In simple words:
 * - Audit answers: â€œWhat happened?â€
 * - Metrics answers: â€œHow often did it happen?â€
 * - Security answers: â€œShould it have happened?â€
 *
 * These three work together to make your app reliable, measurable, and safe.
 */

use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Metrics;
use Avax\HTTP\Session\Session;

// Get a session instance
$session = Session::getInstance();

/**
 * === Step 1: Initialize the Audit and Metrics features ===
 *
 * The Audit feature records every session event (store, delete, flush, destroy)
 * and saves it to a structured log file (usually JSON or line-based text).
 *
 * The Metrics feature counts how many times things happen.
 * Example: how many times we stored something, deleted something, etc.
 */

$audit   = new Audit('/tmp/session_audit.log');   // Save audit entries to this file
$metrics = new Metrics();                         // In-memory metrics tracker

// Register them to listen to session events
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * ğŸ§© Think of this like adding two assistants to your Session:
 * - â€œAuditorâ€ writes everything down in a notebook (who did what, and when)
 * - â€œStatisticianâ€ keeps a counter on the wall tallying how many times it happened
 */

// === Step 2: Perform normal session actions ===
$session->put('user_id', 42);
$session->put('cart_items', ['apple', 'banana']);
$session->forget('cart_items');
$session->flush();

/**
 * ğŸ§  What happens under the hood:
 * - Every `put()` triggers a `stored` event â†’ Audit logs it, Metrics increments it.
 * - Every `forget()` triggers a `deleted` event â†’ Audit logs it, Metrics increments it.
 * - Every `flush()` triggers a `cleared` event â†’ both log and count it.
 *
 * ğŸ§¾ Example Audit log line (JSON):
 *   {"event":"stored","key":"user_id","time":"2025-12-05T18:24:00Z"}
 *
 * ğŸ“ˆ Example Metrics output:
 *   stored: 2
 *   deleted: 1
 *   cleared: 1
 */

// === Step 3: Review your audit logs ===
echo "\n--- Audit log content ---\n";
echo file_get_contents('/tmp/session_audit.log');

/**
 * ğŸ’¬ Real-world uses of Audit:
 * - ğŸ§‘â€ğŸ’¼ Compliance â€” prove who accessed what (GDPR, SOC2)
 * - ğŸ§  Debugging â€” track unexpected session mutations
 * - ğŸ”’ Security â€” detect abnormal access patterns or replay attacks
 *
 * For example:
 * - â€œWhy did the userâ€™s session reset at midnight?â€
 * - â€œWho deleted all the keys from this namespace?â€
 * - â€œWas this action done from a new IP?â€
 */

// === Step 4: Check your metrics counters ===
echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ğŸ’¡ Real-world uses of Metrics:
 * - Track total session writes/deletes
 * - Monitor spikes in session churn (possible attack)
 * - Visualize active session load in Prometheus or Grafana
 *
 * For example:
 * - â€œWe had 5k session stores/min â†’ possible login stormâ€
 * - â€œSpike in session deletions â†’ maybe session policy enforcement triggeredâ€
 */

// === Step 5: Customizing audit format ===
/**
 * Audit logs can be customized:
 * You can choose to write JSON, plain text, or even send logs to an external system.
 *
 * Example of custom formatter:
 */
$audit->setFormatter(function (string $event, array $context) {
    $time = date('H:i:s');

    return "[{$time}] EVENT: {$event} | CONTEXT: " . json_encode($context) . PHP_EOL;
});

$session->put('debug_key', 'value');

/**
 * Output will now look like:
 * [18:45:02] EVENT: stored | CONTEXT: {"key":"debug_key"}
 *
 * This gives you total control over how your logs are written and read.
 */

// === Step 6: Combining Audit + Metrics + Events ===
/**
 * You can have all three features working together like a team:
 *
 * Events  â†’ tell the story (who/what/when)
 * Audit   â†’ writes it down (record of truth)
 * Metrics â†’ counts it up (measure and visualize)
 *
 * This trio gives you 360Â° visibility into your applicationâ€™s session activity.
 *
 * ğŸ’¡ Tip:
 * You can ship these logs to tools like:
 * - ELK Stack (Elasticsearch + Logstash + Kibana)
 * - Grafana Loki
 * - Prometheus (via Metrics)
 * - Sentry or Bugsnag (for error traces)
 */

echo "\nâœ… Session Audit & Metrics example completed.\n";

/**
 * ğŸ§  Summary:
 * - Audit keeps history of every change (what happened)
 * - Metrics keeps counters (how often it happened)
 * - Together, they make your session system transparent
 *
 * ğŸ§© Think of them as:
 *   - Audit = Journal ğŸ“˜
 *   - Metrics = Dashboard ğŸ“Š
 *   - Events = Nerve signals âš¡
 *
 * With these three, your Session component isnâ€™t a â€œblack boxâ€ anymore â€”
 * itâ€™s an intelligent, traceable, and measurable system.
 */

/**
 * Example 07 (Extended): Audit & Metrics in a Real App
 *
 * ğŸ§  Real-world scenario:
 * Letâ€™s imagine weâ€™re building a real web app with login/logout.
 *
 * Each time a user logs in, we:
 *  - store their ID and name in the session
 *  - record the event in an audit log
 *  - increment our â€œactive sessionsâ€ counter
 *
 * Each time a user logs out, we:
 *  - remove their session data
 *  - log the logout event
 *  - decrement the counter
 *
 * This way, we always know:
 *  - Who logged in / logged out
 *  - When they did it
 *  - How many users are active right now
 *
 * This is how large enterprise systems maintain traceability and transparency.
 */

$session = Session::getInstance();
$audit   = new Audit('/tmp/audit_realworld.log');
$metrics = new Metrics();

// register features to listen on every event
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * === Step 1: Simulate a user login ===
 *
 * When a user logs in, we store session data.
 * Each of these will emit a `stored` event â†’ automatically logged and counted.
 */

function loginUser(Session $session, string $userId, string $username) : void
{
    $session->put('user_id', $userId);
    $session->put('username', $username);
    echo "âœ… User '{$username}' logged in.\n";
}

loginUser($session, 'U123', 'Alice');

/**
 * The Audit log will now have:
 *   {"event":"stored","key":"user_id",...}
 *   {"event":"stored","key":"username",...}
 *
 * And Metrics report will include:
 *   stored: 2
 */

/**
 * === Step 2: Simulate a page visit ===
 *
 * Even when users just browse around,
 * we can record â€œpage_accessedâ€ events manually.
 * This helps us measure engagement.
 */

$session->events()->dispatch('page_accessed', ['path' => '/dashboard', 'user_id' => 'U123']);

/**
 * === Step 3: Simulate a logout ===
 *
 * On logout, we remove all session data and
 * emit a â€œlogoutâ€ event for audit & metrics tracking.
 */

function logoutUser(Session $session) : void
{
    $session->flush(); // clears everything, emits `cleared`
    $session->events()->dispatch('logout', ['reason' => 'user_requested']);
    echo "ğŸšª User logged out.\n";
}

logoutUser($session);

/**
 * === Step 4: Review the results ===
 */
echo "\n--- Audit log ---\n";
echo file_get_contents('/tmp/audit_realworld.log');

echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ğŸ§  What did we get here?
 *
 * - Every important user action (login, browse, logout) was tracked.
 * - Audit provides *history* (who, what, when).
 * - Metrics provides *numbers* (how often it happened).
 *
 * ğŸ§¾ Audit snippet:
 * {"event":"stored","key":"user_id"}
 * {"event":"stored","key":"username"}
 * {"event":"logout","reason":"user_requested"}
 *
 * ğŸ“Š Metrics summary:
 * Array
 * (
 *   [stored] => 2
 *   [cleared] => 1
 *   [logout] => 1
 * )
 *
 * ğŸ§© Why this matters:
 * In production, this data helps you:
 * - Detect unusual activity (many logins per minute)
 * - Identify crashes (sessions that end too quickly)
 * - Prove compliance (who did what and when)
 *
 * ğŸ’¡ Tip:
 * You could also visualize `$metrics->report()` in a live dashboard,
 * or send `$audit` logs to Elastic / Loki / Sentry for monitoring.
 */

echo "\nâœ… Real-world Audit & Metrics demo completed.\n";

//  REAL WORLD EXAMPLE (continued)

/**
 * Example 07 (Extended): Audit & Metrics in a Real App
 *
 * ğŸ§  Real-world scenario:
 * Letâ€™s imagine weâ€™re building a real web app with login/logout.
 *
 * Each time a user logs in, we:
 *  - store their ID and name in the session
 *  - record the event in an audit log
 *  - increment our â€œactive sessionsâ€ counter
 *
 * Each time a user logs out, we:
 *  - remove their session data
 *  - log the logout event
 *  - decrement the counter
 *
 * This way, we always know:
 *  - Who logged in / logged out
 *  - When they did it
 *  - How many users are active right now
 *
 * This is how large enterprise systems maintain traceability and transparency.
 */

$session = Session::getInstance();
$audit   = new Audit('/tmp/audit_realworld.log');
$metrics = new Metrics();

// register features to listen on every event
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * === Step 1: Simulate a user login ===
 *
 * When a user logs in, we store session data.
 * Each of these will emit a `stored` event â†’ automatically logged and counted.
 */

function loginUser(Session $session, string $userId, string $username) : void
{
    $session->put('user_id', $userId);
    $session->put('username', $username);
    echo "âœ… User '{$username}' logged in.\n";
}

loginUser($session, 'U123', 'Alice');

/**
 * The Audit log will now have:
 *   {"event":"stored","key":"user_id",...}
 *   {"event":"stored","key":"username",...}
 *
 * And Metrics report will include:
 *   stored: 2
 */

/**
 * === Step 2: Simulate a page visit ===
 *
 * Even when users just browse around,
 * we can record â€œpage_accessedâ€ events manually.
 * This helps us measure engagement.
 */

$session->events()->dispatch('page_accessed', ['path' => '/dashboard', 'user_id' => 'U123']);

/**
 * === Step 3: Simulate a logout ===
 *
 * On logout, we remove all session data and
 * emit a â€œlogoutâ€ event for audit & metrics tracking.
 */

function logoutUser(Session $session) : void
{
    $session->flush(); // clears everything, emits `cleared`
    $session->events()->dispatch('logout', ['reason' => 'user_requested']);
    echo "ğŸšª User logged out.\n";
}

logoutUser($session);

/**
 * === Step 4: Review the results ===
 */
echo "\n--- Audit log ---\n";
echo file_get_contents('/tmp/audit_realworld.log');

echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ğŸ§  What did we get here?
 *
 * - Every important user action (login, browse, logout) was tracked.
 * - Audit provides *history* (who, what, when).
 * - Metrics provides *numbers* (how often it happened).
 *
 * ğŸ§¾ Audit snippet:
 * {"event":"stored","key":"user_id"}
 * {"event":"stored","key":"username"}
 * {"event":"logout","reason":"user_requested"}
 *
 * ğŸ“Š Metrics summary:
 * Array
 * (
 *   [stored] => 2
 *   [cleared] => 1
 *   [logout] => 1
 * )
 *
 * ğŸ§© Why this matters:
 * In production, this data helps you:
 * - Detect unusual activity (many logins per minute)
 * - Identify crashes (sessions that end too quickly)
 * - Prove compliance (who did what and when)
 *
 * ğŸ’¡ Tip:
 * You could also visualize `$metrics->report()` in a live dashboard,
 * or send `$audit` logs to Elastic / Loki / Sentry for monitoring.
 */

echo "\nâœ… Real-world Audit & Metrics demo completed.\n";

=== 08-security-policies-and-enforcement.php ===
<?php
/**
 * Example 08: Security Policies & Enforcement
 *
 * ğŸ§  Theory:
 * Security Policies are like *rules that guard your session*.
 * Each one watches over a specific type of risk and decides
 * whether the session should continue or be stopped.
 *
 * ğŸ’¬ Think of them as â€œsecurity guardsâ€ standing outside your session:
 * - One checks if youâ€™ve been gone too long (MaxIdlePolicy)
 * - One ensures you came through the secure HTTPS door (SecureOnlyPolicy)
 * - One verifies your ticket hasnâ€™t expired (MaxLifetimePolicy)
 * - One checks youâ€™re on the same network (SessionIpPolicy)
 * - One makes sure itâ€™s really your device (CrossAgentPolicy)
 * - And one manager makes sure all guards work together (CompositePolicy)
 *
 * ğŸ›¡ï¸ Why this matters:
 * Without these guards, sessions could stay open forever,
 * even on public computers, or travel over unsafe networks.
 *
 * ---------------------------------------------------------------------
 * ğŸ”’ Every Policy has a single job:
 *   â†’ To check ONE condition and either approve or reject the session.
 *
 * If it fails, it throws a PolicyViolationException â€”
 * which instantly ends or invalidates your session.
 * ---------------------------------------------------------------------
 *  ğŸ§  Enforcement
 *
 *  "Enforcement" means *actively applying* all security policies
 *  before allowing any session action.
 *
 *  Policies define the rules â€” enforcement ensures those rules
 *  are actually respected.
 *
 *  Think of it like a security guard at the door:
 *  - Policies = The building's rules
 *  - Enforcement = The guard checking everyone who enters
 *
 *  Without enforcement, policies are just words on paper.
 */

use Avax\HTTP\Session\Exceptions\PolicyViolationException;
use Avax\HTTP\Session\Security\Policies\{CompositePolicy,
    CrossAgentPolicy,
    MaxIdlePolicy,
    MaxLifetimePolicy,
    PolicyGroupBuilder,
    SecureOnlyPolicy,
    SessionIpPolicy};
use Avax\HTTP\Session\Session;

/**
 * Note: All policies used below (`MaxIdlePolicy`, `MaxLifetimePolicy`,
 * `SecureOnlyPolicy`, `SessionIpPolicy`, `CrossAgentPolicy`,
 * `CompositePolicy`, `PolicyGroupBuilder`) are real classes from the
 * session engine with the exact constructor signatures shown here.
 * This example is meant to be executable against the actual codebase.
 */

$session = Session::getInstance();

/**
 * -------------------------------------------------------------
 * ğŸ•’ 1. MaxIdlePolicy â€” â€œThe inactivity guardâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Checks how long a user has been inactive.
 * If too much time passes (say, 15 minutes), the session expires.
 *
 * ğŸ’¬ Think of it like:
 * Youâ€™re at a coffee shop using free Wi-Fi â˜•.
 * You walk away for too long, and the Wi-Fi disconnects â€” because it
 * assumes youâ€™re gone. Itâ€™s polite security, not punishment.
 *
 * ğŸ’¡ Why it exists:
 * - Prevents hijacking of forgotten sessions
 * - Logs out users who leave sessions open
 *
 * ğŸ¦ Real-world analogy:
 * Like an ATM ğŸ§ â€” if you stop pressing buttons, it cancels your session.
 */

$maxIdle = new MaxIdlePolicy(15 * 60); // 15 minutes

/**
 * -------------------------------------------------------------
 * â³ 2. MaxLifetimePolicy â€” â€œThe absolute expiry guardâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * This one says, â€œNo matter how active you are, your session dies
 * after a fixed total time â€” for example, 2 hours.â€
 *
 * ğŸ’¬ Think of it like:
 * A parking ticket â±ï¸ â€” you can move your car around, but after
 * 2 hours the ticket expires no matter what.
 *
 * ğŸ’¡ Why it exists:
 * - Limits total lifetime of any session token
 * - Prevents attackers from reusing long-lived sessions
 *
 * ğŸ¢ Real-world analogy:
 * A concert wristband ğŸŸï¸ that stops being valid after midnight.
 */

/**
 * âš ï¸ NOTE: Donâ€™t confuse MaxLifetimePolicy with TTL.
 *
 * These two sound similar but control different things:
 *
 * - ğŸ•’ TTL (Time-To-Live) applies to a single key/value.
 *   â†’ Example: $session->put('otp', '123456', ttl: 300);
 *     Only this OTP will expire after 5 minutes.
 *
 * - â³ MaxLifetimePolicy applies to the entire session.
 *   â†’ Example: new MaxLifetimePolicy(3600);
 *     The whole session (all keys) will expire after 1 hour,
 *     even if the user keeps using it.
 *
 * ğŸ’¡ Think of it like:
 * - TTL = â€œThe milk in your fridge has an expiration date.â€ ğŸ¥›
 * - MaxLifetimePolicy = â€œThe whole fridge turns off at midnight.â€ ğŸ•›
 *
 * Use both for maximum safety:
 * TTL for short-lived sensitive data (like OTPs or tokens),
 * MaxLifetimePolicy for overall session expiration.
 */
$maxLifetime = new MaxLifetimePolicy(2 * 3600); // 2 hours total lifetime

/**
 * -------------------------------------------------------------
 * ğŸ”’ 3. SecureOnlyPolicy â€” â€œThe HTTPS guardâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Allows sessions only over HTTPS connections.
 *
 * ğŸ’¬ Think of it like:
 * A private conversation in a soundproof room ğŸ”‡ â€”
 * if youâ€™re trying to talk through a megaphone in public (HTTP),
 * this guard slams the door shut.
 *
 * ğŸ’¡ Why it exists:
 * - Stops attackers from stealing cookies via sniffing
 * - Ensures your data travels through an encrypted tunnel
 *
 * ğŸ§ Real-world analogy:
 * Like whispering secrets in someoneâ€™s ear instead of shouting in the street.
 */

$secureOnly = new SecureOnlyPolicy(true);

/**
 * -------------------------------------------------------------
 * ğŸŒ 4. SessionIpPolicy â€” â€œThe network guardâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Ties your session to the same IP address it started from.
 * If your IP suddenly changes (for example, from one city to another),
 * it assumes something suspicious happened.
 *
 * ğŸ’¬ Think of it like:
 * You checked into a hotel under your name ğŸ¨.
 * If someone tries to use your room key from another building,
 * the hotel system locks it immediately.
 *
 * ğŸ’¡ Why it exists:
 * - Prevents hijacking when session IDs are stolen
 * - Ensures sessions canâ€™t jump between networks
 *
 * ğŸ•µï¸ Real-world analogy:
 * Like a keycard that only works at one hotel door â€” not anywhere else.
 */

$ipPolicy = new SessionIpPolicy();

/**
 * -------------------------------------------------------------
 * ğŸ§­ 5. CrossAgentPolicy â€” â€œThe device fingerprint guardâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Locks your session to the same browser or device that created it.
 * If you log in with Chrome and someone tries to use your session in Safari,
 * it gets blocked.
 *
 * ğŸ’¬ Think of it like:
 * Your face unlock feature on a phone ğŸ“± â€” it wonâ€™t open for anyone else.
 *
 * ğŸ’¡ Why it exists:
 * - Stops session reuse from stolen cookies
 * - Ensures the session only works on your original device
 *
 * ğŸ§© Real-world analogy:
 * Itâ€™s like a theater ticket ğŸ­ that says â€œvalid only on this seat and this showâ€.
 */

$crossAgent = new CrossAgentPolicy();

/**
 * -------------------------------------------------------------
 * ğŸ§© 6. CompositePolicy â€” â€œThe team managerâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Combines multiple smaller guards into one powerful security unit.
 *
 * ğŸ’¬ Think of it like:
 * A night club with several bouncers ğŸ•º:
 * - One checks your ID (SecureOnlyPolicy)
 * - One checks if youâ€™ve been idle (MaxIdlePolicy)
 * - One checks your ticket hasnâ€™t expired (MaxLifetimePolicy)
 *
 * If *any* says â€œnoâ€, youâ€™re not getting in.
 */

$compositePolicy = new CompositePolicy([
    $maxIdle,
    $maxLifetime,
    $secureOnly,
    $ipPolicy,
    $crossAgent
]);

/**
 * -------------------------------------------------------------
 * âš™ï¸ 7. Applying Policies to the Session
 * -------------------------------------------------------------
 *
 * Usually, a SessionManager / SessionProvider wires these policies
 * and runs them before operations like `get()`, `put()`, or
 * `regenerateId()`. In this example we call `$session->applyPolicy()`
 * directly only to make the enforcement flow explicit and easy to
 * follow in isolation.
 *
 * NOTE: In production, SessionProvider enforces these policies automatically.
 * You don't need to call applyPolicy() manually in your app code.
 */

try {
    $session->applyPolicy($compositePolicy);
    $session->put('user_id', 42);
    echo "âœ… Session is secure and active.\n";

    // Simulate user being idle too long
    sleep(16 * 60); // 16 minutes

    // This triggers MaxIdlePolicy
    $session->get('user_id');

} catch (PolicyViolationException $e) {
    echo "ğŸš¨ Policy violation: {$e->getMessage()}\n";
}

/**
 * -------------------------------------------------------------
 * ğŸ§± 8. PolicyGroupBuilder â€” â€œThe recipe makerâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  What it does:
 * Lets you build a policy group with readable, fluent syntax.
 *
 * ğŸ’¬ Think of it like:
 * Writing your own â€œsecurity recipeâ€ in plain English.
 *
 * Example:
 * â€œAll sessions must be secure, expire after 15 minutes, and lock to device.â€
 *
 * Note: `PolicyGroupBuilder::create()->requireAll()->secureOnly()
 * ->maxIdle(900)->maxLifetime(3600)->ipBinding()->userAgentBinding()`
 * is the real fluent API from the policy subsystem, not pseudo-code.
 */

$securityRecipe = PolicyGroupBuilder::create()
    ->requireAll()
    ->secureOnly()
    ->maxIdle(900)
    ->maxLifetime(3600)
    ->ipBinding()
    ->userAgentBinding()
    ->endGroup()
    ->build();

$session->applyPolicy($securityRecipe);

echo "âœ… Built and applied security recipe successfully.\n";

/**
 * -------------------------------------------------------------
 * ğŸ§  9. How policies actually work inside the engine
 * -------------------------------------------------------------
 *
 * - Each policy implements `PolicyInterface` â†’ has `check(Session $session): void`
 * - The session engine runs `check()` for every active policy before any action
 * - If any fails â†’ throws `PolicyViolationException`
 *
 * ğŸ§© Simplified internal logic:
 *
 * class MaxIdlePolicy implements PolicyInterface {
 *     public function check(Session $session): void {
 *         $lastActivity = $session->getMeta('last_activity');
 *         if (time() - $lastActivity > $this->maxIdleTime) {
 *             throw new PolicyViolationException('Session expired due to inactivity.');
 *         }
 *     }
 * }
 *
 * ğŸ’¡ You never call `check()` manually â€” the framework does it for you.
 */

/**
 * -------------------------------------------------------------
 * ğŸ§© 10. Best Practices & Real-world Mapping
 * -------------------------------------------------------------
 *
 * ğŸ›¡ï¸ Always include at least:
 * - MaxIdlePolicy â†’ ends idle sessions
 * - SecureOnlyPolicy â†’ forces HTTPS
 *
 * ğŸ§© Add for extra safety:
 * - SessionIpPolicy â†’ ties session to the same IP
 * - CrossAgentPolicy â†’ ties session to the same device
 * - MaxLifetimePolicy â†’ expires sessions after total time
 *
 * ğŸ¢ Real-world examples:
 * - ğŸ’³ Online banking: auto-logout after 10 minutes (MaxIdle)
 * - âš™ï¸ Admin dashboards: HTTPS only (SecureOnly)
 * - ğŸ§‘â€ğŸ’» Corporate VPNs: IP bound sessions (SessionIp)
 * - ğŸ“± Mobile apps: device-bound sessions (CrossAgent)
 *
 * ğŸ” Advanced tip:
 * Combine these with your Audit feature to log all violations.
 * Youâ€™ll get a live feed of suspicious behavior.
 */

echo "\nâœ… Security Policies & Enforcement example completed successfully.\n";

/**
 * -------------------------------------------------------------
 * ğŸ§¾ Recap
 * -------------------------------------------------------------
 * - MaxIdlePolicy â†’ Like an ATM timeout â€” closes inactive sessions
 * - MaxLifetimePolicy â†’ Like a parking ticket â€” expires after total time
 * - SecureOnlyPolicy â†’ Like whispering secrets in private (HTTPS)
 * - SessionIpPolicy â†’ Like a hotel key that works only for one room
 * - CrossAgentPolicy â†’ Like Face ID â€” only works for your own device
 * - CompositePolicy â†’ Like a team of guards working together
 * - PolicyGroupBuilder â†’ Like writing a â€œsecurity recipeâ€
 *
 * ğŸ§  Together they form your sessionâ€™s immune system.
 * Your app automatically enforces good behavior â€” no extra work needed.
 *
 * ğŸ’¬ Think of it as:
 * â€œYour sessions now protect themselves.â€
 */

=== 09-recovery-and-backup.php ===
<?php
/**
 * Example 09: Recovery & Backup
 *
 * ğŸ§  Theory:
 * The Recovery system is your sessionâ€™s safety net.
 * It makes sure your data *never gets lost* â€” even if your app crashes,
 * the disk fails, or a session write operation goes wrong.
 *
 * ğŸ’¬ In simple terms:
 * Think of Recovery as an â€œUndo + Backupâ€ system for your sessions.
 * If something bad happens, Recovery can rewind your session
 * to the last safe point automatically.
 *
 * ğŸ§± Real-world analogy:
 * - Google Docs auto-saves your document every few seconds ğŸ“
 * - Photoshop lets you hit "Undo" when something goes wrong ğŸ¨
 * - Databases use transactions to roll back incomplete operations ğŸ’¾
 *
 * Session Recovery combines all three ideas.
 *
 * ------------------------------------------------------------------
 * ğŸ” It provides three main mechanisms:
 *
 * 1ï¸âƒ£ Snapshot â€” takes a point-in-time backup of session data
 * 2ï¸âƒ£ Restore â€” reverts to the most recent snapshot
 * 3ï¸âƒ£ Transaction â€” safely applies a batch of changes (commit or rollback)
 *
 * ------------------------------------------------------------------
 * ğŸ§© Why it matters:
 * - Prevents session corruption after a crash
 * - Avoids partial writes (inconsistent data)
 * - Enables safe â€œundoâ€ for critical operations
 * - Adds confidence to multi-step processes (checkout, payment, etc.)
 *
 * Without Recovery, your session data could become corrupted or lost
 * if something fails halfway through â€” like power loss during save.
 */

use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Data\Recovery;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Lifecycle\Config;
use Avax\HTTP\Session\Lifecycle\SessionProvider;
use Avax\HTTP\Session\Security\Encrypter;

// ----------------------------------------------------
// 1ï¸âƒ£ Setup basic session environment
// ----------------------------------------------------
$store     = new FileStore(__DIR__ . '/storage/sessions');
$encrypter = new Encrypter('base64:YourSuperSecureKeyHere');
$config    = new Config(name: 'AVAXSESSID', lifetime: 3600);
$audit     = new Audit(__DIR__ . '/logs/recovery_audit.log');
$recovery  = new Recovery($store);

$session = new SessionProvider(
    store    : $store,
    config   : $config,
    encrypter: $encrypter
);
$session->registerFeature($recovery);
$session->registerFeature($audit);

// ----------------------------------------------------
// ğŸ§© DEMO 1 â€” Snapshot & Restore
// ----------------------------------------------------
/**
 * ğŸ§  Theory:
 * A "snapshot" is like taking a photo of your current session data.
 * If something goes wrong later, you can â€œrestoreâ€ the photo
 * and go back in time.
 *
 * ğŸ’¡ In simple words:
 * - snapshot() = save point
 * - restore()  = load last save
 *
 * ğŸ§± Real-world analogy:
 * Youâ€™re editing a document.
 * You click â€œSaveâ€ (snapshot), your computer crashes (boom ğŸ’¥),
 * and when you reopen it, Recovery automatically loads
 * the last saved version â€” no data lost.
 */

try {
    $session->put('cart', ['item' => 'Laptop', 'price' => 1299]);
    $session->recovery()->snapshot();
    echo "ğŸ’¾ Snapshot created successfully.\n";

    // simulate crash
    throw new RuntimeException("ğŸ’¥ Disk I/O failure while saving session!");
} catch (Throwable $e) {
    echo "âš ï¸ Crash detected: {$e->getMessage()}\n";

    // record audit log
    $session->audit()->record('crash_detected', [
        'reason'    => $e->getMessage(),
        'timestamp' => time(),
    ]);

    // attempt to restore
    $session->recovery()->restore();
    echo "âœ… Session restored from last snapshot.\n";
}

// ----------------------------------------------------
// ğŸ§© DEMO 2 â€” Transaction Safety (All or Nothing)
// ----------------------------------------------------
/**
 * ğŸ§  Theory:
 * Transactions let you group several changes together safely.
 * Either *all* changes succeed, or *none* of them do.
 *
 * ğŸ’¡ Think of it like:
 * â€œI want to update user_id and cart â€” but if any part fails,
 *  undo everything and keep the session clean.â€
 *
 * ğŸ¦ Real-world analogy:
 * Imagine a bank transfer:
 * - Subtract $100 from Alice
 * - Add $100 to Bob
 * If the second operation fails, rollback cancels both.
 */

try {
    $session->recovery()->snapshot(); // optional autosave before transaction
    $session->recovery()->beginTransaction();

    $session->put('user_id', 42);
    $session->put('cart', ['item' => 'Headphones', 'price' => 199]);

    // Uncomment to simulate failure
    // throw new RuntimeException("ğŸ’¥ Payment gateway timeout!");

    $session->recovery()->commit();
    echo "âœ… Transaction committed successfully.\n";
} catch (Throwable $e) {
    echo "ğŸš¨ Transaction error: {$e->getMessage()}\n";

    $session->audit()->record('transaction_rollback', [
        'error'     => $e->getMessage(),
        'timestamp' => time(),
    ]);

    $session->recovery()->rollback();
    echo "â†©ï¸ Rolled back session to previous state.\n";
}

// ----------------------------------------------------
// ğŸ§© DEMO 3 â€” Automatic Recovery Integration
// ----------------------------------------------------
/**
 * ğŸ§  Theory:
 * In real production setups, Recovery works automatically:
 * - If session storage fails â†’ it restores the last snapshot
 * - If transaction fails â†’ it rolls back changes
 *
 * This keeps your app stable even under failure.
 *
 * ğŸ’¬ In simple words:
 * Recovery acts like an â€œinsurance policyâ€ for your sessions.
 */

try {
    echo "ğŸš€ Performing high-risk operation...\n";
    $session->put('temporary', ['step' => 1]);
    throw new RuntimeException("ğŸ’¥ Random crash occurred!");
} catch (Throwable $e) {
    echo "âš ï¸ System failure detected: {$e->getMessage()}\n";
    $session->recovery()->restore();
    echo "âœ… Session auto-restored from last known safe point.\n";
}

/**
 * -------------------------------------------------------------
 * ğŸ§¾ Recap: Recovery in Plain English
 * -------------------------------------------------------------
 *
 * - snapshot() â†’ saves your session state (like saving a game ğŸ®)
 * - restore() â†’ goes back to last save point (like loading a game ğŸ’¾)
 * - beginTransaction() â†’ start a safe block of operations
 * - commit() â†’ confirm changes
 * - rollback() â†’ undo if something fails
 *
 * ğŸ›¡ï¸ Why this matters:
 * - Prevents data loss if the app or disk fails
 * - Protects against partial writes (corruption)
 * - Enables full â€œundoâ€ for session data
 * - Keeps your user experience consistent even after crashes
 *
 * ğŸ’¬ Without Recovery:
 *   If a crash happens mid-write, your users could lose session data.
 *
 * ğŸ’¬ With Recovery:
 *   The session engine quietly restores the last safe snapshot.
 *
 * ğŸ§  Think of it like:
 *   â€œYour session system always keeps a spare parachute ğŸª‚ â€” just in case.â€
 */

=== 10-observability-and-tracing.php ===
<?php
/**
 * Example 10: Observability & Self-Healing (Real Implementation)
 *
 * ğŸ§  THEORY:
 * Observability means your system can *see itself* â€”
 * it can tell you whatâ€™s happening inside, why itâ€™s happening,
 * and recover automatically when something goes wrong.
 *
 * You already have observability features â€” theyâ€™re just hidden in plain sight:
 *
 * - Audit â†’ Records everything that happens (the â€œblack boxâ€)
 * - AsyncEventDispatcher â†’ Emits real-time signals (the â€œnervous systemâ€)
 * - Recovery â†’ Restores the system when something fails (the â€œimmune systemâ€)
 *
 * Together, these make your Session component *self-aware and self-healing*.
 */

use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Data\Recovery;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Session;

// -------------------------------------------------------------
// 1ï¸âƒ£ SETUP: Session with existing observability components
// -------------------------------------------------------------

/**
 * ğŸ§© The FileStore is your â€œmemory driveâ€.
 * Audit is your â€œblack boxâ€.
 * Events is your â€œevent busâ€ (real-time signaling).
 * Recovery is your â€œbackup & immune systemâ€.
 */

$store    = new FileStore(__DIR__ . '/storage/sessions');
$audit    = new Audit(__DIR__ . '/logs/audit_observability.log');
$events   = new Events();
$recovery = new Recovery($store);

$session = Session::getInstance();
$session->registerFeature($audit);
$session->registerFeature($events);
$session->registerFeature($recovery);

/**
 * -------------------------------------------------------------
 * 2ï¸âƒ£ AUDIT â€” The â€œblack box recorderâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  Concept:
 * The Audit feature logs every meaningful session action â€” put, get, flush, etc.
 * If something goes wrong, you can open its log and replay the story.
 *
 * ğŸ’¬ Think of it as a planeâ€™s black box âœˆï¸ â€”
 * it doesnâ€™t stop accidents, but it explains what happened.
 *
 * ğŸ§± Real-world analogy:
 * When a pilot reports â€œengine failureâ€, investigators check the black box.
 * When a user reports â€œI got logged outâ€, you check the audit log.
 */

$session->audit()->record('session_start', ['user_id' => 42]);
$session->put('user_id', 42);
$session->audit()->record('cart_update', ['action' => 'added item', 'item' => 'Laptop']);

/**
 * -------------------------------------------------------------
 * 3ï¸âƒ£ EVENTS â€” The â€œnervous systemâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  Concept:
 * The Events system emits real-time â€œsignalsâ€ whenever something happens.
 * For example: â€œstoredâ€, â€œdeletedâ€, â€œflushedâ€, â€œexpiredâ€.
 *
 * ğŸ’¬ Think of it like the nerves in your body â€”
 * they instantly notify you if somethingâ€™s hot, cold, or broken.
 *
 * ğŸ§± Real-world analogy:
 * Imagine touching something too hot ğŸ”¥ â€” your hand pulls away instantly.
 * Thatâ€™s how events allow instant reactions in your code.
 */

$session->events()->listen('stored', function ($data) {
    echo "ğŸ“¢ [Event] Key '{$data['key']}' was stored.\n";
});

$session->events()->listen('flushed', function () {
    echo "ğŸ§¹ [Event] All session data cleared.\n";
});

// Trigger some actions
$session->put('cart', ['item' => 'Laptop', 'price' => 1200]);
$session->flush();

/**
 * -------------------------------------------------------------
 * 4ï¸âƒ£ RECOVERY â€” The â€œimmune systemâ€
 * -------------------------------------------------------------
 *
 * ğŸ§  Concept:
 * Recovery automatically takes snapshots and can restore data
 * if the session is corrupted or a crash happens.
 *
 * ğŸ’¬ Think of it like an â€œundo buttonâ€ for your session.
 *
 * ğŸ§± Real-world analogy:
 * Imagine writing a long essay on your laptop, and the power goes out ğŸ’¥.
 * Auto-save brings everything back â€” thatâ€™s Recovery.
 *
 * âš™ï¸ Problem it solves:
 * Prevents total data loss due to exceptions, server errors, or backend issues.
 */

try {
    $session->put('checkout_step', 'shipping');
    $session->recovery()->snapshot(); // Auto-save current state

    // Simulate a crash
    throw new RuntimeException('ğŸ’¥ Disk failure while writing session!');

} catch (Throwable $e) {
    echo "âš ï¸ Error detected: {$e->getMessage()}\n";
    $session->recovery()->restore();
    echo "âœ… Recovered session state successfully.\n";
}

/**
 * -------------------------------------------------------------
 * 5ï¸âƒ£ SELF-HEALING â€” Bringing it all together
 * -------------------------------------------------------------
 *
 * ğŸ§  Concept:
 * When something bad happens:
 *   - Events detect it instantly
 *   - Audit records the details
 *   - Recovery restores the last safe state
 *
 * ğŸ’¬ In plain English:
 * â€œThe session system fell, noticed it, healed itself, and told you why.â€
 *
 * ğŸ§± Real-world analogy:
 * Like a self-driving car ğŸš— that detects a flat tire, slows down safely,
 * switches to backup power, and sends a diagnostic report.
 */

$events->listen('crash_detected', function ($context) use ($audit) {
    $audit->record('crash_event', [
        'reason' => $context['reason'] ?? 'unknown',
        'time'   => date('c')
    ]);
    echo "ğŸ› ï¸ Auto-heal triggered for crash: {$context['reason']}\n";
});

// Simulate â€œself-healing eventâ€
$events->dispatch('crash_detected', ['reason' => 'database timeout']);

/**
 * -------------------------------------------------------------
 * ğŸ§¾ SUMMARY
 * -------------------------------------------------------------
 * âœ… Audit â€” records â€œwhat happenedâ€
 * âœ… Events â€” notify â€œwhen it happensâ€
 * âœ… Recovery â€” restores â€œwhen it failsâ€
 *
 * These are your observability and resilience pillars.
 *
 * ğŸ’¬ Think of them like:
 * - The session can now *talk*, *remember*, and *heal*.
 * - You donâ€™t just store data â€” you manage a living system.
 */

echo "\nâœ… Observability & Self-Healing demo completed.\n";

=== 11-Session-Lifecycle-&-Regeneration.php ===
<?php

/**
 * Example 11: Session Lifecycle & Regeneration
 *
 * ğŸ§  Theory:
 * Every session has a *lifecycle* â€” it is born, lives, renews itself, and eventually dies.
 *
 * This example demonstrates how the Session system handles:
 * - creation (starting a new session)
 * - regeneration (changing its ID for security)
 * - renewal (extending active sessions)
 * - expiration (ending idle or old sessions)
 * - termination (safe logout & cleanup)
 *
 * ğŸ’¬ Think of a session like a living organism:
 * - Itâ€™s born when a user logs in.
 * - It grows and evolves as you interact with your app.
 * - It renews its â€œidentityâ€ to stay safe.
 * - It dies when itâ€™s no longer needed â€” to keep the system clean.
 *
 * This lifecycle ensures your app remains secure, predictable, and self-maintaining.
 */

use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Exceptions\SessionException;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Lifecycle\SessionProvider;
use Avax\HTTP\Session\Lifecycle\SessionRegistry;
use Avax\HTTP\Session\Security\Policies\PolicyGroupBuilder;

$store    = new FileStore(__DIR__ . '/storage/sessions');
$audit    = new Audit(__DIR__ . '/logs/lifecycle_audit.log');
$events   = new Events();
$registry = new SessionRegistry();
$session  = new SessionProvider(store: $store);
$session->registerFeature($audit);
$session->registerFeature($events);

// -------------------------------------------------------------
// 1ï¸âƒ£ SESSION BIRTH â€” â€œCreating a new lifeâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * A session is created when a user logs in or starts a new visit.
 * It receives a unique ID and empty storage.
 *
 * ğŸ’¬ In human terms:
 * Think of this as giving every user their own locker in a gym ğŸ‹ï¸.
 * They can now safely store personal items (data).
 */

$session->start();
$userId = 42;
$session->put('user_id', $userId);
$audit->record('session_created', ['user_id' => $userId]);

echo "ğŸ‘¶ Session started for user {$userId} with ID: {$session->getId()}\n";

// -------------------------------------------------------------
// 2ï¸âƒ£ SESSION ACTIVITY â€” â€œGrowing and changingâ€
// -------------------------------------------------------------
/**
 * As the user interacts with your app, you store or update data.
 * This represents an active, living session.
 *
 * Each write updates metadata â€” like last activity time.
 * This will matter later for idle timeout checks.
 */

$session->put('cart', ['item' => 'Laptop', 'price' => 1499]);
$audit->record('cart_update', ['item' => 'Laptop']);
echo "ğŸ§  User added item to cart.\n";

// -------------------------------------------------------------
// 3ï¸âƒ£ SESSION REGENERATION â€” â€œChanging identity for safetyâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * Session fixation attacks happen when an attacker tricks a victim
 * into using a known session ID. To prevent this, we *regenerate*
 * the ID after login or sensitive actions.
 *
 * ğŸ’¬ Think of it as changing your house locks ğŸ”‘ after someone gets a spare key.
 * The contents stay the same â€” but the key (session ID) changes.
 *
 * âš”ï¸ Prevents: Session Fixation Attack
 */

$oldId = $session->getId();
$session->regenerateId();
$newId = $session->getId();

$audit->record('session_regenerated', ['old_id' => $oldId, 'new_id' => $newId]);
echo "â™»ï¸ Session ID regenerated (old: $oldId â†’ new: $newId)\n";

// -------------------------------------------------------------
// 4ï¸âƒ£ SESSION RENEWAL â€” â€œExtending an active lifeâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * If a user stays active, we can â€œrenewâ€ their session
 * â€” meaning we extend its lifetime instead of expiring it.
 *
 * ğŸ’¬ Real-world example:
 * Think of a parking ticket â±ï¸.
 * If you keep feeding the meter (activity), your time extends.
 *
 * âš™ï¸ This works with MaxLifetimePolicy and MaxIdlePolicy.
 */

$policies = PolicyGroupBuilder::create()
    ->requireAll()
    ->maxIdle(900)        // logout if idle 15 min
    ->maxLifetime(3600)   // total life = 1 hour
    ->endGroup()
    ->build();

$session->registerPolicies([$policies]);

$session->renew(); // manual renewal (like â€œstay signed inâ€)
$audit->record('session_renewed', ['user_id' => $userId]);
echo "ğŸ•’ Session lifetime extended â€” user is still active.\n";

// -------------------------------------------------------------
// 5ï¸âƒ£ SESSION EXPIRATION â€” â€œNatural deathâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * If a user leaves your app and goes idle too long,
 * MaxIdlePolicy automatically marks the session as expired.
 *
 * ğŸ’¬ Analogy:
 * Like your online banking session â€” if you go make coffee â˜•,
 * it logs you out after 10 minutes of inactivity.
 */

sleep(1); // Simulate time passing
try {
    $session->applyPolicy($policies);
    echo "âœ… Session is still valid.\n";
} catch (SessionException $e) {
    echo "ğŸ’€ Session expired: {$e->getMessage()}\n";
    $session->destroy();
}

// -------------------------------------------------------------
// 6ï¸âƒ£ SESSION TERMINATION â€” â€œA clean and respectful goodbyeâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * Termination happens when the user explicitly logs out.
 * This wipes session data, revokes cookies, and updates the registry.
 *
 * ğŸ’¬ Think of it as returning your gym locker key ğŸ” and taking your stuff home.
 */

$session->destroy();
$audit->record('session_destroyed', ['user_id' => $userId]);
echo "ğŸ‘‹ User {$userId} logged out â€” session destroyed.\n";

// -------------------------------------------------------------
// 7ï¸âƒ£ SESSION REGISTRY â€” â€œTracking multiple livesâ€
// -------------------------------------------------------------
/**
 * ğŸ§  Concept:
 * The Session Registry keeps track of all user sessions
 * across devices, browsers, or regions.
 *
 * ğŸ’¬ Think of it like Netflix â†’ "You are logged in on: Chrome, iPhone, Smart TV"
 *
 * You can:
 * - revoke sessions on other devices
 * - inspect all active logins
 * - detect hijacking attempts
 */

$registry->register($userId, $newId, 'Chrome on macOS');
$registry->register($userId, 'XYZ987', 'iPhone Safari');
$audit->record('registry_update', ['active_devices' => 2]);

echo "ğŸ“‹ Active sessions for user {$userId}:\n";
foreach ($registry->getSessionsByUser($userId) as $device => $sessionId) {
    echo " - {$device} â†’ {$sessionId}\n";
}

// Simulate revoking one session
$registry->revoke($userId, 'XYZ987');
$audit->record('registry_revoke', ['device' => 'iPhone Safari']);
echo "ğŸš« Revoked iPhone session for user {$userId}.\n";

/**
 * -------------------------------------------------------------
 * ğŸ§¾ RECAP:
 * -------------------------------------------------------------
 * âœ… start() â€” new session born
 * âœ… put() â€” data written
 * âœ… regenerateId() â€” changed identity to prevent fixation
 * âœ… renew() â€” extended lifetime for active users
 * âœ… destroy() â€” end of life, all data wiped
 * âœ… registry â€” manage multiple â€œlivesâ€ across devices
 *
 * ğŸ’¬ Think of it as:
 * "Your sessions now have a complete life cycle â€”
 * they live, evolve, and die safely on their own."
 */

echo "\nğŸŒ Session Lifecycle demo completed successfully.\n";

=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ğŸ“ Scanning directory: $TARGET_DIR"
echo "ğŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ğŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ğŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ğŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ğŸ§© Merged files : $MERGED"
echo "ğŸš« Skipped files: $SKIPPED"
echo "ğŸ“„ Output file  : $OUTPUT_FILE"

