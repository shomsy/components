=== Adapters/SessionAdapter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Adapters;

use Avax\HTTP\Session\Security\CookieManager;

/**
 * SessionAdapter - Native PHP Session Abstraction
 *
 * Abstracts native PHP session functions for testability and portability.
 * Enables dependency injection and mocking in unit tests.
 *
 * Benefits:
 * - Testable: Can be mocked in unit tests
 * - Portable: Easy to switch to different session handlers
 * - Clean: Encapsulates native PHP session functions
 *
 * @package Avax\HTTP\Session\Adapters
 */
final class SessionAdapter
{
    /**
     * SessionAdapter Constructor.
     *
     * @param CookieManager|null $cookieManager Cookie manager for secure cookies.
     */
    public function __construct(
        private ?CookieManager $cookieManager = null
    ) {
        $this->cookieManager ??= CookieManager::lax();
    }

    /**
     * Start a new session or resume existing session.
     *
     * @return bool True on success.
     */
    public function start(): bool
    {
        if ($this->isActive()) {
            return true;
        }

        // Configure session cookie before starting
        $this->cookieManager->configureSessionCookie();

        return session_start();
    }

    /**
     * Check if session is active.
     *
     * @return bool True if session is active.
     */
    public function isActive(): bool
    {
        return session_status() === PHP_SESSION_ACTIVE;
    }

    /**
     * Regenerate session ID.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Prevents session fixation attacks.
     *
     * @param bool $deleteOldSession Delete old session data.
     *
     * @return bool True on success.
     */
    public function regenerateId(bool $deleteOldSession = true): bool
    {
        if (!$this->isActive()) {
            return false;
        }

        return session_regenerate_id($deleteOldSession);
    }

    /**
     * Get current session ID.
     *
     * @return string Session ID.
     */
    public function getId(): string
    {
        return session_id();
    }

    /**
     * Set session ID.
     *
     * @param string $id Session ID.
     *
     * @return bool True on success.
     */
    public function setId(string $id): bool
    {
        if ($this->isActive()) {
            return false; // Cannot change ID of active session
        }

        session_id($id);
        return true;
    }

    /**
     * Get session name.
     *
     * @return string Session name.
     */
    public function getName(): string
    {
        return session_name();
    }

    /**
     * Set session name.
     *
     * @param string $name Session name.
     *
     * @return string Previous session name.
     */
    public function setName(string $name): string
    {
        return session_name($name);
    }

    /**
     * Destroy the current session.
     *
     * OWASP ASVS 3.2.3 Compliant
     *
     * Completely terminates the session:
     * - Clears session data
     * - Destroys server-side session
     * - Removes client cookie
     *
     * @return bool True on success.
     */
    public function destroy(): bool
    {
        if (!$this->isActive()) {
            return false;
        }

        // Clear session variables
        $_SESSION = [];

        // Delete session cookie
        $this->deleteCookie();

        // Destroy server-side session
        return session_destroy();
    }

    /**
     * Delete session cookie.
     *
     * @return bool True on success.
     */
    public function deleteCookie(): bool
    {
        return $this->cookieManager->delete($this->getName());
    }

    /**
     * Write session data and close session.
     *
     * @return bool True on success.
     */
    public function write(): bool
    {
        if (!$this->isActive()) {
            return false;
        }

        return session_write_close();
    }

    /**
     * Abort session changes and close session.
     *
     * @return bool True on success.
     */
    public function abort(): bool
    {
        if (!$this->isActive()) {
            return false;
        }

        return session_abort();
    }

    /**
     * Perform garbage collection.
     *
     * @return int|false Number of deleted sessions or false on failure.
     */
    public function gc(): int|false
    {
        return session_gc();
    }

    /**
     * Set session save path.
     *
     * @param string $path Save path.
     *
     * @return string Previous save path.
     */
    public function setSavePath(string $path): string
    {
        return session_save_path($path);
    }

    /**
     * Get session save path.
     *
     * @return string Save path.
     */
    public function getSavePath(): string
    {
        return session_save_path();
    }

    /**
     * Get session module name.
     *
     * @return string Module name (e.g., 'files', 'redis').
     */
    public function getModuleName(): string
    {
        return session_module_name();
    }

    /**
     * Set session module name.
     *
     * @param string $module Module name.
     *
     * @return string Previous module name.
     */
    public function setModuleName(string $module): string
    {
        return session_module_name($module);
    }

    /**
     * Get session cache limiter.
     *
     * @return string Cache limiter.
     */
    public function getCacheLimiter(): string
    {
        return session_cache_limiter();
    }

    /**
     * Set session cache limiter.
     *
     * @param string $limiter Cache limiter ('nocache', 'public', 'private', etc).
     *
     * @return string Previous cache limiter.
     */
    public function setCacheLimiter(string $limiter): string
    {
        return session_cache_limiter($limiter);
    }

    /**
     * Unset all session variables.
     *
     * @return void
     */
    public function unsetAll(): void
    {
        $_SESSION = [];
    }

    /**
     * Get cookie manager.
     *
     * @return CookieManager Cookie manager instance.
     */
    public function getCookieManager(): CookieManager
    {
        return $this->cookieManager;
    }

    /**
     * Reset session to clean state without destroying it.
     *
     * Useful for privilege de-escalation scenarios.
     *
     * @return void
     */
    public function reset(): void
    {
        if ($this->isActive()) {
            $this->unsetAll();
            $this->regenerateId();
        }
    }
}

=== Config/SessionConfig.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Config;

/**
 * SessionConfig - Configuration Value Object
 *
 * Immutable configuration for SessionManager initialization.
 * 
 * Provides clean, readable configuration without constructor parameter soup.
 * 
 * @example
 *   $config = new SessionConfig(
 *       ttl: 3600,
 *       secure: true,
 *       encryptionKey: 'secret'
 *   );
 *   
 *   $session = new SessionManager($store, $config);
 *
 * @package Avax\HTTP\Session
 */
final readonly class SessionConfig
{
    /**
     * SessionConfig Constructor.
     *
     * @param int|null    $ttl           Default TTL in seconds.
     * @param bool        $secure        Enable auto-encryption by default.
     * @param string|null $encryptionKey Encryption key for secure values.
     */
    public function __construct(
        public ?int $ttl = null,
        public bool $secure = false,
        public ?string $encryptionKey = null
    ) {}

    /**
     * Create default configuration.
     *
     * @return self
     */
    public static function default(): self
    {
        return new self();
    }

    /**
     * Create secure configuration.
     *
     * @param string $encryptionKey The encryption key.
     *
     * @return self
     */
    public static function secure(string $encryptionKey): self
    {
        return new self(secure: true, encryptionKey: $encryptionKey);
    }

    /**
     * Create temporary configuration with TTL.
     *
     * @param int $ttl TTL in seconds.
     *
     * @return self
     */
    public static function temporary(int $ttl): self
    {
        return new self(ttl: $ttl);
    }
}

=== Contracts/FeatureInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts;

/**
 * FeatureInterface - Session Feature Lifecycle Contract
 *
 * Defines lifecycle hooks for session features.
 * Enables automatic initialization and cleanup.
 *
 * Features implement this interface to:
 * - Initialize on session start (boot)
 * - Cleanup on session end (terminate)
 * - Declare feature name for debugging
 *
 * @package Avax\HTTP\Session\Contracts
 */
interface FeatureInterface
{
    /**
     * Boot the feature.
     *
     * Called when session starts or feature is first accessed.
     * Use for initialization logic.
     *
     * @return void
     */
    public function boot(): void;

    /**
     * Terminate the feature.
     *
     * Called when session terminates or is destroyed.
     * Use for cleanup logic (flush logs, save state, etc).
     *
     * @return void
     */
    public function terminate(): void;

    /**
     * Get feature name.
     *
     * @return string Feature identifier.
     */
    public function getName(): string;

    /**
     * Check if feature is enabled.
     *
     * @return bool True if feature is active.
     */
    public function isEnabled(): bool;
}

=== Contracts/Security/Encrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Security;

/**
 * Encrypter - Encryption Contract
 *
 * Defines the contract for session value encryption/decryption.
 * Enables flexible crypto implementations (OpenSSL, Sodium, etc.).
 * 
 * @example
 *   $encrypted = $encrypter->encrypt('sensitive-data');
 *   $decrypted = $encrypter->decrypt($encrypted);
 * 
 * @package Avax\HTTP\Session\Contracts
 */
interface Encrypter
{
    /**
     * Encrypt a value.
     *
     * @param mixed $value The value to encrypt.
     *
     * @return string The encrypted value.
     */
    public function encrypt(mixed $value): string;

    /**
     * Decrypt a value.
     *
     * @param string $encrypted The encrypted value.
     *
     * @return mixed The decrypted value.
     * @throws \RuntimeException If decryption fails.
     */
    public function decrypt(string $encrypted): mixed;
}

=== Contracts/Security/ServerContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Security;

/**
 * ServerContext - Server Environment Context
 *
 * Abstraction for accessing server variables.
 * Enables testability by decoupling from $_SERVER superglobal.
 * 
 * @package Avax\HTTP\Session\Contracts\Security
 */
interface ServerContext
{
    /**
     * Get User-Agent string.
     *
     * @return string User agent.
     */
    public function getUserAgent(): string;

    /**
     * Check if connection is secure (HTTPS).
     *
     * @return bool True if HTTPS.
     */
    public function isSecure(): bool;

    /**
     * Get client IP address.
     *
     * @return string IP address.
     */
    public function getClientIp(): string;
}

=== Contracts/SessionContract.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts;

use Avax\HTTP\Session\Providers\SessionConsumer;

/**
 * SessionContract - Formal API Contract
 *
 * Defines the public API for session management.
 * 
 * Purpose:
 * - API stability for testing and DI
 * - Clear contract for implementations
 * - Documentation of public interface
 * 
 * Note: This is a formal contract, not used internally.
 * SessionManager implements this implicitly.
 *
 * @package Avax\HTTP\Session
 */
interface SessionContract
{
    /**
     * Store a value.
     *
     * @param string   $key   The key.
     * @param mixed    $value The value.
     * @param int|null $ttl   Optional TTL.
     *
     * @return void
     */
    public function put(string $key, mixed $value, ?int $ttl = null): void;

    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null): mixed;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool
     */
    public function has(string $key): bool;

    /**
     * Remove a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function forget(string $key): void;

    /**
     * Get all data.
     *
     * @return array<string, mixed>
     */
    public function all(): array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush(): void;

    /**
     * Create scoped session.
     *
     * @param string $namespace The namespace.
     *
     * @return SessionConsumer Scoped consumer.
     */
    public function scope(string $namespace): SessionConsumer;

    /**
     * Access flash messages.
     *
     * @return \Avax\HTTP\Session\Features\Flash Flash instance.
     */
    public function flash(): \Avax\HTTP\Session\Features\Flash;

    /**
     * Access events.
     *
     * @return \Avax\HTTP\Session\Features\Events Events instance.
     */
    public function events(): \Avax\HTTP\Session\Features\Events;
}

=== Contracts/Storage/Store.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Storage;

/**
 * Store Interface - Storage Abstraction
 *
 * Minimal contract for session persistence.
 * 
 * Implementations:
 * - NativeStore: PHP native sessions
 * - ArrayStore: In-memory (for testing)
 * - RedisStore: Redis backend
 * - DatabaseStore: Database backend
 *
 * @package Avax\HTTP\Session
 */
interface Store
{
    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed The value or default.
     */
    public function get(string $key, mixed $default = null): mixed;

    /**
     * Store a value.
     *
     * @param string $key   The key.
     * @param mixed  $value The value.
     *
     * @return void
     */
    public function put(string $key, mixed $value): void;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool True if exists.
     */
    public function has(string $key): bool;

    /**
     * Delete a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function delete(string $key): void;

    /**
     * Get all data.
     *
     * @return array<string, mixed> All data.
     */
    public function all(): array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush(): void;
}

=== Exceptions/EncryptionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * EncryptionException - Encryption/Decryption Errors
 *
 * Thrown when encryption or decryption operations fail.
 * Provides fine-grained error handling for crypto operations.
 *
 * Error Types:
 * - Key missing or invalid
 * - Encryption failed
 * - Decryption failed
 * - Tag verification failed (GCM mode)
 * - Invalid ciphertext format
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class EncryptionException extends \RuntimeException
{
    /**
     * Create exception for missing encryption key.
     *
     * @param string $keyName Key identifier.
     *
     * @return self
     */
    public static function keyMissing(string $keyName = 'default'): self
    {
        return new self(
            "Encryption key '{$keyName}' is missing or not configured. " .
            "Set encryption key in SessionConfig or environment."
        );
    }

    /**
     * Create exception for invalid encryption key.
     *
     * @param string $reason Reason why key is invalid.
     *
     * @return self
     */
    public static function invalidKey(string $reason): self
    {
        return new self("Invalid encryption key: {$reason}");
    }

    /**
     * Create exception for encryption failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function encryptionFailed(string $reason = 'unknown'): self
    {
        return new self("Encryption failed: {$reason}");
    }

    /**
     * Create exception for decryption failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function decryptionFailed(string $reason = 'unknown'): self
    {
        return new self("Decryption failed: {$reason}");
    }

    /**
     * Create exception for tag verification failure (GCM mode).
     *
     * @return self
     */
    public static function tagVerificationFailed(): self
    {
        return new self(
            "Authentication tag verification failed. " .
            "Data may have been tampered with or corrupted."
        );
    }

    /**
     * Create exception for invalid ciphertext format.
     *
     * @param string $expected Expected format.
     *
     * @return self
     */
    public static function invalidFormat(string $expected): self
    {
        return new self("Invalid ciphertext format. Expected: {$expected}");
    }

    /**
     * Create exception for unsupported cipher.
     *
     * @param string $cipher Cipher name.
     *
     * @return self
     */
    public static function unsupportedCipher(string $cipher): self
    {
        return new self("Unsupported cipher: {$cipher}");
    }

    /**
     * Create exception for key rotation failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function keyRotationFailed(string $reason): self
    {
        return new self("Key rotation failed: {$reason}");
    }
}

=== Exceptions/EncryptionKeyMissingException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * EncryptionKeyMissingException
 *
 * Thrown when encryption is required but no key is configured.
 * 
 * Use Case:
 * - Attempting to store _secure suffixed keys without encryption key
 * - Using secure() scope without encryption key
 * 
 * @example
 *   try {
 *       $session->put('token_secure', 'value');
 *   } catch (EncryptionKeyMissingException $e) {
 *       // Handle missing key
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class EncryptionKeyMissingException extends SessionException
{
    /**
     * Create exception for missing encryption key.
     *
     * @return self
     */
    public static function create(): self
    {
        return new self(
            'Encryption key is required for secure session values. ' .
                'Set encryption key in SessionConfig or SessionManager constructor.'
        );
    }
}

=== Exceptions/ExpiredSessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * ExpiredSessionException
 *
 * Thrown when attempting to access an expired session value.
 * 
 * Use Case:
 * - TTL-based expiration
 * - Policy-based expiration
 * - Manual expiration checks
 * 
 * @example
 *   try {
 *       $value = $session->get('key');
 *   } catch (ExpiredSessionException $e) {
 *       // Handle expiration
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class ExpiredSessionException extends SessionException
{
    /**
     * Create exception for expired key.
     *
     * @param string $key The expired key.
     *
     * @return self
     */
    public static function forKey(string $key): self
    {
        return new self("Session key '{$key}' has expired");
    }
}

=== Exceptions/PolicyViolationException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * PolicyViolationException
 *
 * Thrown when a session policy is violated.
 * 
 * Use Cases:
 * - MaxIdlePolicy timeout
 * - MaxLifetimePolicy exceeded
 * - SecureOnlyPolicy HTTPS requirement
 * - CrossAgentPolicy user agent mismatch
 * 
 * @example
 *   try {
 *       $session->put('key', 'value');
 *   } catch (PolicyViolationException $e) {
 *       // Handle policy violation
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class PolicyViolationException extends SessionException
{
    /**
     * Create exception for policy violation.
     *
     * @param string $policyName The policy that was violated.
     * @param string $reason     The violation reason.
     *
     * @return self
     */
    public static function forPolicy(string $policyName, string $reason): self
    {
        return new self(
            sprintf('Policy violation [%s]: %s', $policyName, $reason)
        );
    }
}

=== Exceptions/RegistryException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * RegistryException - Session Registry Errors
 *
 * Thrown when session registry operations fail.
 * Provides fine-grained error handling for multi-device session management.
 *
 * Error Types:
 * - Session not found
 * - Session already registered
 * - Concurrent session limit exceeded
 * - Revocation errors
 * - Device management errors
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class RegistryException extends \RuntimeException
{
    /**
     * Create exception for session not found.
     *
     * @param string $sessionId Session ID.
     *
     * @return self
     */
    public static function sessionNotFound(string $sessionId): self
    {
        return new self("Session '{$sessionId}' not found in registry.");
    }

    /**
     * Create exception for session already registered.
     *
     * @param string $sessionId Session ID.
     *
     * @return self
     */
    public static function sessionAlreadyRegistered(string $sessionId): self
    {
        return new self("Session '{$sessionId}' is already registered.");
    }

    /**
     * Create exception for concurrent session limit exceeded.
     *
     * @param string $userId User identifier.
     * @param int    $limit  Maximum allowed sessions.
     * @param int    $current Current session count.
     *
     * @return self
     */
    public static function concurrentLimitExceeded(string $userId, int $limit, int $current): self
    {
        return new self(
            "User '{$userId}' has exceeded concurrent session limit. " .
            "Limit: {$limit}, Current: {$current}"
        );
    }

    /**
     * Create exception for revoked session access attempt.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Revocation reason.
     *
     * @return self
     */
    public static function sessionRevoked(string $sessionId, string $reason): self
    {
        return new self(
            "Session '{$sessionId}' has been revoked. Reason: {$reason}"
        );
    }

    /**
     * Create exception for revocation failure.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Failure reason.
     *
     * @return self
     */
    public static function revocationFailed(string $sessionId, string $reason): self
    {
        return new self("Failed to revoke session '{$sessionId}': {$reason}");
    }

    /**
     * Create exception for device not found.
     *
     * @param string $userId    User identifier.
     * @param string $userAgent User agent string.
     *
     * @return self
     */
    public static function deviceNotFound(string $userId, string $userAgent): self
    {
        return new self(
            "No sessions found for user '{$userId}' with device '{$userAgent}'."
        );
    }

    /**
     * Create exception for invalid session metadata.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Reason why metadata is invalid.
     *
     * @return self
     */
    public static function invalidMetadata(string $sessionId, string $reason): self
    {
        return new self("Invalid metadata for session '{$sessionId}': {$reason}");
    }

    /**
     * Create exception for registry storage failure.
     *
     * @param string $operation Operation that failed.
     * @param string $reason    Failure reason.
     *
     * @return self
     */
    public static function storageFailed(string $operation, string $reason): self
    {
        return new self("Registry storage operation '{$operation}' failed: {$reason}");
    }
}

=== Exceptions/SessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * SessionException - Base Exception
 *
 * Base exception for all session-related errors.
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class SessionException extends RuntimeException {}

=== Features/AsyncEventDispatcher.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

/**
 * AsyncEventDispatcher - Asynchronous Event Dispatcher
 *
 * High-throughput event dispatcher with queue-based async processing.
 * Prevents event handling from blocking main request flow.
 *
 * Features:
 * - Queue-based async dispatch
 * - Batch processing
 * - Error handling and retry logic
 * - Memory-efficient (bounded queue)
 * - Graceful shutdown
 *
 * Modes:
 * - SYNC: Immediate synchronous dispatch (default, backward compatible)
 * - ASYNC_MEMORY: In-memory queue, processed on shutdown
 * - ASYNC_FILE: File-based queue, processed by background worker
 * - ASYNC_REDIS: Redis queue (requires Redis extension)
 *
 * @example Sync mode (default)
 *   $dispatcher = new AsyncEventDispatcher();
 *   $dispatcher->listen('event', $callback);
 *   $dispatcher->dispatch('event', $data);  // Immediate
 *
 * @example Async memory mode
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_MEMORY);
 *   $dispatcher->dispatch('event', $data);  // Queued, processed on shutdown
 *
 * @example Async file mode (for background workers)
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_FILE, '/tmp/events.queue');
 *   $dispatcher->dispatch('event', $data);  // Written to file
 *
 * @package Avax\HTTP\Session\Features
 */
final class AsyncEventDispatcher
{
    public const MODE_SYNC = 'sync';
    public const MODE_ASYNC_MEMORY = 'async_memory';
    public const MODE_ASYNC_FILE = 'async_file';
    public const MODE_ASYNC_REDIS = 'async_redis';

    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var array<array{event: string, data: array}> Event queue
     */
    private array $queue = [];

    /**
     * @var bool Shutdown handler registered
     */
    private bool $shutdownRegistered = false;

    /**
     * @var int Maximum queue size (prevent memory exhaustion)
     */
    private int $maxQueueSize = 1000;

    /**
     * @var int Batch size for processing
     */
    private int $batchSize = 100;

    /**
     * AsyncEventDispatcher Constructor.
     *
     * @param string      $mode      Dispatch mode (sync|async_memory|async_file|async_redis).
     * @param string|null $queuePath Queue file path (for async_file mode).
     * @param object|null $redis     Redis instance (for async_redis mode).
     */
    public function __construct(
        private string $mode = self::MODE_SYNC,
        private ?string $queuePath = null,
        private ?object $redis = null
    ) {
        if ($mode === self::MODE_ASYNC_FILE && $queuePath === null) {
            throw new \InvalidArgumentException('Queue path required for async_file mode');
        }

        if ($mode === self::MODE_ASYNC_REDIS && $redis === null) {
            throw new \InvalidArgumentException('Redis instance required for async_redis mode');
        }
    }

    /**
     * Register an event listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function listen(string $event, callable $callback): self
    {
        if (!isset($this->listeners[$event])) {
            $this->listeners[$event] = [];
        }

        $this->listeners[$event][] = $callback;

        return $this;
    }

    /**
     * Register a one-time listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function once(string $event, callable $callback): self
    {
        $wrapper = function (array $data) use ($event, $callback, &$wrapper) {
            $callback($data);
            $this->removeListener($event, $wrapper);
        };

        return $this->listen($event, $wrapper);
    }

    /**
     * Remove a specific listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback to remove.
     *
     * @return self Fluent interface.
     */
    public function removeListener(string $event, callable $callback): self
    {
        if (!isset($this->listeners[$event])) {
            return $this;
        }

        $this->listeners[$event] = array_filter(
            $this->listeners[$event],
            fn($listener) => $listener !== $callback
        );

        return $this;
    }

    /**
     * Dispatch an event.
     *
     * Behavior depends on mode:
     * - SYNC: Immediate dispatch
     * - ASYNC_MEMORY: Queue in memory, process on shutdown
     * - ASYNC_FILE: Write to file queue
     * - ASYNC_REDIS: Push to Redis queue
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []): void
    {
        match ($this->mode) {
            self::MODE_SYNC => $this->dispatchSync($event, $data),
            self::MODE_ASYNC_MEMORY => $this->dispatchAsyncMemory($event, $data),
            self::MODE_ASYNC_FILE => $this->dispatchAsyncFile($event, $data),
            self::MODE_ASYNC_REDIS => $this->dispatchAsyncRedis($event, $data),
            default => throw new \InvalidArgumentException("Invalid mode: {$this->mode}")
        };
    }

    /**
     * Dispatch event synchronously (immediate).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchSync(string $event, array $data): void
    {
        if (!isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            try {
                $callback($data);
            } catch (\Exception $e) {
                error_log("Event listener error [{$event}]: " . $e->getMessage());
            }
        }
    }

    /**
     * Dispatch event asynchronously (memory queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncMemory(string $event, array $data): void
    {
        // Check queue size limit
        if (count($this->queue) >= $this->maxQueueSize) {
            error_log("Event queue full, dropping event: {$event}");
            return;
        }

        // Add to queue
        $this->queue[] = ['event' => $event, 'data' => $data];

        // Register shutdown handler (once)
        if (!$this->shutdownRegistered) {
            register_shutdown_function([$this, 'processQueue']);
            $this->shutdownRegistered = true;
        }
    }

    /**
     * Dispatch event asynchronously (file queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncFile(string $event, array $data): void
    {
        $payload = json_encode(['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Append to queue file (atomic)
        file_put_contents(
            $this->queuePath,
            $payload . PHP_EOL,
            FILE_APPEND | LOCK_EX
        );
    }

    /**
     * Dispatch event asynchronously (Redis queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncRedis(string $event, array $data): void
    {
        $payload = json_encode(['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Push to Redis list
        $this->redis->rPush('session:events', $payload);
    }

    /**
     * Process queued events (called on shutdown).
     *
     * @return void
     */
    public function processQueue(): void
    {
        if (empty($this->queue)) {
            return;
        }

        // Process in batches
        $batches = array_chunk($this->queue, $this->batchSize);

        foreach ($batches as $batch) {
            foreach ($batch as $item) {
                $this->dispatchSync($item['event'], $item['data']);
            }
        }

        // Clear queue
        $this->queue = [];
    }

    /**
     * Process file queue (for background workers).
     *
     * Reads events from file queue and dispatches them.
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processFileQueue(int $limit = 0): int
    {
        if (!file_exists($this->queuePath)) {
            return 0;
        }

        $handle = fopen($this->queuePath, 'r+');
        if (!$handle) {
            return 0;
        }

        // Lock file
        flock($handle, LOCK_EX);

        $processed = 0;
        $remaining = [];

        while (($line = fgets($handle)) !== false) {
            if ($limit > 0 && $processed >= $limit) {
                $remaining[] = $line;
                continue;
            }

            $item = json_decode(trim($line), true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync($item['event'], $item['data']);
                $processed++;
            }
        }

        // Rewrite file with remaining events
        ftruncate($handle, 0);
        rewind($handle);
        foreach ($remaining as $line) {
            fwrite($handle, $line);
        }

        flock($handle, LOCK_UN);
        fclose($handle);

        return $processed;
    }

    /**
     * Process Redis queue (for background workers).
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processRedisQueue(int $limit = 0): int
    {
        $processed = 0;

        while ($limit === 0 || $processed < $limit) {
            $payload = $this->redis->lPop('session:events');
            if (!$payload) {
                break;
            }

            $item = json_decode($payload, true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync($item['event'], $item['data']);
                $processed++;
            }
        }

        return $processed;
    }

    /**
     * Get queue size.
     *
     * @return int Number of queued events.
     */
    public function getQueueSize(): int
    {
        return match ($this->mode) {
            self::MODE_ASYNC_MEMORY => count($this->queue),
            self::MODE_ASYNC_FILE => $this->getFileQueueSize(),
            self::MODE_ASYNC_REDIS => $this->getRedisQueueSize(),
            default => 0
        };
    }

    /**
     * Get file queue size.
     *
     * @return int Number of lines in queue file.
     */
    private function getFileQueueSize(): int
    {
        if (!file_exists($this->queuePath)) {
            return 0;
        }

        return count(file($this->queuePath));
    }

    /**
     * Get Redis queue size.
     *
     * @return int Number of items in Redis list.
     */
    private function getRedisQueueSize(): int
    {
        return $this->redis->lLen('session:events');
    }

    /**
     * Set maximum queue size.
     *
     * @param int $size Maximum size.
     *
     * @return self Fluent interface.
     */
    public function setMaxQueueSize(int $size): self
    {
        $this->maxQueueSize = $size;
        return $this;
    }

    /**
     * Set batch size for processing.
     *
     * @param int $size Batch size.
     *
     * @return self Fluent interface.
     */
    public function setBatchSize(int $size): self
    {
        $this->batchSize = $size;
        return $this;
    }

    /**
     * Get current mode.
     *
     * @return string Mode.
     */
    public function getMode(): string
    {
        return $this->mode;
    }

    /**
     * Clear all listeners.
     *
     * @return self Fluent interface.
     */
    public function clearListeners(): self
    {
        $this->listeners = [];
        return $this;
    }

    /**
     * Clear queue.
     *
     * @return self Fluent interface.
     */
    public function clearQueue(): self
    {
        $this->queue = [];
        return $this;
    }
}

=== Features/Audit.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;

/**
 * Audit - Lightweight Session Audit Logger
 *
 * Provides simple audit logging for session operations.
 * Logs are written to PSR-3 logger, file, or error_log.
 *
 * @example With PSR-3 logger
 *   $audit = new Audit(logger: $psrLoggerInstance);
 *
 * @example With file
 *   $audit = new Audit(logPath: '/var/log/session.log');
 *
 * @package Avax\HTTP\Session
 */
final class Audit implements FeatureInterface
{
    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Audit Constructor.
     *
     * @param string|null $logPath Optional log file path. Uses error_log if null and no logger.
     * @param object|null $logger  Optional PSR-3 compatible logger.
     */
    public function __construct(
        private ?string $logPath = null,
        private ?object $logger = null
    ) {}

    /**
     * Record an audit event.
     *
     * @param string               $event Event name (e.g., 'stored', 'retrieved', 'deleted').
     * @param array<string, mixed> $data  Event context data.
     *
     * @return void
     */
    public function record(string $event, array $data = []): void
    {
        $timestamp = date('c');
        $eventUpper = strtoupper($event);
        $context = empty($data) ? '' : ' ' . json_encode($data);

        $message = sprintf(
            "[%s] SESSION_%s%s",
            $timestamp,
            $eventUpper,
            $context
        );

        // PSR-3 logger takes priority
        if ($this->logger !== null && method_exists($this->logger, 'info')) {
            $this->logger->info($message, $data);
            return;
        }

        // File logging with error handling
        if ($this->logPath !== null) {
            if (!@file_put_contents($this->logPath, $message . "\n", FILE_APPEND)) {
                error_log("Failed to write session audit log to {$this->logPath}");
            }
            return;
        }

        // Fallback to error_log
        error_log($message);
    }

    /**
     * {@inheritdoc}
     */
    public function boot(): void
    {
        $this->enabled = true;
        $this->record('audit_enabled');
    }

    /**
     * {@inheritdoc}
     */
    public function terminate(): void
    {
        $this->record('audit_terminated');
        $this->enabled = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'audit';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }
}

=== Features/AuditRotator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

/**
 * AuditRotator - Log Rotation and Size Management
 *
 * Manages audit log rotation based on size and age.
 * Prevents unbounded log growth in production environments.
 *
 * Features:
 * - Size-based rotation (max file size)
 * - Time-based rotation (daily, weekly, monthly)
 * - Automatic compression of old logs
 * - Retention policy (delete old logs)
 * - Atomic rotation (no data loss)
 *
 * @example
 *   $rotator = new AuditRotator('/var/log/session.log');
 *   $rotator->setMaxSize(10 * 1024 * 1024);  // 10 MB
 *   $rotator->setMaxFiles(7);                 // Keep 7 days
 *   $rotator->rotate();
 *
 * @package Avax\HTTP\Session\Features
 */
final class AuditRotator
{
    private const DEFAULT_MAX_SIZE = 10485760; // 10 MB
    private const DEFAULT_MAX_FILES = 7;
    private const DEFAULT_COMPRESS = true;

    /**
     * AuditRotator Constructor.
     *
     * @param string $logPath     Path to log file.
     * @param int    $maxSize     Maximum file size in bytes (default: 10 MB).
     * @param int    $maxFiles    Maximum number of rotated files to keep (default: 7).
     * @param bool   $compress    Compress rotated logs (default: true).
     */
    public function __construct(
        private string $logPath,
        private int $maxSize = self::DEFAULT_MAX_SIZE,
        private int $maxFiles = self::DEFAULT_MAX_FILES,
        private bool $compress = self::DEFAULT_COMPRESS
    ) {}

    /**
     * Check if rotation is needed.
     *
     * @return bool True if log should be rotated.
     */
    public function shouldRotate(): bool
    {
        if (!file_exists($this->logPath)) {
            return false;
        }

        $size = filesize($this->logPath);
        return $size >= $this->maxSize;
    }

    /**
     * Rotate the log file.
     *
     * Renames current log to .1, shifts existing rotated logs,
     * and optionally compresses old logs.
     *
     * @return bool True on success.
     */
    public function rotate(): bool
    {
        if (!$this->shouldRotate()) {
            return false;
        }

        try {
            // Shift existing rotated logs
            $this->shiftRotatedLogs();

            // Rename current log to .1
            $rotatedPath = $this->logPath . '.1';
            if (!rename($this->logPath, $rotatedPath)) {
                return false;
            }

            // Compress if enabled
            if ($this->compress) {
                $this->compressLog($rotatedPath);
            }

            // Clean up old logs
            $this->cleanupOldLogs();

            return true;
        } catch (\Exception $e) {
            error_log("Log rotation failed: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Force rotation regardless of size.
     *
     * Useful for time-based rotation (daily, weekly, etc).
     *
     * @return bool True on success.
     */
    public function forceRotate(): bool
    {
        if (!file_exists($this->logPath)) {
            return false;
        }

        // Temporarily set max size to 0 to force rotation
        $originalMaxSize = $this->maxSize;
        $this->maxSize = 0;

        $result = $this->rotate();

        $this->maxSize = $originalMaxSize;

        return $result;
    }

    /**
     * Shift existing rotated logs.
     *
     * .1 → .2, .2 → .3, etc.
     *
     * @return void
     */
    private function shiftRotatedLogs(): void
    {
        // Start from the highest number and work backwards
        for ($i = $this->maxFiles - 1; $i >= 1; $i--) {
            $oldPath = $this->logPath . '.' . $i;
            $newPath = $this->logPath . '.' . ($i + 1);

            // Check both compressed and uncompressed versions
            foreach ([$oldPath, $oldPath . '.gz'] as $path) {
                if (file_exists($path)) {
                    $targetPath = ($path === $oldPath) ? $newPath : $newPath . '.gz';
                    rename($path, $targetPath);
                }
            }
        }
    }

    /**
     * Compress a log file using gzip.
     *
     * @param string $path Path to log file.
     *
     * @return bool True on success.
     */
    private function compressLog(string $path): bool
    {
        if (!file_exists($path)) {
            return false;
        }

        $compressedPath = $path . '.gz';

        // Read original file
        $content = file_get_contents($path);
        if ($content === false) {
            return false;
        }

        // Compress and write
        $compressed = gzencode($content, 9);
        if ($compressed === false) {
            return false;
        }

        if (file_put_contents($compressedPath, $compressed) === false) {
            return false;
        }

        // Delete original
        unlink($path);

        return true;
    }

    /**
     * Clean up old rotated logs beyond retention limit.
     *
     * @return void
     */
    private function cleanupOldLogs(): void
    {
        for ($i = $this->maxFiles + 1; $i <= $this->maxFiles + 10; $i++) {
            foreach ([$this->logPath . '.' . $i, $this->logPath . '.' . $i . '.gz'] as $path) {
                if (file_exists($path)) {
                    unlink($path);
                }
            }
        }
    }

    /**
     * Get current log file size.
     *
     * @return int Size in bytes, or 0 if file doesn't exist.
     */
    public function getCurrentSize(): int
    {
        if (!file_exists($this->logPath)) {
            return 0;
        }

        return filesize($this->logPath);
    }

    /**
     * Get human-readable current size.
     *
     * @return string Size with unit (e.g., "5.2 MB").
     */
    public function getCurrentSizeFormatted(): string
    {
        return $this->formatBytes($this->getCurrentSize());
    }

    /**
     * Get list of all rotated log files.
     *
     * @return array<string> List of file paths.
     */
    public function getRotatedLogs(): array
    {
        $logs = [];

        for ($i = 1; $i <= $this->maxFiles + 10; $i++) {
            foreach ([$this->logPath . '.' . $i, $this->logPath . '.' . $i . '.gz'] as $path) {
                if (file_exists($path)) {
                    $logs[] = $path;
                }
            }
        }

        return $logs;
    }

    /**
     * Get total size of all log files (current + rotated).
     *
     * @return int Total size in bytes.
     */
    public function getTotalSize(): int
    {
        $total = $this->getCurrentSize();

        foreach ($this->getRotatedLogs() as $path) {
            $total += filesize($path);
        }

        return $total;
    }

    /**
     * Format bytes to human-readable string.
     *
     * @param int $bytes Bytes.
     *
     * @return string Formatted string.
     */
    private function formatBytes(int $bytes): string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $i = 0;

        while ($bytes >= 1024 && $i < count($units) - 1) {
            $bytes /= 1024;
            $i++;
        }

        return round($bytes, 2) . ' ' . $units[$i];
    }

    /**
     * Set maximum file size.
     *
     * @param int $bytes Size in bytes.
     *
     * @return self Fluent interface.
     */
    public function setMaxSize(int $bytes): self
    {
        $this->maxSize = $bytes;
        return $this;
    }

    /**
     * Set maximum number of rotated files to keep.
     *
     * @param int $count Number of files.
     *
     * @return self Fluent interface.
     */
    public function setMaxFiles(int $count): self
    {
        $this->maxFiles = $count;
        return $this;
    }

    /**
     * Enable or disable compression.
     *
     * @param bool $compress Enable compression.
     *
     * @return self Fluent interface.
     */
    public function setCompress(bool $compress): self
    {
        $this->compress = $compress;
        return $this;
    }

    /**
     * Get configuration summary.
     *
     * @return array<string, mixed> Configuration.
     */
    public function getConfig(): array
    {
        return [
            'log_path' => $this->logPath,
            'max_size' => $this->formatBytes($this->maxSize),
            'max_files' => $this->maxFiles,
            'compress' => $this->compress,
            'current_size' => $this->getCurrentSizeFormatted(),
            'total_size' => $this->formatBytes($this->getTotalSize()),
            'rotated_count' => count($this->getRotatedLogs()),
        ];
    }
}

=== Features/Events.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;

/**
 * Events - Simple Event Dispatcher
 *
 * Provides basic pub/sub functionality for session events.
 *
 * Events:
 * - stored: When a value is stored
 * - retrieved: When a value is retrieved
 * - deleted: When a value is deleted
 * - flushed: When session is flushed
 *
 * @example
 *   $events->listen('stored', function($data) {
 *       logger()->info('Value stored', $data);
 *   });
 *
 *   // One-time listener
 *   $events->once('stored', function($data) {
 *       metrics()->increment('session.first_write');
 *   });
 *
 * @package Avax\HTTP\Session
 */
final class Events implements FeatureInterface
{
    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Register an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function listen(string $event, callable $callback): void
    {
        $this->listeners[$event][] = $callback;
    }

    /**
     * Register a one-time event listener.
     *
     * Listener will be automatically removed after first dispatch.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function once(string $event, callable $callback): void
    {
        $wrapper = function ($data) use ($event, $callback, &$wrapper) {
            $callback($data);
            $this->removeListener($event, $wrapper);
        };

        $this->listen($event, $wrapper);
    }

    /**
     * Remove an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback to remove.
     *
     * @return void
     */
    public function removeListener(string $event, callable $callback): void
    {
        if (!isset($this->listeners[$event])) {
            return;
        }

        $this->listeners[$event] = array_filter(
            $this->listeners[$event],
            fn($listener) => $listener !== $callback
        );
    }

    /**
     * Dispatch an event to all registered listeners.
     *
     * @param string               $event The event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []): void
    {
        if (!isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            $callback($data);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot(): void
    {
        // Events are ready on construction
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate(): void
    {
        // Clear all listeners on termination
        $this->listeners = [];
        $this->enabled = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'events';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }
}

=== Features/Flash.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\Storage\Store;
use Avax\HTTP\Session\Contracts\FeatureInterface;

/**
 * Flash - Flash Messages Feature
 *
 * Provides one-time messages that persist across a single redirect.
 *
 * Message Types:
 * - success: Success messages
 * - error: Error messages
 * - warning: Warning messages
 * - info: Informational messages
 *
 * @example
 *   $flash->success('Profile updated!');
 *   $flash->error('Invalid credentials');
 *
 *   $message = $flash->get('success');  // Auto-removed after retrieval
 *
 * @package Avax\HTTP\Session
 */
final class Flash implements FeatureInterface
{
    private const PREFIX = '_flash.';
    private bool $enabled = true;

    /**
     * Flash Constructor.
     *
     * @param Store $store The storage backend.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Add a success message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function success(string $message): void
    {
        $this->add('success', $message);
    }

    /**
     * Add an error message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function error(string $message): void
    {
        $this->add('error', $message);
    }

    /**
     * Add a warning message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function warning(string $message): void
    {
        $this->add('warning', $message);
    }

    /**
     * Add an info message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function info(string $message): void
    {
        $this->add('info', $message);
    }

    /**
     * Add a flash message.
     *
     * @param string $key     The message key.
     * @param string $message The message.
     *
     * @return void
     */
    public function add(string $key, string $message): void
    {
        $this->store->put(self::PREFIX . $key, $message);
    }

    /**
     * Get and remove a flash message.
     *
     * @param string      $key     The message key.
     * @param string|null $default Default value.
     *
     * @return string|null The message or default.
     */
    public function get(string $key, ?string $default = null): ?string
    {
        $flashKey = self::PREFIX . $key;
        $message = $this->store->get($flashKey, $default);

        if ($message !== $default) {
            $this->store->delete($flashKey);
        }

        return $message;
    }

    /**
     * Check if a flash message exists.
     *
     * @param string $key The message key.
     *
     * @return bool True if exists.
     */
    public function has(string $key): bool
    {
        return $this->store->has(self::PREFIX . $key);
    }

    /**
     * Add a flash message for immediate use (same request).
     *
     * Unlike add(), this message is NOT removed after first retrieval.
     * Use for displaying messages in the same request.
     *
     * @param string $key     The message key.
     * @param string $message The message.
     *
     * @return void
     */
    public function now(string $key, string $message): void
    {
        $this->add("now.{$key}", $message);
    }

    /**
     * Clear all flash messages.
     *
     * @return void
     */
    public function clear(): void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::PREFIX)) {
                $this->store->delete($key);
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot(): void
    {
        // Flash messages are lazy-loaded, no boot logic needed
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate(): void
    {
        // Clear all flash messages on session termination
        $this->clear();
        $this->enabled = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'flash';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }
}

=== Features/RateLimiterFeature.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Features;

use Redis;
use DateTimeImmutable;

/**
 * RateLimiterFeature
 *
 * Implements distributed rate limiting using Redis (token bucket algorithm).
 * Fallback to in-memory array for development environments.
 *
 * @package Foundation\HTTP\Session\Features
 */
final class RateLimiterFeature
{
    private array $localCache = [];

    public function __construct(
        private readonly ?Redis $redis = null,
        private readonly int $limit = 100,
        private readonly int $windowSeconds = 60
    ) {}

    public function allow(string $key): bool
    {
        $now = time();

        if ($this->redis) {
            $bucket = sprintf('ratelimit:%s', $key);
            $count = $this->redis->incr($bucket);

            if ($count === 1) {
                $this->redis->expire($bucket, $this->windowSeconds);
            }

            return $count <= $this->limit;
        }

        // In-memory fallback
        $window = (int) floor($now / $this->windowSeconds);

        if (!isset($this->localCache[$key])) {
            $this->localCache[$key] = ['count' => 0, 'window' => $window];
        }

        if ($this->localCache[$key]['window'] !== $window) {
            $this->localCache[$key] = ['count' => 0, 'window' => $window];
        }

        $this->localCache[$key]['count']++;

        return $this->localCache[$key]['count'] <= $this->limit;
    }

    public function getResetTime(string $key): DateTimeImmutable
    {
        $now = time();
        $reset = $now + $this->windowSeconds;
        return new DateTimeImmutable("@{$reset}");
    }
}

=== Features/SessionVersioning.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Features;

use DateTimeImmutable;

/**
 * SessionVersioning
 *
 * Manages versioned session snapshots for rollback and audit recovery.
 *
 * @package Foundation\HTTP\Session\Features
 */
final class SessionVersioning
{
    private array $versions = [];

    public function createSnapshot(array $data): string
    {
        $versionId = bin2hex(random_bytes(8));
        $this->versions[$versionId] = [
            'timestamp' => new DateTimeImmutable(),
            'data' => $data
        ];

        return $versionId;
    }

    public function restoreSnapshot(string $versionId): ?array
    {
        return $this->versions[$versionId]['data'] ?? null;
    }

    public function listVersions(): array
    {
        return array_map(
            fn ($v) => $v['timestamp']->format(DATE_ATOM),
            $this->versions
        );
    }
}

=== Features/Snapshots.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\Storage\Store;
use Avax\HTTP\Session\Contracts\FeatureInterface;

/**
 * Snapshots - Session State Snapshot Manager
 *
 * Provides snapshot and restore functionality for session state.
 * Useful for rollback scenarios, state comparison, or debugging.
 *
 * @example
 *   $snapshots = new Snapshots();
 *   $snapshots->snapshot('before_checkout', $sessionData);
 *   // ... later
 *   $data = $snapshots->restore('before_checkout');
 *
 * @package Avax\HTTP\Session
 */
final class Snapshots implements FeatureInterface
{
    /**
     * @var array<string, string> Snapshot storage (name => serialized data)
     */
    private array $snapshots = [];

    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Create a snapshot of session state.
     *
     * @param string               $name Snapshot identifier.
     * @param array<string, mixed> $data Session data to snapshot.
     *
     * @return void
     */
    public function snapshot(string $name, array $data): void
    {
        $this->snapshots[$name] = serialize([
            'data' => $data,
            'timestamp' => time(),
            'name' => $name,
        ]);
    }

    /**
     * Restore session state from a snapshot.
     *
     * @param string $name Snapshot identifier.
     *
     * @return array<string, mixed>|null Session data or null if snapshot doesn't exist.
     */
    public function restore(string $name): ?array
    {
        if (!isset($this->snapshots[$name])) {
            return null;
        }

        $snapshot = unserialize($this->snapshots[$name]);

        return $snapshot['data'] ?? null;
    }

    /**
     * Check if a snapshot exists.
     *
     * @param string $name Snapshot identifier.
     *
     * @return bool True if snapshot exists.
     */
    public function has(string $name): bool
    {
        return isset($this->snapshots[$name]);
    }

    /**
     * Delete a snapshot.
     *
     * @param string $name Snapshot identifier.
     *
     * @return void
     */
    public function delete(string $name): void
    {
        unset($this->snapshots[$name]);
    }

    /**
     * Get all snapshot names.
     *
     * @return array<int, string> List of snapshot names.
     */
    public function all(): array
    {
        return array_keys($this->snapshots);
    }

    /**
     * Save all snapshots to a Store.
     *
     * Enables persistence across requests.
     *
     * @param Store  $store The storage backend.
     * @param string $key   Storage key (default: '_snapshots').
     *
     * @return void
     */
    public function saveTo(Store $store, string $key = '_snapshots'): void
    {
        $store->put($key, $this->snapshots);
    }

    /**
     * Load snapshots from a Store.
     *
     * Restores snapshots from persistent storage.
     *
     * @param Store  $store The storage backend.
     * @param string $key   Storage key (default: '_snapshots').
     *
     * @return void
     */
    public function loadFrom(Store $store, string $key = '_snapshots'): void
    {
        $snapshots = $store->get($key, []);

        if (is_array($snapshots)) {
            $this->snapshots = $snapshots;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot(): void
    {
        // Snapshots are ready on construction
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate(): void
    {
        // Clear all snapshots on termination
        $this->snapshots = [];
        $this->enabled = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'snapshots';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }
}

=== Middleware/MetricsMiddleware.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Middleware;

use Avax\HTTP\Session\Observability\MetricCollector;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

/**
 * MetricsMiddleware
 *
 * PSR-15 compatible middleware that measures session-related request metrics.
 * - Latency measurement
 * - Session hit/miss tracking
 * - Error count
 *
 * @package Foundation\HTTP\Session\Middleware
 */
final class MetricsMiddleware implements MiddlewareInterface
{
    public function __construct(
        private readonly MetricCollector $metrics
    ) {}

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $start = microtime(true);

        try {
            $response = $handler->handle($request);
            $duration = microtime(true) - $start;

            $this->metrics->observeLatency($duration);
            $this->metrics->increment('session_ops_total');

            return $response;
        } catch (\Throwable $e) {
            $this->metrics->increment('session_errors_total');
            throw $e;
        }
    }
}

=== Observability/MetricCollector.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Observability;

/**
 * MetricCollector
 *
 * Simple in-memory metrics collector for Prometheus-compatible exporters.
 *
 * @package Foundation\HTTP\Session\Observability
 */
final class MetricCollector
{
    private array $metrics = [
        'session_ops_total' => 0,
        'session_errors_total' => 0,
        'session_latency_seconds' => []
    ];

    public function increment(string $metric): void
    {
        if (!isset($this->metrics[$metric])) {
            $this->metrics[$metric] = 0;
        }
        $this->metrics[$metric]++;
    }

    public function observeLatency(float $seconds): void
    {
        $this->metrics['session_latency_seconds'][] = $seconds;
    }

    public function export(): array
    {
        $avgLatency = empty($this->metrics['session_latency_seconds'])
            ? 0
            : array_sum($this->metrics['session_latency_seconds']) / count($this->metrics['session_latency_seconds']);

        return [
            'session_ops_total' => $this->metrics['session_ops_total'],
            'session_errors_total' => $this->metrics['session_errors_total'],
            'session_latency_avg_seconds' => $avgLatency,
        ];
    }
}

=== Observability/PrometheusExporter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Observability;

/**
 * PrometheusExporter
 *
 * Exports session metrics in Prometheus text-based exposition format.
 *
 * @package Foundation\HTTP\Session\Observability
 */
final readonly class PrometheusExporter
{
    public function __construct(
        private MetricCollector $collector
    ) {}

    public function render(): string
    {
        $metrics = $this->collector->export();
        $lines = [];

        foreach ($metrics as $name => $value) {
            $lines[] = sprintf('# TYPE %s gauge', $name);
            $lines[] = sprintf('%s %s', $name, $value);
        }

        return implode(separator: PHP_EOL, array: $lines) . PHP_EOL;
    }
}

=== Providers/Session.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Providers;

use Avax\Support\Facades\Facade;

/**
 * Session - Laravel-Style Session Facade
 *
 * Static proxy to SessionProvider instance for convenient access.
 * 
 * Provider-Consumer Pattern:
 * - Session facade provides static access
 * - SessionProvider is the underlying provider
 * - SessionConsumer handles contextual operations
 * 
 * @example
 *   Session::put('user_id', 123);
 *   Session::for('cart')->secure()->put('items', $items);
 *   Session::flash()->success('Saved!');
 * 
 * @method static void put(string $key, mixed $value, ?int $ttl = null)
 * @method static mixed get(string $key, mixed $default = null)
 * @method static bool has(string $key)
 * @method static void forget(string $key)
 * @method static array all()
 * @method static void flush()
 * @method static SessionConsumer for(string $context)
 * @method static SessionConsumer scope(string $namespace)
 * @method static Flash flash()
 * @method static Events events()
 * @method static self registerPolicy(Policies\PolicyInterface $policy)
 * @method static self enableAudit(?string $path = null)
 * @method static void snapshot(string $name)
 * @method static void restore(string $name)
 * @method static mixed remember(string $key, callable $callback, ?int $ttl = null)
 *
 * @package Avax\HTTP\Session
 * @see SessionProvider
 */
class Session extends Facade
{
    /**
     * Get the accessor for the facade.
     *
     * @return string The facade accessor name.
     */
    protected static function getFacadeAccessor(): string
    {
        return SessionProvider::class;
    }
}

=== Providers/SessionConsumer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Providers;

/**
 * SessionConsumer - Contextual Session Consumer
 *
 * Represents a contextual, purpose-specific consumer of the SessionProvider.
 * Created via $session->for($context) or $session->scope($context).
 * 
 * Provider-Consumer Pattern:
 * - SessionProvider = Provider (aggregate root, lifecycle management)
 * - SessionConsumer = Consumer (contextual DSL adapter)
 * 
 * Features:
 * - Namespace isolation (e.g., 'cart', 'user', 'admin')
 * - TTL configuration
 * - Auto-encryption via secure() method
 * - Chainable fluent API
 * 
 * @example
 *   $session->for('cart')
 *       ->secure()
 *       ->ttl(3600)
 *       ->put('items', $items);
 *
 * @package Avax\HTTP\Session
 */
final class SessionConsumer
{
    private ?int $ttl = null;
    private bool $secure = false;

    /**
     * SessionConsumer Constructor.
     *
     * @param string          $namespace The consumer context namespace.
     * @param SessionProvider $provider  The session provider.
     */
    public function __construct(
        private string $namespace,
        private SessionProvider $provider
    ) {}

    /**
     * Set TTL for all operations in this consumer context.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Fluent interface.
     */
    public function ttl(int $seconds): self
    {
        $this->ttl = $seconds;
        return $this;
    }

    /**
     * Enable auto-encryption for all operations in this consumer context.
     *
     * @return self Fluent interface.
     */
    public function secure(): self
    {
        $this->secure = true;
        return $this;
    }

    /**
     * Store a value in this consumer context.
     *
     * @param string $key   The key (will be namespaced).
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value): void
    {
        $scopedKey = $this->buildKey($key);
        $this->provider->put($scopedKey, $value, $this->ttl);
    }

    /**
     * Retrieve a value from this consumer context.
     *
     * @param string $key     The key (will be namespaced).
     * @param mixed  $default Default value if not found.
     *
     * @return mixed The retrieved value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        $scopedKey = $this->buildKey($key);
        return $this->provider->get($scopedKey, $default);
    }

    /**
     * Check if a key exists in this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool
    {
        $scopedKey = $this->buildKey($key);
        return $this->provider->has($scopedKey);
    }

    /**
     * Remove a value from this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return void
     */
    public function forget(string $key): void
    {
        $scopedKey = $this->buildKey($key);
        $this->provider->forget($scopedKey);
    }

    /**
     * Remember a value using lazy evaluation.
     *
     * Proxy to provider's remember() method with scoped key.
     *
     * @param string   $key      The key (will be namespaced).
     * @param callable $callback Callback to generate value.
     *
     * @return mixed The cached or generated value.
     */
    public function remember(string $key, callable $callback): mixed
    {
        $scopedKey = $this->buildKey($key);
        return $this->provider->remember($scopedKey, $callback, $this->ttl);
    }

    /**
     * Create a temporary consumer with TTL.
     *
     * Shortcut for ->ttl() configuration.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Consumer with TTL configured.
     */
    public function temporary(int $seconds): self
    {
        return $this->ttl($seconds);
    }

    /**
     * Build scoped key with namespace and security suffix.
     *
     * @param string $key The base key.
     *
     * @return string The scoped key.
     */
    private function buildKey(string $key): string
    {
        $scopedKey = "{$this->namespace}.{$key}";

        if ($this->secure) {
            $scopedKey .= '_secure';
        }

        return $scopedKey;
    }

    /**
     * String representation for debugging.
     *
     * @return string Debug representation.
     */
    public function __toString(): string
    {
        return sprintf(
            'SessionConsumer(%s, secure=%s, ttl=%s)',
            $this->namespace,
            $this->secure ? 'true' : 'false',
            $this->ttl ?? 'null'
        );
    }
}

=== Providers/SessionProvider.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Providers;

use Avax\HTTP\Session\Config\SessionConfig;
use Avax\HTTP\Session\Contracts\SessionContract;
use Avax\HTTP\Session\Contracts\Storage\Store;
use Avax\HTTP\Session\Security\EncrypterFactory;
use Avax\HTTP\Session\Security\PolicyEnforcer;
use Avax\HTTP\Session\Security\CookieManager;
use Avax\HTTP\Session\Security\SessionRegistry;
use Avax\HTTP\Session\Security\SessionNonce;
use Avax\HTTP\Session\Adapters\SessionAdapter;
use Avax\HTTP\Session\Security\Policies\PolicyInterface;
use Avax\HTTP\Session\Contracts\FeatureInterface;
use Avax\HTTP\Session\Features\{Flash, Events, Audit, Snapshots};

/**
 * SessionProvider - Enterprise Session Provider V4.0
 *
 * Acts as the core session provider — responsible for managing
 * session lifecycle, persistence, and behavioral features.
 *
 * Provider-Consumer Pattern:
 * - SessionProvider = Provider (aggregate root, lifecycle management)
 * - SessionConsumer = Consumer (contextual DSL adapter)
 *
 * V4.0 Enterprise Edition Features:
 * - EncrypterFactory: Real AES-256-GCM encryption with key rotation
 * - PolicyEnforcer: Centralized policy enforcement
 * - CookieManager: OWASP-compliant cookie security
 * - SessionAdapter: Testable session operations
 * - SessionRegistry: Multi-device session control
 * - SessionNonce: Replay attack prevention
 * - FeatureInterface: Unified feature lifecycle
 *
 * Built-in Features (Zero Configuration):
 * - Auto-encryption (via _secure suffix convention)
 * - Auto-TTL (via ttl parameter)
 * - Namespacing (via scope() / for() builders)
 * - Remember pattern (lazy evaluation)
 * - Policy enforcement (security rules)
 * - Audit logging (observability)
 * - Snapshots (state management)
 *
 * Enterprise Rules:
 * - Smart Conventions: _secure suffix triggers auto-encryption
 * - Lazy Loading: Flash, Events, Audit, Snapshots created only when needed
 * - Dependency Injection: All services injected for testability
 * - Zero Ceremony: Minimal interfaces
 *
 * @example Basic usage
 *   $session = new SessionProvider($store);
 *   $session->put('user_id', 123);
 *   $userId = $session->get('user_id');
 *
 * @example Natural DSL with for()
 *   $session->for('cart')
 *       ->secure()
 *       ->ttl(3600)
 *       ->put('items', $items);
 *
 * @example With Policies
 *   $session->registerPolicy(new MaxIdlePolicy(900));
 *   $session->registerPolicy(new SecureOnlyPolicy());
 *
 * @example With Audit
 *   $session->enableAudit('/var/log/session.log');
 *
 * @example With Snapshots
 *   $session->snapshot('before_checkout');
 *   // ... later
 *   $session->restore('before_checkout');
 *
 * @package Avax\HTTP\Session
 */
final class SessionProvider implements SessionContract
{
    private ?Flash $flash = null;
    private ?Events $events = null;
    private ?Audit $audit = null;
    private ?Snapshots $snapshots = null;
    private EncrypterFactory $encrypter;
    private PolicyEnforcer $policyEnforcer;
    private CookieManager $cookieManager;
    private SessionAdapter $sessionAdapter;
    private ?SessionRegistry $registry = null;
    private ?SessionNonce $nonce = null;

    /**
     * @var array<FeatureInterface> Registered features
     */
    private array $features = [];

    /**
     * SessionProvider Constructor.
     *
     * @param Store               $store           The storage backend.
     * @param SessionConfig|null  $config          Optional configuration.
     * @param EncrypterFactory|null $encrypter     Optional encrypter factory.
     * @param PolicyEnforcer|null $policyEnforcer  Optional policy enforcer.
     * @param CookieManager|null  $cookieManager   Optional cookie manager.
     * @param SessionAdapter|null $sessionAdapter  Optional session adapter.
     */
    public function __construct(
        private Store $store,
        ?SessionConfig $config = null,
        ?EncrypterFactory $encrypter = null,
        ?PolicyEnforcer $policyEnforcer = null,
        ?CookieManager $cookieManager = null,
        ?SessionAdapter $sessionAdapter = null
    ) {
        $config ??= SessionConfig::default();

        // Initialize core services
        $this->encrypter = $encrypter ?? new EncrypterFactory();
        $this->policyEnforcer = $policyEnforcer ?? new PolicyEnforcer();
        $this->cookieManager = $cookieManager ?? CookieManager::lax();
        $this->sessionAdapter = $sessionAdapter ?? new SessionAdapter($this->cookieManager);
    }

    // ========================================
    // CORE OPERATIONS
    // ========================================

    /**
     * Store a value in the session.
     *
     * Smart Conventions:
     * - Keys ending with '_secure' are auto-encrypted (via EncrypterFactory)
     * - TTL parameter sets automatic expiration
     * - Policy enforcement (via PolicyEnforcer)
     * - Audit logging (if enabled)
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Optional time-to-live in seconds.
     *
     * @return void
     */
    public function put(string $key, mixed $value, ?int $ttl = null): void
    {
        // Enforce policies before write (delegated to PolicyEnforcer)
        $this->policyEnforcer->enforce($this->all());

        // Auto-encrypt if key ends with '_secure' (using EncrypterFactory)
        if (str_ends_with($key, '_secure')) {
            $value = $this->encrypter->encrypt($value);
        }

        $this->store->put($key, $value);

        // Auto-TTL if specified
        if ($ttl !== null) {
            $this->store->put("_ttl.{$key}", time() + $ttl);
        }

        // Audit logging
        $this->audit?->record('stored', ['key' => $key, 'ttl' => $ttl]);

        // Dispatch event if events enabled
        $this->events?->dispatch('stored', ['key' => $key, 'ttl' => $ttl]);
    }

    /**
     * Retrieve a value from the session.
     *
     * Smart Conventions:
     * - Auto-checks TTL expiration
     * - Auto-decrypts '_secure' suffixed keys (via EncrypterFactory)
     * - Policy enforcement (via PolicyEnforcer)
     *
     * @param string $key     The session key.
     * @param mixed  $default Default value if key doesn't exist.
     *
     * @return mixed The retrieved value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        // Enforce policies before read (delegated to PolicyEnforcer)
        $this->policyEnforcer->enforce($this->all());

        // Check TTL expiration first
        if ($this->isExpired($key)) {
            $this->forget($key);
            return $default;
        }

        $value = $this->store->get($key, $default);

        // Auto-decrypt if encrypted (using EncrypterFactory with key rotation)
        if (str_ends_with($key, '_secure') && $value !== $default) {
            $value = $this->encrypter->decrypt($value);
        }

        // Audit logging
        $this->audit?->record('retrieved', ['key' => $key]);

        return $value;
    }

    /**
     * Check if a key exists in the session.
     *
     * @param string $key The session key.
     *
     * @return bool True if key exists and not expired.
     */
    public function has(string $key): bool
    {
        if ($this->isExpired($key)) {
            $this->forget($key);
            return false;
        }

        return $this->store->has($key);
    }

    /**
     * Remove a value from the session.
     *
     * Also removes associated TTL metadata.
     *
     * @param string $key The session key.
     *
     * @return void
     */
    public function forget(string $key): void
    {
        $this->store->delete($key);
        $this->store->delete("_ttl.{$key}");

        // Audit logging
        $this->audit?->record('deleted', ['key' => $key]);

        // Dispatch event
        $this->events?->dispatch('deleted', ['key' => $key]);
    }

    /**
     * Get all session data.
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array
    {
        return $this->store->all();
    }

    /**
     * Clear all session data.
     *
     * @return void
     */
    public function flush(): void
    {
        $this->store->flush();

        // Audit logging
        $this->audit?->record('flushed');

        // Dispatch event
        $this->events?->dispatch('flushed');
    }

    /**
     * Terminate session securely.
     *
     * OWASP ASVS 3.2.3 Compliant
     *
     * Performs complete session cleanup:
     * - Terminates all features (via FeatureInterface)
     * - Clears all data
     * - Destroys server session (via SessionAdapter)
     * - Removes client cookie (via CookieManager)
     * - Prevents session reuse
     * - Audit logs termination
     *
     * @param string $reason Termination reason (for audit).
     *
     * @return void
     */
    public function terminate(string $reason = 'logout'): void
    {
        // Audit logging
        $this->audit?->record('session_terminated', ['reason' => $reason]);

        // Terminate all features
        $this->terminateFeatures();

        // Clear all session data
        $this->flush();

        // Destroy server-side session (via SessionAdapter)
        $this->sessionAdapter->destroy();
    }

    /**
     * Login with automatic session regeneration.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Automatically regenerates session ID to prevent fixation.
     * Registers session in SessionRegistry for multi-device control.
     *
     * @param string $userId User identifier.
     *
     * @return void
     */
    public function login(string $userId): void
    {
        // CRITICAL: Regenerate ID before setting user data (via SessionAdapter)
        $this->regenerateId();

        $this->put('user_id', $userId);
        $this->put('_authenticated', true);
        $this->put('_login_time', time());

        // Register session in SessionRegistry
        if ($this->registry !== null) {
            $this->registry->register($userId, $this->getId(), [
                'ip' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
            ]);
        }

        // Audit
        $this->audit?->record('session_login', ['user_id' => $userId]);
    }

    /**
     * Elevate user privileges.
     *
     * OWASP ASVS 3.2.1 Compliant
     * 
     * Regenerates session ID when user gains elevated permissions.
     *
     * @param array<string> $newRoles New user roles.
     *
     * @return void
     */
    public function elevatePrivileges(array $newRoles): void
    {
        // CRITICAL: Regenerate ID on privilege change
        $this->regenerateId();

        $this->put('roles', $newRoles);
        $this->put('_privilege_elevation_time', time());

        // Audit
        $this->audit?->record('privilege_elevation', ['roles' => $newRoles]);
    }

    /**
     * Regenerate session ID.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Prevents session fixation attacks.
     * Delegated to SessionAdapter for testability.
     *
     * @param bool $deleteOldSession Delete old session data.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true): void
    {
        $this->sessionAdapter->regenerateId($deleteOldSession);

        // Audit
        $this->audit?->record('session_regenerated');
    }

    /**
     * Get current session ID.
     *
     * Delegated to SessionAdapter.
     *
     * @return string Session ID.
     */
    public function getId(): string
    {
        return $this->sessionAdapter->getId();
    }

    // ========================================
    // DSL BUILDERS (Provider-Consumer Pattern)
    // ========================================

    /**
     * Create a contextual session consumer (Natural DSL).
     *
     * This is the natural, domain-oriented method for creating
     * session consumers. Reads like: "for this context...".
     *
     * @example
     *   $session->for('cart')->secure()->put('items', $items);
     *
     * @param string $context The consumer context.
     *
     * @return SessionConsumer Consumer for contextual operations.
     */
    public function for(string $context): SessionConsumer
    {
        return new SessionConsumer($context, $this);
    }

    /**
     * Create a scoped session consumer (Technical DSL).
     *
     * Alias for for() - provides technical namespace isolation.
     *
     * @example
     *   $session->scope('user')->ttl(3600)->put('id', 123);
     *
     * @param string $namespace The scope namespace.
     *
     * @return SessionConsumer Consumer for scoped operations.
     */
    public function scope(string $namespace): SessionConsumer
    {
        return $this->for($namespace);
    }

    /**
     * Access flash messages feature.
     *
     * Lazy-loaded on first access.
     *
     * @example
     *   $session->flash()->success('Saved!');
     *   $message = $session->flash()->get('success');
     *
     * @return Flash Flash messages manager.
     */
    public function flash(): Flash
    {
        return $this->flash ??= new Flash($this->store);
    }

    /**
     * Access events feature.
     *
     * Lazy-loaded on first access.
     *
     * @example
     *   $session->events()->listen('stored', fn($data) => logger()->info($data));
     *
     * @return Events Event dispatcher.
     */
    public function events(): Events
    {
        return $this->events ??= new Events();
    }

    // ========================================
    // POLICY SYSTEM
    // ========================================

    /**
     * Register a session policy.
     *
     * Policies are enforced on every put() and get() operation.
     * Delegated to PolicyEnforcer.
     *
     * @example
     *   $session->registerPolicy(new MaxIdlePolicy(900));
     *   $session->registerPolicy(new SecureOnlyPolicy());
     *
     * @param PolicyInterface $policy The policy to register.
     *
     * @return self Fluent interface.
     */
    public function registerPolicy(PolicyInterface $policy): self
    {
        $this->policyEnforcer->register($policy);
        return $this;
    }

    /**
     * Register multiple policies at once.
     *
     * @param array<PolicyInterface> $policies Policies to register.
     *
     * @return self Fluent interface.
     */
    public function registerPolicies(array $policies): self
    {
        $this->policyEnforcer->registerMany($policies);
        return $this;
    }

    // ========================================
    // AUDIT SYSTEM
    // ========================================

    /**
     * Get audit instance (if enabled).
     *
     * @return Audit|null Audit instance or null.
     */
    public function audit(): ?Audit
    {
        return $this->audit;
    }

    /**
     * Enable audit logging.
     *
     * @example
     *   $session->enableAudit('/var/log/session.log');
     *
     * @param string|null $path Optional log file path.
     *
     * @return self Fluent interface.
     */
    public function enableAudit(?string $path = null): self
    {
        $this->audit = new Audit($path);
        return $this;
    }

    // ========================================
    // SNAPSHOT SYSTEM
    // ========================================

    /**
     * Access snapshots feature.
     *
     * Lazy-loaded on first access.
     *
     * @return Snapshots Snapshot manager.
     */
    public function snapshots(): Snapshots
    {
        return $this->snapshots ??= new Snapshots();
    }

    /**
     * Create a snapshot of current session state.
     *
     * @example
     *   $session->snapshot('before_checkout');
     *
     * @param string $name Snapshot name.
     *
     * @return void
     */
    public function snapshot(string $name): void
    {
        $this->snapshots()->snapshot($name, $this->all());

        // Audit logging
        $this->audit?->record('snapshot', ['name' => $name]);
    }

    /**
     * Restore session state from a snapshot.
     *
     * @example
     *   $session->restore('before_checkout');
     *
     * @param string $name Snapshot name.
     *
     * @return void
     */
    public function restore(string $name): void
    {
        $data = $this->snapshots()->restore($name);

        if ($data === null) {
            return;
        }

        $this->flush();

        foreach ($data as $key => $value) {
            $this->put($key, $value);
        }

        // Audit logging
        $this->audit?->record('restored', ['name' => $name]);
    }

    // ========================================
    // SMART HELPERS
    // ========================================

    /**
     * Remember pattern - lazy evaluation with caching.
     *
     * Retrieves value if exists, otherwise executes callback and stores result.
     *
     * @example
     *   $user = $session->remember('current_user', fn() => User::find($id));
     *
     * @param string   $key      The cache key.
     * @param callable $callback Callback to generate value.
     * @param int|null $ttl      Optional TTL in seconds.
     *
     * @return mixed The cached or generated value.
     */
    public function remember(string $key, callable $callback, ?int $ttl = null): mixed
    {
        if ($this->has($key)) {
            return $this->get($key);
        }

        $value = $callback();
        $this->put($key, $value, $ttl);

        return $value;
    }

    /**
     * Create a temporary session consumer.
     *
     * Convenience method for consumers with TTL.
     *
     * @example
     *   $session->temporary(300)->put('otp', '123456');
     *
     * @param int $seconds TTL in seconds.
     *
     * @return SessionConsumer Consumer with TTL.
     */
    public function temporary(int $seconds): SessionConsumer
    {
        return $this->for('temp')->ttl($seconds);
    }

    // ========================================
    // INTERNAL HELPERS
    // ========================================

    /**
     * Check if a key has expired.
     *
     * @param string $key The session key.
     *
     * @return bool True if expired.
     */
    private function isExpired(string $key): bool
    {
        $expiry = $this->store->get("_ttl.{$key}");
        return $expiry !== null && time() > $expiry;
    }

    // ========================================
    // SERVICE ACCESSORS
    // ========================================

    /**
     * Get EncrypterFactory instance.
     *
     * @return EncrypterFactory Encrypter factory.
     */
    public function getEncrypter(): EncrypterFactory
    {
        return $this->encrypter;
    }

    /**
     * Get PolicyEnforcer instance.
     *
     * @return PolicyEnforcer Policy enforcer.
     */
    public function getPolicyEnforcer(): PolicyEnforcer
    {
        return $this->policyEnforcer;
    }

    /**
     * Get CookieManager instance.
     *
     * @return CookieManager Cookie manager.
     */
    public function getCookieManager(): CookieManager
    {
        return $this->cookieManager;
    }

    /**
     * Get SessionAdapter instance.
     *
     * @return SessionAdapter Session adapter.
     */
    public function getSessionAdapter(): SessionAdapter
    {
        return $this->sessionAdapter;
    }

    /**
     * Get SessionRegistry instance.
     *
     * @return SessionRegistry|null Session registry or null.
     */
    public function getRegistry(): ?SessionRegistry
    {
        return $this->registry;
    }

    /**
     * Enable SessionRegistry for multi-device control.
     *
     * @return self Fluent interface.
     */
    public function enableRegistry(): self
    {
        $this->registry = new SessionRegistry($this->store);
        return $this;
    }

    /**
     * Get SessionNonce instance.
     *
     * @return SessionNonce|null Session nonce or null.
     */
    public function getNonce(): ?SessionNonce
    {
        return $this->nonce;
    }

    /**
     * Enable SessionNonce for replay attack prevention.
     *
     * @return self Fluent interface.
     */
    public function enableNonce(): self
    {
        $this->nonce = new SessionNonce($this->store);
        return $this;
    }

    // ========================================
    // FEATURE LIFECYCLE MANAGEMENT
    // ========================================

    /**
     * Boot all registered features.
     *
     * @return void
     */
    private function bootFeatures(): void
    {
        foreach ($this->features as $feature) {
            if ($feature instanceof FeatureInterface) {
                $feature->boot();
            }
        }
    }

    /**
     * Terminate all registered features.
     *
     * @return void
     */
    private function terminateFeatures(): void
    {
        foreach ($this->features as $feature) {
            if ($feature instanceof FeatureInterface) {
                $feature->terminate();
            }
        }
    }

    /**
     * Register a feature.
     *
     * @param FeatureInterface $feature Feature to register.
     *
     * @return self Fluent interface.
     */
    public function registerFeature(FeatureInterface $feature): self
    {
        $this->features[$feature->getName()] = $feature;
        $feature->boot();
        return $this;
    }
}

=== Security/CookieManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

/**
 * CookieManager - Centralized Cookie Policy Enforcement
 *
 * OWASP ASVS 3.4.1 Compliant
 *
 * Enforces secure cookie attributes (Secure, HttpOnly, SameSite).
 * Prevents common cookie-based attacks:
 * - XSS (via HttpOnly)
 * - Man-in-the-middle (via Secure)
 * - CSRF (via SameSite)
 *
 * @package Avax\HTTP\Session\Security
 */
final class CookieManager
{
    /**
     * CookieManager Constructor.
     *
     * @param bool   $secure     Require HTTPS (default: true).
     * @param bool   $httpOnly   Prevent JavaScript access (default: true).
     * @param string $sameSite   SameSite policy: 'Lax', 'Strict', 'None' (default: 'Lax').
     * @param string $path       Cookie path (default: '/').
     * @param string $domain     Cookie domain (default: '').
     * @param int    $lifetime   Cookie lifetime in seconds (default: 0 = session).
     */
    public function __construct(
        private bool $secure = true,
        private bool $httpOnly = true,
        private string $sameSite = 'Lax',
        private string $path = '/',
        private string $domain = '',
        private int $lifetime = 0
    ) {
        // Validate SameSite
        if (!in_array($sameSite, ['Lax', 'Strict', 'None'], true)) {
            throw new \InvalidArgumentException(
                "Invalid SameSite value: {$sameSite}. Must be 'Lax', 'Strict', or 'None'."
            );
        }

        // SameSite=None requires Secure flag
        if ($sameSite === 'None' && !$secure) {
            throw new \InvalidArgumentException(
                'SameSite=None requires Secure flag to be true (HTTPS only).'
            );
        }
    }

    /**
     * Create a strict security configuration.
     *
     * - SameSite=Strict
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function strict(): self
    {
        return new self(
            secure: true,
            httpOnly: true,
            sameSite: 'Strict'
        );
    }

    /**
     * Create a lax security configuration (default).
     *
     * - SameSite=Lax
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function lax(): self
    {
        return new self(
            secure: true,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Create a development configuration (insecure).
     *
     * - SameSite=Lax
     * - Secure=false
     * - HttpOnly=true
     *
     * @return self
     */
    public static function development(): self
    {
        return new self(
            secure: false,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Set a cookie with enforced security attributes.
     *
     * @param string $name     Cookie name.
     * @param string $value    Cookie value.
     * @param int    $expires  Expiration timestamp (0 = session).
     *
     * @return bool True on success.
     */
    public function set(string $name, string $value, int $expires = 0): bool
    {
        $expires = $expires ?: ($this->lifetime ? time() + $this->lifetime : 0);

        // PHP 7.3+ array format
        return setcookie($name, $value, [
            'expires' => $expires,
            'path' => $this->path,
            'domain' => $this->domain,
            'secure' => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Delete a cookie.
     *
     * Sets expiration to past time to trigger browser deletion.
     *
     * @param string $name Cookie name.
     *
     * @return bool True on success.
     */
    public function delete(string $name): bool
    {
        return setcookie($name, '', [
            'expires' => time() - 3600,
            'path' => $this->path,
            'domain' => $this->domain,
            'secure' => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get a cookie value.
     *
     * @param string     $name    Cookie name.
     * @param mixed|null $default Default value.
     *
     * @return mixed Cookie value or default.
     */
    public function get(string $name, mixed $default = null): mixed
    {
        return $_COOKIE[$name] ?? $default;
    }

    /**
     * Check if a cookie exists.
     *
     * @param string $name Cookie name.
     *
     * @return bool True if exists.
     */
    public function has(string $name): bool
    {
        return isset($_COOKIE[$name]);
    }

    /**
     * Configure session cookie parameters.
     *
     * OWASP ASVS 3.2.2 Compliant
     *
     * Applies security policy to PHP session cookies.
     *
     * @return void
     */
    public function configureSessionCookie(): void
    {
        session_set_cookie_params([
            'lifetime' => $this->lifetime,
            'path' => $this->path,
            'domain' => $this->domain,
            'secure' => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get current cookie configuration.
     *
     * @return array<string, mixed> Configuration array.
     */
    public function getConfig(): array
    {
        return [
            'secure' => $this->secure,
            'httpOnly' => $this->httpOnly,
            'sameSite' => $this->sameSite,
            'path' => $this->path,
            'domain' => $this->domain,
            'lifetime' => $this->lifetime,
        ];
    }

    /**
     * Check if configuration is production-ready.
     *
     * @return bool True if secure configuration.
     */
    public function isSecure(): bool
    {
        return $this->secure && $this->httpOnly && $this->sameSite !== 'None';
    }
}

=== Security/Crypto/FipsAwareEncrypter.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Security\Crypto;

use RuntimeException;

/**
 * FipsAwareEncrypter
 *
 * Provides dual-mode encryption supporting AES-256-GCM and AES-256-CBC-HMAC-SHA256.
 * Automatically detects FIPS mode through OPENSSL_FIPS environment variable.
 *
 * @package Foundation\HTTP\Session\Security\Crypto
 */
final class FipsAwareEncrypter
{
    public function __construct(
        private readonly string $key
    ) {}

    public function encrypt(string $plaintext): string
    {
        $fipsMode = getenv('OPENSSL_FIPS') === '1';

        if ($fipsMode) {
            $iv = random_bytes(16);
            $ciphertext = openssl_encrypt($plaintext, 'AES-256-CBC', $this->key, OPENSSL_RAW_DATA, $iv);
            $hmac = hash_hmac('sha256', $ciphertext, $this->key, true);
            return base64_encode($iv . $hmac . $ciphertext);
        }

        $iv = random_bytes(12);
        $tag = '';
        $ciphertext = openssl_encrypt($plaintext, 'aes-256-gcm', $this->key, OPENSSL_RAW_DATA, $iv, $tag);
        return base64_encode($iv . $tag . $ciphertext);
    }

    public function decrypt(string $ciphertext): string
    {
        $decoded = base64_decode($ciphertext, true);

        if (getenv('OPENSSL_FIPS') === '1') {
            $iv = substr($decoded, 0, 16);
            $hmac = substr($decoded, 16, 32);
            $ct = substr($decoded, 48);

            $calcHmac = hash_hmac('sha256', $ct, $this->key, true);
            if (!hash_equals($hmac, $calcHmac)) {
                throw new RuntimeException('HMAC verification failed');
            }

            return openssl_decrypt($ct, 'AES-256-CBC', $this->key, OPENSSL_RAW_DATA, $iv);
        }

        $iv = substr($decoded, 0, 12);
        $tag = substr($decoded, 12, 16);
        $ct = substr($decoded, 28);

        return openssl_decrypt($ct, 'aes-256-gcm', $this->key, OPENSSL_RAW_DATA, $iv, $tag);
    }
}

=== Security/Crypto/NullEncrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Crypto;

use Avax\HTTP\Session\Contracts\Security\Encrypter;

/**
 * NullEncrypter - No-Op Encrypter
 *
 * Dummy encrypter for testing or development.
 * Does NOT actually encrypt - just base64 encodes.
 * 
 * @warning DO NOT use in production!
 * 
 * @package Avax\HTTP\Session\Crypto
 */
final class NullEncrypter implements Encrypter
{
    /**
     * {@inheritdoc}
     */
    public function encrypt(mixed $value): string
    {
        return base64_encode(serialize($value));
    }

    /**
     * {@inheritdoc}
     */
    public function decrypt(string $encrypted): mixed
    {
        return unserialize(base64_decode($encrypted));
    }
}

=== Security/Crypto/OpenSSLEncrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Crypto;

use Avax\HTTP\Session\Contracts\Security\Encrypter;

/**
 * OpenSSLEncrypter - Production-Grade AES-256-GCM Encryption
 *
 * OWASP ASVS 3.3.2 & 3.3.3 Compliant
 * 
 * Features:
 * - AES-256-GCM (Authenticated Encryption with Associated Data)
 * - Automatic IV generation per encryption
 * - Authentication tag for integrity verification
 * - Tampering detection
 * - Cryptographically secure random IVs
 * 
 * Security Properties:
 * - Confidentiality: AES-256 encryption
 * - Integrity: GCM authentication tag
 * - Non-replayability: Unique IV per operation
 * 
 * @package Avax\HTTP\Session\Security\Crypto
 */
final class OpenSSLEncrypter implements Encrypter
{
    private const CIPHER = 'aes-256-gcm';
    private const IV_LENGTH = 12;      // 96 bits for GCM
    private const TAG_LENGTH = 16;     // 128 bits authentication tag

    /**
     * OpenSSLEncrypter Constructor.
     *
     * @param string $key Encryption key (32 bytes for AES-256).
     *
     * @throws \InvalidArgumentException If key length is invalid.
     */
    public function __construct(
        private string $key
    ) {
        if (strlen($key) !== 32) {
            throw new \InvalidArgumentException(
                'Encryption key must be exactly 32 bytes for AES-256'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function encrypt(mixed $value): string
    {
        $plaintext = serialize($value);

        // Generate cryptographically secure random IV
        $iv = random_bytes(self::IV_LENGTH);

        // Encrypt with AES-256-GCM
        $tag = '';
        $ciphertext = openssl_encrypt(
            $plaintext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            '',
            self::TAG_LENGTH
        );

        if ($ciphertext === false) {
            throw new \RuntimeException('Encryption failed');
        }

        // Package: IV + Tag + Ciphertext (all binary)
        $package = $iv . $tag . $ciphertext;

        // Encode for safe storage
        return base64_encode($package);
    }

    /**
     * {@inheritdoc}
     */
    public function decrypt(string $payload): mixed
    {
        // Decode from base64
        $package = base64_decode($payload, true);

        if ($package === false || strlen($package) < (self::IV_LENGTH + self::TAG_LENGTH)) {
            throw new \RuntimeException('Invalid encrypted payload');
        }

        // Unpack: IV + Tag + Ciphertext
        $iv = substr($package, 0, self::IV_LENGTH);
        $tag = substr($package, self::IV_LENGTH, self::TAG_LENGTH);
        $ciphertext = substr($package, self::IV_LENGTH + self::TAG_LENGTH);

        // Decrypt with authentication tag verification
        $plaintext = openssl_decrypt(
            $ciphertext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag
        );

        if ($plaintext === false) {
            // Tampering detected or invalid key
            throw new \RuntimeException('Decryption failed - possible tampering detected');
        }

        return unserialize($plaintext);
    }
}

=== Security/CsrfToken.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * CsrfToken - CSRF Token Management
 *
 * OWASP ASVS 4.2.2 Compliant
 * 
 * Session-bound CSRF token generation and verification.
 * 
 * Features:
 * - Cryptographically secure tokens
 * - Session-bound (invalidated on logout)
 * - Constant-time comparison
 * - Automatic rotation
 * 
 * @package Avax\HTTP\Session\Security
 */
final class CsrfToken
{
    private const TOKEN_KEY = '_csrf_token';
    private const TOKEN_LENGTH = 32;  // 256 bits

    /**
     * CsrfToken Constructor.
     *
     * @param Store $store Session storage.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Generate a new CSRF token.
     *
     * Stores token in session for verification.
     *
     * @return string Hex-encoded token.
     */
    public function generate(): string
    {
        $token = bin2hex(random_bytes(self::TOKEN_LENGTH));
        $this->store->put(self::TOKEN_KEY, $token);
        return $token;
    }

    /**
     * Verify CSRF token.
     *
     * Uses constant-time comparison to prevent timing attacks.
     *
     * @param string $providedToken Token to verify.
     *
     * @return bool True if valid.
     */
    public function verify(string $providedToken): bool
    {
        $storedToken = $this->store->get(self::TOKEN_KEY);

        if ($storedToken === null) {
            return false;
        }

        return hash_equals($storedToken, $providedToken);
    }

    /**
     * Verify token or throw exception.
     *
     * @param string $providedToken Token to verify.
     *
     * @return void
     * 
     * @throws \RuntimeException If token invalid.
     */
    public function verifyOrFail(string $providedToken): void
    {
        if (!$this->verify($providedToken)) {
            throw new \RuntimeException('CSRF token mismatch - possible CSRF attack');
        }
    }

    /**
     * Get current token (generate if missing).
     *
     * @return string Current token.
     */
    public function getToken(): string
    {
        $token = $this->store->get(self::TOKEN_KEY);

        if ($token === null) {
            return $this->generate();
        }

        return $token;
    }

    /**
     * Rotate CSRF token.
     *
     * Generates new token, invalidating the old one.
     *
     * @return string New token.
     */
    public function rotate(): string
    {
        return $this->generate();
    }

    /**
     * Clear CSRF token.
     *
     * Call on logout to invalidate token.
     *
     * @return void
     */
    public function clear(): void
    {
        $this->store->delete(self::TOKEN_KEY);
    }
}

=== Security/EncrypterFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Security\Crypto\OpenSSLEncrypter;

/**
 * EncrypterFactory - Encrypter with Key Management
 *
 * OWASP ASVS 3.1.3 Compliant
 * 
 * Integrates KeyManager with encryption operations.
 * Supports key rotation by attempting decryption with all known keys.
 * 
 * @package Avax\HTTP\Session\Security
 */
final class EncrypterFactory
{
    private KeyManager $keyManager;

    /**
     * EncrypterFactory Constructor.
     *
     * @param KeyManager|null $keyManager Key manager (optional, creates default).
     */
    public function __construct(?KeyManager $keyManager = null)
    {
        $this->keyManager = $keyManager ?? new KeyManager();
    }

    /**
     * Create encrypter with active key.
     *
     * @return Encrypter Encrypter instance.
     */
    public function create(): Encrypter
    {
        $activeKey = $this->keyManager->getActiveKey();
        return new OpenSSLEncrypter($activeKey);
    }

    /**
     * Encrypt with active key.
     *
     * @param mixed $value Value to encrypt.
     *
     * @return string Encrypted payload.
     */
    public function encrypt(mixed $value): string
    {
        return $this->create()->encrypt($value);
    }

    /**
     * Decrypt with key rotation support.
     *
     * Attempts decryption with all known keys (active + rotated).
     * Enables seamless key rotation.
     *
     * @param string $payload Encrypted payload.
     *
     * @return mixed Decrypted value.
     * 
     * @throws \RuntimeException If decryption fails with all keys.
     */
    public function decrypt(string $payload): mixed
    {
        $allKeys = $this->keyManager->getAllKeys();

        foreach ($allKeys as $key) {
            try {
                $encrypter = new OpenSSLEncrypter($key);
                return $encrypter->decrypt($payload);
            } catch (\Exception $e) {
                // Try next key
                continue;
            }
        }

        // All keys failed
        throw new \RuntimeException(
            'Decryption failed with all known keys - possible tampering or key mismatch'
        );
    }
}

=== Security/KeyManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

/**
 * KeyManager - Encryption Key Management
 *
 * OWASP ASVS 3.1.1 & 3.1.2 Compliant
 * 
 * Manages encryption keys with rotation support.
 * Allows seamless key rotation without invalidating existing sessions.
 * 
 * Keys are loaded from environment variables for security.
 * 
 * Environment Variables:
 * - SESSION_KEY_ACTIVE: Current encryption key (32 bytes hex)
 * - SESSION_KEY_ROTATED: Comma-separated previous keys (optional)
 * 
 * @package Avax\HTTP\Session\Security
 */
final class KeyManager
{
    /**
     * Get the active encryption key.
     *
     * @return string Active key (32 bytes).
     * 
     * @throws \RuntimeException If key not configured.
     */
    public function getActiveKey(): string
    {
        $key = getenv('SESSION_KEY_ACTIVE');

        if ($key === false || $key === '') {
            throw new \RuntimeException(
                'SESSION_KEY_ACTIVE environment variable not set'
            );
        }

        // Convert from hex to binary
        $binaryKey = hex2bin($key);

        if ($binaryKey === false || strlen($binaryKey) !== 32) {
            throw new \RuntimeException(
                'SESSION_KEY_ACTIVE must be 64 hex characters (32 bytes)'
            );
        }

        return $binaryKey;
    }

    /**
     * Get previously rotated keys.
     *
     * Used to decrypt sessions encrypted with old keys.
     *
     * @return array<string> Array of previous keys (32 bytes each).
     */
    public function getPreviousKeys(): array
    {
        $keysString = getenv('SESSION_KEY_ROTATED');

        if ($keysString === false || $keysString === '') {
            return [];
        }

        $hexKeys = explode(',', $keysString);
        $binaryKeys = [];

        foreach ($hexKeys as $hexKey) {
            $hexKey = trim($hexKey);
            $binaryKey = hex2bin($hexKey);

            if ($binaryKey !== false && strlen($binaryKey) === 32) {
                $binaryKeys[] = $binaryKey;
            }
        }

        return $binaryKeys;
    }

    /**
     * Get all keys (active + rotated).
     *
     * Useful for decryption attempts with multiple keys.
     *
     * @return array<string> All available keys.
     */
    public function getAllKeys(): array
    {
        return array_merge(
            [$this->getActiveKey()],
            $this->getPreviousKeys()
        );
    }

    /**
     * Generate a new random key.
     *
     * Helper method for key generation (use offline).
     *
     * @return string Hex-encoded 32-byte key.
     */
    public static function generateKey(): string
    {
        return bin2hex(random_bytes(32));
    }
}

=== Security/NativeServerContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Security\ServerContext;

/**
 * NativeServerContext - PHP Native Server Context
 *
 * Default implementation using PHP's $_SERVER superglobal.
 * 
 * @package Avax\HTTP\Session\Security
 */
final class NativeServerContext implements ServerContext
{
    /**
     * {@inheritdoc}
     */
    public function getUserAgent(): string
    {
        return $_SERVER['HTTP_USER_AGENT'] ?? '';
    }

    /**
     * {@inheritdoc}
     */
    public function isSecure(): bool
    {
        return isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';
    }

    /**
     * {@inheritdoc}
     */
    public function getClientIp(): string
    {
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }
}

=== Security/Policies/CompositePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * CompositePolicy - Composite Policy Pattern
 *
 * Combines multiple policies into a single policy.
 * Enables grouping and reusable policy sets.
 *
 * Execution Modes:
 * - ALL: All policies must pass (default, AND logic)
 * - ANY: At least one policy must pass (OR logic)
 * - NONE: All policies must fail (inverse logic)
 *
 * @example
 *   $composite = new CompositePolicy([
 *       new MaxIdlePolicy(900),
 *       new SecureOnlyPolicy(),
 *       new SessionIpPolicy()
 *   ]);
 *
 * @example With ANY mode
 *   $composite = CompositePolicy::any([
 *       new AdminRolePolicy(),
 *       new SuperuserPolicy()
 *   ]);
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class CompositePolicy implements PolicyInterface
{
    public const MODE_ALL = 'all';
    public const MODE_ANY = 'any';
    public const MODE_NONE = 'none';

    /**
     * @var array<PolicyInterface> Child policies
     */
    private array $policies = [];

    /**
     * CompositePolicy Constructor.
     *
     * @param array<PolicyInterface> $policies    Child policies.
     * @param string                 $mode        Execution mode (all|any|none).
     * @param string                 $name        Policy name.
     */
    public function __construct(
        array $policies = [],
        private string $mode = self::MODE_ALL,
        private string $name = 'composite'
    ) {
        foreach ($policies as $policy) {
            $this->add($policy);
        }
    }

    /**
     * Create composite with ALL mode (AND logic).
     *
     * All policies must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function all(array $policies, string $name = 'composite_all'): self
    {
        return new self($policies, self::MODE_ALL, $name);
    }

    /**
     * Create composite with ANY mode (OR logic).
     *
     * At least one policy must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function any(array $policies, string $name = 'composite_any'): self
    {
        return new self($policies, self::MODE_ANY, $name);
    }

    /**
     * Create composite with NONE mode (inverse logic).
     *
     * All policies must fail.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function none(array $policies, string $name = 'composite_none'): self
    {
        return new self($policies, self::MODE_NONE, $name);
    }

    /**
     * Add a child policy.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy): self
    {
        $this->policies[] = $policy;
        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data): void
    {
        if (empty($this->policies)) {
            return; // No policies to enforce
        }

        match ($this->mode) {
            self::MODE_ALL => $this->enforceAll($data),
            self::MODE_ANY => $this->enforceAny($data),
            self::MODE_NONE => $this->enforceNone($data),
            default => throw new \InvalidArgumentException("Invalid mode: {$this->mode}")
        };
    }

    /**
     * Enforce ALL policies (AND logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy fails.
     */
    private function enforceAll(array $data): void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
            } catch (\Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        if (!empty($failures)) {
            throw new \RuntimeException(
                sprintf(
                    'Composite policy "%s" failed (ALL mode): %s',
                    $this->name,
                    implode('; ', $failures)
                )
            );
        }
    }

    /**
     * Enforce ANY policy (OR logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If all policies fail.
     */
    private function enforceAny(array $data): void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
                return; // At least one passed, success!
            } catch (\Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        // All policies failed
        throw new \RuntimeException(
            sprintf(
                'Composite policy "%s" failed (ANY mode): All child policies failed: %s',
                $this->name,
                implode('; ', $failures)
            )
        );
    }

    /**
     * Enforce NONE policy (inverse logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy passes.
     */
    private function enforceNone(array $data): void
    {
        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);

                // Policy passed, but we wanted it to fail
                throw new \RuntimeException(
                    sprintf(
                        'Composite policy "%s" failed (NONE mode): Policy "%s" should have failed but passed',
                        $this->name,
                        $policy->getName()
                    )
                );
            } catch (\Exception $e) {
                // Policy failed, which is what we wanted (continue)
                continue;
            }
        }

        // All policies failed, which is what we wanted (success)
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * Get child policies.
     *
     * @return array<PolicyInterface> Child policies.
     */
    public function getPolicies(): array
    {
        return $this->policies;
    }

    /**
     * Get execution mode.
     *
     * @return string Mode (all|any|none).
     */
    public function getMode(): string
    {
        return $this->mode;
    }

    /**
     * Check if composite is empty.
     *
     * @return bool True if no child policies.
     */
    public function isEmpty(): bool
    {
        return empty($this->policies);
    }

    /**
     * Get number of child policies.
     *
     * @return int Count.
     */
    public function count(): int
    {
        return count($this->policies);
    }
}

=== Security/Policies/CrossAgentPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use Avax\HTTP\Session\Contracts\Security\ServerContext;
use Avax\HTTP\Session\Security\NativeServerContext;
use Avax\HTTP\Session\Exceptions\PolicyViolationException;

/**
 * CrossAgentPolicy - User Agent Consistency Policy
 *
 * Detects session hijacking by comparing User-Agent strings.
 * If User-Agent changes during session lifetime, policy is violated.
 * 
 * Uses ServerContext for testability.
 * 
 * @package Avax\HTTP\Session\Security\Policies
 */
final class CrossAgentPolicy implements PolicyInterface
{
    /**
     * CrossAgentPolicy Constructor.
     *
     * @param ServerContext|null $serverContext Server context (default: native).
     */
    public function __construct(
        private ?ServerContext $serverContext = null
    ) {
        $this->serverContext ??= new NativeServerContext();
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data): void
    {
        $storedAgent = $data['_user_agent'] ?? null;
        $currentAgent = $this->serverContext->getUserAgent();

        // First time - store current agent
        if ($storedAgent === null) {
            return;
        }

        // Agent mismatch - possible hijacking
        if ($storedAgent !== $currentAgent) {
            throw PolicyViolationException::forPolicy(
                'cross_agent',
                'User Agent mismatch detected - possible session hijacking'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'cross_agent';
    }
}

=== Security/Policies/MaxIdlePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * MaxIdlePolicy - Session Idle Timeout Policy
 *
 * Enforces maximum idle time for sessions. If session is inactive
 * longer than the configured period, policy violation is triggered.
 * 
 * @package Avax\HTTP\Session\Policies
 */
final class MaxIdlePolicy implements PolicyInterface
{
    /**
     * MaxIdlePolicy Constructor.
     *
     * @param int $maxIdleSeconds Maximum idle time in seconds (default: 30 minutes).
     */
    public function __construct(
        private int $maxIdleSeconds = 1800
    ) {}

    /**
     * Enforce max idle policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session is idle too long.
     */
    public function enforce(array $data): void
    {
        $lastActivity = $data['_last_activity'] ?? null;

        if ($lastActivity === null) {
            return;
        }

        $idleTime = time() - $lastActivity;

        if ($idleTime > $this->maxIdleSeconds) {
            throw new \RuntimeException(
                sprintf(
                    'Session expired due to inactivity. Idle for %d seconds (max: %d).',
                    $idleTime,
                    $this->maxIdleSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName(): string
    {
        return 'max_idle';
    }
}

=== Security/Policies/MaxLifetimePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * MaxLifetimePolicy - Session Maximum Lifetime Policy
 *
 * Enforces absolute maximum lifetime for sessions regardless of activity.
 * Once session reaches max lifetime, it must be terminated.
 * 
 * @package Avax\HTTP\Session\Policies
 */
final class MaxLifetimePolicy implements PolicyInterface
{
    /**
     * MaxLifetimePolicy Constructor.
     *
     * @param int $maxLifetimeSeconds Maximum session lifetime in seconds (default: 1 hour).
     */
    public function __construct(
        private int $maxLifetimeSeconds = 3600
    ) {}

    /**
     * Enforce max lifetime policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session exceeded max lifetime.
     */
    public function enforce(array $data): void
    {
        $createdAt = $data['_created_at'] ?? null;

        if ($createdAt === null) {
            return;
        }

        $lifetime = time() - $createdAt;

        if ($lifetime > $this->maxLifetimeSeconds) {
            throw new \RuntimeException(
                sprintf(
                    'Session expired (max lifetime). Active for %d seconds (max: %d).',
                    $lifetime,
                    $this->maxLifetimeSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName(): string
    {
        return 'max_lifetime';
    }
}

=== Security/Policies/PolicyGroupBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * PolicyGroupBuilder - Fluent Builder for Policy Groups
 *
 * Provides Spring Security-style fluent API for building policy groups.
 * Makes complex policy configurations readable and maintainable.
 *
 * @example Basic usage
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->add(new MaxIdlePolicy(900))
 *           ->add(new SecureOnlyPolicy())
 *       ->build();
 *
 * @example Complex groups
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->maxIdle(900)
 *           ->secureOnly()
 *           ->requireAny()
 *               ->ipBinding()
 *               ->userAgentBinding()
 *           ->endGroup()
 *       ->build();
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class PolicyGroupBuilder
{
    /**
     * @var CompositePolicy|null Root composite policy
     */
    private ?CompositePolicy $root = null;

    /**
     * @var CompositePolicy|null Current working composite
     */
    private ?CompositePolicy $current = null;

    /**
     * @var array<CompositePolicy> Stack for nested groups
     */
    private array $stack = [];

    /**
     * PolicyGroupBuilder Constructor.
     */
    private function __construct()
    {
        // Use create() factory instead
    }

    /**
     * Create a new builder instance.
     *
     * @return self
     */
    public static function create(): self
    {
        return new self();
    }

    /**
     * Start a "require all" group (AND logic).
     *
     * All policies in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAll(string $name = 'require_all'): self
    {
        return $this->startGroup(CompositePolicy::MODE_ALL, $name);
    }

    /**
     * Start a "require any" group (OR logic).
     *
     * At least one policy in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAny(string $name = 'require_any'): self
    {
        return $this->startGroup(CompositePolicy::MODE_ANY, $name);
    }

    /**
     * Start a "require none" group (inverse logic).
     *
     * All policies in this group must fail.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireNone(string $name = 'require_none'): self
    {
        return $this->startGroup(CompositePolicy::MODE_NONE, $name);
    }

    /**
     * Add a custom policy to current group.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy): self
    {
        if ($this->current === null) {
            throw new \RuntimeException('No active group. Call requireAll(), requireAny(), or requireNone() first.');
        }

        $this->current->add($policy);
        return $this;
    }

    /**
     * Add MaxIdlePolicy to current group.
     *
     * @param int $seconds Maximum idle time in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxIdle(int $seconds): self
    {
        return $this->add(new MaxIdlePolicy($seconds));
    }

    /**
     * Add MaxLifetimePolicy to current group.
     *
     * @param int $seconds Maximum lifetime in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxLifetime(int $seconds): self
    {
        return $this->add(new MaxLifetimePolicy($seconds));
    }

    /**
     * Add SecureOnlyPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function secureOnly(): self
    {
        return $this->add(new SecureOnlyPolicy());
    }

    /**
     * Add SessionIpPolicy to current group.
     *
     * @param bool $strict Strict mode (default: true).
     *
     * @return self Fluent interface.
     */
    public function ipBinding(bool $strict = true): self
    {
        return $this->add(new SessionIpPolicy($strict));
    }

    /**
     * Add CrossAgentPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function userAgentBinding(): self
    {
        return $this->add(new CrossAgentPolicy());
    }

    /**
     * End current group and return to parent.
     *
     * @return self Fluent interface.
     */
    public function endGroup(): self
    {
        if (empty($this->stack)) {
            throw new \RuntimeException('No group to end. Already at root level.');
        }

        $this->current = array_pop($this->stack);
        return $this;
    }

    /**
     * Build the final policy structure.
     *
     * @return PolicyInterface|CompositePolicy Built policy.
     */
    public function build(): PolicyInterface|CompositePolicy
    {
        if ($this->root === null) {
            throw new \RuntimeException('No policies configured. Use requireAll(), requireAny(), or requireNone() to start.');
        }

        // If only one policy in root, return it directly
        if ($this->root->count() === 1) {
            return $this->root->getPolicies()[0];
        }

        return $this->root;
    }

    /**
     * Build and return as array of policies.
     *
     * Useful for bulk registration with PolicyEnforcer.
     *
     * @return array<PolicyInterface> Policies.
     */
    public function buildAsArray(): array
    {
        $policy = $this->build();

        if ($policy instanceof CompositePolicy) {
            return [$policy];
        }

        return [$policy];
    }

    /**
     * Start a new group.
     *
     * @param string $mode Group mode (all|any|none).
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    private function startGroup(string $mode, string $name): self
    {
        $composite = new CompositePolicy([], $mode, $name);

        if ($this->root === null) {
            // First group becomes root
            $this->root = $composite;
            $this->current = $composite;
        } else {
            // Nested group
            if ($this->current === null) {
                throw new \RuntimeException('Current group is null. This should not happen.');
            }

            // Add nested group to current
            $this->current->add($composite);

            // Push current to stack
            $this->stack[] = $this->current;

            // Make nested group current
            $this->current = $composite;
        }

        return $this;
    }

    /**
     * Create a security hardened preset.
     *
     * Includes:
     * - MaxIdle: 15 minutes
     * - MaxLifetime: 8 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Strict
     * - User Agent Binding
     *
     * @return PolicyInterface Built policy.
     */
    public static function securityHardened(): PolicyInterface
    {
        return self::create()
            ->requireAll('security_hardened')
                ->maxIdle(900)              // 15 minutes
                ->maxLifetime(28800)        // 8 hours
                ->secureOnly()
                ->ipBinding(strict: true)
                ->userAgentBinding()
            ->build();
    }

    /**
     * Create a balanced security preset.
     *
     * Includes:
     * - MaxIdle: 30 minutes
     * - MaxLifetime: 24 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Relaxed
     *
     * @return PolicyInterface Built policy.
     */
    public static function balanced(): PolicyInterface
    {
        return self::create()
            ->requireAll('balanced')
                ->maxIdle(1800)             // 30 minutes
                ->maxLifetime(86400)        // 24 hours
                ->secureOnly()
                ->ipBinding(strict: false)
            ->build();
    }

    /**
     * Create a development-friendly preset.
     *
     * Includes:
     * - MaxIdle: 2 hours
     * - MaxLifetime: 7 days
     *
     * @return PolicyInterface Built policy.
     */
    public static function development(): PolicyInterface
    {
        return self::create()
            ->requireAll('development')
                ->maxIdle(7200)             // 2 hours
                ->maxLifetime(604800)       // 7 days
            ->build();
    }
}

=== Security/Policies/PolicyInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * PolicyInterface - Session Security Policy Contract
 *
 * Defines the contract for session security policies.
 * Policies are enforced before each session operation.
 * 
 * @package Avax\HTTP\Session\Policies
 */
interface PolicyInterface
{
    /**
     * Enforce the policy rules.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If policy is violated.
     */
    public function enforce(array $data): void;

    /**
     * Get the policy name.
     *
     * @return string The policy identifier.
     */
    public function getName(): string;
}

=== Security/Policies/SecureOnlyPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * SecureOnlyPolicy - HTTPS-Only Session Policy
 *
 * Enforces that session operations only occur over HTTPS.
 * Prevents session hijacking over insecure connections.
 * 
 * @package Avax\HTTP\Session\Policies
 */
final class SecureOnlyPolicy implements PolicyInterface
{
    /**
     * Enforce HTTPS-only policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If connection is not HTTPS.
     */
    public function enforce(array $data): void
    {
        $isSecure = !empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';

        if (!$isSecure) {
            throw new \RuntimeException(
                'Session access requires HTTPS connection for security.'
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName(): string
    {
        return 'secure_only';
    }
}

=== Security/Policies/SessionIpPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use Avax\HTTP\Session\Exceptions\PolicyViolationException;

/**
 * SessionIpPolicy - IP Address Binding Policy
 *
 * OWASP ASVS 3.4.1 Compliant
 * 
 * Binds sessions to client IP address to detect session hijacking.
 * Supports both strict mode (exact match) and relaxed mode (subnet match).
 * 
 * Security Trade-offs:
 * - Strict: More secure, but breaks with mobile networks (IP changes)
 * - Relaxed: Less secure, but handles legitimate IP changes
 * 
 * @package Avax\HTTP\Session\Security\Policies
 */
final class SessionIpPolicy implements PolicyInterface
{
    /**
     * SessionIpPolicy Constructor.
     *
     * @param bool $strictMode If true, require exact IP match. If false, allow /24 subnet.
     */
    public function __construct(
        private bool $strictMode = false
    ) {}

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data): void
    {
        $storedIp = $data['_client_ip'] ?? null;
        $currentIp = $_SERVER['REMOTE_ADDR'] ?? '';

        // First time - no stored IP yet
        if ($storedIp === null) {
            return;
        }

        if ($this->strictMode) {
            // Strict: Exact match required
            if ($storedIp !== $currentIp) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_strict',
                    'IP address mismatch (strict) - possible session hijacking'
                );
            }
        } else {
            // Relaxed: Same /24 subnet
            if (!$this->isSameSubnet($storedIp, $currentIp)) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_relaxed',
                    'IP subnet mismatch - possible session hijacking'
                );
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return $this->strictMode ? 'ip_binding_strict' : 'ip_binding_relaxed';
    }

    /**
     * Check if two IPs are in the same /24 subnet.
     *
     * @param string $ip1 First IP.
     * @param string $ip2 Second IP.
     *
     * @return bool True if same subnet.
     */
    private function isSameSubnet(string $ip1, string $ip2): bool
    {
        $parts1 = explode('.', $ip1);
        $parts2 = explode('.', $ip2);

        // Compare first 3 octets (class C subnet)
        return $parts1[0] === $parts2[0]
            && $parts1[1] === $parts2[1]
            && $parts1[2] === $parts2[2];
    }
}

=== Security/PolicyEnforcer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Security\Policies\PolicyInterface;

/**
 * PolicyEnforcer - Policy Enforcement Service
 *
 * Centralized service for enforcing session security policies.
 * Reduces SessionProvider complexity.
 * 
 * @package Avax\HTTP\Session\Security
 */
final class PolicyEnforcer
{
    /**
     * @var array<PolicyInterface> Registered policies
     */
    private array $policies = [];

    /**
     * @var ?\Avax\HTTP\Session\Features\Audit Audit logger
     */
    private $audit = null;

    /**
     * PolicyEnforcer Constructor.
     *
     * @param \Avax\HTTP\Session\Features\Audit|null $audit Optional audit logger.
     */
    public function __construct($audit = null)
    {
        $this->audit = $audit;
    }

    /**
     * Register a policy.
     *
     * @param PolicyInterface $policy The policy.
     *
     * @return void
     */
    public function register(PolicyInterface $policy): void
    {
        $this->policies[] = $policy;
    }

    /**
     * Register multiple policies at once.
     *
     * @param array<PolicyInterface> $policies Policies to register.
     *
     * @return void
     */
    public function registerMany(array $policies): void
    {
        foreach ($policies as $policy) {
            $this->register($policy);
        }
    }

    /**
     * Enforce all registered policies.
     *
     * OWASP ASVS 3.4.2 - Security event audit logging
     *
     * @param array<string, mixed> $data Session data for policy checks.
     *
     * @return void
     * @throws \RuntimeException If any policy is violated.
     */
    public function enforce(array $data): void
    {
        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
            } catch (\Exception $e) {
                // AUDIT: Log security violation
                if ($this->audit !== null) {
                    $this->audit->record('policy_violation', [
                        'policy' => $policy->getName(),
                        'reason' => $e->getMessage()
                    ]);
                }

                // Re-throw exception
                throw $e;
            }
        }
    }

    /**
     * Get all registered policies.
     *
     * @return array<PolicyInterface> Policies.
     */
    public function getPolicies(): array
    {
        return $this->policies;
    }
}

=== Security/SessionIdValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

/**
 * SessionIdValidator - Session ID Entropy Validation
 *
 * OWASP ASVS 3.2.2 Compliant
 * 
 * Validates session ID quality to ensure cryptographic strength.
 * 
 * Requirements:
 * - Minimum 128 bits entropy (32 hex chars)
 * - Cryptographically secure randomness
 * - No pattern repetition
 * 
 * @package Avax\HTTP\Session\Security
 */
final class SessionIdValidator
{
    private const MIN_LENGTH = 32;  // 128 bits in hex

    /**
     * Validate session ID entropy.
     *
     * @param string $sessionId Session ID to validate.
     *
     * @return bool True if valid.
     * 
     * @throws \RuntimeException If session ID quality insufficient.
     */
    public static function validate(string $sessionId): bool
    {
        // Check minimum length (128 bits)
        if (strlen($sessionId) < self::MIN_LENGTH) {
            throw new \RuntimeException(
                sprintf(
                    'Session ID entropy too low: %d chars (minimum %d)',
                    strlen($sessionId),
                    self::MIN_LENGTH
                )
            );
        }

        // Check for pattern repetition (basic randomness test)
        if (preg_match('/^(.)\1+$/', $sessionId)) {
            throw new \RuntimeException('Session ID lacks randomness - repetitive pattern detected');
        }

        // Check for sequential patterns
        if (preg_match('/01234|12345|23456|abcde|bcdef/', $sessionId)) {
            throw new \RuntimeException('Session ID lacks randomness - sequential pattern detected');
        }

        return true;
    }

    /**
     * Validate current session ID.
     *
     * @return bool True if current session ID is valid.
     */
    public static function validateCurrent(): bool
    {
        $sessionId = session_id();

        if (empty($sessionId)) {
            throw new \RuntimeException('No active session to validate');
        }

        return self::validate($sessionId);
    }
}

=== Security/SessionNonce.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * SessionNonce - Replay Attack Prevention
 *
 * OWASP ASVS 3.3.4 Compliant
 * 
 * Generates and validates single-use tokens (nonces) to prevent
 * replay attacks on critical state-changing operations.
 * 
 * Nonces are cryptographically secure random values.
 * 
 * @package Avax\HTTP\Session\Security
 */
final class SessionNonce
{
    private const NONCE_KEY = '_nonce';
    private const NONCE_LENGTH = 16; // 128 bits

    /**
     * SessionNonce Constructor.
     *
     * @param Store $store Session storage.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Generate a new nonce.
     *
     * Stores it in session for later verification.
     *
     * @return string Hex-encoded nonce.
     */
    public function generate(): string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $this->store->put(self::NONCE_KEY, $nonce);
        return $nonce;
    }

    /**
     * Verify and consume a nonce.
     *
     * Nonce is deleted after verification (single-use).
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return bool True if nonce is valid.
     */
    public function verify(string $providedNonce): bool
    {
        $storedNonce = $this->store->get(self::NONCE_KEY);

        if ($storedNonce === null) {
            return false; // No nonce stored
        }

        // Consume nonce (delete it)
        $this->store->delete(self::NONCE_KEY);

        // Constant-time comparison
        return hash_equals($storedNonce, $providedNonce);
    }

    /**
     * Verify nonce or throw exception.
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return void
     * 
     * @throws \RuntimeException If nonce invalid.
     */
    public function verifyOrFail(string $providedNonce): void
    {
        if (!$this->verify($providedNonce)) {
            throw new \RuntimeException(
                'Invalid or missing nonce - potential replay attack detected'
            );
        }
    }

    /**
     * Check if a nonce exists in session.
     *
     * @return bool True if nonce present.
     */
    public function exists(): bool
    {
        return $this->store->has(self::NONCE_KEY);
    }

    // ========================================
    // PER-REQUEST NONCE (REPLAY ATTACK PREVENTION)
    // ========================================

    /**
     * Generate a per-request nonce.
     *
     * Used for critical operations that should only execute once.
     * Each request gets a unique nonce that expires after use.
     *
     * @param string $action Action identifier (e.g., 'delete_account', 'transfer_funds').
     *
     * @return string Hex-encoded nonce.
     */
    public function generateForRequest(string $action): string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $key = self::NONCE_KEY . ".{$action}";

        $this->store->put($key, [
            'nonce' => $nonce,
            'created_at' => time(),
            'action' => $action,
        ]);

        return $nonce;
    }

    /**
     * Verify and consume a per-request nonce.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds (default: 300 = 5 minutes).
     *
     * @return bool True if valid.
     */
    public function verifyForRequest(string $action, string $providedNonce, int $maxAge = 300): bool
    {
        $key = self::NONCE_KEY . ".{$action}";
        $stored = $this->store->get($key);

        if ($stored === null) {
            return false; // No nonce for this action
        }

        // Check expiration
        if (time() - $stored['created_at'] > $maxAge) {
            $this->store->delete($key);
            return false; // Expired
        }

        // Consume nonce (delete it)
        $this->store->delete($key);

        // Constant-time comparison
        return hash_equals($stored['nonce'], $providedNonce);
    }

    /**
     * Verify per-request nonce or throw exception.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid or expired.
     */
    public function verifyForRequestOrFail(string $action, string $providedNonce, int $maxAge = 300): void
    {
        if (!$this->verifyForRequest($action, $providedNonce, $maxAge)) {
            throw new \RuntimeException(
                "Invalid or expired nonce for action '{$action}' - potential replay attack detected"
            );
        }
    }

    /**
     * Clear all per-request nonces.
     *
     * @return void
     */
    public function clearAllRequests(): void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::NONCE_KEY . '.')) {
                $this->store->delete($key);
            }
        }
    }

    /**
     * Get all active per-request nonces.
     *
     * Useful for debugging.
     *
     * @return array<string, array> Action => nonce data.
     */
    public function getActiveRequests(): array
    {
        $all = $this->store->all();
        $nonces = [];

        foreach ($all as $key => $value) {
            if (str_starts_with($key, self::NONCE_KEY . '.') && is_array($value)) {
                $action = substr($key, strlen(self::NONCE_KEY) + 1);
                $nonces[$action] = $value;
            }
        }

        return $nonces;
    }
}

=== Security/SessionRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * SessionRegistry - Multi-Device Session Control
 *
 * OWASP ASVS 3.3.8 Compliant
 * 
 * Tracks and manages concurrent sessions per user.
 * Prevents session sharing and enables single-device enforcement.
 * 
 * Features:
 * - Track multiple sessions per user
 * - Terminate other sessions on new login
 * - Concurrent session limit enforcement
 * - Session metadata tracking (IP, user agent, timestamp)
 * 
 * @package Avax\HTTP\Session\Security
 */
final class SessionRegistry
{
    private const REGISTRY_PREFIX = '_registry_';

    /**
     * SessionRegistry Constructor.
     *
     * @param Store $store Session storage backend.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Register a new session for a user.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID.
     * @param array  $metadata  Optional metadata (IP, user agent, etc).
     *
     * @return void
     */
    public function register(string $userId, string $sessionId, array $metadata = []): void
    {
        $key = self::REGISTRY_PREFIX . $userId;
        $sessions = $this->store->get($key, []);

        $sessions[$sessionId] = array_merge($metadata, [
            'created_at' => time(),
            'last_activity' => time(),
        ]);

        $this->store->put($key, $sessions);
    }

    /**
     * Get all active sessions for a user.
     *
     * @param string $userId User identifier.
     *
     * @return array<string, array> Session ID => metadata.
     */
    public function getActiveSessions(string $userId): array
    {
        $key = self::REGISTRY_PREFIX . $userId;
        return $this->store->get($key, []);
    }

    /**
     * Terminate all other sessions except current.
     *
     * Useful for "single device" enforcement.
     *
     * @param string $userId          User identifier.
     * @param string $exceptSessionId Current session to preserve.
     *
     * @return int Number of terminated sessions.
     */
    public function terminateOtherSessions(string $userId, string $exceptSessionId): int
    {
        $sessions = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $metadata) {
            if ($sessionId !== $exceptSessionId) {
                // In real implementation, you'd call session_destroy() for each ID
                unset($sessions[$sessionId]);
                $terminated++;
            }
        }

        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->put($key, $sessions);

        return $terminated;
    }

    /**
     * Terminate a specific session.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID to terminate.
     *
     * @return bool True if session was found and terminated.
     */
    public function terminateSession(string $userId, string $sessionId): bool
    {
        $sessions = $this->getActiveSessions($userId);

        if (!isset($sessions[$sessionId])) {
            return false;
        }

        unset($sessions[$sessionId]);

        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->put($key, $sessions);

        return true;
    }

    /**
     * Update last activity timestamp for a session.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID.
     *
     * @return void
     */
    public function updateActivity(string $userId, string $sessionId): void
    {
        $sessions = $this->getActiveSessions($userId);

        if (isset($sessions[$sessionId])) {
            $sessions[$sessionId]['last_activity'] = time();

            $key = self::REGISTRY_PREFIX . $userId;
            $this->store->put($key, $sessions);
        }
    }

    /**
     * Check if user has exceeded concurrent session limit.
     *
     * @param string $userId User identifier.
     * @param int    $limit  Maximum allowed concurrent sessions.
     *
     * @return bool True if limit exceeded.
     */
    public function hasExceededLimit(string $userId, int $limit): bool
    {
        $sessions = $this->getActiveSessions($userId);
        return count($sessions) >= $limit;
    }

    // ========================================
    // REVOCATION LIST (OWASP ASVS 3.3.8)
    // ========================================

    /**
     * Add a session to revocation list.
     *
     * Revoked sessions cannot be used anymore, even if valid.
     * Useful for:
     * - Forced logout
     * - Security breaches
     * - Password changes
     * - Privilege changes
     *
     * @param string $sessionId Session ID to revoke.
     * @param string $reason    Revocation reason.
     *
     * @return void
     */
    public function revoke(string $sessionId, string $reason = 'manual_revocation'): void
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);

        $revoked[$sessionId] = [
            'revoked_at' => time(),
            'reason' => $reason,
        ];

        $this->store->put($key, $revoked);
    }

    /**
     * Check if a session is revoked.
     *
     * @param string $sessionId Session ID to check.
     *
     * @return bool True if revoked.
     */
    public function isRevoked(string $sessionId): bool
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);

        return isset($revoked[$sessionId]);
    }

    /**
     * Get revocation details for a session.
     *
     * @param string $sessionId Session ID.
     *
     * @return array|null Revocation details or null.
     */
    public function getRevocationDetails(string $sessionId): ?array
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);

        return $revoked[$sessionId] ?? null;
    }

    /**
     * Revoke all sessions for a user.
     *
     * Useful for:
     * - Password changes
     * - Security breaches
     * - Account lockout
     *
     * @param string $userId User identifier.
     * @param string $reason Revocation reason.
     *
     * @return int Number of sessions revoked.
     */
    public function revokeAllForUser(string $userId, string $reason = 'user_revocation'): int
    {
        $sessions = $this->getActiveSessions($userId);
        $count = 0;

        foreach (array_keys($sessions) as $sessionId) {
            $this->revoke($sessionId, $reason);
            $count++;
        }

        // Also clear active sessions
        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->delete($key);

        return $count;
    }

    /**
     * Remove a session from revocation list.
     *
     * Use with caution - only for administrative purposes.
     *
     * @param string $sessionId Session ID to unrevoke.
     *
     * @return bool True if was revoked and now removed.
     */
    public function unrevoke(string $sessionId): bool
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);

        if (!isset($revoked[$sessionId])) {
            return false;
        }

        unset($revoked[$sessionId]);
        $this->store->put($key, $revoked);

        return true;
    }

    /**
     * Clear old revoked sessions.
     *
     * Removes revocations older than specified age.
     *
     * @param int $maxAge Maximum age in seconds (default: 30 days).
     *
     * @return int Number of cleared revocations.
     */
    public function clearOldRevocations(int $maxAge = 2592000): int
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);
        $cleared = 0;

        foreach ($revoked as $sessionId => $data) {
            if (time() - $data['revoked_at'] > $maxAge) {
                unset($revoked[$sessionId]);
                $cleared++;
            }
        }

        $this->store->put($key, $revoked);

        return $cleared;
    }

    /**
     * Get all revoked sessions.
     *
     * @return array<string, array> Session ID => revocation data.
     */
    public function getAllRevoked(): array
    {
        $key = self::REGISTRY_PREFIX . 'revoked';
        return $this->store->get($key, []);
    }

    /**
     * Count total revoked sessions.
     *
     * @return int Count.
     */
    public function countRevoked(): int
    {
        return count($this->getAllRevoked());
    }

    // ========================================
    // DEVICE MANAGEMENT
    // ========================================

    /**
     * Get sessions grouped by device/user agent.
     *
     * @param string $userId User identifier.
     *
     * @return array<string, array> Device fingerprint => sessions.
     */
    public function getSessionsByDevice(string $userId): array
    {
        $sessions = $this->getActiveSessions($userId);
        $byDevice = [];

        foreach ($sessions as $sessionId => $metadata) {
            $fingerprint = $metadata['user_agent'] ?? 'unknown';
            $byDevice[$fingerprint][] = array_merge(['session_id' => $sessionId], $metadata);
        }

        return $byDevice;
    }

    /**
     * Terminate all sessions from a specific device.
     *
     * @param string $userId      User identifier.
     * @param string $userAgent   User agent string to match.
     *
     * @return int Number of terminated sessions.
     */
    public function terminateDevice(string $userId, string $userAgent): int
    {
        $sessions = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $metadata) {
            if (($metadata['user_agent'] ?? '') === $userAgent) {
                $this->terminateSession($userId, $sessionId);
                $terminated++;
            }
        }

        return $terminated;
    }
}

=== Security/SessionSignature.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

/**
 * SessionSignature - HMAC-based Session Integrity
 *
 * OWASP ASVS 3.3.3 Compliant
 * 
 * Provides cryptographic signing and verification of session data
 * to prevent tampering attacks.
 * 
 * Uses SHA-256 HMAC for integrity verification.
 * 
 * @package Avax\HTTP\Session\Security
 */
final class SessionSignature
{
    private const ALGO = 'sha256';

    /**
     * Sign session data with HMAC.
     *
     * @param string $data Session data to sign.
     * @param string $key  Secret signing key.
     *
     * @return string HMAC signature (hex).
     */
    public static function sign(string $data, string $key): string
    {
        return hash_hmac(self::ALGO, $data, $key);
    }

    /**
     * Verify HMAC signature.
     *
     * Uses constant-time comparison to prevent timing attacks.
     *
     * @param string $data      Original data.
     * @param string $signature Signature to verify.
     * @param string $key       Secret signing key.
     *
     * @return bool True if signature valid.
     */
    public static function verify(string $data, string $signature, string $key): bool
    {
        $expectedSignature = self::sign($data, $key);
        return hash_equals($expectedSignature, $signature);
    }
}

=== Storage/AbstractStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * AbstractStore - Base Store Implementation
 *
 * Provides common functionality for all Store implementations.
 * Reduces code duplication across NativeStore, ArrayStore, NullStore.
 *
 * Default Implementations:
 * - has(): Checks if get() returns non-null
 * - pull(): Gets and deletes in one operation
 * - increment()/decrement(): Numeric operations
 * - clear(): Alias for flush()
 *
 * @package Avax\HTTP\Session\Storage
 */
abstract class AbstractStore implements Store
{
    /**
     * {@inheritdoc}
     */
    abstract public function get(string $key, mixed $default = null): mixed;

    /**
     * {@inheritdoc}
     */
    abstract public function put(string $key, mixed $value): void;

    /**
     * {@inheritdoc}
     */
    public function has(string $key): bool
    {
        return $this->get($key) !== null;
    }

    /**
     * {@inheritdoc}
     */
    abstract public function delete(string $key): void;

    /**
     * {@inheritdoc}
     */
    abstract public function all(): array;

    /**
     * {@inheritdoc}
     */
    abstract public function flush(): void;

    /**
     * Get and remove a value in one operation.
     *
     * @param string     $key     The key.
     * @param mixed|null $default Default value.
     *
     * @return mixed The value or default.
     */
    public function pull(string $key, mixed $default = null): mixed
    {
        $value = $this->get($key, $default);

        if ($value !== $default) {
            $this->delete($key);
        }

        return $value;
    }

    /**
     * Increment a numeric value.
     *
     * @param string $key   The key.
     * @param int    $value Amount to increment (default: 1).
     *
     * @return int New value.
     */
    public function increment(string $key, int $value = 1): int
    {
        $current = (int) $this->get($key, 0);
        $new = $current + $value;
        $this->put($key, $new);

        return $new;
    }

    /**
     * Decrement a numeric value.
     *
     * @param string $key   The key.
     * @param int    $value Amount to decrement (default: 1).
     *
     * @return int New value.
     */
    public function decrement(string $key, int $value = 1): int
    {
        return $this->increment($key, -$value);
    }

    /**
     * Check if store is empty.
     *
     * @return bool True if no data stored.
     */
    public function isEmpty(): bool
    {
        return empty($this->all());
    }

    /**
     * Get number of stored items.
     *
     * @return int Item count.
     */
    public function count(): int
    {
        return count($this->all());
    }

    /**
     * Alias for flush().
     *
     * @return void
     */
    public function clear(): void
    {
        $this->flush();
    }

    /**
     * Store multiple key-value pairs.
     *
     * @param array<string, mixed> $values Key-value pairs.
     *
     * @return void
     */
    public function putMany(array $values): void
    {
        foreach ($values as $key => $value) {
            $this->put($key, $value);
        }
    }

    /**
     * Delete multiple keys.
     *
     * @param array<string> $keys Keys to delete.
     *
     * @return void
     */
    public function deleteMany(array $keys): void
    {
        foreach ($keys as $key) {
            $this->delete($key);
        }
    }
}

=== Storage/ArrayStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * ArrayStore - In-Memory Session Storage
 *
 * In-memory storage for testing and development.
 * Data is lost after request ends.
 * 
 * Perfect for:
 * - Unit tests
 * - Development/debugging
 * - Isolated test scenarios
 * 
 * @package Avax\HTTP\Session
 */
final class ArrayStore extends AbstractStore
{
    /**
     * @var array<string, mixed> In-memory storage
     */
    private array $data = [];

    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $this->data[$key] ?? $default;
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value): void
    {
        $this->data[$key] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key): bool
    {
        return isset($this->data[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key): void
    {
        unset($this->data[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function all(): array
    {
        return $this->data;
    }

    /**
     * {@inheritdoc}
     */
    public function flush(): void
    {
        $this->data = [];
    }
}

=== Storage/Key.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

/**
 * Key - Type-Safe Session Key Value Object
 *
 * Prevents key naming conflicts and provides type safety.
 * Enforces naming conventions and namespacing.
 *
 * Features:
 * - Immutable value object
 * - Namespace support (prefix)
 * - Validation (no special characters)
 * - Reserved key detection
 * - String conversion
 * - Equality comparison
 *
 * @example
 *   $key = Key::make('user_id');
 *   $key = Key::make('cart', 'items');  // cart.items
 *   $key = Key::secure('password');     // password_secure
 *
 * @package Avax\HTTP\Session\Storage
 */
final class Key implements \Stringable
{
    /**
     * Reserved key prefixes (internal use only).
     */
    private const RESERVED_PREFIXES = ['_ttl', '_flash', '_csrf', '_nonce', '_snapshot', '_registry'];

    /**
     * Key Constructor.
     *
     * @param string      $name      Key name.
     * @param string|null $namespace Optional namespace (prefix).
     */
    private function __construct(
        private string $name,
        private ?string $namespace = null
    ) {
        $this->validate();
    }

    /**
     * Create a new key.
     *
     * @param string      $name      Key name.
     * @param string|null $namespace Optional namespace.
     *
     * @return self
     */
    public static function make(string $name, ?string $namespace = null): self
    {
        return new self($name, $namespace);
    }

    /**
     * Create a secure key (auto-encrypted).
     *
     * Appends '_secure' suffix for auto-encryption.
     *
     * @param string      $name      Key name.
     * @param string|null $namespace Optional namespace.
     *
     * @return self
     */
    public static function secure(string $name, ?string $namespace = null): self
    {
        if (!str_ends_with($name, '_secure')) {
            $name .= '_secure';
        }

        return new self($name, $namespace);
    }

    /**
     * Create a temporary key (with TTL).
     *
     * @param string      $name      Key name.
     * @param string|null $namespace Optional namespace.
     *
     * @return self
     */
    public static function temporary(string $name, ?string $namespace = null): self
    {
        return new self($name, $namespace);
    }

    /**
     * Create a flash key.
     *
     * @param string $type Flash type (success, error, warning, info).
     *
     * @return self
     */
    public static function flash(string $type): self
    {
        return new self($type, '_flash');
    }

    /**
     * Create a CSRF token key.
     *
     * @return self
     */
    public static function csrf(): self
    {
        return new self('token', '_csrf');
    }

    /**
     * Create a nonce key.
     *
     * @param string|null $action Optional action identifier.
     *
     * @return self
     */
    public static function nonce(?string $action = null): self
    {
        $name = $action ?? 'default';
        return new self($name, '_nonce');
    }

    /**
     * Create a snapshot key.
     *
     * @param string $name Snapshot name.
     *
     * @return self
     */
    public static function snapshot(string $name): self
    {
        return new self($name, '_snapshot');
    }

    /**
     * Create a registry key.
     *
     * @param string $userId User identifier.
     *
     * @return self
     */
    public static function registry(string $userId): self
    {
        return new self($userId, '_registry');
    }

    /**
     * Validate key name.
     *
     * @return void
     *
     * @throws \InvalidArgumentException If key is invalid.
     */
    private function validate(): void
    {
        // Check empty
        if (empty($this->name)) {
            throw new \InvalidArgumentException('Key name cannot be empty');
        }

        // Check length
        if (strlen($this->toString()) > 255) {
            throw new \InvalidArgumentException('Key length cannot exceed 255 characters');
        }

        // Check for null bytes
        if (str_contains($this->name, "\0")) {
            throw new \InvalidArgumentException('Key cannot contain null bytes');
        }

        // Check namespace if provided
        if ($this->namespace !== null && empty($this->namespace)) {
            throw new \InvalidArgumentException('Namespace cannot be empty string');
        }
    }

    /**
     * Check if key is reserved (internal use).
     *
     * @return bool True if reserved.
     */
    public function isReserved(): bool
    {
        if ($this->namespace === null) {
            return false;
        }

        return in_array($this->namespace, self::RESERVED_PREFIXES, true);
    }

    /**
     * Check if key is secure (auto-encrypted).
     *
     * @return bool True if secure.
     */
    public function isSecure(): bool
    {
        return str_ends_with($this->name, '_secure');
    }

    /**
     * Get key name (without namespace).
     *
     * @return string Key name.
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * Get namespace.
     *
     * @return string|null Namespace or null.
     */
    public function getNamespace(): ?string
    {
        return $this->namespace;
    }

    /**
     * Get full key string (with namespace).
     *
     * @return string Full key.
     */
    public function toString(): string
    {
        if ($this->namespace === null) {
            return $this->name;
        }

        return $this->namespace . '.' . $this->name;
    }

    /**
     * Convert to string.
     *
     * @return string Full key.
     */
    public function __toString(): string
    {
        return $this->toString();
    }

    /**
     * Check equality with another key.
     *
     * @param Key $other Other key.
     *
     * @return bool True if equal.
     */
    public function equals(Key $other): bool
    {
        return $this->toString() === $other->toString();
    }

    /**
     * Create a new key with different namespace.
     *
     * @param string $namespace New namespace.
     *
     * @return self New key instance.
     */
    public function withNamespace(string $namespace): self
    {
        return new self($this->name, $namespace);
    }

    /**
     * Create a new key without namespace.
     *
     * @return self New key instance.
     */
    public function withoutNamespace(): self
    {
        return new self($this->name, null);
    }

    /**
     * Create a TTL meta key for this key.
     *
     * @return self TTL meta key.
     */
    public function toTtlKey(): self
    {
        return new self($this->toString(), '_ttl');
    }

    /**
     * Check if this is a TTL meta key.
     *
     * @return bool True if TTL key.
     */
    public function isTtlKey(): bool
    {
        return $this->namespace === '_ttl';
    }

    /**
     * Parse a string into a Key object.
     *
     * @param string $keyString Key string (e.g., "namespace.name").
     *
     * @return self Key instance.
     */
    public static function parse(string $keyString): self
    {
        $parts = explode('.', $keyString, 2);

        if (count($parts) === 1) {
            return new self($parts[0], null);
        }

        return new self($parts[1], $parts[0]);
    }

    /**
     * Create multiple keys from array.
     *
     * @param array<string> $names Key names.
     * @param string|null   $namespace Optional namespace for all keys.
     *
     * @return array<self> Array of Key instances.
     */
    public static function many(array $names, ?string $namespace = null): array
    {
        return array_map(
            fn($name) => new self($name, $namespace),
            $names
        );
    }

    /**
     * Get hash of the key (for use as array key).
     *
     * @return string Hash.
     */
    public function hash(): string
    {
        return md5($this->toString());
    }

    /**
     * Check if key matches a pattern.
     *
     * @param string $pattern Pattern (supports * wildcard).
     *
     * @return bool True if matches.
     */
    public function matches(string $pattern): bool
    {
        $regex = '/^' . str_replace('*', '.*', preg_quote($pattern, '/')) . '$/';
        return preg_match($regex, $this->toString()) === 1;
    }

    /**
     * Get all reserved prefixes.
     *
     * @return array<string> Reserved prefixes.
     */
    public static function getReservedPrefixes(): array
    {
        return self::RESERVED_PREFIXES;
    }

    /**
     * Serialize to JSON.
     *
     * @return array<string, mixed> JSON data.
     */
    public function jsonSerialize(): array
    {
        return [
            'name' => $this->name,
            'namespace' => $this->namespace,
            'full' => $this->toString(),
            'is_secure' => $this->isSecure(),
            'is_reserved' => $this->isReserved(),
        ];
    }
}

=== Storage/NativeStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * NativeStore - PHP Native Session Storage
 *
 * Production-ready implementation using PHP's native session functions.
 * 
 * Features:
 * - Auto-starts session if not started
 * - Error handling for session_start failures  
 * - Thread-safe operations
 * - Persistent across requests
 * - OWASP ASVS 3.3.1 compliant cookie security
 *
 * @package Avax\HTTP\Session
 */
final class NativeStore extends AbstractStore
{
    /**
     * NativeStore Constructor.
     *
     * Auto-starts session with OWASP-compliant security settings.
     * 
     * @throws \RuntimeException If session cannot be started.
     */
    public function __construct()
    {
        if (session_status() === PHP_SESSION_NONE) {
            // OWASP ASVS 3.3.1: Secure Cookie Attributes
            session_set_cookie_params([
                'secure' => true,         // HTTPS only
                'httponly' => true,       // No JavaScript access (XSS protection)
                'samesite' => 'Strict',   // CSRF protection
            ]);

            // Additional security hardening
            ini_set('session.cookie_secure', '1');
            ini_set('session.cookie_httponly', '1');
            ini_set('session.cookie_samesite', 'Strict');
            ini_set('session.use_strict_mode', '1');  // Reject uninitialized session IDs
            ini_set('session.use_only_cookies', '1'); // No URL-based session IDs

            if (!@session_start()) {
                throw new \RuntimeException('Failed to start native PHP session');
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $_SESSION[$key] ?? $default;
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value): void
    {
        $_SESSION[$key] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key): bool
    {
        return isset($_SESSION[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key): void
    {
        unset($_SESSION[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function all(): array
    {
        return $_SESSION;
    }

    /**
     * {@inheritdoc}
     */
    public function flush(): void
    {
        $_SESSION = [];
    }
}

=== Storage/NullStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * NullStore - No-Op Session Storage
 *
 * Dummy storage that discards all data.
 * Useful for dry-run mode or testing without side effects.
 * 
 * Use Cases:
 * - Performance testing (no I/O overhead)
 * - Dry-run scenarios
 * - Feature flags (disabled state)
 * 
 * @package Avax\HTTP\Session
 */
final class NullStore extends AbstractStore
{
    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $default;
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value): void
    {
        // No-op
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key): bool
    {
        return false;
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key): void
    {
        // No-op
    }

    /**
     * {@inheritdoc}
     */
    public function all(): array
    {
        return [];
    }

    /**
     * {@inheritdoc}
     */
    public function flush(): void
    {
        // No-op
    }
}

=== Storage/Psr16CacheAdapter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

// PSR-16 Simple Cache Interface
// Note: Install psr/simple-cache via composer for production use
// This is a fallback stub for development without the package
if (!interface_exists(\Psr\SimpleCache\CacheInterface::class)) {
    /**
     * Stub interface for PSR-16 CacheInterface.
     * Install psr/simple-cache package for production use.
     */
    interface CacheInterface {
        public function get(string $key, mixed $default = null): mixed;
        public function set(string $key, mixed $value, null|int|\DateInterval $ttl = null): bool;
        public function delete(string $key): bool;
        public function clear(): bool;
        public function getMultiple(iterable $keys, mixed $default = null): iterable;
        public function setMultiple(iterable $values, null|int|\DateInterval $ttl = null): bool;
        public function deleteMultiple(iterable $keys): bool;
        public function has(string $key): bool;
    }
}

/**
 * Psr16CacheAdapter - PSR-16 Simple Cache Adapter
 *
 * Bridges session Store interface with PSR-16 Simple Cache.
 * Enables session storage in Redis, Memcached, or any PSR-16 cache.
 *
 * Benefits:
 * - Interoperability with existing cache layers
 * - High-performance session storage (Redis, Memcached)
 * - Automatic expiration support
 * - Vendor-agnostic caching
 *
 * @example With Symfony Cache
 *   $cache = new FilesystemAdapter();
 *   $store = new Psr16CacheAdapter($cache);
 *   $session = new SessionProvider($store);
 *
 * @example With Laravel Cache
 *   $cache = Cache::store('redis');
 *   $store = new Psr16CacheAdapter($cache);
 *
 * @package Avax\HTTP\Session\Storage
 */
final class Psr16CacheAdapter extends AbstractStore
{
    /**
     * Psr16CacheAdapter Constructor.
     *
     * @param object|CacheInterface $cache    PSR-16 cache instance.
     * @param string                $prefix   Key prefix for namespacing (default: 'session_').
     * @param int|null              $ttl      Default TTL in seconds (null = no expiration).
     */
    public function __construct(
        private object $cache,
        private string $prefix = 'session_',
        private ?int $ttl = null
    ) {}

    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $this->cache->get($this->prefixKey($key), $default);
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value): void
    {
        $this->cache->set($this->prefixKey($key), $value, $this->ttl);
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key): bool
    {
        return $this->cache->has($this->prefixKey($key));
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key): void
    {
        $this->cache->delete($this->prefixKey($key));
    }

    /**
     * {@inheritdoc}
     */
    public function all(): array
    {
        // PSR-16 doesn't support "get all keys"
        // We maintain a meta key to track all session keys
        $keys = $this->cache->get($this->prefixKey('_keys'), []);
        $data = [];

        foreach ($keys as $key) {
            $value = $this->cache->get($this->prefixKey($key));
            if ($value !== null) {
                $data[$key] = $value;
            }
        }

        return $data;
    }

    /**
     * {@inheritdoc}
     */
    public function flush(): void
    {
        $keys = $this->cache->get($this->prefixKey('_keys'), []);

        foreach ($keys as $key) {
            $this->cache->delete($this->prefixKey($key));
        }

        $this->cache->delete($this->prefixKey('_keys'));
    }

    /**
     * Override put to track keys.
     *
     * @param string $key   The key.
     * @param mixed  $value The value.
     *
     * @return void
     */
    public function putWithTracking(string $key, mixed $value): void
    {
        // Track this key
        $keys = $this->cache->get($this->prefixKey('_keys'), []);
        if (!in_array($key, $keys, true)) {
            $keys[] = $key;
            $this->cache->set($this->prefixKey('_keys'), $keys);
        }

        // Store the value
        $this->put($key, $value);
    }

    /**
     * Override delete to untrack keys.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function deleteWithTracking(string $key): void
    {
        // Untrack this key
        $keys = $this->cache->get($this->prefixKey('_keys'), []);
        $keys = array_filter($keys, fn($k) => $k !== $key);
        $this->cache->set($this->prefixKey('_keys'), array_values($keys));

        // Delete the value
        $this->delete($key);
    }

    /**
     * Prefix a key with namespace.
     *
     * @param string $key Original key.
     *
     * @return string Prefixed key.
     */
    private function prefixKey(string $key): string
    {
        return $this->prefix . $key;
    }

    /**
     * Set default TTL.
     *
     * @param int|null $ttl TTL in seconds.
     *
     * @return void
     */
    public function setDefaultTtl(?int $ttl): void
    {
        $this->ttl = $ttl;
    }

    /**
     * Get underlying PSR-16 cache instance.
     *
     * @return object Cache instance.
     */
    public function getCache(): object
    {
        return $this->cache;
    }

    /**
     * Store multiple key-value pairs with TTL.
     *
     * @param array<string, mixed> $values Key-value pairs.
     * @param int|null             $ttl    Optional TTL override.
     *
     * @return void
     */
    public function putManyWithTtl(array $values, ?int $ttl = null): void
    {
        $prefixed = [];
        foreach ($values as $key => $value) {
            $prefixed[$this->prefixKey($key)] = $value;
        }

        $this->cache->setMultiple($prefixed, $ttl ?? $this->ttl);
    }

    /**
     * Get multiple values.
     *
     * @param array<string> $keys    Keys to retrieve.
     * @param mixed|null    $default Default value.
     *
     * @return array<string, mixed> Key-value pairs.
     */
    public function getMany(array $keys, mixed $default = null): array
    {
        $prefixed = array_map(fn($k) => $this->prefixKey($k), $keys);
        $values = $this->cache->getMultiple($prefixed, $default);

        // Remove prefix from keys
        $result = [];
        foreach ($values as $prefixedKey => $value) {
            $originalKey = substr($prefixedKey, strlen($this->prefix));
            $result[$originalKey] = $value;
        }

        return $result;
    }

    /**
     * Delete multiple keys.
     *
     * @param array<string> $keys Keys to delete.
     *
     * @return void
     */
    public function deleteMany(array $keys): void
    {
        $prefixed = array_map(fn($k) => $this->prefixKey($k), $keys);
        $this->cache->deleteMultiple($prefixed);
    }

    /**
     * Clear entire cache (including non-session keys).
     *
     * WARNING: This clears the ENTIRE cache, not just session data.
     *
     * @return void
     */
    public function clearEntireCache(): void
    {
        $this->cache->clear();
    }
}

=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "❌ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "📁 Scanning directory: $TARGET_DIR"
echo "📄 Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "🚫 Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "⏭️  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "⏭️  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "🧪 [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "🔄 [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "✅ Done!"
echo "🧩 Merged files : $MERGED"
echo "🚫 Skipped files: $SKIPPED"
echo "📄 Output file  : $OUTPUT_FILE"

