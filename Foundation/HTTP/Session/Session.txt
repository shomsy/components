=== Config/SessionConfig.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Config;

/**
 * SessionConfig - Configuration Value Object
 *
 * Immutable configuration for SessionManager initialization.
 *
 * Provides clean, readable configuration without constructor parameter soup.
 *
 * @example
 *   $config = new SessionConfig(
 *       ttl: 3600,
 *       secure: true,
 *       encryptionKey: 'secret'
 *   );
 *
 *   $session = new SessionManager($store, $config);
 *
 * @package Avax\HTTP\Session
 */
final readonly class SessionConfig
{
    /**
     * SessionConfig Constructor.
     *
     * @param int|null    $ttl           Default TTL in seconds.
     * @param bool        $secure        Enable auto-encryption by default.
     * @param string|null $encryptionKey Encryption key for secure values.
     */
    public function __construct(
        public int|null    $ttl = null,
        public bool        $secure = false,
        public string|null $encryptionKey = null
    ) {}

    /**
     * Create default configuration.
     *
     * @return self
     */
    public static function default() : self
    {
        return new self();
    }

    /**
     * Create secure configuration.
     *
     * @param string $encryptionKey The encryption key.
     *
     * @return self
     */
    public static function secure(string $encryptionKey) : self
    {
        return new self(secure: true, encryptionKey: $encryptionKey);
    }

    /**
     * Create temporary configuration with TTL.
     *
     * @param int $ttl TTL in seconds.
     *
     * @return self
     */
    public static function temporary(int $ttl) : self
    {
        return new self(ttl: $ttl);
    }
}

=== Contracts/FeatureInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts;

/**
 * FeatureInterface - Session Feature Lifecycle Contract
 *
 * Defines lifecycle hooks for session features.
 * Enables automatic initialization and cleanup.
 *
 * Features implement this interface to:
 * - Initialize on session start (boot)
 * - Cleanup on session end (terminate)
 * - Declare feature name for debugging
 *
 * @package Avax\HTTP\Session\Contracts
 */
interface FeatureInterface
{
    /**
     * Boot the feature.
     *
     * Called when session starts or feature is first accessed.
     * Use for initialization logic.
     *
     * @return void
     */
    public function boot() : void;

    /**
     * Terminate the feature.
     *
     * Called when session terminates or is destroyed.
     * Use for cleanup logic (flush logs, save state, etc).
     *
     * @return void
     */
    public function terminate() : void;

    /**
     * Get feature name.
     *
     * @return string Feature identifier.
     */
    public function getName() : string;

    /**
     * Check if feature is enabled.
     *
     * @return bool True if feature is active.
     */
    public function isEnabled() : bool;
}

=== Contracts/Security/Encrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Security;

/**
 * Encrypter - Encryption Contract
 *
 * Defines the contract for session value encryption/decryption.
 * Enables flexible crypto implementations (OpenSSL, Sodium, etc.).
 *
 * @example
 *   $encrypted = $encrypter->encrypt('sensitive-data');
 *   $decrypted = $encrypter->decrypt($encrypted);
 *
 * @package Avax\HTTP\Session\Contracts
 */
interface Encrypter
{
    /**
     * Encrypt a value.
     *
     * @param mixed $value The value to encrypt.
     *
     * @return string The encrypted value.
     */
    public function encrypt(mixed $value) : string;

    /**
     * Decrypt a value.
     *
     * @param string $encrypted The encrypted value.
     *
     * @return mixed The decrypted value.
     * @throws \RuntimeException If decryption fails.
     */
    public function decrypt(string $encrypted) : mixed;
}

=== Contracts/Security/ServerContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Security;

/**
 * ServerContext - Server Environment Context
 *
 * Abstraction for accessing server variables.
 * Enables testability by decoupling from $_SERVER superglobal.
 *
 * @package Avax\HTTP\Session\Contracts\Security
 */
interface ServerContext
{
    /**
     * Get User-Agent string.
     *
     * @return string User agent.
     */
    public function getUserAgent() : string;

    /**
     * Check if connection is secure (HTTPS).
     *
     * @return bool True if HTTPS.
     */
    public function isSecure() : bool;

    /**
     * Get client IP address.
     *
     * @return string IP address.
     */
    public function getClientIp() : string;
}

=== Contracts/SessionContract.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts;

use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Features\Flash;
use Avax\HTTP\Session\Providers\SessionConsumer;

/**
 * SessionContract - Formal API Contract
 *
 * Defines the public API for session management.
 *
 * Purpose:
 * - API stability for testing and DI
 * - Clear contract for implementations
 * - Documentation of public interface
 *
 * Note: This is a formal contract, not used internally.
 * SessionManager implements this implicitly.
 *
 * @package Avax\HTTP\Session
 */
interface SessionContract
{
    /**
     * Store a value.
     *
     * @param string   $key   The key.
     * @param mixed    $value The value.
     * @param int|null $ttl   Optional TTL.
     *
     * @return void
     */
    public function put(string $key, mixed $value, int|null $ttl = null) : void;

    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool
     */
    public function has(string $key) : bool;

    /**
     * Remove a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function forget(string $key) : void;

    /**
     * Get all data.
     *
     * @return array<string, mixed>
     */
    public function all() : array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush() : void;

    /**
     * Create scoped session.
     *
     * @param string $namespace The namespace.
     *
     * @return SessionConsumer Scoped consumer.
     */
    public function scope(string $namespace) : SessionConsumer;

    /**
     * Access flash messages.
     *
     * @return \Avax\HTTP\Session\Features\Flash Flash instance.
     */
    public function flash() : Flash;

    /**
     * Access events.
     *
     * @return \Avax\HTTP\Session\Features\Events Events instance.
     */
    public function events() : Events;
}

=== Contracts/SessionInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts;

use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Features\Flash;

/**
 * SessionInterface
 *
 * Unified contract for the refactored session component.
 * Provides a small, expressive API used across HTTP, Auth and Security layers.
 */
interface SessionInterface
{
    public function put(string $key, mixed $value, int|null $ttl = null) : void;

    /**
     * Alias for put().
     */
    public function set(string $key, mixed $value, int|null $ttl = null) : void;

    public function get(string $key, mixed $default = null) : mixed;

    public function has(string $key) : bool;

    public function forget(string $key) : void;

    /**
     * Alias for forget().
     */
    public function delete(string $key) : void;

    /**
     * Alias for forget().
     */
    public function remove(string $key) : void;

    public function all() : array;

    public function flush() : void;

    /**
     * Start the underlying session mechanism (idempotent).
     */
    public function start() : bool;

    public function regenerateId(bool $deleteOldSession = true) : void;

    public function getId() : string;

    public function login(string $userId) : void;

    public function terminate(string $reason = 'logout') : void;

    public function remember(string $key, callable $callback, int|null $ttl = null) : mixed;

    public function flash() : Flash;

    public function events() : Events;
}

=== Contracts/Storage/Store.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Contracts\Storage;

/**
 * Store Interface - Storage Abstraction
 *
 * Minimal contract for session persistence.
 *
 * Implementations:
 * - NativeStore: PHP native sessions
 * - ArrayStore: In-memory (for testing)
 * - RedisStore: Redis backend
 * - DatabaseStore: Database backend
 *
 * @package Avax\HTTP\Session
 */
interface Store
{
    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed The value or default.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Store a value.
     *
     * @param string $key   The key.
     * @param mixed  $value The value.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool True if exists.
     */
    public function has(string $key) : bool;

    /**
     * Delete a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function delete(string $key) : void;

    /**
     * Get all data.
     *
     * @return array<string, mixed> All data.
     */
    public function all() : array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush() : void;
}

=== Data/AbstractStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

/**
 * Session Component
 *
 * AbstractStore - Base Store Implementation
 *
 * Provides common functionality for all Store implementations.
 * Reduces code duplication across NativeStore, ArrayStore, NullStore.
 *
 * Default Implementations:
 * - has(): Checks if get() returns non-null
 * - pull(): Gets and deletes in one operation
 * - increment()/decrement(): Numeric operations
 * - clear(): Alias for flush()
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
abstract class AbstractStore implements StoreInterface
{
    /**
     * {@inheritdoc}
     */
    public function has(string $key) : bool
    {
        return $this->get($key) !== null;
    }

    /**
     * {@inheritdoc}
     */
    abstract public function get(string $key, mixed $default = null) : mixed;

    /**
     * Get and remove a value in one operation.
     *
     * @param string     $key     The key.
     * @param mixed|null $default Default value.
     *
     * @return mixed The value or default.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        $value = $this->get($key, $default);

        if ($value !== $default) {
            $this->delete($key);
        }

        return $value;
    }

    /**
     * {@inheritdoc}
     */
    abstract public function delete(string $key) : void;

    /**
     * Decrement a numeric value.
     *
     * @param string $key   The key.
     * @param int    $value Amount to decrement (default: 1).
     *
     * @return int New value.
     */
    public function decrement(string $key, int $value = 1) : int
    {
        return $this->increment($key, -$value);
    }

    /**
     * Increment a numeric value.
     *
     * @param string $key   The key.
     * @param int    $value Amount to increment (default: 1).
     *
     * @return int New value.
     */
    public function increment(string $key, int $value = 1) : int
    {
        $current = (int) $this->get($key, 0);
        $new     = $current + $value;
        $this->put($key, $new);

        return $new;
    }

    /**
     * {@inheritdoc}
     */
    abstract public function put(string $key, mixed $value) : void;

    /**
     * Check if store is empty.
     *
     * @return bool True if no data stored.
     */
    public function isEmpty() : bool
    {
        return empty($this->all());
    }

    /**
     * {@inheritdoc}
     */
    abstract public function all() : array;

    /**
     * Get number of stored items.
     *
     * @return int Item count.
     */
    public function count() : int
    {
        return count($this->all());
    }

    /**
     * Alias for flush().
     *
     * @return void
     */
    public function clear() : void
    {
        $this->flush();
    }

    /**
     * {@inheritdoc}
     */
    abstract public function flush() : void;

    /**
     * Store multiple key-value pairs.
     *
     * @param array<string, mixed> $values Key-value pairs.
     *
     * @return void
     */
    public function putMany(array $values) : void
    {
        foreach ($values as $key => $value) {
            $this->put($key, $value);
        }
    }

    /**
     * Delete multiple keys.
     *
     * @param array<string> $keys Keys to delete.
     *
     * @return void
     */
    public function deleteMany(array $keys) : void
    {
        foreach ($keys as $key) {
            $this->delete($key);
        }
    }
}

=== Data/ArrayStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

/**
 * Session Component
 *
 * ArrayStore - In-Memory Session Storage
 *
 * In-memory storage for testing and development.
 * Data is lost after request ends.
 *
 * Perfect for:
 * - Unit tests
 * - Development/debugging
 * - Isolated test scenarios
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
final class ArrayStore extends AbstractStore
{
    /**
     * @var array<string, mixed> In-memory storage
     */
    private array $data = [];

    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->data[$key] ?? $default;
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value) : void
    {
        $this->data[$key] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key) : bool
    {
        return isset($this->data[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key) : void
    {
        unset($this->data[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function all() : array
    {
        return $this->data;
    }

    /**
     * {@inheritdoc}
     */
    public function flush() : void
    {
        $this->data = [];
    }
}

=== Data/FileStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

use Avax\Filesystem\Storage\FileStorageInterface;
use Avax\HTTP\Session\Contracts\Storage\Store;
use RuntimeException;
use Throwable;

/**
 * Class FileStore
 *
 * ðŸ§  Purpose:
 * Adapter between Session and the underlying Foundation FileStorage system.
 *
 * Translates high-level session operations (put, get, forget, flush)
 * into low-level file operations (write, read, delete).
 *
 * No facades are used â€” everything runs through dependency injection.
 *
 * ðŸ’¬ Think of it as:
 * â€œSession speaks human (put/get), FileStorage speaks technical (write/read).â€
 * FileStore is the translator that connects them.
 */
final readonly class FileStore implements Store, StoreInterface
{
    public function __construct(
        private FileStorageInterface $storage,
        private string               $directory = 'sessions'
    ) {}

    /**
     * Save a session value.
     */
    public function put(string $key, mixed $value) : void
    {
        $path = $this->pathFor(key: $key);

        try {
            $this->storage->write(path: $path, content: serialize(value: $value));
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : "Failed to write session key '{$key}': " . $e->getMessage(),
                code    : 0,
                previous: $e
            );
        }
    }

    /**
     * Build a consistent file path for the given key.
     */
    private function pathFor(string $key) : string
    {
        return "{$this->directory}/" . md5(string: $key) . '.sess';
    }

    /**
     * Retrieve a session value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $path = $this->pathFor(key: $key);

        if (! $this->storage->exists(path: $path)) {
            return $default;
        }

        try {
            return unserialize(data: $this->storage->read(path: $path));
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : "Failed to read session key '{$key}': " . $e->getMessage(),
                code    : 0,
                previous: $e
            );
        }
    }

    /**
     * Delete a specific session key.
     */
    public function forget(string $key) : void
    {
        try {
            $this->storage->delete(path: $this->pathFor(key: $key));
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : "Failed to delete session key '{$key}': " . $e->getMessage(),
                code    : 0,
                previous: $e
            );
        }
    }

    /**
     * Alias for forget(), kept for interface compatibility.
     *
     * ðŸ’¬ Think of this as â€œsynonymâ€ for forget().
     * Some APIs prefer `delete()` naming.
     */
    public function delete(string $key) : void
    {
        $this->forget(key: $key);
    }

    /**
     * Check if a key exists.
     */
    public function has(string $key) : bool
    {
        return $this->storage->exists(path: $this->pathFor(key: $key));
    }

    /**
     * Retrieve all session data currently stored.
     *
     * ðŸ§  Purpose:
     * Used by Recovery or Debug features to inspect the entire session snapshot.
     *
     * ðŸ’¬ Think of it like â€œshow me everything saved for this sessionâ€.
     */
    public function all() : array
    {
        try {
            $files = $this->storage->listFiles($this->directory);
            $data  = [];

            foreach ($files as $file) {
                $content = $this->storage->read(path: $file);

                // Reverse the MD5 naming â€” use file name (no extension) as key
                $key        = basename(path: $file, suffix: '.sess');
                $data[$key] = unserialize(data: $content);
            }

            return $data;
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : "Failed to read all session data: " . $e->getMessage(),
                code    : 0,
                previous: $e
            );
        }
    }

    /**
     * Delete all session data.
     */
    public function flush() : void
    {
        try {
            $this->storage->deleteDirectory(directory: $this->directory);
        } catch (Throwable $e) {
            throw new RuntimeException(
                message : "Failed to flush session directory: " . $e->getMessage(),
                code    : 0,
                previous: $e
            );
        }
    }
}

=== Data/Migrator.php ===
<?php

declare(strict_types=1);

namespace Shomsy\Components\Foundation\HTTP\Session\Data;

/**
 * Session Component
 *
 * Migrator - Session Data Migrator
 *
 * Migrates session data from one storage backend to another.
 * Useful for transitioning between different session storage implementations.
 *
 * Use cases:
 * - Moving from file-based to Redis storage
 * - Transitioning to database sessions
 * - Data backup and restoration
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
final class Migrator
{
    /**
     * Migrator Constructor.
     *
     * @param StoreInterface $source Source storage backend.
     * @param StoreInterface $target Target storage backend.
     */
    public function __construct(
        private StoreInterface $source,
        private StoreInterface $target
    ) {}

    /**
     * Migrate specific keys only.
     *
     * @param array<string> $keys Keys to migrate.
     *
     * @return int Number of migrated items.
     */
    public function migrateKeys(array $keys) : int
    {
        $count = 0;
        foreach ($keys as $key) {
            if ($this->source->has($key)) {
                $value = $this->source->get($key);
                $this->target->put($key, $value);
                $count++;
            }
        }

        return $count;
    }

    /**
     * Migrate and clear source.
     *
     * @return int Number of migrated items.
     */
    public function migrateAndClear() : int
    {
        $count = $this->migrate();
        $this->source->flush();

        return $count;
    }

    /**
     * Migrate all data from source to target.
     *
     * @return int Number of migrated items.
     */
    public function migrate() : int
    {
        $count = 0;
        foreach ($this->source->all() as $key => $value) {
            $this->target->put($key, $value);
            $count++;
        }

        return $count;
    }

    /**
     * Verify migration integrity.
     *
     * Checks if all data was successfully migrated.
     *
     * @return bool True if all data matches.
     */
    public function verify() : bool
    {
        $sourceData = $this->source->all();
        $targetData = $this->target->all();

        if (count($sourceData) !== count($targetData)) {
            return false;
        }

        foreach ($sourceData as $key => $value) {
            if (! isset($targetData[$key]) || $targetData[$key] !== $value) {
                return false;
            }
        }

        return true;
    }
}

=== Data/NativeStore.php ===
<?php

declare(strict_types=1);

namespace Shomsy\Components\Foundation\HTTP\Session\Data;

use RuntimeException;
use SessionUpdateTimestampHandlerInterface;
use Shomsy\Components\Foundation\HTTP\Session\Exceptions\SessionStartException;
use Shomsy\Components\Foundation\HTTP\Session\Security\CookieManager;
use Shomsy\Components\Foundation\HTTP\Session\Security\LockManager;

/**
 * Session Component
 *
 * NativeStore - PHP Native Session Storage
 *
 * Production-ready implementation using PHP's native session functions with enhanced features:
 * - Session locking for concurrent request safety
 * - OWASP ASVS 3.3.1+ compliant security
 * - Configurable session settings
 * - Implements SessionUpdateTimestampHandlerInterface for better performance
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
final class NativeStore extends AbstractStore implements SessionUpdateTimestampHandlerInterface
{
    private ?LockManager $lockManager;
    private array        $sessionData = [];
    private bool         $isLocked    = false;

    /**
     * NativeStore Constructor.
     *
     * @param CookieManager|null $cookieManager Cookie manager instance
     * @param LockManager|null   $lockManager   Optional lock manager for concurrent access control
     */
    public function __construct(
        private readonly ?CookieManager $cookieManager = null,
        ?LockManager                    $lockManager = null
    )
    {
        $this->lockManager = $lockManager;
    }

    /**
     * {@inheritdoc}
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $this->ensureStarted();

        return $this->sessionData[$key] ?? $default;
    }

    /**
     * Ensure the session is started
     */
    private function ensureStarted() : void
    {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            $this->start();
        }
    }

    /**
     * Start the session if not already started
     *
     * @throws SessionStartException If session cannot be started
     */
    public function start() : void
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            return;
        }

        $this->cookieManager?->configureSessionCookie();

        // Apply security settings
        $this->configureSessionIni();

        if (! session_start()) {
            throw new SessionStartException(
                'Failed to start session: ' . (error_get_last()['message'] ?? 'Unknown error')
            );
        }

        $this->sessionData = &$_SESSION;
        $this->acquireLock(session_id());
    }

    /**
     * Configure PHP session settings
     */
    private function configureSessionIni() : void
    {
        $config = [
            'session.cookie_secure'    => '1',
            'session.cookie_httponly'  => '1',
            'session.cookie_samesite'  => 'Strict',
            'session.use_strict_mode'  => '1',
            'session.use_only_cookies' => '1',
            'session.use_trans_sid'    => '0',
            'session.cookie_lifetime'  => '0', // Until browser close
            'session.gc_maxlifetime'   => (string) (60 * 60 * 24), // 24 hours
            'session.gc_probability'   => '1',
            'session.gc_divisor'       => '1000',
        ];

        foreach ($config as $key => $value) {
            ini_set($key, $value);
        }
    }

    /**
     * Acquire a lock for the current session
     */
    private function acquireLock(string $sessionId) : void
    {
        if ($this->lockManager && ! $this->lockManager->acquire($sessionId)) {
            throw new RuntimeException('Could not acquire session lock');
        }
        $this->isLocked = true;
    }

    /**
     * {@inheritdoc}
     */
    public function put(string $key, mixed $value) : void
    {
        $this->ensureStarted();
        $this->sessionData[$key] = $value;
    }

    /**
     * {@inheritdoc}
     */
    public function has(string $key) : bool
    {
        $this->ensureStarted();

        return array_key_exists($key, $this->sessionData);
    }

    /**
     * {@inheritdoc}
     */
    public function delete(string $key) : void
    {
        $this->ensureStarted();
        unset($this->sessionData[$key]);
    }

    /**
     * {@inheritdoc}
     */
    public function all() : array
    {
        $this->ensureStarted();

        return $this->sessionData;
    }

    /**
     * {@inheritdoc}
     */
    public function flush() : void
    {
        $this->ensureStarted();
        $this->sessionData = [];
    }

    /**
     * Destroy the session
     */
    public function destroy() : bool
    {
        if (session_status() !== PHP_SESSION_ACTIVE) {
            return false;
        }

        $sessionId         = session_id();
        $this->sessionData = [];
        session_destroy();
        $this->releaseLock($sessionId);

        return true;
    }

    /**
     * Release the current session lock
     */
    private function releaseLock(string $sessionId) : void
    {
        if ($this->lockManager && $this->isLocked) {
            $this->lockManager->release($sessionId);
            $this->isLocked = false;
        }
    }

    // SessionUpdateTimestampHandlerInterface methods

    /**
     * {@inheritdoc}
     */
    public function validateId($sessionId) : bool
    {
        return preg_match('/^[a-zA-Z0-9,-]{22,256}$/', $sessionId) === 1;
    }

    /**
     * {@inheritdoc}
     */
    public function updateTimestamp($sessionId, $data) : bool
    {
        return true; // Native PHP handles this
    }

    /**
     * Destructor - ensures session is properly closed
     */
    public function __destruct()
    {
        $this->close();
    }

    /**
     * Close the session and release locks
     */
    public function close() : void
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            $sessionId = session_id();
            session_write_close();
            $this->releaseLock($sessionId);
        }
    }
}

=== Data/Recovery.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

use RuntimeException;
use Throwable;

/**
 * Session Component
 *
 * Recovery - Session Recovery Manager
 *
 * Provides session backup, restoration, and recovery capabilities.
 * Enables rollback to previous session states in case of errors.
 *
 * Use cases:
 * - Automatic session backups
 * - Error recovery
 * - Transaction-like session operations
 * - Debugging and diagnostics
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
final class Recovery
{
    /**
     * @var array<string, array> Backup storage
     */
    private array $backups = [];

    /**
     * Recovery Constructor.
     *
     * @param StoreInterface $store Session storage.
     */
    public function __construct(
        private StoreInterface $store
    ) {}

    /**
     * Check if a backup exists.
     *
     * @param string $name Backup name.
     *
     * @return bool True if backup exists.
     */
    public function hasBackup(string $name = 'default') : bool
    {
        return isset($this->backups[$name]);
    }

    /**
     * Get all backup names.
     *
     * @return array<string> Backup names.
     */
    public function listBackups() : array
    {
        return array_keys($this->backups);
    }

    /**
     * Get backup metadata.
     *
     * @param string $name Backup name.
     *
     * @return array|null Backup metadata or null.
     */
    public function getBackupInfo(string $name = 'default') : array|null
    {
        if (! isset($this->backups[$name])) {
            return null;
        }

        return [
            'name'      => $name,
            'timestamp' => $this->backups[$name]['timestamp'],
            'size'      => count($this->backups[$name]['data']),
            'age'       => time() - $this->backups[$name]['timestamp'],
        ];
    }

    /**
     * Clear all backups.
     *
     * @return void
     */
    public function clearAllBackups() : void
    {
        $this->backups = [];
    }

    /**
     * Perform an operation with automatic backup and rollback on failure.
     *
     * @param callable $operation  The operation to perform.
     * @param string   $backupName Backup name (default: auto-generated).
     *
     * @return mixed The operation result.
     *
     * @throws RuntimeException If operation fails.
     */
    public function transaction(callable $operation, string $backupName = '') : mixed
    {
        $backupName = $backupName ?: 'transaction_' . uniqid();

        // Create backup before operation
        $this->backup($backupName);

        try {
            $result = $operation();

            // Success - delete backup
            $this->deleteBackup($backupName);

            return $result;
        } catch (Throwable $e) {
            // Failure - restore from backup
            $this->restore($backupName);
            $this->deleteBackup($backupName);

            throw new RuntimeException(
                'Session transaction failed: ' . $e->getMessage(),
                previous: $e
            );
        }
    }

    /**
     * Create a backup of current session state.
     *
     * @param string $name Backup name.
     *
     * @return void
     */
    public function backup(string $name = 'default') : void
    {
        $this->backups[$name] = [
            'data'      => $this->store->all(),
            'timestamp' => time(),
        ];
    }

    /**
     * Delete a backup.
     *
     * @param string $name Backup name.
     *
     * @return bool True if backup was deleted.
     */
    public function deleteBackup(string $name = 'default') : bool
    {
        if (! isset($this->backups[$name])) {
            return false;
        }

        unset($this->backups[$name]);

        return true;
    }

    /**
     * Restore session from a backup.
     *
     * @param string $name Backup name.
     *
     * @return bool True if backup was found and restored.
     */
    public function restore(string $name = 'default') : bool
    {
        if (! isset($this->backups[$name])) {
            return false;
        }

        $this->store->flush();

        foreach ($this->backups[$name]['data'] as $key => $value) {
            $this->store->put($key, $value);
        }

        return true;
    }

    /**
     * Export session data for external backup.
     *
     * @return string Serialized session data.
     */
    public function export() : string
    {
        return serialize($this->store->all());
    }

    /**
     * Import session data from external backup.
     *
     * @param string $data Serialized session data.
     *
     * @return bool True on success.
     */
    public function import(string $data) : bool
    {
        try {
            $sessionData = unserialize($data);

            if (! is_array($sessionData)) {
                return false;
            }

            $this->store->flush();

            foreach ($sessionData as $key => $value) {
                $this->store->put($key, $value);
            }

            return true;
        } catch (Throwable) {
            return false;
        }
    }
}

=== Data/Serializer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

use RuntimeException;
use Throwable;

/**
 * Session Component
 *
 * Serializer - Session Data Serialization
 *
 * Handles serialization and deserialization of session data.
 * Supports multiple formats for different use cases.
 *
 * Supported formats:
 * - PHP native serialize/unserialize
 * - JSON encoding
 * - Base64 encoding for safe transport
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
final class Serializer
{
    /**
     * Serialize data to JSON.
     *
     * @param mixed $data Data to serialize.
     *
     * @return string JSON string.
     *
     * @throws RuntimeException If JSON encoding fails.
     */
    public function toJson(mixed $data) : string
    {
        $json = json_encode($data, JSON_THROW_ON_ERROR);

        if ($json === false) {
            throw new RuntimeException('Failed to encode data to JSON');
        }

        return $json;
    }

    /**
     * Deserialize data from JSON.
     *
     * @param string $json JSON string.
     *
     * @return mixed Decoded data.
     *
     * @throws RuntimeException If JSON decoding fails.
     */
    public function fromJson(string $json) : mixed
    {
        try {
            return json_decode($json, associative: true, flags: JSON_THROW_ON_ERROR);
        } catch (Throwable $e) {
            throw new RuntimeException('Failed to decode JSON: ' . $e->getMessage(), previous: $e);
        }
    }

    /**
     * Encode data to base64 for safe transport.
     *
     * @param mixed $data Data to encode.
     *
     * @return string Base64 encoded string.
     */
    public function toBase64(mixed $data) : string
    {
        return base64_encode($this->serialize($data));
    }

    /**
     * Serialize data using PHP's native serialization.
     *
     * @param mixed $data Data to serialize.
     *
     * @return string Serialized data.
     */
    public function serialize(mixed $data) : string
    {
        return serialize($data);
    }

    /**
     * Decode data from base64.
     *
     * @param string $encoded Base64 encoded string.
     *
     * @return mixed Decoded data.
     *
     * @throws RuntimeException If decoding fails.
     */
    public function fromBase64(string $encoded) : mixed
    {
        $decoded = base64_decode($encoded, strict: true);

        if ($decoded === false) {
            throw new RuntimeException('Failed to decode base64 data');
        }

        return $this->unserialize($decoded);
    }

    /**
     * Unserialize data using PHP's native unserialization.
     *
     * @param string $data Serialized data.
     *
     * @return mixed Unserialized data.
     *
     * @throws RuntimeException If unserialization fails.
     */
    public function unserialize(string $data) : mixed
    {
        try {
            return unserialize($data);
        } catch (Throwable $e) {
            throw new RuntimeException('Failed to unserialize data: ' . $e->getMessage(), previous: $e);
        }
    }

    /**
     * Check if data is serialized.
     *
     * @param string $data Data to check.
     *
     * @return bool True if data appears to be serialized.
     */
    public function isSerialized(string $data) : bool
    {
        $data = trim($data);

        if ($data === 'N;') {
            return true;
        }

        if (strlen($data) < 4) {
            return false;
        }

        if ($data[1] !== ':') {
            return false;
        }

        $lastChar = $data[strlen($data) - 1];
        if ($lastChar !== ';' && $lastChar !== '}') {
            return false;
        }

        $token = $data[0];
        switch ($token) {
            case 's':
            case 'a':
            case 'O':
                return (bool) preg_match("/^{$token}:[0-9]+:/s", $data);
            case 'b':
            case 'i':
            case 'd':
                return (bool) preg_match("/^{$token}:[0-9.E+-]+;$/", $data);
        }

        return false;
    }

    /**
     * Safely unserialize data with validation.
     *
     * @param string $data           Serialized data.
     * @param array  $allowedClasses Allowed classes for unserialization.
     *
     * @return mixed Unserialized data.
     *
     * @throws RuntimeException If unserialization fails or contains disallowed classes.
     */
    public function safeUnserialize(string $data, array $allowedClasses = []) : mixed
    {
        try {
            return unserialize($data, ['allowed_classes' => $allowedClasses]);
        } catch (Throwable $e) {
            throw new RuntimeException('Failed to safely unserialize data: ' . $e->getMessage(), previous: $e);
        }
    }
}

=== Data/StoreInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Data;

/**
 * Session Component
 *
 * StoreInterface - Storage Abstraction
 *
 * Minimal contract for session persistence.
 *
 * Implementations:
 * - NativeStore: PHP native sessions
 * - ArrayStore: In-memory (for testing)
 * - RedisStore: Redis backend
 * - DatabaseStore: Database backend
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Data
 */
interface StoreInterface
{
    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed The value or default.
     */
    public function get(string $key, mixed $default = null) : mixed;

    /**
     * Store a value.
     *
     * @param string $key   The key.
     * @param mixed  $value The value.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool True if exists.
     */
    public function has(string $key) : bool;

    /**
     * Delete a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function delete(string $key) : void;

    /**
     * Get all data.
     *
     * @return array<string, mixed> All data.
     */
    public function all() : array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush() : void;
}

=== Exceptions/EncryptionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * EncryptionException - Encryption/Decryption Errors
 *
 * Thrown when encryption or decryption operations fail.
 * Provides fine-grained error handling for crypto operations.
 *
 * Error Types:
 * - Key missing or invalid
 * - Encryption failed
 * - Decryption failed
 * - Tag verification failed (GCM mode)
 * - Invalid ciphertext format
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class EncryptionException extends RuntimeException
{
    /**
     * Create exception for missing encryption key.
     *
     * @param string $keyName Key identifier.
     *
     * @return self
     */
    public static function keyMissing(string $keyName = 'default') : self
    {
        return new self(
            "Encryption key '{$keyName}' is missing or not configured. " .
            "Set encryption key in SessionConfig or environment."
        );
    }

    /**
     * Create exception for invalid encryption key.
     *
     * @param string $reason Reason why key is invalid.
     *
     * @return self
     */
    public static function invalidKey(string $reason) : self
    {
        return new self("Invalid encryption key: {$reason}");
    }

    /**
     * Create exception for encryption failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function encryptionFailed(string $reason = 'unknown') : self
    {
        return new self("Encryption failed: {$reason}");
    }

    /**
     * Create exception for decryption failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function decryptionFailed(string $reason = 'unknown') : self
    {
        return new self("Decryption failed: {$reason}");
    }

    /**
     * Create exception for tag verification failure (GCM mode).
     *
     * @return self
     */
    public static function tagVerificationFailed() : self
    {
        return new self(
            "Authentication tag verification failed. " .
            "Data may have been tampered with or corrupted."
        );
    }

    /**
     * Create exception for invalid ciphertext format.
     *
     * @param string $expected Expected format.
     *
     * @return self
     */
    public static function invalidFormat(string $expected) : self
    {
        return new self("Invalid ciphertext format. Expected: {$expected}");
    }

    /**
     * Create exception for unsupported cipher.
     *
     * @param string $cipher Cipher name.
     *
     * @return self
     */
    public static function unsupportedCipher(string $cipher) : self
    {
        return new self("Unsupported cipher: {$cipher}");
    }

    /**
     * Create exception for key rotation failure.
     *
     * @param string $reason Failure reason.
     *
     * @return self
     */
    public static function keyRotationFailed(string $reason) : self
    {
        return new self("Key rotation failed: {$reason}");
    }
}

=== Exceptions/EncryptionKeyMissingException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * EncryptionKeyMissingException
 *
 * Thrown when encryption is required but no key is configured.
 *
 * Use Case:
 * - Attempting to store _secure suffixed keys without encryption key
 * - Using secure() scope without encryption key
 *
 * @example
 *   try {
 *       $session->put('token_secure', 'value');
 *   } catch (EncryptionKeyMissingException $e) {
 *       // Handle missing key
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class EncryptionKeyMissingException extends SessionException
{
    /**
     * Create exception for missing encryption key.
     *
     * @return self
     */
    public static function create() : self
    {
        return new self(
            'Encryption key is required for secure session values. ' .
            'Set encryption key in SessionConfig or SessionManager constructor.'
        );
    }
}

=== Exceptions/ExpiredSessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * ExpiredSessionException
 *
 * Thrown when attempting to access an expired session value.
 *
 * Use Case:
 * - TTL-based expiration
 * - Policy-based expiration
 * - Manual expiration checks
 *
 * @example
 *   try {
 *       $value = $session->get('key');
 *   } catch (ExpiredSessionException $e) {
 *       // Handle expiration
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class ExpiredSessionException extends SessionException
{
    /**
     * Create exception for expired key.
     *
     * @param string $key The expired key.
     *
     * @return self
     */
    public static function forKey(string $key) : self
    {
        return new self("Session key '{$key}' has expired");
    }
}

=== Exceptions/PolicyViolationException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

/**
 * PolicyViolationException
 *
 * Thrown when a session policy is violated.
 *
 * Use Cases:
 * - MaxIdlePolicy timeout
 * - MaxLifetimePolicy exceeded
 * - SecureOnlyPolicy HTTPS requirement
 * - CrossAgentPolicy user agent mismatch
 *
 * @example
 *   try {
 *       $session->put('key', 'value');
 *   } catch (PolicyViolationException $e) {
 *       // Handle policy violation
 *   }
 *
 * @package Avax\HTTP\Session\Exceptions
 */
final class PolicyViolationException extends SessionException
{
    /**
     * Create exception for policy violation.
     *
     * @param string $policyName The policy that was violated.
     * @param string $reason     The violation reason.
     *
     * @return self
     */
    public static function forPolicy(string $policyName, string $reason) : self
    {
        return new self(
            sprintf('Policy violation [%s]: %s', $policyName, $reason)
        );
    }
}

=== Exceptions/RegistryException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * RegistryException - Session Registry Errors
 *
 * Thrown when session registry operations fail.
 * Provides fine-grained error handling for multi-device session management.
 *
 * Error Types:
 * - Session not found
 * - Session already registered
 * - Concurrent session limit exceeded
 * - Revocation errors
 * - Device management errors
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class RegistryException extends RuntimeException
{
    /**
     * Create exception for session not found.
     *
     * @param string $sessionId Session ID.
     *
     * @return self
     */
    public static function sessionNotFound(string $sessionId) : self
    {
        return new self("Session '{$sessionId}' not found in registry.");
    }

    /**
     * Create exception for session already registered.
     *
     * @param string $sessionId Session ID.
     *
     * @return self
     */
    public static function sessionAlreadyRegistered(string $sessionId) : self
    {
        return new self("Session '{$sessionId}' is already registered.");
    }

    /**
     * Create exception for concurrent session limit exceeded.
     *
     * @param string $userId  User identifier.
     * @param int    $limit   Maximum allowed sessions.
     * @param int    $current Current session count.
     *
     * @return self
     */
    public static function concurrentLimitExceeded(string $userId, int $limit, int $current) : self
    {
        return new self(
            "User '{$userId}' has exceeded concurrent session limit. " .
            "Limit: {$limit}, Current: {$current}"
        );
    }

    /**
     * Create exception for revoked session access attempt.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Revocation reason.
     *
     * @return self
     */
    public static function sessionRevoked(string $sessionId, string $reason) : self
    {
        return new self(
            "Session '{$sessionId}' has been revoked. Reason: {$reason}"
        );
    }

    /**
     * Create exception for revocation failure.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Failure reason.
     *
     * @return self
     */
    public static function revocationFailed(string $sessionId, string $reason) : self
    {
        return new self("Failed to revoke session '{$sessionId}': {$reason}");
    }

    /**
     * Create exception for device not found.
     *
     * @param string $userId    User identifier.
     * @param string $userAgent User agent string.
     *
     * @return self
     */
    public static function deviceNotFound(string $userId, string $userAgent) : self
    {
        return new self(
            "No sessions found for user '{$userId}' with device '{$userAgent}'."
        );
    }

    /**
     * Create exception for invalid session metadata.
     *
     * @param string $sessionId Session ID.
     * @param string $reason    Reason why metadata is invalid.
     *
     * @return self
     */
    public static function invalidMetadata(string $sessionId, string $reason) : self
    {
        return new self("Invalid metadata for session '{$sessionId}': {$reason}");
    }

    /**
     * Create exception for registry storage failure.
     *
     * @param string $operation Operation that failed.
     * @param string $reason    Failure reason.
     *
     * @return self
     */
    public static function storageFailed(string $operation, string $reason) : self
    {
        return new self("Registry storage operation '{$operation}' failed: {$reason}");
    }
}

=== Exceptions/SessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * SessionException - Base Exception
 *
 * Base exception for all session-related errors.
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class SessionException extends RuntimeException {}

=== Exceptions/SessionStartException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;
use Throwable;

class SessionStartException extends RuntimeException
{
    #[\Override]
    public function __construct(string $message = "Failed to start session", int $code = 0, Throwable|null $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }
}

=== Features/AsyncEventDispatcher.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Exception;
use InvalidArgumentException;

/**
 * AsyncEventDispatcher - Asynchronous Event Dispatcher
 *
 * High-throughput event dispatcher with queue-based async processing.
 * Prevents event handling from blocking main request flow.
 *
 * Features:
 * - Queue-based async dispatch
 * - Batch processing
 * - Error handling and retry logic
 * - Memory-efficient (bounded queue)
 * - Graceful shutdown
 *
 * Modes:
 * - SYNC: Immediate synchronous dispatch (default, backward compatible)
 * - ASYNC_MEMORY: In-memory queue, processed on shutdown
 * - ASYNC_FILE: File-based queue, processed by background worker
 * - ASYNC_REDIS: Redis queue (requires Redis extension)
 *
 * @example Sync mode (default)
 *   $dispatcher = new AsyncEventDispatcher();
 *   $dispatcher->listen('event', $callback);
 *   $dispatcher->dispatch('event', $data);  // Immediate
 *
 * @example Async memory mode
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_MEMORY);
 *   $dispatcher->dispatch('event', $data);  // Queued, processed on shutdown
 *
 * @example Async file mode (for background workers)
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_FILE, '/tmp/events.queue');
 *   $dispatcher->dispatch('event', $data);  // Written to file
 *
 * @package Avax\HTTP\Session\Features
 */
final class AsyncEventDispatcher
{
    public const string MODE_SYNC         = 'sync';
    public const string MODE_ASYNC_MEMORY = 'async_memory';
    public const string MODE_ASYNC_FILE   = 'async_file';
    public const string MODE_ASYNC_REDIS  = 'async_redis';

    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var array<array{event: string, data: array}> Event queue
     */
    private array $queue = [];

    /**
     * @var bool Shutdown handler registered
     */
    private bool $shutdownRegistered = false;

    /**
     * @var int Maximum queue size (prevent memory exhaustion)
     */
    private int $maxQueueSize = 1000;

    /**
     * @var int Batch size for processing
     */
    private int $batchSize = 100;

    /**
     * AsyncEventDispatcher Constructor.
     *
     * @param string|null $mode      Dispatch mode (sync|async_memory|async_file|async_redis).
     * @param string|null $queuePath Queue file path (for async_file mode).
     * @param object|null $redis     Redis instance (for async_redis mode).
     */
    public function __construct(
        private string|null          $mode = null,
        private readonly string|null $queuePath = null,
        private readonly object|null $redis = null
    )
    {
        $this->mode ??= self::MODE_SYNC;
        if ($mode === self::MODE_ASYNC_FILE && $queuePath === null) {
            throw new InvalidArgumentException(message: 'Queue path required for async_file mode');
        }

        if ($this->mode === self::MODE_ASYNC_REDIS && $this->redis === null) {
            throw new InvalidArgumentException(message: 'Redis instance required for async_redis mode');
        }
    }

    /**
     * Register a one-time listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function once(string $event, callable $callback) : self
    {
        $wrapper = function (array $data) use ($callback, $event, &$wrapper) {
            $callback($data);
            $this->removeListener(event: $event, callback: $wrapper);
        };

        return $this->listen(event: $event, callback: $wrapper);
    }

    /**
     * Remove a specific listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback to remove.
     *
     * @return self Fluent interface.
     */
    public function removeListener(string $event, callable $callback) : self
    {
        if (! isset($this->listeners[$event])) {
            return $this;
        }

        $this->listeners[$event] = array_filter(
            array   : $this->listeners[$event],
            callback: static fn($listener) => $listener !== $callback
        );

        return $this;
    }

    /**
     * Register an event listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function listen(string $event, callable $callback) : self
    {
        if (! isset($this->listeners[$event])) {
            $this->listeners[$event] = [];
        }

        $this->listeners[$event][] = $callback;

        return $this;
    }

    /**
     * Dispatch an event.
     *
     * Behavior depends on mode:
     * - SYNC: Immediate dispatch
     * - ASYNC_MEMORY: Queue in memory, process on shutdown
     * - ASYNC_FILE: Write to file queue
     * - ASYNC_REDIS: Push to Redis queue
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []) : void
    {
        match ($this->mode) {
            self::MODE_SYNC         => $this->dispatchSync(event: $event, data: $data),
            self::MODE_ASYNC_MEMORY => $this->dispatchAsyncMemory(event: $event, data: $data),
            self::MODE_ASYNC_FILE   => $this->dispatchAsyncFile(event: $event, data: $data),
            self::MODE_ASYNC_REDIS  => $this->dispatchAsyncRedis(event: $event, data: $data),
            default                 => throw new InvalidArgumentException(message: "Invalid mode: {$this->mode}")
        };
    }

    /**
     * Dispatch event synchronously (immediate).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchSync(string $event, array $data) : void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            try {
                $callback($data);
            } catch (Exception $e) {
                error_log(message: "Event listener error [{$event}]: " . $e->getMessage());
            }
        }
    }

    /**
     * Dispatch event asynchronously (memory queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncMemory(string $event, array $data) : void
    {
        // Check queue size limit
        if (count(value: $this->queue) >= $this->maxQueueSize) {
            error_log(message: "Event queue full, dropping event: {$event}");

            return;
        }

        // Add to queue
        $this->queue[] = compact('event', 'data');

        // Register shutdown handler (once)
        if (! $this->shutdownRegistered) {
            register_shutdown_function(callback: [$this, 'processQueue']);
            $this->shutdownRegistered = true;
        }
    }

    /**
     * Dispatch event asynchronously (file queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncFile(string $event, array $data) : void
    {
        $payload = json_encode(value: ['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Append to queue file (atomic)
        file_put_contents(
            filename: $this->queuePath,
            data    : $payload . PHP_EOL,
            flags   : FILE_APPEND | LOCK_EX
        );
    }

    /**
     * Dispatch event asynchronously (Redis queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncRedis(string $event, array $data) : void
    {
        $payload = json_encode(value: ['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Push to Redis list
        $this->redis->rPush('session:events', $payload);
    }

    /**
     * Process queued events (called on shutdown).
     *
     * @return void
     */
    public function processQueue() : void
    {
        if (empty($this->queue)) {
            return;
        }

        // Process in batches
        $batches = array_chunk(array: $this->queue, length: $this->batchSize);

        foreach ($batches as $batch) {
            foreach ($batch as $item) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
            }
        }

        // Clear queue
        $this->queue = [];
    }

    /**
     * Process file queue (for background workers).
     *
     * Reads events from file queue and dispatches them.
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processFileQueue(int $limit = 0) : int
    {
        if (! file_exists(filename: $this->queuePath)) {
            return 0;
        }

        $handle = fopen(filename: $this->queuePath, mode: 'r+');
        if (! $handle) {
            return 0;
        }

        // Lock file
        flock(stream: $handle, operation: LOCK_EX);

        $processed = 0;
        $remaining = [];

        while (($line = fgets(stream: $handle)) !== false) {
            if ($limit > 0 && $processed >= $limit) {
                $remaining[] = $line;
                continue;
            }

            $item = json_decode(json: trim(string: $line), associative: true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
                $processed++;
            }
        }

        // Rewrite file with remaining events
        ftruncate(stream: $handle, size: 0);
        rewind(stream: $handle);
        foreach ($remaining as $line) {
            fwrite(stream: $handle, data: $line);
        }

        flock(stream: $handle, operation: LOCK_UN);
        fclose(stream: $handle);

        return $processed;
    }

    /**
     * Process Redis queue (for background workers).
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processRedisQueue(int $limit = 0) : int
    {
        $processed = 0;

        while ($limit === 0 || $processed < $limit) {
            $payload = $this->redis->lPop('session:events');
            if (! $payload) {
                break;
            }

            $item = json_decode(json: $payload, associative: true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
                $processed++;
            }
        }

        return $processed;
    }

    /**
     * Get queue size.
     *
     * @return int Number of queued events.
     */
    public function getQueueSize() : int
    {
        return match ($this->mode) {
            self::MODE_ASYNC_MEMORY => count(value: $this->queue),
            self::MODE_ASYNC_FILE   => $this->getFileQueueSize(),
            self::MODE_ASYNC_REDIS  => $this->getRedisQueueSize(),
            default                 => 0
        };
    }

    /**
     * Get file queue size.
     *
     * @return int Number of lines in queue file.
     */
    private function getFileQueueSize() : int
    {
        if (! file_exists(filename: $this->queuePath)) {
            return 0;
        }

        return count(value: file(filename: $this->queuePath));
    }

    /**
     * Get Redis queue size.
     *
     * @return int Number of items in Redis list.
     */
    private function getRedisQueueSize() : int
    {
        return $this->redis->lLen('session:events');
    }

    /**
     * Set maximum queue size.
     *
     * @param int $size Maximum size.
     *
     * @return self Fluent interface.
     */
    public function setMaxQueueSize(int $size) : self
    {
        $this->maxQueueSize = $size;

        return $this;
    }

    /**
     * Set batch size for processing.
     *
     * @param int $size Batch size.
     *
     * @return self Fluent interface.
     */
    public function setBatchSize(int $size) : self
    {
        $this->batchSize = $size;

        return $this;
    }

    /**
     * Get current mode.
     *
     * @return string Mode.
     */
    public function getMode() : string
    {
        return $this->mode;
    }

    /**
     * Clear all listeners.
     *
     * @return self Fluent interface.
     */
    public function clearListeners() : self
    {
        $this->listeners = [];

        return $this;
    }

    /**
     * Clear queue.
     *
     * @return self Fluent interface.
     */
    public function clearQueue() : self
    {
        $this->queue = [];

        return $this;
    }
}

=== Features/Audit.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;
use Avax\Logging\LoggerFactory;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * ðŸ§  Audit - Enterprise-Grade Session Audit Logger
 * ============================================================
 *
 * This feature provides structured, secure, and resilient audit logging
 * for all session lifecycle events within the Avax HTTP framework.
 *
 * It integrates seamlessly with your `LoggerFactory` and PSR-3 loggers,
 * automatically attaching contextual data such as:
 * - environment name (dev/staging/prod)
 * - session ID
 * - user ID (if available)
 * - client IP address
 * - timestamp
 *
 * ðŸ’¬ Think of it as:
 * â€œThe corporate black box for your session layer â€”
 *  every action is recorded, structured, and traceable.â€
 *
 * âš™ï¸ Key Features:
 * - âœ… PSR-3 compliant â€” works with any logger implementation
 * - âœ… JSON-structured logs â€” ready for ELK, Loki, or Datadog ingestion
 * - âœ… Crash-safe â€” never throws exceptions during logging
 * - âœ… Context-aware â€” captures environment, IP, and session metadata
 * - âœ… Sensitive-data sanitization â€” masks tokens, passwords, secrets
 *
 * @package Avax\HTTP\Session\Features
 * @author  â€”
 */
final class Audit implements FeatureInterface
{
    /**
     * Whether the audit feature is currently active.
     *
     * @var bool
     */
    private bool $enabled = true;

    /**
     * The PSR-3 compliant logger used to record audit events.
     *
     * This is resolved automatically using the `LoggerFactory`
     * if no custom logger is provided in the constructor.
     *
     * @var LoggerInterface
     */
    private readonly LoggerInterface $logger;

    /**
     * Optional log file path for fallback or standalone use.
     *
     * @var string|null
     */
    private readonly ?string $logPath;

    // -------------------------------------------------------------------------
    // ðŸš€ CONSTRUCTOR
    // -------------------------------------------------------------------------

    /**
     * Construct a new Audit feature instance.
     *
     * @param LoggerInterface|null $logger  Optional PSR-3 logger instance.
     * @param string|null          $logPath Optional direct log file path (fallback mode).
     *
     * ðŸ’¬ Think of it as:
     * â€œYou can give me a PSR logger, a file path â€” or nothing.
     *  Iâ€™ll make sure your audit events are never lost.â€
     */
    public function __construct(LoggerInterface|null $logger = null, string|null $logPath = null)
    {
        $this->logger  = $logger ?? (new LoggerFactory())->createLoggerFor(channel: 'session-audit');
        $this->logPath = $logPath;
    }

    // -------------------------------------------------------------------------
    // ðŸ§© FEATURE INTERFACE METHODS
    // -------------------------------------------------------------------------

    /**
     * Get the feature name.
     *
     * @return string The feature identifier ("audit").
     */
    public function getName() : string
    {
        return 'audit';
    }

    /**
     * Boot the audit feature.
     *
     * Called automatically when the feature is registered within
     * the SessionProvider. Enables logging and records initialization.
     *
     * ðŸ’¬ Think of it as â€œstarting the flight recorderâ€.
     *
     * @return void
     */
    public function boot() : void
    {
        $this->enabled = true;

        $this->record(
            event: 'audit_initialized',
            data : [
                'status'    => 'enabled',
                'env'       => getenv(name: 'APP_ENV') ?: 'production',
                'timestamp' => date(format: 'c'),
            ]
        );
    }

    /**
     * Record a structured audit event.
     *
     * This method safely logs session actions, with contextual metadata.
     * It never throws exceptions â€” even if the logger or file operation fails.
     *
     * @param string               $event Event name (e.g. 'session_created', 'key_deleted').
     * @param array<string, mixed> $data  Additional context (e.g. user ID, request details).
     *
     * ðŸ’¬ Example:
     * ```php
     * $audit->record('session_regenerated', [
     *     'user_id' => 42,
     *     'old_id'  => 'abc123',
     *     'new_id'  => 'xyz789'
     * ]);
     * ```
     *
     * @return void
     */
    public function record(string $event, array $data = []) : void
    {
        if (! $this->enabled) {
            return;
        }

        $payload = [
            'timestamp'   => date(format: 'c'),
            'event'       => strtoupper(string: $event),
            'environment' => getenv(name: 'APP_ENV') ?: 'production',
            'session_id'  => $data['session_id'] ?? $_COOKIE['PHPSESSID'] ?? null,
            'user_id'     => $data['user_id'] ?? $this->resolveUserId(),
            'ip_address'  => $this->resolveClientIp(),
            'action_data' => $this->sanitize(data: $data),
        ];

        try {
            // âœ… PSR-3 structured log entry
            $this->logger->info(message: '[SESSION_AUDIT]', context: $payload);
        } catch (Throwable $e) {
            // âš ï¸ Fail-safe fallback â€” write to file if possible
            if ($this->logPath) {
                $this->writeToFile($payload);
            } else {
                error_log(message: "âš ï¸ [Audit] Logging failed: {$e->getMessage()}");
            }
        }
    }

    /**
     * Resolve the current user's ID from session context.
     *
     * Attempts to infer `user_id` automatically from PHP session data.
     * If unavailable, returns null.
     *
     * @return int|null The current user's ID, or null if unknown.
     */
    private function resolveUserId() : ?int
    {
        return $_SESSION['user_id'] ?? null;
    }

    // -------------------------------------------------------------------------
    // ðŸ§  AUDIT LOGIC
    // -------------------------------------------------------------------------

    /**
     * Determine the client's IP address safely.
     *
     * Handles typical proxy headers to extract the real IP
     * while remaining compatible with direct connections.
     *
     * @return string|null The detected client IP, or null if not available.
     */
    private function resolveClientIp() : ?string
    {
        return $_SERVER['HTTP_CLIENT_IP']
            ?? $_SERVER['HTTP_X_FORWARDED_FOR']
            ?? $_SERVER['REMOTE_ADDR']
            ?? null;
    }

    // -------------------------------------------------------------------------
    // ðŸ§© HELPERS
    // -------------------------------------------------------------------------

    /**
     * Sanitize potentially sensitive data before logging.
     *
     * Removes or masks fields that could contain confidential information,
     * such as passwords, tokens, or API keys.
     *
     * Supports deep recursive sanitization for nested arrays.
     *
     * @param array<string, mixed> $data Input data to clean.
     *
     * @return array<string, mixed> Sanitized version of the data.
     */
    private function sanitize(array $data) : array
    {
        $blacklist = ['password', 'token', 'api_key', 'secret'];
        $clean     = [];

        foreach ($data as $key => $value) {
            if (is_array($value)) {
                $clean[$key] = $this->sanitize($value);
                continue;
            }

            $clean[$key] = in_array($key, $blacklist, true)
                ? '***MASKED***'
                : $value;
        }

        return $clean;
    }

    /**
     * Write the audit payload to file in JSON format.
     *
     * @param array<string, mixed> $payload Structured log data.
     *
     * @return void
     */
    private function writeToFile(array $payload) : void
    {
        $json = json_encode($payload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        $dir  = dirname($this->logPath);

        if (! is_dir($dir)) {
            mkdir($dir, 0775, true);
        }

        @file_put_contents($this->logPath, $json . PHP_EOL, FILE_APPEND | LOCK_EX);
    }

    /**
     * Gracefully shut down the audit feature.
     *
     * Called during Session termination or provider shutdown.
     * Writes a final log entry to indicate the audit system was disabled.
     *
     * ðŸ’¬ Think of it as â€œturning off the black box recorderâ€.
     *
     * @return void
     */
    public function terminate() : void
    {
        $this->record(
            event: 'audit_terminated',
            data : [
                'status'    => 'disabled',
                'timestamp' => date(format: 'c'),
            ]
        );

        $this->enabled = false;
    }

    /**
     * Check if the audit feature is active.
     *
     * @return bool True if active, false if disabled.
     */
    public function isEnabled() : bool
    {
        return $this->enabled;
    }
}

=== Features/AuditRotator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Exception;

/**
 * AuditRotator - Log Rotation and Size Management
 *
 * Manages audit log rotation based on size and age.
 * Prevents unbounded log growth in production environments.
 *
 * Features:
 * - Size-based rotation (max file size)
 * - Time-based rotation (daily, weekly, monthly)
 * - Automatic compression of old logs
 * - Retention policy (delete old logs)
 * - Atomic rotation (no data loss)
 *
 * @example
 *   $rotator = new AuditRotator('/var/log/session.log');
 *   $rotator->setMaxSize(10 * 1024 * 1024);  // 10 MB
 *   $rotator->setMaxFiles(7);                 // Keep 7 days
 *   $rotator->rotate();
 *
 * @package Avax\HTTP\Session\Features
 */
final class AuditRotator
{
    private const DEFAULT_MAX_SIZE  = 10485760; // 10 MB
    private const DEFAULT_MAX_FILES = 7;
    private const DEFAULT_COMPRESS  = true;

    /**
     * AuditRotator Constructor.
     *
     * @param string $logPath  Path to log file.
     * @param int    $maxSize  Maximum file size in bytes (default: 10 MB).
     * @param int    $maxFiles Maximum number of rotated files to keep (default: 7).
     * @param bool   $compress Compress rotated logs (default: true).
     */
    public function __construct(
        private string $logPath,
        private int    $maxSize = self::DEFAULT_MAX_SIZE,
        private int    $maxFiles = self::DEFAULT_MAX_FILES,
        private bool   $compress = self::DEFAULT_COMPRESS
    ) {}

    /**
     * Force rotation regardless of size.
     *
     * Useful for time-based rotation (daily, weekly, etc).
     *
     * @return bool True on success.
     */
    public function forceRotate() : bool
    {
        if (! file_exists($this->logPath)) {
            return false;
        }

        // Temporarily set max size to 0 to force rotation
        $originalMaxSize = $this->maxSize;
        $this->maxSize   = 0;

        $result = $this->rotate();

        $this->maxSize = $originalMaxSize;

        return $result;
    }

    /**
     * Rotate the log file.
     *
     * Renames current log to .1, shifts existing rotated logs,
     * and optionally compresses old logs.
     *
     * @return bool True on success.
     */
    public function rotate() : bool
    {
        if (! $this->shouldRotate()) {
            return false;
        }

        try {
            // Shift existing rotated logs
            $this->shiftRotatedLogs();

            // Rename current log to .1
            $rotatedPath = $this->logPath . '.1';
            if (! rename($this->logPath, $rotatedPath)) {
                return false;
            }

            // Compress if enabled
            if ($this->compress) {
                $this->compressLog($rotatedPath);
            }

            // Clean up old logs
            $this->cleanupOldLogs();

            return true;
        } catch (Exception $e) {
            error_log("Log rotation failed: " . $e->getMessage());

            return false;
        }
    }

    /**
     * Check if rotation is needed.
     *
     * @return bool True if log should be rotated.
     */
    public function shouldRotate() : bool
    {
        if (! file_exists($this->logPath)) {
            return false;
        }

        $size = filesize($this->logPath);

        return $size >= $this->maxSize;
    }

    /**
     * Shift existing rotated logs.
     *
     * .1 â†’ .2, .2 â†’ .3, etc.
     *
     * @return void
     */
    private function shiftRotatedLogs() : void
    {
        // Start from the highest number and work backwards
        for ($i = $this->maxFiles - 1; $i >= 1; $i--) {
            $oldPath = $this->logPath . '.' . $i;
            $newPath = $this->logPath . '.' . ($i + 1);

            // Check both compressed and uncompressed versions
            foreach ([$oldPath, $oldPath . '.gz'] as $path) {
                if (file_exists($path)) {
                    $targetPath = ($path === $oldPath) ? $newPath : $newPath . '.gz';
                    rename($path, $targetPath);
                }
            }
        }
    }

    /**
     * Compress a log file using gzip.
     *
     * @param string $path Path to log file.
     *
     * @return bool True on success.
     */
    private function compressLog(string $path) : bool
    {
        if (! file_exists($path)) {
            return false;
        }

        $compressedPath = $path . '.gz';

        // Read original file
        $content = file_get_contents($path);
        if ($content === false) {
            return false;
        }

        // Compress and write
        $compressed = gzencode($content, 9);
        if ($compressed === false) {
            return false;
        }

        if (file_put_contents($compressedPath, $compressed) === false) {
            return false;
        }

        // Delete original
        unlink($path);

        return true;
    }

    /**
     * Clean up old rotated logs beyond retention limit.
     *
     * @return void
     */
    private function cleanupOldLogs() : void
    {
        for ($i = $this->maxFiles + 1; $i <= $this->maxFiles + 10; $i++) {
            foreach ([$this->logPath . '.' . $i, $this->logPath . '.' . $i . '.gz'] as $path) {
                if (file_exists($path)) {
                    unlink($path);
                }
            }
        }
    }

    /**
     * Set maximum file size.
     *
     * @param int $bytes Size in bytes.
     *
     * @return self Fluent interface.
     */
    public function setMaxSize(int $bytes) : self
    {
        $this->maxSize = $bytes;

        return $this;
    }

    /**
     * Set maximum number of rotated files to keep.
     *
     * @param int $count Number of files.
     *
     * @return self Fluent interface.
     */
    public function setMaxFiles(int $count) : self
    {
        $this->maxFiles = $count;

        return $this;
    }

    /**
     * Enable or disable compression.
     *
     * @param bool $compress Enable compression.
     *
     * @return self Fluent interface.
     */
    public function setCompress(bool $compress) : self
    {
        $this->compress = $compress;

        return $this;
    }

    /**
     * Get configuration summary.
     *
     * @return array<string, mixed> Configuration.
     */
    public function getConfig() : array
    {
        return [
            'log_path'      => $this->logPath,
            'max_size'      => $this->formatBytes($this->maxSize),
            'max_files'     => $this->maxFiles,
            'compress'      => $this->compress,
            'current_size'  => $this->getCurrentSizeFormatted(),
            'total_size'    => $this->formatBytes($this->getTotalSize()),
            'rotated_count' => count($this->getRotatedLogs()),
        ];
    }

    /**
     * Format bytes to human-readable string.
     *
     * @param int $bytes Bytes.
     *
     * @return string Formatted string.
     */
    private function formatBytes(int $bytes) : string
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $i     = 0;

        while ($bytes >= 1024 && $i < count($units) - 1) {
            $bytes /= 1024;
            $i++;
        }

        return round($bytes, 2) . ' ' . $units[$i];
    }

    /**
     * Get human-readable current size.
     *
     * @return string Size with unit (e.g., "5.2 MB").
     */
    public function getCurrentSizeFormatted() : string
    {
        return $this->formatBytes($this->getCurrentSize());
    }

    /**
     * Get current log file size.
     *
     * @return int Size in bytes, or 0 if file doesn't exist.
     */
    public function getCurrentSize() : int
    {
        if (! file_exists($this->logPath)) {
            return 0;
        }

        return filesize($this->logPath);
    }

    /**
     * Get total size of all log files (current + rotated).
     *
     * @return int Total size in bytes.
     */
    public function getTotalSize() : int
    {
        $total = $this->getCurrentSize();

        foreach ($this->getRotatedLogs() as $path) {
            $total += filesize($path);
        }

        return $total;
    }

    /**
     * Get list of all rotated log files.
     *
     * @return array<string> List of file paths.
     */
    public function getRotatedLogs() : array
    {
        $logs = [];

        for ($i = 1; $i <= $this->maxFiles + 10; $i++) {
            foreach ([$this->logPath . '.' . $i, $this->logPath . '.' . $i . '.gz'] as $path) {
                if (file_exists($path)) {
                    $logs[] = $path;
                }
            }
        }

        return $logs;
    }
}

=== Features/Events.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;

/**
 * Events - Simple Event Dispatcher
 *
 * Provides basic pub/sub functionality for session events.
 *
 * Events:
 * - stored: When a value is stored
 * - retrieved: When a value is retrieved
 * - deleted: When a value is deleted
 * - flushed: When session is flushed
 *
 * @example
 *   $events->listen('stored', function($data) {
 *       logger()->info('Value stored', $data);
 *   });
 *
 *   // One-time listener
 *   $events->once('stored', function($data) {
 *       metrics()->increment('session.first_write');
 *   });
 *
 * @package Avax\HTTP\Session
 */
final class Events implements FeatureInterface
{
    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Register a one-time event listener.
     *
     * Listener will be automatically removed after first dispatch.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function once(string $event, callable $callback) : void
    {
        $wrapper = function ($data) use ($event, $callback, &$wrapper) {
            $callback($data);
            $this->removeListener($event, $wrapper);
        };

        $this->listen($event, $wrapper);
    }

    /**
     * Remove an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback to remove.
     *
     * @return void
     */
    public function removeListener(string $event, callable $callback) : void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        $this->listeners[$event] = array_filter(
            $this->listeners[$event],
            fn($listener) => $listener !== $callback
        );
    }

    /**
     * Register an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function listen(string $event, callable $callback) : void
    {
        $this->listeners[$event][] = $callback;
    }

    /**
     * Dispatch an event to all registered listeners.
     *
     * @param string               $event The event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []) : void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            $callback($data);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot() : void
    {
        // Events are ready on construction
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate() : void
    {
        // Clear all listeners on termination
        $this->listeners = [];
        $this->enabled   = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return 'events';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled() : bool
    {
        return $this->enabled;
    }
}

=== Features/Flash.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;
use Avax\HTTP\Session\Data\StoreInterface;
use Override;

/**
 * Flash - Flash Messages Feature
 *
 * Provides one-time messages that persist across a single redirect.
 *
 * Message Types:
 * - success: Success messages
 * - error: Error messages
 * - warning: Warning messages
 * - info: Informational messages
 *
 * @example
 *   $flash->success('Profile updated!');
 *   $flash->error('Invalid credentials');
 *
 *   $message = $flash->get('success');  // Auto-removed after retrieval
 *
 * @package Avax\HTTP\Session
 */
final class Flash implements FeatureInterface
{
    private const string PREFIX = '_flash.';
    private bool $enabled = true;

    /**
     * Flash Constructor.
     *
     * @param StoreInterface $store The storage backend.
     */
    public function __construct(
        private StoreInterface $store
    ) {}

    /**
     * Add a success message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function success(string $message) : void
    {
        $this->add('success', $message);
    }

    /**
     * Add a flash message.
     *
     * @param string $key     The message key.
     * @param string $message The message.
     *
     * @return void
     */
    public function add(string $key, string $message) : void
    {
        $this->store->put(self::PREFIX . $key, $message);
    }

    /**
     * Add an error message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function error(string $message) : void
    {
        $this->add('error', $message);
    }

    /**
     * Add a warning message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function warning(string $message) : void
    {
        $this->add('warning', $message);
    }

    /**
     * Add an info message.
     *
     * @param string $message The message.
     *
     * @return void
     */
    public function info(string $message) : void
    {
        $this->add('info', $message);
    }

    /**
     * Get and remove a flash message.
     *
     * @param string      $key     The message key.
     * @param string|null $default Default value.
     *
     * @return string|null The message or default.
     */
    public function get(string $key, string|null $default = null) : string|null
    {
        $flashKey = self::PREFIX . $key;
        $message  = $this->store->get($flashKey, $default);

        if ($message !== $default) {
            $this->store->delete($flashKey);
        }

        return $message;
    }

    /**
     * Check if a flash message exists.
     *
     * @param string $key The message key.
     *
     * @return bool True if exists.
     */
    public function has(string $key) : bool
    {
        return $this->store->has(self::PREFIX . $key);
    }

    /**
     * Add a flash message for immediate use (same request).
     *
     * Unlike add(), this message is NOT removed after first retrieval.
     * Use for displaying messages in the same request.
     *
     * @param string $key     The message key.
     * @param string $message The message.
     *
     * @return void
     */
    public function now(string $key, string $message) : void
    {
        $this->add("now.{$key}", $message);
    }

    /**
     * {@inheritdoc}
     */
    #[Override]
    public function boot() : void
    {
        // Flash messages are lazy-loaded, no boot logic needed
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    #[Override]
    public function terminate() : void
    {
        // Clear all flash messages on session termination
        $this->clear();
        $this->enabled = false;
    }

    /**
     * Clear all flash messages.
     *
     * @return void
     */
    public function clear() : void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::PREFIX)) {
                $this->store->delete($key);
            }
        }
    }

    /**
     * {@inheritdoc}
     */
    #[Override]
    public function getName() : string
    {
        return 'flash';
    }

    /**
     * {@inheritdoc}
     */
    #[Override]
    public function isEnabled() : bool
    {
        return $this->enabled;
    }
}

=== Features/RateLimiterFeature.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use DateTimeImmutable;
use Redis;

/**
 * RateLimiterFeature
 *
 * Implements distributed rate limiting using Redis (token bucket algorithm).
 * Fallback to in-memory array for development environments.
 *
 * @package Avax\HTTP\Session\Features
 */
final class RateLimiterFeature
{
    private array $localCache = [];

    public function __construct(
        private readonly Redis|null $redis = null,
        private readonly int        $limit = 100,
        private readonly int        $windowSeconds = 60
    ) {}

    public function allow(string $key) : bool
    {
        $now = time();

        if ($this->redis) {
            $bucket = sprintf('ratelimit:%s', $key);
            $count  = $this->redis->incr($bucket);

            if ($count === 1) {
                $this->redis->expire($bucket, $this->windowSeconds);
            }

            return $count <= $this->limit;
        }

        // In-memory fallback
        $window = (int) floor($now / $this->windowSeconds);

        if (! isset($this->localCache[$key])) {
            $this->localCache[$key] = ['count' => 0, 'window' => $window];
        }

        if ($this->localCache[$key]['window'] !== $window) {
            $this->localCache[$key] = ['count' => 0, 'window' => $window];
        }

        $this->localCache[$key]['count']++;

        return $this->localCache[$key]['count'] <= $this->limit;
    }

    public function getResetTime(string $key) : DateTimeImmutable
    {
        $now   = time();
        $reset = $now + $this->windowSeconds;

        return new DateTimeImmutable("@{$reset}");
    }
}

=== Features/SessionVersioning.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use DateTimeImmutable;

/**
 * SessionVersioning
 *
 * Manages versioned session snapshots for rollback and audit recovery.
 *
 * @package Avax\HTTP\Session\Features
 */
final class SessionVersioning
{
    private array $versions = [];

    /**
     * @throws \Random\RandomException
     */
    public function createSnapshot(array $data) : string
    {
        $versionId                  = bin2hex(random_bytes(8));
        $this->versions[$versionId] = [
            'timestamp' => new DateTimeImmutable(),
            'data'      => $data
        ];

        return $versionId;
    }

    public function restoreSnapshot(string $versionId) : array|null
    {
        return $this->versions[$versionId]['data'] ?? null;
    }

    public function listVersions() : array
    {
        return array_map(
            fn($v) => $v['timestamp']->format(DATE_ATOM),
            $this->versions
        );
    }
}

=== Features/Snapshots.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features;

use Avax\HTTP\Session\Contracts\FeatureInterface;
use Avax\HTTP\Session\Contracts\Storage\Store;

/**
 * Snapshots - Session State Snapshot Manager
 *
 * Provides snapshot and restore functionality for session state.
 * Useful for rollback scenarios, state comparison, or debugging.
 *
 * @example
 *   $snapshots = new Snapshots();
 *   $snapshots->snapshot('before_checkout', $sessionData);
 *   // ... later
 *   $data = $snapshots->restore('before_checkout');
 *
 * @package Avax\HTTP\Session
 */
final class Snapshots implements FeatureInterface
{
    /**
     * @var array<string, string> Snapshot storage (name => serialized data)
     */
    private array $snapshots = [];

    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Create a snapshot of session state.
     *
     * @param string               $name Snapshot identifier.
     * @param array<string, mixed> $data Session data to snapshot.
     *
     * @return void
     */
    public function snapshot(string $name, array $data) : void
    {
        $this->snapshots[$name] = serialize([
            'data'      => $data,
            'timestamp' => time(),
            'name'      => $name,
        ]);
    }

    /**
     * Restore session state from a snapshot.
     *
     * @param string $name Snapshot identifier.
     *
     * @return array<string, mixed>|null Session data or null if snapshot doesn't exist.
     */
    public function restore(string $name) : array|null
    {
        if (! isset($this->snapshots[$name])) {
            return null;
        }

        $snapshot = unserialize($this->snapshots[$name]);

        return $snapshot['data'] ?? null;
    }

    /**
     * Check if a snapshot exists.
     *
     * @param string $name Snapshot identifier.
     *
     * @return bool True if snapshot exists.
     */
    public function has(string $name) : bool
    {
        return isset($this->snapshots[$name]);
    }

    /**
     * Delete a snapshot.
     *
     * @param string $name Snapshot identifier.
     *
     * @return void
     */
    public function delete(string $name) : void
    {
        unset($this->snapshots[$name]);
    }

    /**
     * Get all snapshot names.
     *
     * @return array<int, string> List of snapshot names.
     */
    public function all() : array
    {
        return array_keys($this->snapshots);
    }

    /**
     * Save all snapshots to a Store.
     *
     * Enables persistence across requests.
     *
     * @param Store  $store The storage backend.
     * @param string $key   Storage key (default: '_snapshots').
     *
     * @return void
     */
    public function saveTo(Store $store, string $key = '_snapshots') : void
    {
        $store->put($key, $this->snapshots);
    }

    /**
     * Load snapshots from a Store.
     *
     * Restores snapshots from persistent storage.
     *
     * @param Store  $store The storage backend.
     * @param string $key   Storage key (default: '_snapshots').
     *
     * @return void
     */
    public function loadFrom(Store $store, string $key = '_snapshots') : void
    {
        $snapshots = $store->get($key, []);

        if (is_array($snapshots)) {
            $this->snapshots = $snapshots;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot() : void
    {
        // Snapshots are ready on construction
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate() : void
    {
        // Clear all snapshots on termination
        $this->snapshots = [];
        $this->enabled   = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return 'snapshots';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled() : bool
    {
        return $this->enabled;
    }
}

=== Lifecycle/Config.php ===
<?php

declare(strict_types=1);

namespace Shomsy\Components\Foundation\HTTP\Session\Lifecycle;

/**
 * Session Component
 *
 * Config - Configuration Value Object
 *
 * Immutable configuration for SessionProvider initialization.
 *
 * Provides clean, readable configuration without constructor parameter soup.
 *
 * @example
 *   $config = new Config(
 *       ttl: 3600,
 *       secure: true,
 *       encryptionKey: 'secret'
 *   );
 *
 *   $session = new SessionProvider($store, $config);
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Lifecycle
 */
final readonly class Config
{
    /**
     * Config Constructor.
     *
     * @param int|null    $ttl           Default TTL in seconds.
     * @param bool        $secure        Enable auto-encryption by default.
     * @param string|null $encryptionKey Encryption key for secure values.
     */
    public function __construct(
        public int|null    $ttl = null,
        public bool        $secure = false,
        public string|null $encryptionKey = null
    ) {}

    /**
     * Create default configuration.
     *
     * @return self
     */
    public static function default() : self
    {
        return new self();
    }

    /**
     * Create secure configuration.
     *
     * @param string $encryptionKey The encryption key.
     *
     * @return self
     */
    public static function secure(string $encryptionKey) : self
    {
        return new self(secure: true, encryptionKey: $encryptionKey);
    }

    /**
     * Create temporary configuration with TTL.
     *
     * @param int $ttl TTL in seconds.
     *
     * @return self
     */
    public static function temporary(int $ttl) : self
    {
        return new self(ttl: $ttl);
    }
}

=== Lifecycle/SessionAdapter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Lifecycle;

use Avax\HTTP\Session\Security\CookieManager;

/**
 * Session Component
 *
 * SessionAdapter - Native PHP Session Abstraction
 *
 * Abstracts native PHP session functions for testability and portability.
 * Enables dependency injection and mocking in unit tests.
 *
 * Benefits:
 * - Testable: Can be mocked in unit tests
 * - Portable: Easy to switch to different session handlers
 * - Clean: Encapsulates native PHP session functions
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Lifecycle
 */
final class SessionAdapter
{
    /**
     * SessionAdapter Constructor.
     *
     * @param CookieManager|null $cookieManager Cookie manager for secure cookies.
     */
    public function __construct(private CookieManager|null $cookieManager = null)
    {
        $this->cookieManager ??= CookieManager::lax();
    }

    /**
     * Start a new session or resume existing session.
     *
     * @return bool True on success.
     */
    public function start() : bool
    {
        if ($this->isActive()) {
            return true;
        }

        // Configure session cookie before starting
        $this->cookieManager->configureSessionCookie();

        return session_start();
    }

    /**
     * Check if session is active.
     *
     * @return bool True if session is active.
     */
    public function isActive() : bool
    {
        return session_status() === PHP_SESSION_ACTIVE;
    }

    /**
     * Get current session ID.
     *
     * @return string Session ID.
     */
    public function getId() : string
    {
        return session_id();
    }

    /**
     * Set session ID.
     *
     * @param string $id Session ID.
     *
     * @return bool True on success.
     */
    public function setId(string $id) : bool
    {
        if ($this->isActive()) {
            return false; // Cannot change ID of active session
        }

        session_id($id);

        return true;
    }

    /**
     * Set session name.
     *
     * @param string $name Session name.
     *
     * @return string Previous session name.
     */
    public function setName(string $name) : string
    {
        return session_name($name);
    }

    /**
     * Destroy the current session.
     *
     * OWASP ASVS 3.2.3 Compliant
     *
     * Completely terminates the session:
     * - Clears session data
     * - Destroys server-side session
     * - Removes client cookie
     *
     * @return bool True on success.
     */
    public function destroy() : bool
    {
        if (! $this->isActive()) {
            return false;
        }

        // Clear session variables
        $_SESSION = [];

        // Delete session cookie
        $this->deleteCookie();

        // Destroy server-side session
        return session_destroy();
    }

    /**
     * Delete session cookie.
     *
     * @return bool True on success.
     */
    public function deleteCookie() : bool
    {
        return $this->cookieManager->delete($this->getName());
    }

    /**
     * Get session name.
     *
     * @return string Session name.
     */
    public function getName() : string
    {
        return session_name();
    }

    /**
     * Write session data and close session.
     *
     * @return bool True on success.
     */
    public function write() : bool
    {
        if (! $this->isActive()) {
            return false;
        }

        return session_write_close();
    }

    /**
     * Abort session changes and close session.
     *
     * @return bool True on success.
     */
    public function abort() : bool
    {
        if (! $this->isActive()) {
            return false;
        }

        return session_abort();
    }

    /**
     * Perform garbage collection.
     *
     * @return int|false Number of deleted sessions or false on failure.
     */
    public function gc() : int|false
    {
        return session_gc();
    }

    /**
     * Set session save path.
     *
     * @param string $path Save path.
     *
     * @return string Previous save path.
     */
    public function setSavePath(string $path) : string
    {
        return session_save_path($path);
    }

    /**
     * Get session save path.
     *
     * @return string Save path.
     */
    public function getSavePath() : string
    {
        return session_save_path();
    }

    /**
     * Get session module name.
     *
     * @return string Module name (e.g., 'files', 'redis').
     */
    public function getModuleName() : string
    {
        return session_module_name();
    }

    /**
     * Set session module name.
     *
     * @param string $module Module name.
     *
     * @return string Previous module name.
     */
    public function setModuleName(string $module) : string
    {
        return session_module_name($module);
    }

    /**
     * Get session cache limiter.
     *
     * @return string Cache limiter.
     */
    public function getCacheLimiter() : string
    {
        return session_cache_limiter();
    }

    /**
     * Set session cache limiter.
     *
     * @param string $limiter Cache limiter ('nocache', 'public', 'private', etc).
     *
     * @return string Previous cache limiter.
     */
    public function setCacheLimiter(string $limiter) : string
    {
        return session_cache_limiter($limiter);
    }

    /**
     * Get cookie manager.
     *
     * @return CookieManager Cookie manager instance.
     */
    public function getCookieManager() : CookieManager
    {
        return $this->cookieManager;
    }

    /**
     * Reset session to clean state without destroying it.
     *
     * Useful for privilege de-escalation scenarios.
     *
     * @return void
     */
    public function reset() : void
    {
        if ($this->isActive()) {
            $this->unsetAll();
            $this->regenerateId();
        }
    }

    /**
     * Unset all session variables.
     *
     * @return void
     */
    public function unsetAll() : void
    {
        $_SESSION = [];
    }

    /**
     * Regenerate session ID.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Prevents session fixation attacks.
     *
     * @param bool $deleteOldSession Delete old session data.
     *
     * @return bool True on success.
     */
    public function regenerateId(bool $deleteOldSession = true) : bool
    {
        if (! $this->isActive()) {
            return false;
        }

        return session_regenerate_id($deleteOldSession);
    }
}

=== Lifecycle/SessionConsumer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Lifecycle;

/**
 * Session Component
 *
 * SessionConsumer - Contextual Session Consumer
 *
 * Represents a contextual, purpose-specific consumer of the SessionProvider.
 * Created via $session->for($context) or $session->scope($context).
 *
 * Provider-Consumer Pattern:
 * - SessionProvider = Provider (aggregate root, lifecycle management)
 * - SessionConsumer = Consumer (contextual DSL adapter)
 *
 * Features:
 * - Namespace isolation (e.g., 'cart', 'user', 'admin')
 * - TTL configuration
 * - Auto-encryption via secure() method
 * - Chainable fluent API
 *
 * @example
 *   $session->for('cart')
 *       ->secure()
 *       ->ttl(3600)
 *       ->put('items', $items);
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Lifecycle
 */
final class SessionConsumer
{
    private int|null $ttl    = null;
    private bool     $secure = false;

    /**
     * SessionConsumer Constructor.
     *
     * @param string          $namespace The consumer context namespace.
     * @param SessionProvider $provider  The session provider.
     */
    public function __construct(
        private readonly string          $namespace,
        private readonly SessionProvider $provider
    ) {}

    /**
     * Enable auto-encryption for all operations in this consumer context.
     *
     * @return self Fluent interface.
     */
    public function secure() : self
    {
        $this->secure = true;

        return $this;
    }

    /**
     * Store a value in this consumer context.
     *
     * @param string $key   The key (will be namespaced).
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        $scopedKey = $this->buildKey($key);
        $this->provider->put(
            key  : $scopedKey,
            value: $value,
            ttl  : $this->ttl
        );
    }

    /**
     * Build scoped key with namespace and security suffix.
     *
     * @param string $key The base key.
     *
     * @return string The scoped key.
     */
    private function buildKey(string $key) : string
    {
        $scopedKey = "{$this->namespace}.{$key}";

        if ($this->secure) {
            $scopedKey .= '_secure';
        }

        return $scopedKey;
    }

    /**
     * Retrieve a value from this consumer context.
     *
     * @param string $key     The key (will be namespaced).
     * @param mixed  $default Default value if not found.
     *
     * @return mixed The retrieved value or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $scopedKey = $this->buildKey($key);

        return $this->provider->get(
            key    : $scopedKey,
            default: $default
        );
    }

    /**
     * Check if a key exists in this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return bool True if key exists.
     */
    public function has(string $key) : bool
    {
        $scopedKey = $this->buildKey($key);

        return $this->provider->has(key: $scopedKey);
    }

    /**
     * Remove a value from this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        $scopedKey = $this->buildKey($key);
        $this->provider->forget(key: $scopedKey);
    }

    /**
     * Remember a value using lazy evaluation.
     *
     * Proxy to provider's remember() method with scoped key.
     *
     * @param string   $key      The key (will be namespaced).
     * @param callable $callback Callback to generate value.
     *
     * @return mixed The cached or generated value.
     */
    public function remember(string $key, callable $callback) : mixed
    {
        $scopedKey = $this->buildKey($key);

        return $this->provider->remember(
            key     : $scopedKey,
            callback: $callback,
            ttl     : $this->ttl
        );
    }

    /**
     * Create a temporary consumer with TTL.
     *
     * Shortcut for ->ttl() configuration.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Consumer with TTL configured.
     */
    public function temporary(int $seconds) : self
    {
        return $this->ttl($seconds);
    }

    /**
     * Set TTL for all operations in this consumer context.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Fluent interface.
     */
    public function ttl(int $seconds) : self
    {
        $this->ttl = $seconds;

        return $this;
    }

    /**
     * String representation for debugging.
     *
     * @return string Debug representation.
     */
    public function __toString() : string
    {
        return sprintf(
            'SessionConsumer(%s, secure=%s, ttl=%s)',
            $this->namespace,
            $this->secure ? 'true' : 'false',
            $this->ttl ?? 'null'
        );
    }
}

=== Lifecycle/SessionNonce.php ===
<?php

declare(strict_types=1);

namespace Shomsy\Components\Foundation\HTTP\Session\Lifecycle;

use RuntimeException;
use Shomsy\Components\Foundation\HTTP\Session\Data\StoreInterface;

/**
 * Session Component
 *
 * SessionNonce - Replay Attack Prevention
 *
 * OWASP ASVS 3.3.4 Compliant
 *
 * Generates and validates single-use tokens (nonces) to prevent
 * replay attacks on critical state-changing operations.
 *
 * Nonces are cryptographically secure random values.
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Lifecycle
 */
final class SessionNonce
{
    private const string NONCE_KEY    = '_nonce';
    private const int    NONCE_LENGTH = 16; // 128 bits

    /**
     * SessionNonce Constructor.
     *
     * @param StoreInterface $store Session storage.
     */
    public function __construct(
        private StoreInterface $store
    ) {}

    /**
     * Generate a new nonce.
     *
     * Stores it in session for later verification.
     *
     * @return string Hex-encoded nonce.
     */
    public function generate() : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $this->store->put(key: self::NONCE_KEY, value: $nonce);

        return $nonce;
    }

    /**
     * Verify nonce or throw exception.
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid.
     */
    public function verifyOrFail(string $providedNonce) : void
    {
        if (! $this->verify($providedNonce)) {
            throw new RuntimeException(
                'Invalid or missing nonce - potential replay attack detected'
            );
        }
    }

    /**
     * Verify and consume a nonce.
     *
     * Nonce is deleted after verification (single-use).
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return bool True if nonce is valid.
     */
    public function verify(string $providedNonce) : bool
    {
        $storedNonce = $this->store->get(key: self::NONCE_KEY);

        if ($storedNonce === null) {
            return false; // No nonce stored
        }

        // Consume nonce (delete it)
        $this->store->delete(key: self::NONCE_KEY);

        // Constant-time comparison
        return hash_equals($storedNonce, $providedNonce);
    }

    /**
     * Check if a nonce exists in session.
     *
     * @return bool True if nonce present.
     */
    public function exists() : bool
    {
        return $this->store->has(key: self::NONCE_KEY);
    }

    // ========================================
    // PER-REQUEST NONCE (REPLAY ATTACK PREVENTION)
    // ========================================

    /**
     * Generate a per-request nonce.
     *
     * Used for critical operations that should only execute once.
     * Each request gets a unique nonce that expires after use.
     *
     * @param string $action Action identifier (e.g., 'delete_account', 'transfer_funds').
     *
     * @return string Hex-encoded nonce.
     */
    public function generateForRequest(string $action) : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $key   = self::NONCE_KEY . ".{$action}";

        $this->store->put(key: $key, value: [
            'nonce'      => $nonce,
            'created_at' => time(),
            'action'     => $action,
        ]);

        return $nonce;
    }

    /**
     * Verify per-request nonce or throw exception.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid or expired.
     */
    public function verifyForRequestOrFail(string $action, string $providedNonce, int $maxAge = 300) : void
    {
        if (! $this->verifyForRequest($action, $providedNonce, $maxAge)) {
            throw new RuntimeException(
                "Invalid or expired nonce for action '{$action}' - potential replay attack detected"
            );
        }
    }

    /**
     * Verify and consume a per-request nonce.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds (default: 300 = 5 minutes).
     *
     * @return bool True if valid.
     */
    public function verifyForRequest(string $action, string $providedNonce, int $maxAge = 300) : bool
    {
        $key    = self::NONCE_KEY . ".{$action}";
        $stored = $this->store->get(key: $key);

        if ($stored === null) {
            return false; // No nonce for this action
        }

        // Check expiration
        if (time() - $stored['created_at'] > $maxAge) {
            $this->store->delete(key: $key);

            return false; // Expired
        }

        // Consume nonce (delete it)
        $this->store->delete(key: $key);

        // Constant-time comparison
        return hash_equals($stored['nonce'], $providedNonce);
    }

    /**
     * Clear all per-request nonces.
     *
     * @return void
     */
    public function clearAllRequests() : void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::NONCE_KEY . '.')) {
                $this->store->delete(key: $key);
            }
        }
    }

    /**
     * Get all active per-request nonces.
     *
     * Useful for debugging.
     *
     * @return array<string, array> Action => nonce data.
     */
    public function getActiveRequests() : array
    {
        $all    = $this->store->all();
        $nonces = [];

        foreach ($all as $key => $value) {
            if (str_starts_with($key, self::NONCE_KEY . '.') && is_array($value)) {
                $action          = substr($key, strlen(self::NONCE_KEY) + 1);
                $nonces[$action] = $value;
            }
        }

        return $nonces;
    }
}

=== Lifecycle/SessionProvider.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Lifecycle;

use Avax\HTTP\Session\Config\SessionConfig;
use Avax\HTTP\Session\Contracts\FeatureInterface;
use Avax\HTTP\Session\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Contracts\SessionContract;
use Avax\HTTP\Session\Contracts\SessionInterface;
use Avax\HTTP\Session\Data\StoreInterface;
use Avax\HTTP\Session\Features\{Audit, Events, Flash, Snapshots};
use Avax\HTTP\Session\Security\CookieManager;
use Avax\HTTP\Session\Security\EncrypterFactory;
use Avax\HTTP\Session\Security\Policies\PolicyInterface;
use Avax\HTTP\Session\Security\PolicyEnforcer;
use Avax\HTTP\Session\Security\SessionNonce;
use Avax\HTTP\Session\Security\SessionRegistry;
use Override;
use SensitiveParameter;

/**
 * Session Component
 *
 * SessionProvider - Enterprise Session Provider V4.0
 *
 * Acts as the core session provider â€” responsible for managing
 * session lifecycle, persistence, and behavioral features.
 *
 * Provider-Consumer Pattern:
 * - SessionProvider = Provider (aggregate root, lifecycle management)
 * - SessionConsumer = Consumer (contextual DSL adapter)
 *
 * V4.0 Enterprise Edition Features:
 * - EncrypterFactory: Real AES-256-GCM encryption with key rotation
 * - PolicyEnforcer: Centralized policy enforcement
 * - CookieManager: OWASP-compliant cookie security
 * - SessionAdapter: Testable session operations
 * - SessionRegistry: Multi-device session control
 * - SessionNonce: Replay attack prevention
 * - FeatureInterface: Unified feature lifecycle
 *
 * Built-in Features (Zero Configuration):
 * - Auto-encryption (via _secure suffix convention)
 * - Auto-TTL (via ttl parameter)
 * - Namespacing (via scope() / for() builders)
 * - Remember pattern (lazy evaluation)
 * - Policy enforcement (security rules)
 * - Audit logging (observability)
 * - Snapshots (state management)
 *
 * Enterprise Rules:
 * - Smart Conventions: _secure suffix triggers auto-encryption
 * - Lazy Loading: Flash, Events, Audit, Snapshots created only when needed
 * - Dependency Injection: All services injected for testability
 * - Zero Ceremony: Minimal interfaces
 *
 * @example Basic usage
 *   $session = new SessionProvider($store);
 *   $session->put('user_id', 123);
 *   $userId = $session->get('user_id');
 *
 * @example Natural DSL with for()
 *   $session->for('cart')
 *       ->secure()
 *       ->ttl(3600)
 *       ->put('items', $items);
 *
 * @example With Policies
 *   $session->registerPolicy(new MaxIdlePolicy(900));
 *   $session->registerPolicy(new SecureOnlyPolicy());
 *
 * @example With Audit
 *   $session->enableAudit('/var/log/session.log');
 *
 * @example With Snapshots
 *   $session->snapshot('before_checkout');
 *   // ... later
 *   $session->restore('before_checkout');
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session
 */
final class SessionProvider implements SessionContract, SessionInterface
{
    private Flash|null           $flash     = null;
    private Events|null          $events    = null;
    private Audit|null           $audit     = null;
    private Snapshots|null       $snapshots = null;
    private EncrypterFactory     $encrypter;
    private PolicyEnforcer       $policyEnforcer;
    private CookieManager        $cookieManager;
    private SessionAdapter       $sessionAdapter;
    private SessionRegistry|null $registry  = null;
    private SessionNonce|null    $nonce     = null;

    /**
     * @var array<FeatureInterface> Registered features
     */
    private array $features = [];

    /**
     * SessionProvider Constructor.
     *
     * @param StoreInterface      $store          The storage backend.
     * @param SessionConfig|null  $config         Optional configuration.
     * @param Encrypter|null      $encrypter      Optional encrypter factory.
     * @param PolicyEnforcer|null $policyEnforcer Optional policy enforcer.
     * @param CookieManager|null  $cookieManager  Optional cookie manager.
     * @param SessionAdapter|null $sessionAdapter Optional session adapter.
     */
    public function __construct(
        private readonly StoreInterface           $store,
        SessionConfig|null                        $config = null,
        Encrypter|null                            $encrypter = null,
        PolicyEnforcer|null                       $policyEnforcer = null,
        CookieManager|null                        $cookieManager = null,
        #[SensitiveParameter] SessionAdapter|null $sessionAdapter = null
    )
    {
        $config ??= SessionConfig::default();

        // Initialize core services
        $this->encrypter      = $encrypter ?? new EncrypterFactory();
        $this->policyEnforcer = $policyEnforcer ?? new PolicyEnforcer();
        $this->cookieManager  = $cookieManager ?? CookieManager::lax();
        $this->sessionAdapter = $sessionAdapter ?? new SessionAdapter(cookieManager: $this->cookieManager);
    }

    // ========================================
    // CORE OPERATIONS
    // ========================================

    /**
     * Terminate session securely.
     *
     * OWASP ASVS 3.2.3 Compliant
     *
     * Performs complete session cleanup:
     * - Terminates all features (via FeatureInterface)
     * - Clears all data
     * - Destroys server session (via SessionAdapter)
     * - Removes client cookie (via CookieManager)
     * - Prevents session reuse
     * - Audit logs termination
     *
     * @param string $reason Termination reason (for audit).
     *
     * @return void
     */
    #[Override]
    public function terminate(string $reason = 'logout') : void
    {
        // Audit logging
        $this->audit?->record(event: 'session_terminated', data: compact(var_name: 'reason'));

        // Terminate all features
        $this->terminateFeatures();

        // Clear all session data
        $this->flush();

        // Destroy server-side session (via SessionAdapter)
        $this->sessionAdapter->destroy();
    }

    /**
     * Terminate all registered features.
     *
     * @return void
     */
    private function terminateFeatures() : void
    {
        foreach ($this->features as $feature) {
            if ($feature instanceof FeatureInterface) {
                $feature->terminate();
            }
        }
    }

    /**
     * Clear all session data.
     *
     * @return void
     */
    #[Override]
    public function flush() : void
    {
        $this->store->flush();

        // Audit logging
        $this->audit?->record(event: 'flushed');

        // Dispatch event
        $this->events?->dispatch(event: 'flushed');
    }

    /**
     * Login with automatic session regeneration.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Automatically regenerates session ID to prevent fixation.
     * Registers session in SessionRegistry for multi-device control.
     *
     * @param string $userId User identifier.
     *
     * @return void
     */
    #[Override]
    public function login(string $userId) : void
    {
        // CRITICAL: Regenerate ID before setting user data (via SessionAdapter)
        $this->regenerateId();

        $this->put(key: 'user_id', value: $userId);
        $this->put(key: '_authenticated', value: true);
        $this->put(key: '_login_time', value: time());

        // Register session in SessionRegistry
        if ($this->registry !== null) {
            $this->registry->register(
                userId   : $userId,
                sessionId: $this->getId(),
                metadata : [
                    'ip'         => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
                    'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
                ]
            );
        }

        // Audit
        $this->audit?->record(event: 'session_login', data: ['user_id' => $userId]);
    }

    /**
     * Regenerate session ID.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Prevents session fixation attacks.
     * Delegated to SessionAdapter for testability.
     *
     * @param bool $deleteOldSession Delete old session data.
     *
     * @return void
     */
    #[Override]
    public function regenerateId(bool $deleteOldSession = true) : void
    {
        $this->sessionAdapter->regenerateId(deleteOldSession: $deleteOldSession);

        // Audit
        $this->audit?->record(event: 'session_regenerated');
    }

    /**
     * Store a value in the session.
     *
     * Smart Conventions:
     * - Keys ending with '_secure' are auto-encrypted (via EncrypterFactory)
     * - TTL parameter sets automatic expiration
     * - Policy enforcement (via PolicyEnforcer)
     * - Audit logging (if enabled)
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Optional time-to-live in seconds.
     *
     * @return void
     */
    #[Override]
    public function put(string $key, mixed $value, int|null $ttl = null) : void
    {
        // Enforce policies before write (delegated to PolicyEnforcer)
        $this->policyEnforcer->enforce(data: $this->all());

        // Auto-encrypt if key ends with '_secure' (using EncrypterFactory)
        if (str_ends_with(haystack: $key, needle: '_secure')) {
            $value = $this->encrypter->encrypt(value: $value);
        }

        $this->store->put(key: $key, value: $value);

        // Auto-TTL if specified
        if ($ttl !== null) {
            $this->store->put(
                key  : "_ttl.{$key}",
                value: time() + $ttl
            );
        }

        // Audit logging
        $this->audit?->record(event: 'stored', data: compact('key', 'ttl'));

        // Dispatch event if events enabled
        $this->events?->dispatch(event: 'stored', data: compact('key', 'ttl'));
    }

    /**
     * Get all session data.
     *
     * @return array<string, mixed> All session data.
     */
    #[Override]
    public function all() : array
    {
        return $this->store->all();
    }

    /**
     * Get current session ID.
     *
     * Delegated to SessionAdapter.
     *
     * @return string Session ID.
     */
    #[Override]
    public function getId() : string
    {
        return $this->sessionAdapter->getId();
    }

    /**
     * Elevate user privileges.
     *
     * OWASP ASVS 3.2.1 Compliant
     *
     * Regenerates session ID when user gains elevated permissions.
     *
     * @param array<string> $newRoles New user roles.
     *
     * @return void
     */
    public function elevatePrivileges(array $newRoles) : void
    {
        // CRITICAL: Regenerate ID on privilege change
        $this->regenerateId();

        $this->put(key: 'roles', value: $newRoles);
        $this->put(key: '_privilege_elevation_time', value: time());

        // Audit
        $this->audit?->record(event: 'privilege_elevation', data: ['roles' => $newRoles]);
    }

    /**
     * Alias for put() to ease transition from the old API.
     */
    #[Override]
    public function set(string $key, mixed $value, int|null $ttl = null) : void
    {
        $this->put(key: $key, value: $value, ttl: $ttl);
    }

    /**
     * Alias for forget() to ease transition from the old API.
     */
    #[Override]
    public function remove(string $key) : void
    {
        $this->forget(key: $key);
    }

    /**
     * Remove a value from the session.
     *
     * Also removes associated TTL metadata.
     *
     * @param string $key The session key.
     *
     * @return void
     */
    #[Override]
    public function forget(string $key) : void
    {
        $this->store->delete(key: $key);
        $this->store->delete(key: "_ttl.{$key}");

        // Audit logging
        $this->audit?->record(event: 'deleted', data: compact(var_name: 'key'));

        // Dispatch event
        $this->events?->dispatch(event: 'deleted', data: compact(var_name: 'key'));
    }

    /**
     * Alias for forget() to ease transition from the old API.
     */
    #[Override]
    public function delete(string $key) : void
    {
        $this->forget(key: $key);
    }

    /**
     * Start session (idempotent) through the adapter.
     */
    #[Override]
    public function start() : bool
    {
        return $this->sessionAdapter->start();
    }

    /**
     * Proxy flash getter for convenience.
     */
    public function getFlash(string $key, mixed $default = null) : string|null
    {
        return $this->flash()->get(key: $key, default: $default);
    }

    /**
     * Retrieve a value from the session.
     *
     * Smart Conventions:
     * - Auto-checks TTL expiration
     * - Auto-decrypts '_secure' suffixed keys (via EncrypterFactory)
     * - Policy enforcement (via PolicyEnforcer)
     *
     * @param string $key     The session key.
     * @param mixed  $default Default value if key doesn't exist.
     *
     * @return mixed The retrieved value or default.
     */
    #[Override]
    public function get(string $key, mixed $default = null) : mixed
    {
        // Enforce policies before read (delegated to PolicyEnforcer)
        $this->policyEnforcer->enforce(data: $this->all());

        // Check TTL expiration first
        if ($this->isExpired(key: $key)) {
            $this->forget(key: $key);

            return $default;
        }

        $value = $this->store->get(key: $key, default: $default);

        // Auto-decrypt if encrypted (using EncrypterFactory with key rotation)
        if (str_ends_with(haystack: $key, needle: '_secure') && $value !== $default) {
            $value = $this->encrypter->decrypt(payload: $value);
        }

        // Audit logging
        $this->audit?->record(event: 'retrieved', data: compact(var_name: 'key'));

        return $value;
    }

    // ========================================
    // DSL BUILDERS (Provider-Consumer Pattern)
    // ========================================

    /**
     * Check if a key has expired.
     *
     * @param string $key The session key.
     *
     * @return bool True if expired.
     */
    private function isExpired(string $key) : bool
    {
        $expiry = $this->store->get(key: "_ttl.{$key}");

        return $expiry !== null && time() > $expiry;
    }

    /**
     * Access flash messages feature.
     *
     * Lazy-loaded on first access.
     *
     * @return Flash Flash messages manager.
     * @example
     *   $session->flash()->success('Saved!');
     *   $message = $session->flash()->get('success');
     *
     */
    #[Override]
    public function flash() : Flash
    {
        return $this->flash ??= new Flash(store: $this->store);
    }

    /**
     * Create a scoped session consumer (Technical DSL).
     *
     * Alias for for() - provides technical namespace isolation.
     *
     * @param string $namespace The scope namespace.
     *
     * @return SessionConsumer Consumer for scoped operations.
     * @example
     *   $session->scope('user')->ttl(3600)->put('id', 123);
     *
     */
    public function scope(string $namespace) : SessionConsumer
    {
        return $this->for(context: $namespace);
    }

    /**
     * Create a contextual session consumer (Natural DSL).
     *
     * This is the natural, domain-oriented method for creating
     * session consumers. Reads like: "for this context...".
     *
     * @param string $context The consumer context.
     *
     * @return SessionConsumer Consumer for contextual operations.
     * @example
     *   $session->for('cart')->secure()->put('items', $items);
     *
     */
    public function for(string $context) : SessionConsumer
    {
        return new SessionConsumer(namespace: $context, provider: $this);
    }

    // ========================================
    // POLICY SYSTEM
    // ========================================

    /**
     * Access events feature.
     *
     * Lazy-loaded on first access.
     *
     * @return Events Event dispatcher.
     * @example
     *   $session->events()->listen('stored', fn($data) => logger()->info($data));
     *
     */
    #[Override]
    public function events() : Events
    {
        return $this->events ??= new Events();
    }

    /**
     * Register a session policy.
     *
     * Policies are enforced on every put() and get() operation.
     * Delegated to PolicyEnforcer.
     *
     * @param PolicyInterface $policy The policy to register.
     *
     * @return self Fluent interface.
     * @example
     *   $session->registerPolicy(new MaxIdlePolicy(900));
     *   $session->registerPolicy(new SecureOnlyPolicy());
     *
     */
    public function registerPolicy(PolicyInterface $policy) : self
    {
        $this->policyEnforcer->register(policy: $policy);

        return $this;
    }

    // ========================================
    // AUDIT SYSTEM
    // ========================================

    /**
     * Register multiple policies at once.
     *
     * @param array<PolicyInterface> $policies Policies to register.
     *
     * @return self Fluent interface.
     */
    public function registerPolicies(array $policies) : self
    {
        $this->policyEnforcer->registerMany(policies: $policies);

        return $this;
    }

    /**
     * Get audit instance (if enabled).
     *
     * @return Audit|null Audit instance or null.
     */
    public function audit() : Audit|null
    {
        return $this->audit;
    }

    // ========================================
    // SNAPSHOT SYSTEM
    // ========================================

    /**
     * Enable audit logging.
     *
     * @param string|null $path Optional log file path.
     *
     * @return self Fluent interface.
     * @example
     *   $session->enableAudit('/var/log/session.log');
     *
     */
    public function enableAudit(string|null $path = null) : self
    {
        $this->audit = new Audit(logPath: $path);

        return $this;
    }

    /**
     * Create a snapshot of current session state.
     *
     * @param string $name Snapshot name.
     *
     * @return void
     * @example
     *   $session->snapshot('before_checkout');
     *
     */
    public function snapshot(string $name) : void
    {
        $this->snapshots()->snapshot(
            name: $name,
            data: $this->all()
        );

        // Audit logging
        $this->audit?->record(event: 'snapshot', data: compact(var_name: 'name'));
    }

    /**
     * Access snapshots feature.
     *
     * Lazy-loaded on first access.
     *
     * @return Snapshots Snapshot manager.
     */
    public function snapshots() : Snapshots
    {
        return $this->snapshots ??= new Snapshots();
    }

    // ========================================
    // SMART HELPERS
    // ========================================

    /**
     * Restore session state from a snapshot.
     *
     * @param string $name Snapshot name.
     *
     * @return void
     * @example
     *   $session->restore('before_checkout');
     *
     */
    public function restore(string $name) : void
    {
        $data = $this->snapshots()->restore(name: $name);

        if ($data === null) {
            return;
        }

        $this->flush();

        foreach ($data as $key => $value) {
            $this->put(key: $key, value: $value);
        }

        // Audit logging
        $this->audit?->record(event: 'restored', data: compact(var_name: 'name'));
    }

    /**
     * Remember pattern - lazy evaluation with caching.
     *
     * Retrieves value if exists, otherwise executes callback and stores result.
     *
     * @param string   $key      The cache key.
     * @param callable $callback Callback to generate value.
     * @param int|null $ttl      Optional TTL in seconds.
     *
     * @return mixed The cached or generated value.
     * @example
     *   $user = $session->remember('current_user', fn() => User::find($id));
     *
     */
    #[Override]
    public function remember(string $key, callable $callback, int|null $ttl = null) : mixed
    {
        if ($this->has(key: $key)) {
            return $this->get(key: $key);
        }

        $value = $callback();
        $this->put(key: $key, value: $value, ttl: $ttl);

        return $value;
    }

    // ========================================
    // INTERNAL HELPERS
    // ========================================

    /**
     * Check if a key exists in the session.
     *
     * @param string $key The session key.
     *
     * @return bool True if key exists and not expired.
     */
    #[Override]
    public function has(string $key) : bool
    {
        if ($this->isExpired(key: $key)) {
            $this->forget(key: $key);

            return false;
        }

        return $this->store->has(key: $key);
    }

    // ========================================
    // SERVICE ACCESSORS
    // ========================================

    /**
     * Create a temporary session consumer.
     *
     * Convenience method for consumers with TTL.
     *
     * @param int $seconds TTL in seconds.
     *
     * @return SessionConsumer Consumer with TTL.
     * @example
     *   $session->temporary(300)->put('otp', '123456');
     *
     */
    public function temporary(int $seconds) : SessionConsumer
    {
        return $this->for(context: 'temp')->ttl(seconds: $seconds);
    }

    /**
     * Get EncrypterFactory instance.
     *
     * @return EncrypterFactory Encrypter factory.
     */
    public function getEncrypter() : EncrypterFactory
    {
        return $this->encrypter;
    }

    /**
     * Get PolicyEnforcer instance.
     *
     * @return PolicyEnforcer Policy enforcer.
     */
    public function getPolicyEnforcer() : PolicyEnforcer
    {
        return $this->policyEnforcer;
    }

    /**
     * Get CookieManager instance.
     *
     * @return CookieManager Cookie manager.
     */
    public function getCookieManager() : CookieManager
    {
        return $this->cookieManager;
    }

    /**
     * Get SessionAdapter instance.
     *
     * @return SessionAdapter Session adapter.
     */
    public function getSessionAdapter() : SessionAdapter
    {
        return $this->sessionAdapter;
    }

    /**
     * Get SessionRegistry instance.
     *
     * @return SessionRegistry|null Session registry or null.
     */
    public function getRegistry() : SessionRegistry|null
    {
        return $this->registry;
    }

    /**
     * Enable SessionRegistry for multi-device control.
     *
     * @return self Fluent interface.
     */
    public function enableRegistry() : self
    {
        $this->registry = new SessionRegistry(store: $this->store);

        return $this;
    }

    /**
     * Get SessionNonce instance.
     *
     * @return SessionNonce|null Session nonce or null.
     */
    public function getNonce() : SessionNonce|null
    {
        return $this->nonce;
    }

    // ========================================
    // FEATURE LIFECYCLE MANAGEMENT
    // ========================================

    /**
     * Enable SessionNonce for replay attack prevention.
     *
     * @return self Fluent interface.
     */
    public function enableNonce() : self
    {
        $this->nonce = new SessionNonce(store: $this->store);

        return $this;
    }

    /**
     * Register a feature.
     *
     * @param FeatureInterface $feature Feature to register.
     *
     * @return self Fluent interface.
     */
    public function registerFeature(FeatureInterface $feature) : self
    {
        $this->features[$feature->getName()] = $feature;
        $feature->boot();

        return $this;
    }

    /**
     * Boot all registered features.
     *
     * @return void
     */
    private function bootFeatures() : void
    {
        foreach ($this->features as $feature) {
            if ($feature instanceof FeatureInterface) {
                $feature->boot();
            }
        }
    }
}

=== Lifecycle/SessionRegistry.php ===
<?php

declare(strict_types=1);

namespace Shomsy\Components\Foundation\HTTP\Session\Lifecycle;

use Shomsy\Components\Foundation\HTTP\Session\Data\StoreInterface;

/**
 * Session Component
 *
 * SessionRegistry - Multi-Device Session Control
 *
 * OWASP ASVS 3.3.8 Compliant
 *
 * Tracks and manages concurrent sessions per user.
 * Prevents session sharing and enables single-device enforcement.
 *
 * Features:
 * - Track multiple sessions per user
 * - Terminate other sessions on new login
 * - Concurrent session limit enforcement
 * - Session metadata tracking (IP, user agent, timestamp)
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session\Lifecycle
 */
final class SessionRegistry
{
    private const string REGISTRY_PREFIX = '_registry_';

    /**
     * SessionRegistry Constructor.
     *
     * @param StoreInterface $store Session storage backend.
     */
    public function __construct(
        private StoreInterface $store
    ) {}

    /**
     * Register a new session for a user.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID.
     * @param array  $metadata  Optional metadata (IP, user agent, etc).
     *
     * @return void
     */
    public function register(string $userId, string $sessionId, array $metadata = []) : void
    {
        $key      = self::REGISTRY_PREFIX . $userId;
        $sessions = $this->store->get(key: $key, default: []);

        $sessions[$sessionId] = array_merge($metadata, [
            'created_at'    => time(),
            'last_activity' => time(),
        ]);

        $this->store->put(key: $key, value: $sessions);
    }

    /**
     * Terminate all other sessions except current.
     *
     * Useful for "single device" enforcement.
     *
     * @param string $userId          User identifier.
     * @param string $exceptSessionId Current session to preserve.
     *
     * @return int Number of terminated sessions.
     */
    public function terminateOtherSessions(string $userId, string $exceptSessionId) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $metadata) {
            if ($sessionId !== $exceptSessionId) {
                // In real implementation, you'd call session_destroy() for each ID
                unset($sessions[$sessionId]);
                $terminated++;
            }
        }

        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->put(key: $key, value: $sessions);

        return $terminated;
    }

    /**
     * Get all active sessions for a user.
     *
     * @param string $userId User identifier.
     *
     * @return array<string, array> Session ID => metadata.
     */
    public function getActiveSessions(string $userId) : array
    {
        $key = self::REGISTRY_PREFIX . $userId;

        return $this->store->get(key: $key, default: []);
    }

    /**
     * Update last activity timestamp for a session.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID.
     *
     * @return void
     */
    public function updateActivity(string $userId, string $sessionId) : void
    {
        $sessions = $this->getActiveSessions($userId);

        if (isset($sessions[$sessionId])) {
            $sessions[$sessionId]['last_activity'] = time();

            $key = self::REGISTRY_PREFIX . $userId;
            $this->store->put(key: $key, value: $sessions);
        }
    }

    /**
     * Check if user has exceeded concurrent session limit.
     *
     * @param string $userId User identifier.
     * @param int    $limit  Maximum allowed concurrent sessions.
     *
     * @return bool True if limit exceeded.
     */
    public function hasExceededLimit(string $userId, int $limit) : bool
    {
        $sessions = $this->getActiveSessions($userId);

        return count($sessions) >= $limit;
    }

    /**
     * Check if a session is revoked.
     *
     * @param string $sessionId Session ID to check.
     *
     * @return bool True if revoked.
     */
    public function isRevoked(string $sessionId) : bool
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        return isset($revoked[$sessionId]);
    }

    // ========================================
    // REVOCATION LIST (OWASP ASVS 3.3.8)
    // ========================================

    /**
     * Get revocation details for a session.
     *
     * @param string $sessionId Session ID.
     *
     * @return array|null Revocation details or null.
     */
    public function getRevocationDetails(string $sessionId) : array|null
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        return $revoked[$sessionId] ?? null;
    }

    /**
     * Revoke all sessions for a user.
     *
     * Useful for:
     * - Password changes
     * - Security breaches
     * - Account lockout
     *
     * @param string $userId User identifier.
     * @param string $reason Revocation reason.
     *
     * @return int Number of sessions revoked.
     */
    public function revokeAllForUser(string $userId, string $reason = 'user_revocation') : int
    {
        $sessions = $this->getActiveSessions($userId);
        $count    = 0;

        foreach (array_keys($sessions) as $sessionId) {
            $this->revoke($sessionId, $reason);
            $count++;
        }

        // Also clear active sessions
        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->delete(key: $key);

        return $count;
    }

    /**
     * Add a session to revocation list.
     *
     * Revoked sessions cannot be used anymore, even if valid.
     * Useful for:
     * - Forced logout
     * - Security breaches
     * - Password changes
     * - Privilege changes
     *
     * @param string $sessionId Session ID to revoke.
     * @param string $reason    Revocation reason.
     *
     * @return void
     */
    public function revoke(string $sessionId, string $reason = 'manual_revocation') : void
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        $revoked[$sessionId] = [
            'revoked_at' => time(),
            'reason'     => $reason,
        ];

        $this->store->put(key: $key, value: $revoked);
    }

    /**
     * Remove a session from revocation list.
     *
     * Use with caution - only for administrative purposes.
     *
     * @param string $sessionId Session ID to unrevoke.
     *
     * @return bool True if was revoked and now removed.
     */
    public function unrevoke(string $sessionId) : bool
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        if (! isset($revoked[$sessionId])) {
            return false;
        }

        unset($revoked[$sessionId]);
        $this->store->put(key: $key, value: $revoked);

        return true;
    }

    /**
     * Clear old revoked sessions.
     *
     * Removes revocations older than specified age.
     *
     * @param int $maxAge Maximum age in seconds (default: 30 days).
     *
     * @return int Number of cleared revocations.
     */
    public function clearOldRevocations(int $maxAge = 2592000) : int
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get($key, []);
        $cleared = 0;

        foreach ($revoked as $sessionId => $data) {
            if (time() - $data['revoked_at'] > $maxAge) {
                unset($revoked[$sessionId]);
                $cleared++;
            }
        }

        $this->store->put(key: $key, value: $revoked);

        return $cleared;
    }

    /**
     * Count total revoked sessions.
     *
     * @return int Count.
     */
    public function countRevoked() : int
    {
        return count($this->getAllRevoked());
    }

    /**
     * Get all revoked sessions.
     *
     * @return array<string, array> Session ID => revocation data.
     */
    public function getAllRevoked() : array
    {
        $key = self::REGISTRY_PREFIX . 'revoked';

        return $this->store->get(key: $key, default: []);
    }

    /**
     * Get sessions grouped by device/user agent.
     *
     * @param string $userId User identifier.
     *
     * @return array<string, array> Device fingerprint => sessions.
     */
    public function getSessionsByDevice(string $userId) : array
    {
        $sessions = $this->getActiveSessions($userId);
        $byDevice = [];

        foreach ($sessions as $sessionId => $metadata) {
            $fingerprint              = $metadata['user_agent'] ?? 'unknown';
            $byDevice[$fingerprint][] = array_merge(['session_id' => $sessionId], $metadata);
        }

        return $byDevice;
    }

    // ========================================
    // DEVICE MANAGEMENT
    // ========================================

    /**
     * Terminate all sessions from a specific device.
     *
     * @param string $userId    User identifier.
     * @param string $userAgent User agent string to match.
     *
     * @return int Number of terminated sessions.
     */
    public function terminateDevice(string $userId, string $userAgent) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $metadata) {
            if (($metadata['user_agent'] ?? '') === $userAgent) {
                $this->terminateSession($userId, $sessionId);
                $terminated++;
            }
        }

        return $terminated;
    }

    /**
     * Terminate a specific session.
     *
     * @param string $userId    User identifier.
     * @param string $sessionId Session ID to terminate.
     *
     * @return bool True if session was found and terminated.
     */
    public function terminateSession(string $userId, string $sessionId) : bool
    {
        $sessions = $this->getActiveSessions($userId);

        if (! isset($sessions[$sessionId])) {
            return false;
        }

        unset($sessions[$sessionId]);

        $key = self::REGISTRY_PREFIX . $userId;
        $this->store->put(key: $key, value: $sessions);

        return true;
    }
}

=== Observability/MetricCollector.php ===
<?php

declare(strict_types=1);

namespace Avax\Foundation\HTTP\Session\Observability;

/**
 * MetricCollector
 *
 * Simple in-memory metrics collector for Prometheus-compatible exporters.
 *
 * @package Avax\Foundation\HTTP\Session\Observability
 */
final class MetricCollector
{
    private array $metrics
        = [
            'session_ops_total'       => 0,
            'session_errors_total'    => 0,
            'session_latency_seconds' => []
        ];

    public function increment(string $metric) : void
    {
        if (! isset($this->metrics[$metric])) {
            $this->metrics[$metric] = 0;
        }
        $this->metrics[$metric]++;
    }

    public function observeLatency(float $seconds) : void
    {
        $this->metrics['session_latency_seconds'][] = $seconds;
    }

    public function export() : array
    {
        $avgLatency = empty($this->metrics['session_latency_seconds'])
            ? 0
            : array_sum($this->metrics['session_latency_seconds']) / count($this->metrics['session_latency_seconds']);

        return [
            'session_ops_total'           => $this->metrics['session_ops_total'],
            'session_errors_total'        => $this->metrics['session_errors_total'],
            'session_latency_avg_seconds' => $avgLatency,
        ];
    }
}

=== Observability/MetricCollectorInterface.php ===
<?php
declare(strict_types=1);

namespace Avax\Foundation\HTTP\Session\Observability;

interface MetricCollectorInterface
{
    public function increment(string $metric, array $labels = []) : void;

    public function observe(string $metric, float $value, array $labels = []) : void;
}

=== Observability/NullCollector.php ===
<?php
declare(strict_types=1);

namespace Avax\Foundation\HTTP\Session\Observability;

final class NullCollector implements MetricCollectorInterface
{
    public function increment(string $metric, array $labels = []) : void {}

    public function observe(string $metric, float $value, array $labels = []) : void {}
}

=== Observability/PrometheusExporter.php ===
<?php

declare(strict_types=1);

namespace Avax\Foundation\HTTP\Session\Observability;

/**
 * PrometheusExporter
 *
 * Exports session metrics in Prometheus text-based exposition format.
 *
 * @package Foundation\HTTP\Session\Observability
 */
final readonly class PrometheusExporter
{
    public function __construct(
        private MetricCollector $collector
    ) {}

    public function render() : string
    {
        $metrics = $this->collector->export();
        $lines   = [];

        foreach ($metrics as $name => $value) {
            $lines[] = sprintf('# TYPE %s gauge', $name);
            $lines[] = sprintf('%s %s', $name, $value);
        }

        return implode(separator: PHP_EOL, array: $lines) . PHP_EOL;
    }
}

=== Observability/SessionHealthProbe.php ===
<?php
declare(strict_types=1);

namespace Avax\Foundation\HTTP\Session\Observability;

final class SessionHealthProbe
{
    public function __construct(private string $sessionPath) {}

    public function isHealthy() : bool
    {
        return is_dir($this->sessionPath) && is_writable($this->sessionPath);
    }
}

=== Security/CookieManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use InvalidArgumentException;

/**
 * CookieManager - Centralized Cookie Policy Enforcement
 *
 * OWASP ASVS 3.4.1 Compliant
 *
 * Enforces secure cookie attributes (Secure, HttpOnly, SameSite).
 * Prevents common cookie-based attacks:
 * - XSS (via HttpOnly)
 * - Man-in-the-middle (via Secure)
 * - CSRF (via SameSite)
 *
 * @package Avax\HTTP\Session\Security
 */
final readonly class CookieManager
{
    /**
     * CookieManager Constructor.
     *
     * @param bool   $secure   Require HTTPS (default: true).
     * @param bool   $httpOnly Prevent JavaScript access (default: true).
     * @param string $sameSite SameSite policy: 'Lax', 'Strict', 'None' (default: 'Lax').
     * @param string $path     Cookie path (default: '/').
     * @param string $domain   Cookie domain (default: '').
     * @param int    $lifetime Cookie lifetime in seconds (default: 0 = session).
     */
    public function __construct(
        private bool   $secure = true,
        private bool   $httpOnly = true,
        private string $sameSite = 'Lax',
        private string $path = '/',
        private string $domain = '',
        private int    $lifetime = 0
    )
    {
        // Validate SameSite
        if (! in_array($sameSite, ['Lax', 'Strict', 'None'], true)) {
            throw new InvalidArgumentException(
                "Invalid SameSite value: {$sameSite}. Must be 'Lax', 'Strict', or 'None'."
            );
        }

        // SameSite=None requires Secure flag
        if ($sameSite === 'None' && ! $secure) {
            throw new InvalidArgumentException(
                'SameSite=None requires Secure flag to be true (HTTPS only).'
            );
        }
    }

    /**
     * Create a strict security configuration.
     *
     * - SameSite=Strict
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function strict() : self
    {
        return new self(
            secure  : true,
            httpOnly: true,
            sameSite: 'Strict'
        );
    }

    /**
     * Create a lax security configuration (default).
     *
     * - SameSite=Lax
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function lax() : self
    {
        return new self(
            secure  : true,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Create a development configuration (insecure).
     *
     * - SameSite=Lax
     * - Secure=false
     * - HttpOnly=true
     *
     * @return self
     */
    public static function development() : self
    {
        return new self(
            secure  : false,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Set a cookie with enforced security attributes.
     *
     * @param string $name    Cookie name.
     * @param string $value   Cookie value.
     * @param int    $expires Expiration timestamp (0 = session).
     *
     * @return bool True on success.
     */
    public function set(string $name, string $value, int $expires = 0) : bool
    {
        $expires = $expires ?: ($this->lifetime ? time() + $this->lifetime : 0);

        // PHP 7.3+ array format
        return setcookie($name, $value, [
            'expires'  => $expires,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Delete a cookie.
     *
     * Sets expiration to past time to trigger browser deletion.
     *
     * @param string $name Cookie name.
     *
     * @return bool True on success.
     */
    public function delete(string $name) : bool
    {
        return setcookie($name, '', [
            'expires'  => time() - 3600,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get a cookie value.
     *
     * @param string     $name    Cookie name.
     * @param mixed|null $default Default value.
     *
     * @return mixed Cookie value or default.
     */
    public function get(string $name, mixed $default = null) : mixed
    {
        return $_COOKIE[$name] ?? $default;
    }

    /**
     * Check if a cookie exists.
     *
     * @param string $name Cookie name.
     *
     * @return bool True if exists.
     */
    public function has(string $name) : bool
    {
        return isset($_COOKIE[$name]);
    }

    /**
     * Configure session cookie parameters.
     *
     * OWASP ASVS 3.2.2 Compliant
     *
     * Applies security policy to PHP session cookies.
     *
     * @return void
     */
    public function configureSessionCookie() : void
    {
        session_set_cookie_params([
            'lifetime' => $this->lifetime,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get current cookie configuration.
     *
     * @return array<string, mixed> Configuration array.
     */
    public function getConfig() : array
    {
        return [
            'secure'   => $this->secure,
            'httpOnly' => $this->httpOnly,
            'sameSite' => $this->sameSite,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'lifetime' => $this->lifetime,
        ];
    }

    /**
     * Check if configuration is production-ready.
     *
     * @return bool True if secure configuration.
     */
    public function isSecure() : bool
    {
        return $this->secure && $this->httpOnly && $this->sameSite !== 'None';
    }
}

=== Security/Crypto/FipsAwareEncrypter.php ===
<?php

declare(strict_types=1);

namespace Foundation\HTTP\Session\Security\Crypto;

use RuntimeException;

/**
 * FipsAwareEncrypter
 *
 * Provides dual-mode encryption supporting AES-256-GCM and AES-256-CBC-HMAC-SHA256.
 * Automatically detects FIPS mode through OPENSSL_FIPS environment variable.
 *
 * @package Foundation\HTTP\Session\Security\Crypto
 */
final class FipsAwareEncrypter
{
    public function __construct(
        private readonly string $key
    ) {}

    public function encrypt(string $plaintext) : string
    {
        $fipsMode = getenv('OPENSSL_FIPS') === '1';

        if ($fipsMode) {
            $iv         = random_bytes(16);
            $ciphertext = openssl_encrypt($plaintext, 'AES-256-CBC', $this->key, OPENSSL_RAW_DATA, $iv);
            $hmac       = hash_hmac('sha256', $ciphertext, $this->key, true);

            return base64_encode($iv . $hmac . $ciphertext);
        }

        $iv         = random_bytes(12);
        $tag        = '';
        $ciphertext = openssl_encrypt($plaintext, 'aes-256-gcm', $this->key, OPENSSL_RAW_DATA, $iv, $tag);

        return base64_encode($iv . $tag . $ciphertext);
    }

    public function decrypt(string $ciphertext) : string
    {
        $decoded = base64_decode($ciphertext, true);

        if (getenv('OPENSSL_FIPS') === '1') {
            $iv   = substr($decoded, 0, 16);
            $hmac = substr($decoded, 16, 32);
            $ct   = substr($decoded, 48);

            $calcHmac = hash_hmac('sha256', $ct, $this->key, true);
            if (! hash_equals($hmac, $calcHmac)) {
                throw new RuntimeException('HMAC verification failed');
            }

            return openssl_decrypt($ct, 'AES-256-CBC', $this->key, OPENSSL_RAW_DATA, $iv);
        }

        $iv  = substr($decoded, 0, 12);
        $tag = substr($decoded, 12, 16);
        $ct  = substr($decoded, 28);

        return openssl_decrypt($ct, 'aes-256-gcm', $this->key, OPENSSL_RAW_DATA, $iv, $tag);
    }
}

=== Security/Crypto/NullEncrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Crypto;

use Avax\HTTP\Session\Contracts\Security\Encrypter;

/**
 * NullEncrypter - No-Op Encrypter
 *
 * Dummy encrypter for testing or development.
 * Does NOT actually encrypt - just base64 encodes.
 *
 * @warning DO NOT use in production!
 *
 * @package Avax\HTTP\Session\Crypto
 */
final class NullEncrypter implements Encrypter
{
    /**
     * {@inheritdoc}
     */
    public function encrypt(mixed $value) : string
    {
        return base64_encode(serialize($value));
    }

    /**
     * {@inheritdoc}
     */
    public function decrypt(string $encrypted) : mixed
    {
        return unserialize(base64_decode($encrypted));
    }
}

=== Security/Crypto/OpenSSLEncrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Crypto;

use Avax\HTTP\Session\Contracts\Security\Encrypter;
use InvalidArgumentException;
use RuntimeException;

/**
 * OpenSSLEncrypter - Production-Grade AES-256-GCM Encryption
 *
 * OWASP ASVS 3.3.2 & 3.3.3 Compliant
 *
 * Features:
 * - AES-256-GCM (Authenticated Encryption with Associated Data)
 * - Automatic IV generation per encryption
 * - Authentication tag for integrity verification
 * - Tampering detection
 * - Cryptographically secure random IVs
 *
 * Security Properties:
 * - Confidentiality: AES-256 encryption
 * - Integrity: GCM authentication tag
 * - Non-replayability: Unique IV per operation
 *
 * @package Avax\HTTP\Session\Security\Crypto
 */
final class OpenSSLEncrypter implements Encrypter
{
    private const CIPHER     = 'aes-256-gcm';
    private const IV_LENGTH  = 12;      // 96 bits for GCM
    private const TAG_LENGTH = 16;     // 128 bits authentication tag

    /**
     * OpenSSLEncrypter Constructor.
     *
     * @param string $key Encryption key (32 bytes for AES-256).
     *
     * @throws \InvalidArgumentException If key length is invalid.
     */
    public function __construct(
        private string $key
    )
    {
        if (strlen($key) !== 32) {
            throw new InvalidArgumentException(
                'Encryption key must be exactly 32 bytes for AES-256'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function encrypt(mixed $value) : string
    {
        $plaintext = serialize($value);

        // Generate cryptographically secure random IV
        $iv = random_bytes(self::IV_LENGTH);

        // Encrypt with AES-256-GCM
        $tag        = '';
        $ciphertext = openssl_encrypt(
            $plaintext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            '',
            self::TAG_LENGTH
        );

        if ($ciphertext === false) {
            throw new RuntimeException('Encryption failed');
        }

        // Package: IV + Tag + Ciphertext (all binary)
        $package = $iv . $tag . $ciphertext;

        // Encode for safe storage
        return base64_encode($package);
    }

    /**
     * {@inheritdoc}
     */
    public function decrypt(string $payload) : mixed
    {
        // Decode from base64
        $package = base64_decode($payload, true);

        if ($package === false || strlen($package) < (self::IV_LENGTH + self::TAG_LENGTH)) {
            throw new RuntimeException('Invalid encrypted payload');
        }

        // Unpack: IV + Tag + Ciphertext
        $iv         = substr($package, 0, self::IV_LENGTH);
        $tag        = substr($package, self::IV_LENGTH, self::TAG_LENGTH);
        $ciphertext = substr($package, self::IV_LENGTH + self::TAG_LENGTH);

        // Decrypt with authentication tag verification
        $plaintext = openssl_decrypt(
            $ciphertext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag
        );

        if ($plaintext === false) {
            // Tampering detected or invalid key
            throw new RuntimeException('Decryption failed - possible tampering detected');
        }

        return unserialize($plaintext);
    }
}

=== Security/CsrfToken.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;
use RuntimeException;

/**
 * CsrfToken - CSRF Token Management
 *
 * OWASP ASVS 4.2.2 Compliant
 *
 * Session-bound CSRF token generation and verification.
 *
 * Features:
 * - Cryptographically secure tokens
 * - Session-bound (invalidated on logout)
 * - Constant-time comparison
 * - Automatic rotation
 *
 * @package Avax\HTTP\Session\Security
 */
final class CsrfToken
{
    private const TOKEN_KEY    = '_csrf_token';
    private const TOKEN_LENGTH = 32;  // 256 bits

    /**
     * CsrfToken Constructor.
     *
     * @param Store $store Session storage.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Verify token or throw exception.
     *
     * @param string $providedToken Token to verify.
     *
     * @return void
     *
     * @throws \RuntimeException If token invalid.
     */
    public function verifyOrFail(string $providedToken) : void
    {
        if (! $this->verify($providedToken)) {
            throw new RuntimeException('CSRF token mismatch - possible CSRF attack');
        }
    }

    /**
     * Verify CSRF token.
     *
     * Uses constant-time comparison to prevent timing attacks.
     *
     * @param string $providedToken Token to verify.
     *
     * @return bool True if valid.
     */
    public function verify(string $providedToken) : bool
    {
        $storedToken = $this->store->get(self::TOKEN_KEY);

        if ($storedToken === null) {
            return false;
        }

        return hash_equals($storedToken, $providedToken);
    }

    /**
     * Get current token (generate if missing).
     *
     * @return string Current token.
     */
    public function getToken() : string
    {
        $token = $this->store->get(self::TOKEN_KEY);

        if ($token === null) {
            return $this->generate();
        }

        return $token;
    }

    /**
     * Generate a new CSRF token.
     *
     * Stores token in session for verification.
     *
     * @return string Hex-encoded token.
     */
    public function generate() : string
    {
        $token = bin2hex(random_bytes(self::TOKEN_LENGTH));
        $this->store->put(self::TOKEN_KEY, $token);

        return $token;
    }

    /**
     * Rotate CSRF token.
     *
     * Generates new token, invalidating the old one.
     *
     * @return string New token.
     */
    public function rotate() : string
    {
        return $this->generate();
    }

    /**
     * Clear CSRF token.
     *
     * Call on logout to invalidate token.
     *
     * @return void
     */
    public function clear() : void
    {
        $this->store->delete(self::TOKEN_KEY);
    }
}

=== Security/EncrypterFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Security\Crypto\OpenSSLEncrypter;
use Exception;
use RuntimeException;

/**
 * EncrypterFactory - Encrypter with Key Management
 *
 * OWASP ASVS 3.1.3 Compliant
 *
 * Integrates KeyManager with encryption operations.
 * Supports key rotation by attempting decryption with all known keys.
 *
 * @package Avax\HTTP\Session\Security
 */
final class EncrypterFactory
{
    private KeyManager $keyManager;

    /**
     * EncrypterFactory Constructor.
     *
     * @param KeyManager|null $keyManager Key manager (optional, creates default).
     */
    public function __construct(KeyManager|null $keyManager = null)
    {
        $this->keyManager = $keyManager ?? new KeyManager();
    }

    /**
     * Encrypt with active key.
     *
     * @param mixed $value Value to encrypt.
     *
     * @return string Encrypted payload.
     */
    public function encrypt(mixed $value) : string
    {
        return $this->create()->encrypt(value: $value);
    }

    /**
     * Create encrypter with active key.
     *
     * @return Encrypter Encrypter instance.
     */
    public function create() : Encrypter
    {
        $activeKey = $this->keyManager->getActiveKey();

        return new OpenSSLEncrypter(key: $activeKey);
    }

    /**
     * Decrypt with key rotation support.
     *
     * Attempts decryption with all known keys (active + rotated).
     * Enables seamless key rotation.
     *
     * @param string $payload Encrypted payload.
     *
     * @return mixed Decrypted value.
     *
     * @throws \RuntimeException If decryption fails with all keys.
     */
    public function decrypt(string $payload) : mixed
    {
        $allKeys = $this->keyManager->getAllKeys();

        foreach ($allKeys as $key) {
            try {
                $encrypter = new OpenSSLEncrypter(key: $key);

                return $encrypter->decrypt(payload: $payload);
            } catch (Exception $e) {
                // Try next key
                continue;
            }
        }

        // All keys failed
        throw new RuntimeException(
            message: 'Decryption failed with all known keys - possible tampering or key mismatch'
        );
    }
}

=== Security/KeyManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use RuntimeException;

/**
 * KeyManager - Encryption Key Management
 *
 * OWASP ASVS 3.1.1 & 3.1.2 Compliant
 *
 * Manages encryption keys with rotation support.
 * Allows seamless key rotation without invalidating existing sessions.
 *
 * Keys are loaded from environment variables for security.
 *
 * Environment Variables:
 * - SESSION_KEY_ACTIVE: Current encryption key (32 bytes hex)
 * - SESSION_KEY_ROTATED: Comma-separated previous keys (optional)
 *
 * @package Avax\HTTP\Session\Security
 */
final class KeyManager
{
    /**
     * Generate a new random key.
     *
     * Helper method for key generation (use offline).
     *
     * @return string Hex-encoded 32-byte key.
     */
    public static function generateKey() : string
    {
        return bin2hex(random_bytes(32));
    }

    /**
     * Get all keys (active + rotated).
     *
     * Useful for decryption attempts with multiple keys.
     *
     * @return array<string> All available keys.
     */
    public function getAllKeys() : array
    {
        return array_merge(
            [$this->getActiveKey()],
            $this->getPreviousKeys()
        );
    }

    /**
     * Get the active encryption key.
     *
     * @return string Active key (32 bytes).
     *
     * @throws \RuntimeException If key not configured.
     */
    public function getActiveKey() : string
    {
        $key = getenv('SESSION_KEY_ACTIVE');

        if ($key === false || $key === '') {
            throw new RuntimeException(
                'SESSION_KEY_ACTIVE environment variable not set'
            );
        }

        // Convert from hex to binary
        $binaryKey = hex2bin($key);

        if ($binaryKey === false || strlen($binaryKey) !== 32) {
            throw new RuntimeException(
                'SESSION_KEY_ACTIVE must be 64 hex characters (32 bytes)'
            );
        }

        return $binaryKey;
    }

    /**
     * Get previously rotated keys.
     *
     * Used to decrypt sessions encrypted with old keys.
     *
     * @return array<string> Array of previous keys (32 bytes each).
     */
    public function getPreviousKeys() : array
    {
        $keysString = getenv('SESSION_KEY_ROTATED');

        if ($keysString === false || $keysString === '') {
            return [];
        }

        $hexKeys    = explode(',', $keysString);
        $binaryKeys = [];

        foreach ($hexKeys as $hexKey) {
            $hexKey    = trim($hexKey);
            $binaryKey = hex2bin($hexKey);

            if ($binaryKey !== false && strlen($binaryKey) === 32) {
                $binaryKeys[] = $binaryKey;
            }
        }

        return $binaryKeys;
    }
}

=== Security/NativeServerContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Security\ServerContext;

/**
 * NativeServerContext - PHP Native Server Context
 *
 * Default implementation using PHP's $_SERVER superglobal.
 *
 * @package Avax\HTTP\Session\Security
 */
final class NativeServerContext implements ServerContext
{
    /**
     * {@inheritdoc}
     */
    public function getUserAgent() : string
    {
        return $_SERVER['HTTP_USER_AGENT'] ?? '';
    }

    /**
     * {@inheritdoc}
     */
    public function isSecure() : bool
    {
        return isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';
    }

    /**
     * {@inheritdoc}
     */
    public function getClientIp() : string
    {
        return $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
    }
}

=== Security/Policies/CompositePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use Exception;
use InvalidArgumentException;
use RuntimeException;

/**
 * CompositePolicy - Composite Policy Pattern
 *
 * Combines multiple policies into a single policy.
 * Enables grouping and reusable policy sets.
 *
 * Execution Modes:
 * - ALL: All policies must pass (default, AND logic)
 * - ANY: At least one policy must pass (OR logic)
 * - NONE: All policies must fail (inverse logic)
 *
 * @example
 *   $composite = new CompositePolicy([
 *       new MaxIdlePolicy(900),
 *       new SecureOnlyPolicy(),
 *       new SessionIpPolicy()
 *   ]);
 *
 * @example With ANY mode
 *   $composite = CompositePolicy::any([
 *       new AdminRolePolicy(),
 *       new SuperuserPolicy()
 *   ]);
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class CompositePolicy implements PolicyInterface
{
    public const MODE_ALL  = 'all';
    public const MODE_ANY  = 'any';
    public const MODE_NONE = 'none';

    /**
     * @var array<PolicyInterface> Child policies
     */
    private array $policies = [];

    /**
     * CompositePolicy Constructor.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $mode     Execution mode (all|any|none).
     * @param string                 $name     Policy name.
     */
    public function __construct(
        array          $policies = [],
        private string $mode = self::MODE_ALL,
        private string $name = 'composite'
    )
    {
        foreach ($policies as $policy) {
            $this->add($policy);
        }
    }

    /**
     * Add a child policy.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy) : self
    {
        $this->policies[] = $policy;

        return $this;
    }

    /**
     * Create composite with ALL mode (AND logic).
     *
     * All policies must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function all(array $policies, string $name = 'composite_all') : self
    {
        return new self($policies, self::MODE_ALL, $name);
    }

    /**
     * Create composite with ANY mode (OR logic).
     *
     * At least one policy must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function any(array $policies, string $name = 'composite_any') : self
    {
        return new self($policies, self::MODE_ANY, $name);
    }

    /**
     * Create composite with NONE mode (inverse logic).
     *
     * All policies must fail.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function none(array $policies, string $name = 'composite_none') : self
    {
        return new self($policies, self::MODE_NONE, $name);
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        if (empty($this->policies)) {
            return; // No policies to enforce
        }

        match ($this->mode) {
            self::MODE_ALL  => $this->enforceAll($data),
            self::MODE_ANY  => $this->enforceAny($data),
            self::MODE_NONE => $this->enforceNone($data),
            default         => throw new InvalidArgumentException("Invalid mode: {$this->mode}")
        };
    }

    /**
     * Enforce ALL policies (AND logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy fails.
     */
    private function enforceAll(array $data) : void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
            } catch (Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        if (! empty($failures)) {
            throw new RuntimeException(
                sprintf(
                    'Composite policy "%s" failed (ALL mode): %s',
                    $this->name,
                    implode('; ', $failures)
                )
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * Enforce ANY policy (OR logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If all policies fail.
     */
    private function enforceAny(array $data) : void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);

                return; // At least one passed, success!
            } catch (Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        // All policies failed
        throw new RuntimeException(
            sprintf(
                'Composite policy "%s" failed (ANY mode): All child policies failed: %s',
                $this->name,
                implode('; ', $failures)
            )
        );
    }

    /**
     * Enforce NONE policy (inverse logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy passes.
     */
    private function enforceNone(array $data) : void
    {
        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);

                // Policy passed, but we wanted it to fail
                throw new RuntimeException(
                    sprintf(
                        'Composite policy "%s" failed (NONE mode): Policy "%s" should have failed but passed',
                        $this->name,
                        $policy->getName()
                    )
                );
            } catch (Exception $e) {
                // Policy failed, which is what we wanted (continue)
                continue;
            }
        }

        // All policies failed, which is what we wanted (success)
    }

    /**
     * Get child policies.
     *
     * @return array<PolicyInterface> Child policies.
     */
    public function getPolicies() : array
    {
        return $this->policies;
    }

    /**
     * Get execution mode.
     *
     * @return string Mode (all|any|none).
     */
    public function getMode() : string
    {
        return $this->mode;
    }

    /**
     * Check if composite is empty.
     *
     * @return bool True if no child policies.
     */
    public function isEmpty() : bool
    {
        return empty($this->policies);
    }

    /**
     * Get number of child policies.
     *
     * @return int Count.
     */
    public function count() : int
    {
        return count($this->policies);
    }
}

=== Security/Policies/CrossAgentPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use Avax\HTTP\Session\Contracts\Security\ServerContext;
use Avax\HTTP\Session\Exceptions\PolicyViolationException;
use Avax\HTTP\Session\Security\NativeServerContext;

/**
 * CrossAgentPolicy - User Agent Consistency Policy
 *
 * Detects session hijacking by comparing User-Agent strings.
 * If User-Agent changes during session lifetime, policy is violated.
 *
 * Uses ServerContext for testability.
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class CrossAgentPolicy implements PolicyInterface
{
    /**
     * CrossAgentPolicy Constructor.
     *
     * @param ServerContext|null $serverContext Server context (default: native).
     */
    public function __construct(
        private ServerContext|null $serverContext = null
    )
    {
        $this->serverContext ??= new NativeServerContext();
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        $storedAgent  = $data['_user_agent'] ?? null;
        $currentAgent = $this->serverContext->getUserAgent();

        // First time - store current agent
        if ($storedAgent === null) {
            return;
        }

        // Agent mismatch - possible hijacking
        if ($storedAgent !== $currentAgent) {
            throw PolicyViolationException::forPolicy(
                'cross_agent',
                'User Agent mismatch detected - possible session hijacking'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return 'cross_agent';
    }
}

=== Security/Policies/MaxIdlePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use RuntimeException;

/**
 * MaxIdlePolicy - Session Idle Timeout Policy
 *
 * Enforces maximum idle time for sessions. If session is inactive
 * longer than the configured period, policy violation is triggered.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class MaxIdlePolicy implements PolicyInterface
{
    /**
     * MaxIdlePolicy Constructor.
     *
     * @param int $maxIdleSeconds Maximum idle time in seconds (default: 30 minutes).
     */
    public function __construct(
        private int $maxIdleSeconds = 1800
    ) {}

    /**
     * Enforce max idle policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session is idle too long.
     */
    public function enforce(array $data) : void
    {
        $lastActivity = $data['_last_activity'] ?? null;

        if ($lastActivity === null) {
            return;
        }

        $idleTime = time() - $lastActivity;

        if ($idleTime > $this->maxIdleSeconds) {
            throw new RuntimeException(
                sprintf(
                    'Session expired due to inactivity. Idle for %d seconds (max: %d).',
                    $idleTime,
                    $this->maxIdleSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'max_idle';
    }
}

=== Security/Policies/MaxLifetimePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use RuntimeException;

/**
 * MaxLifetimePolicy - Session Maximum Lifetime Policy
 *
 * Enforces absolute maximum lifetime for sessions regardless of activity.
 * Once session reaches max lifetime, it must be terminated.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class MaxLifetimePolicy implements PolicyInterface
{
    /**
     * MaxLifetimePolicy Constructor.
     *
     * @param int $maxLifetimeSeconds Maximum session lifetime in seconds (default: 1 hour).
     */
    public function __construct(
        private int $maxLifetimeSeconds = 3600
    ) {}

    /**
     * Enforce max lifetime policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session exceeded max lifetime.
     */
    public function enforce(array $data) : void
    {
        $createdAt = $data['_created_at'] ?? null;

        if ($createdAt === null) {
            return;
        }

        $lifetime = time() - $createdAt;

        if ($lifetime > $this->maxLifetimeSeconds) {
            throw new RuntimeException(
                sprintf(
                    'Session expired (max lifetime). Active for %d seconds (max: %d).',
                    $lifetime,
                    $this->maxLifetimeSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'max_lifetime';
    }
}

=== Security/Policies/PolicyGroupBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use RuntimeException;

/**
 * PolicyGroupBuilder - Fluent Builder for Policy Groups
 *
 * Provides Spring Security-style fluent API for building policy groups.
 * Makes complex policy configurations readable and maintainable.
 *
 * @example Basic usage
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->add(new MaxIdlePolicy(900))
 *           ->add(new SecureOnlyPolicy())
 *       ->build();
 *
 * @example Complex groups
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->maxIdle(900)
 *           ->secureOnly()
 *           ->requireAny()
 *               ->ipBinding()
 *               ->userAgentBinding()
 *           ->endGroup()
 *       ->build();
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class PolicyGroupBuilder
{
    /**
     * @var CompositePolicy|null Root composite policy
     */
    private CompositePolicy|null $root = null;

    /**
     * @var CompositePolicy|null Current working composite
     */
    private CompositePolicy|null $current = null;

    /**
     * @var array<CompositePolicy> Stack for nested groups
     */
    private array $stack = [];

    /**
     * PolicyGroupBuilder Constructor.
     */
    private function __construct()
    {
        // Use create() factory instead
    }

    /**
     * Create a security hardened preset.
     *
     * Includes:
     * - MaxIdle: 15 minutes
     * - MaxLifetime: 8 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Strict
     * - User Agent Binding
     *
     * @return PolicyInterface Built policy.
     */
    public static function securityHardened() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'security_hardened')
            ->maxIdle(seconds: 900)              // 15 minutes
            ->maxLifetime(seconds: 28800)        // 8 hours
            ->secureOnly()
            ->ipBinding()
            ->userAgentBinding()
            ->build();
    }

    /**
     * Build the final policy structure.
     *
     * @return PolicyInterface|CompositePolicy Built policy.
     */
    public function build() : PolicyInterface|CompositePolicy
    {
        if ($this->root === null) {
            throw new RuntimeException(message: 'No policies configured. Use requireAll(), requireAny(), or requireNone() to start.');
        }

        // If only one policy in root, return it directly
        if ($this->root->count() === 1) {
            return $this->root->getPolicies()[0];
        }

        return $this->root;
    }

    /**
     * Add CrossAgentPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function userAgentBinding() : self
    {
        return $this->add(policy: new CrossAgentPolicy());
    }

    /**
     * Add a custom policy to current group.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy) : self
    {
        if ($this->current === null) {
            throw new RuntimeException(message: 'No active group. Call requireAll(), requireAny(), or requireNone() first.');
        }

        $this->current->add(policy: $policy);

        return $this;
    }

    /**
     * Add SessionIpPolicy to current group.
     *
     * @param bool $strict Strict mode (default: true).
     *
     * @return self Fluent interface.
     */
    public function ipBinding(bool $strict = true) : self
    {
        return $this->add(policy: new SessionIpPolicy(strictMode: $strict));
    }

    /**
     * Add SecureOnlyPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function secureOnly() : self
    {
        return $this->add(policy: new SecureOnlyPolicy());
    }

    /**
     * Add MaxLifetimePolicy to current group.
     *
     * @param int $seconds Maximum lifetime in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxLifetime(int $seconds) : self
    {
        return $this->add(policy: new MaxLifetimePolicy(maxLifetimeSeconds: $seconds));
    }

    /**
     * Add MaxIdlePolicy to current group.
     *
     * @param int $seconds Maximum idle time in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxIdle(int $seconds) : self
    {
        return $this->add(policy: new MaxIdlePolicy(maxIdleSeconds: $seconds));
    }

    /**
     * Start a "require all" group (AND logic).
     *
     * All policies in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAll(string $name = 'require_all') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_ALL, name: $name);
    }

    /**
     * Start a new group.
     *
     * @param string $mode Group mode (all|any|none).
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    private function startGroup(string $mode, string $name) : self
    {
        $composite = new CompositePolicy(policies: [], mode: $mode, name: $name);

        if ($this->root === null) {
            // First group becomes root
            $this->root    = $composite;
            $this->current = $composite;
        } else {
            // Nested group
            if ($this->current === null) {
                throw new RuntimeException(message: 'Current group is null. This should not happen.');
            }

            // Add nested group to current
            $this->current->add(policy: $composite);

            // Push current to stack
            $this->stack[] = $this->current;

            // Make nested group current
            $this->current = $composite;
        }

        return $this;
    }

    /**
     * Create a new builder instance.
     *
     * @return self
     */
    public static function create() : self
    {
        return new self();
    }

    /**
     * Create a balanced security preset.
     *
     * Includes:
     * - MaxIdle: 30 minutes
     * - MaxLifetime: 24 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Relaxed
     *
     * @return PolicyInterface Built policy.
     */
    public static function balanced() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'balanced')
            ->maxIdle(seconds: 1800)             // 30 minutes
            ->maxLifetime(seconds: 86400)        // 24 hours
            ->secureOnly()
            ->ipBinding(strict: false)
            ->build();
    }

    /**
     * Create a development-friendly preset.
     *
     * Includes:
     * - MaxIdle: 2 hours
     * - MaxLifetime: 7 days
     *
     * @return PolicyInterface Built policy.
     */
    public static function development() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'development')
            ->maxIdle(seconds: 7200)             // 2 hours
            ->maxLifetime(seconds: 604800)       // 7 days
            ->build();
    }

    /**
     * Start a "require any" group (OR logic).
     *
     * At least one policy in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAny(string $name = 'require_any') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_ANY, name: $name);
    }

    /**
     * Start a "require none" group (inverse logic).
     *
     * All policies in this group must fail.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireNone(string $name = 'require_none') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_NONE, name: $name);
    }

    /**
     * End current group and return to parent.
     *
     * @return self Fluent interface.
     */
    public function endGroup() : self
    {
        if (empty($this->stack)) {
            throw new RuntimeException(message: 'No group to end. Already at root level.');
        }

        $this->current = array_pop(array: $this->stack);

        return $this;
    }

    /**
     * Build and return as array of policies.
     *
     * Useful for bulk registration with PolicyEnforcer.
     *
     * @return array<PolicyInterface> Policies.
     */
    public function buildAsArray() : array
    {
        $policy = $this->build();

        if ($policy instanceof CompositePolicy) {
            return [$policy];
        }

        return [$policy];
    }
}

=== Security/Policies/PolicyInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

/**
 * PolicyInterface - Session Security Policy Contract
 *
 * Defines the contract for session security policies.
 * Policies are enforced before each session operation.
 *
 * @package Avax\HTTP\Session\Policies
 */
interface PolicyInterface
{
    /**
     * Enforce the policy rules.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If policy is violated.
     */
    public function enforce(array $data) : void;

    /**
     * Get the policy name.
     *
     * @return string The policy identifier.
     */
    public function getName() : string;
}

=== Security/Policies/SecureOnlyPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use RuntimeException;

/**
 * SecureOnlyPolicy - HTTPS-Only Session Policy
 *
 * Enforces that session operations only occur over HTTPS.
 * Prevents session hijacking over insecure connections.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class SecureOnlyPolicy implements PolicyInterface
{
    /**
     * Enforce HTTPS-only policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If connection is not HTTPS.
     */
    public function enforce(array $data) : void
    {
        $isSecure = ! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';

        if (! $isSecure) {
            throw new RuntimeException(
                'Session access requires HTTPS connection for security.'
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'secure_only';
    }
}

=== Security/Policies/SessionIpPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security\Policies;

use Avax\HTTP\Session\Exceptions\PolicyViolationException;

/**
 * SessionIpPolicy - IP Address Binding Policy
 *
 * OWASP ASVS 3.4.1 Compliant
 *
 * Binds sessions to client IP address to detect session hijacking.
 * Supports both strict mode (exact match) and relaxed mode (subnet match).
 *
 * Security Trade-offs:
 * - Strict: More secure, but breaks with mobile networks (IP changes)
 * - Relaxed: Less secure, but handles legitimate IP changes
 *
 * @package Avax\HTTP\Session\Security\Policies
 */
final class SessionIpPolicy implements PolicyInterface
{
    /**
     * SessionIpPolicy Constructor.
     *
     * @param bool $strictMode If true, require exact IP match. If false, allow /24 subnet.
     */
    public function __construct(
        private bool $strictMode = false
    ) {}

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        $storedIp  = $data['_client_ip'] ?? null;
        $currentIp = $_SERVER['REMOTE_ADDR'] ?? '';

        // First time - no stored IP yet
        if ($storedIp === null) {
            return;
        }

        if ($this->strictMode) {
            // Strict: Exact match required
            if ($storedIp !== $currentIp) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_strict',
                    'IP address mismatch (strict) - possible session hijacking'
                );
            }
        } else {
            // Relaxed: Same /24 subnet
            if (! $this->isSameSubnet($storedIp, $currentIp)) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_relaxed',
                    'IP subnet mismatch - possible session hijacking'
                );
            }
        }
    }

    /**
     * Check if two IPs are in the same /24 subnet.
     *
     * @param string $ip1 First IP.
     * @param string $ip2 Second IP.
     *
     * @return bool True if same subnet.
     */
    private function isSameSubnet(string $ip1, string $ip2) : bool
    {
        $parts1 = explode('.', $ip1);
        $parts2 = explode('.', $ip2);

        // Compare first 3 octets (class C subnet)
        return $parts1[0] === $parts2[0]
            && $parts1[1] === $parts2[1]
            && $parts1[2] === $parts2[2];
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return $this->strictMode ? 'ip_binding_strict' : 'ip_binding_relaxed';
    }
}

=== Security/PolicyEnforcer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Security\Policies\PolicyInterface;
use Exception;

/**
 * PolicyEnforcer - Policy Enforcement Service
 *
 * Centralized service for enforcing session security policies.
 * Reduces SessionProvider complexity.
 *
 * @package Avax\HTTP\Session\Security
 */
final class PolicyEnforcer
{
    /**
     * @var array<PolicyInterface> Registered policies
     */
    private array $policies = [];

    /**
     * @var ?\Avax\HTTP\Session\Features\Audit Audit logger
     */
    private $audit = null;

    /**
     * PolicyEnforcer Constructor.
     *
     * @param \Avax\HTTP\Session\Features\Audit|null $audit Optional audit logger.
     */
    public function __construct($audit = null)
    {
        $this->audit = $audit;
    }

    /**
     * Register multiple policies at once.
     *
     * @param array<PolicyInterface> $policies Policies to register.
     *
     * @return void
     */
    public function registerMany(array $policies) : void
    {
        foreach ($policies as $policy) {
            $this->register($policy);
        }
    }

    /**
     * Register a policy.
     *
     * @param PolicyInterface $policy The policy.
     *
     * @return void
     */
    public function register(PolicyInterface $policy) : void
    {
        $this->policies[] = $policy;
    }

    /**
     * Enforce all registered policies.
     *
     * OWASP ASVS 3.4.2 - Security event audit logging
     *
     * @param array<string, mixed> $data Session data for policy checks.
     *
     * @return void
     * @throws \RuntimeException If any policy is violated.
     */
    public function enforce(array $data) : void
    {
        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
            } catch (Exception $e) {
                // AUDIT: Log security violation
                if ($this->audit !== null) {
                    $this->audit->record('policy_violation', [
                        'policy' => $policy->getName(),
                        'reason' => $e->getMessage()
                    ]);
                }

                // Re-throw exception
                throw $e;
            }
        }
    }

    /**
     * Get all registered policies.
     *
     * @return array<PolicyInterface> Policies.
     */
    public function getPolicies() : array
    {
        return $this->policies;
    }
}

=== Security/SessionIdValidator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use RuntimeException;

/**
 * SessionIdValidator - Session ID Entropy Validation
 *
 * OWASP ASVS 3.2.2 Compliant
 *
 * Validates session ID quality to ensure cryptographic strength.
 *
 * Requirements:
 * - Minimum 128 bits entropy (32 hex chars)
 * - Cryptographically secure randomness
 * - No pattern repetition
 *
 * @package Avax\HTTP\Session\Security
 */
final class SessionIdValidator
{
    private const MIN_LENGTH = 32;  // 128 bits in hex

    /**
     * Validate current session ID.
     *
     * @return bool True if current session ID is valid.
     */
    public static function validateCurrent() : bool
    {
        $sessionId = session_id();

        if (empty($sessionId)) {
            throw new RuntimeException('No active session to validate');
        }

        return self::validate($sessionId);
    }

    /**
     * Validate session ID entropy.
     *
     * @param string $sessionId Session ID to validate.
     *
     * @return bool True if valid.
     *
     * @throws \RuntimeException If session ID quality insufficient.
     */
    public static function validate(string $sessionId) : bool
    {
        // Check minimum length (128 bits)
        if (strlen($sessionId) < self::MIN_LENGTH) {
            throw new RuntimeException(
                sprintf(
                    'Session ID entropy too low: %d chars (minimum %d)',
                    strlen($sessionId),
                    self::MIN_LENGTH
                )
            );
        }

        // Check for pattern repetition (basic randomness test)
        if (preg_match('/^(.)\1+$/', $sessionId)) {
            throw new RuntimeException('Session ID lacks randomness - repetitive pattern detected');
        }

        // Check for sequential patterns
        if (preg_match('/01234|12345|23456|abcde|bcdef/', $sessionId)) {
            throw new RuntimeException('Session ID lacks randomness - sequential pattern detected');
        }

        return true;
    }
}

=== Security/SessionNonce.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;
use RuntimeException;

/**
 * SessionNonce - Replay Attack Prevention
 *
 * OWASP ASVS 3.3.4 Compliant
 *
 * Generates and validates single-use tokens (nonces) to prevent
 * replay attacks on critical state-changing operations.
 *
 * Nonces are cryptographically secure random values.
 *
 * @package Avax\HTTP\Session\Security
 */
final class SessionNonce
{
    private const string NONCE_KEY    = '_nonce';
    private const int    NONCE_LENGTH = 16; // 128 bits

    /**
     * SessionNonce Constructor.
     *
     * @param Store $store Session storage.
     */
    public function __construct(
        private Store $store
    ) {}

    /**
     * Generate a new nonce.
     *
     * Stores it in session for later verification.
     *
     * @return string Hex-encoded nonce.
     */
    public function generate() : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $this->store->put(key: self::NONCE_KEY, value: $nonce);

        return $nonce;
    }

    /**
     * Verify nonce or throw exception.
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid.
     */
    public function verifyOrFail(string $providedNonce) : void
    {
        if (! $this->verify($providedNonce)) {
            throw new RuntimeException(
                'Invalid or missing nonce - potential replay attack detected'
            );
        }
    }

    /**
     * Verify and consume a nonce.
     *
     * Nonce is deleted after verification (single-use).
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return bool True if nonce is valid.
     */
    public function verify(string $providedNonce) : bool
    {
        $storedNonce = $this->store->get(key: self::NONCE_KEY);

        if ($storedNonce === null) {
            return false; // No nonce stored
        }

        // Consume nonce (delete it)
        $this->store->delete(key: self::NONCE_KEY);

        // Constant-time comparison
        return hash_equals($storedNonce, $providedNonce);
    }

    /**
     * Check if a nonce exists in session.
     *
     * @return bool True if nonce present.
     */
    public function exists() : bool
    {
        return $this->store->has(key: self::NONCE_KEY);
    }

    // ========================================
    // PER-REQUEST NONCE (REPLAY ATTACK PREVENTION)
    // ========================================

    /**
     * Generate a per-request nonce.
     *
     * Used for critical operations that should only execute once.
     * Each request gets a unique nonce that expires after use.
     *
     * @param string $action Action identifier (e.g., 'delete_account', 'transfer_funds').
     *
     * @return string Hex-encoded nonce.
     */
    public function generateForRequest(string $action) : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $key   = self::NONCE_KEY . ".{$action}";

        $this->store->put(key: $key, value: [
            'nonce'      => $nonce,
            'created_at' => time(),
            'action'     => $action,
        ]);

        return $nonce;
    }

    /**
     * Verify per-request nonce or throw exception.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid or expired.
     */
    public function verifyForRequestOrFail(string $action, string $providedNonce, int $maxAge = 300) : void
    {
        if (! $this->verifyForRequest($action, $providedNonce, $maxAge)) {
            throw new RuntimeException(
                "Invalid or expired nonce for action '{$action}' - potential replay attack detected"
            );
        }
    }

    /**
     * Verify and consume a per-request nonce.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds (default: 300 = 5 minutes).
     *
     * @return bool True if valid.
     */
    public function verifyForRequest(string $action, string $providedNonce, int $maxAge = 300) : bool
    {
        $key    = self::NONCE_KEY . ".{$action}";
        $stored = $this->store->get(key: $key);

        if ($stored === null) {
            return false; // No nonce for this action
        }

        // Check expiration
        if (time() - $stored['created_at'] > $maxAge) {
            $this->store->delete(key: $key);

            return false; // Expired
        }

        // Consume nonce (delete it)
        $this->store->delete(key: $key);

        // Constant-time comparison
        return hash_equals($stored['nonce'], $providedNonce);
    }

    /**
     * Clear all per-request nonces.
     *
     * @return void
     */
    public function clearAllRequests() : void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::NONCE_KEY . '.')) {
                $this->store->delete(key: $key);
            }
        }
    }

    /**
     * Get all active per-request nonces.
     *
     * Useful for debugging.
     *
     * @return array<string, array> Action => nonce data.
     */
    public function getActiveRequests() : array
    {
        $all    = $this->store->all();
        $nonces = [];

        foreach ($all as $key => $value) {
            if (str_starts_with($key, self::NONCE_KEY . '.') && is_array($value)) {
                $action          = substr($key, strlen(self::NONCE_KEY) + 1);
                $nonces[$action] = $value;
            }
        }

        return $nonces;
    }
}

=== Security/SessionRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

use Avax\HTTP\Session\Contracts\Storage\Store;
use SensitiveParameter;

/**
 * ðŸ§  SessionRegistry â€” Multi-Device Session Management
 *
 * ------------------------------------------------------------------------
 * THEORY (for dummies):
 * ------------------------------------------------------------------------
 * Imagine every user has a small â€œnotebookâ€ ðŸ“’ where all their active
 * sessions are recorded â€” each page is one device or browser where
 * theyâ€™re currently logged in.
 *
 * That notebook is the *Session Registry*.
 *
 * Its job is to:
 * - Keep track of all active sessions per user ðŸ‘¤
 * - Detect if a session is too old or idle â³
 * - Let you force logout from other devices ðŸªŸ
 * - Revoke or block compromised sessions ðŸš«
 *
 * Think of it as your â€œcontrol roomâ€ for all user logins.
 * ------------------------------------------------------------------------
 *
 * ðŸ›¡ï¸ Why it exists:
 * Without a registry, you canâ€™t:
 * - Prevent stolen tokens from staying valid forever
 * - Enforce â€œsingle-device loginâ€ or session limits
 * - View all devices a user is logged in from
 * - Revoke access after password change or breach
 *
 * This is required by OWASP ASVS 3.3.8 â€” â€œApplications must allow
 * sessions to be revoked and limit concurrent sessions.â€
 *
 * ------------------------------------------------------------------------
 * TECHNICAL OVERVIEW:
 * ------------------------------------------------------------------------
 * - All data is stored inside your Session Store (FileStore / RedisStore)
 * - Each user has their own â€œregistry keyâ€: _registry_{userId}
 * - Each session entry contains metadata like IP, user-agent, timestamps
 * - A separate â€œrevoked listâ€ stores sessions that are invalid forever
 *
 * ðŸ’¡ Think of it as two tables:
 *   1ï¸âƒ£ Active sessions per user
 *   2ï¸âƒ£ Revoked (banned) sessions globally
 * ------------------------------------------------------------------------
 */
final class SessionRegistry
{
    private const string REGISTRY_PREFIX = '_registry_';

    public function __construct(
        private readonly Store $store
    ) {}

    // ============================================================
    // 1ï¸âƒ£ REGISTRATION â€” adding new sessions
    // ============================================================

    /**
     * Register a new session for a user.
     *
     * ðŸ§  What happens:
     * Every time a user logs in, we record:
     * - Which session ID they got
     * - From what IP and device (metadata)
     * - When it was created
     */
    public function register(string $userId, #[SensitiveParameter] string $sessionId, array $metadata = []) : void
    {
        $key      = self::REGISTRY_PREFIX . $userId;
        $sessions = $this->store->get(key: $key, default: []);

        $sessions[$sessionId] = array_merge($metadata, [
            'created_at'    => time(),
            'last_activity' => time(),
        ]);

        $this->store->put(key: $key, value: $sessions);
    }

    // ============================================================
    // 2ï¸âƒ£ ACTIVITY â€” updating and checking
    // ============================================================

    /**
     * Update last activity timestamp.
     *
     * ðŸ’¬ Think of this as â€œheartbeatâ€ â€” every time user interacts,
     * we update the time so we know theyâ€™re still alive ðŸ«€.
     */
    public function updateActivity(string $userId, #[SensitiveParameter] string $sessionId) : void
    {
        $sessions = $this->getActiveSessions($userId);
        if (! isset($sessions[$sessionId])) {
            return;
        }

        $sessions[$sessionId]['last_activity'] = time();
        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);
    }

    /**
     * Retrieve all active sessions for a user.
     */
    public function getActiveSessions(string $userId) : array
    {
        return $this->store->get(key: self::REGISTRY_PREFIX . $userId, default: []);
    }

    /**
     * Get metadata for a specific session.
     */
    public function getSessionMetadata(string $userId, #[SensitiveParameter] string $sessionId) : array|null
    {
        $sessions = $this->getActiveSessions($userId);

        return $sessions[$sessionId] ?? null;
    }

    /**
     * Terminate all sessions except the current one.
     *
     * ðŸ§  Useful when user logs in again and you want
     * to â€œkick outâ€ other devices â€” classic â€œsingle device loginâ€.
     */
    public function terminateOtherSessions(string $userId, #[SensitiveParameter] string $exceptSessionId) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $meta) {
            if ($sessionId !== $exceptSessionId) {
                unset($sessions[$sessionId]);
                $terminated++;
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return $terminated;
    }

    // ============================================================
    // 3ï¸âƒ£ TERMINATION â€” ending sessions
    // ============================================================

    /**
     * Terminate one specific session.
     */
    public function terminateSession(string $userId, #[SensitiveParameter] string $sessionId) : bool
    {
        $sessions = $this->getActiveSessions($userId);
        if (! isset($sessions[$sessionId])) {
            return false;
        }

        unset($sessions[$sessionId]);
        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return true;
    }

    /**
     * Terminate all sessions from a given device / browser.
     */
    public function terminateDevice(string $userId, string $userAgent) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $id => $meta) {
            if (($meta['user_agent'] ?? '') === $userAgent) {
                unset($sessions[$id]);
                $terminated++;
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return $terminated;
    }

    /**
     * Check if user exceeded allowed number of sessions.
     *
     * Example: allow only 2 devices per account.
     */
    public function hasExceededLimit(string $userId, int $limit) : bool
    {
        return $this->countActiveSessions($userId) >= $limit;
    }

    // ============================================================
    // 4ï¸âƒ£ LIMITS â€” enforcing concurrent session limits
    // ============================================================

    /**
     * Count how many sessions user currently has.
     */
    public function countActiveSessions(string $userId) : int
    {
        return count($this->getActiveSessions($userId));
    }

    // ============================================================
    // 5ï¸âƒ£ REVOCATION LIST â€” permanently blocked sessions
    // ============================================================

    /**
     * Add a session to global revocation list.
     *
     * ðŸ’¬ Once revoked, a session is forever invalid â€” even if cookie exists.
     * Typical use cases:
     * - Password change
     * - Security breach
     * - Manual admin logout
     */
    public function revoke(#[SensitiveParameter] string $sessionId, string $reason = 'manual_revocation') : void
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        $revoked[$sessionId] = [
            'revoked_at' => time(),
            'reason'     => $reason,
        ];

        $this->store->put(key: $key, value: $revoked);
    }

    /**
     * Check if a session is revoked.
     */
    public function isRevoked(#[SensitiveParameter] string $sessionId) : bool
    {
        return isset($this->getAllRevoked()[$sessionId]);
    }

    /**
     * Get the global list of revoked sessions.
     *
     * ðŸ§  Purpose:
     * Exposes the complete revocation table so higher-level components
     * (admin panels, audit tools, security dashboards) can inspect which
     * session IDs are permanently blocked and why.
     *
     * ðŸ’¬ Think of it as:
     * â€œShow me the blacklist of all sessions that are not allowed to log in
     * anymore, regardless of cookie or token state.â€
     *
     * @return array<string, array{
     *     revoked_at:int,
     *     reason:string
     * }> Map of session ID to revocation metadata.
     */
    public function getAllRevoked() : array
    {
        return $this->store->get(key: self::REGISTRY_PREFIX . 'revoked', default: []);
    }

    /**
     * Remove session from revocation list.
     */
    public function unrevoke(#[SensitiveParameter] string $sessionId) : bool
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        if (! isset($revoked[$sessionId])) {
            return false;
        }

        unset($revoked[$sessionId]);
        $this->store->put(key: $key, value: $revoked);

        return true;
    }

    /**
     * Clear old revoked sessions (default 30 days).
     */
    public function clearOldRevocations(int $maxAge = 2_592_000) : int
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);
        $cleared = 0;

        foreach ($revoked as $id => $meta) {
            if (time() - $meta['revoked_at'] > $maxAge) {
                unset($revoked[$id]);
                $cleared++;
            }
        }

        $this->store->put(key: $key, value: $revoked);

        return $cleared;
    }

    /**
     * Count the total number of revoked sessions.
     *
     * This method inspects the global revocation list and returns
     * how many session IDs are currently marked as revoked.
     *
     * @return int Number of revoked sessions.
     */
    public function countRevoked() : int
    {
        return count($this->getAllRevoked());
    }

    /**
     * Get detailed revocation metadata for a specific session.
     *
     * ðŸ§  Purpose:
     * Allows security and audit layers to understand *why* a session was
     * revoked (e.g. password change, breach response, manual admin action).
     *
     * ðŸ’¬ Think of it as:
     * â€œTell me the story behind this session ID â€” when it was blocked and for
     * what reason.â€
     *
     * @param string $sessionId The session identifier to inspect.
     *
     * @return array<string, mixed>|null Revocation metadata or null if not revoked.
     */
    public function getRevocationDetails(#[SensitiveParameter] string $sessionId) : array|null
    {
        return $this->getAllRevoked()[$sessionId] ?? null;
    }

    // ============================================================
    // 6ï¸âƒ£ MAINTENANCE â€” cleanup and purge
    // ============================================================

    /**
     * Remove all session records for a user â€” including revoked ones.
     * Use this when deleting user accounts completely.
     */
    public function purgeUser(string $userId) : void
    {
        $this->store->delete(self::REGISTRY_PREFIX . $userId);

        $revoked = $this->getAllRevoked();
        foreach ($revoked as $sid => $meta) {
            if (($meta['user_id'] ?? null) === $userId) {
                unset($revoked[$sid]);
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . 'revoked', value: $revoked);
    }

    /**
     * Group user sessions by device (user-agent).
     */
    public function getSessionsByDevice(string $userId) : array
    {
        $sessions = $this->getActiveSessions($userId);
        $devices  = [];

        foreach ($sessions as $sid => $meta) {
            $fingerprint             = $meta['user_agent'] ?? 'unknown';
            $devices[$fingerprint][] = ['session_id' => $sid] + $meta;
        }

        return $devices;
    }
}

=== Security/SessionSignature.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Security;

/**
 * SessionSignature - HMAC-based Session Integrity
 *
 * OWASP ASVS 3.3.3 Compliant
 *
 * Provides cryptographic signing and verification of session data
 * to prevent tampering attacks.
 *
 * Uses SHA-256 HMAC for integrity verification.
 *
 * @package Avax\HTTP\Session\Security
 */
final class SessionSignature
{
    private const string ALGO = 'sha256';

    /**
     * Verify HMAC signature.
     *
     * Uses constant-time comparison to prevent timing attacks.
     *
     * @param string $data      Original data.
     * @param string $signature Signature to verify.
     * @param string $key       Secret signing key.
     *
     * @return bool True if signature valid.
     */
    public static function verify(string $data, string $signature, string $key) : bool
    {
        $expectedSignature = self::sign(data: $data, key: $key);

        return hash_equals(known_string: $expectedSignature, user_string: $signature);
    }

    /**
     * Sign session data with HMAC.
     *
     * @param string $data Session data to sign.
     * @param string $key  Secret signing key.
     *
     * @return string HMAC signature (hex).
     */
    public static function sign(string $data, string $key) : string
    {
        return hash_hmac(algo: self::ALGO, data: $data, key: $key);
    }
}

=== Session.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session;

use Avax\HTTP\Session\Features\{Events, Flash};
use Avax\HTTP\Session\Lifecycle\{SessionConsumer, SessionNonce, SessionProvider, SessionRegistry};
use Avax\HTTP\Session\Security\Policies\PolicyInterface;

/**
 * Session Component
 *
 * Main facade for enterprise-grade session management.
 *
 * This is the primary entry point for the Session Component.
 * It provides a clean, intuitive API for managing user sessions with
 * enterprise features like encryption, policies, auditing, and more.
 *
 * The Session Component is built with security in mind, following OWASP ASVS
 * guidelines and modern PHP best practices.
 *
 * Features:
 * - Auto-encryption for sensitive data
 * - TTL (time-to-live) support
 * - Namespace isolation
 * - Flash messages
 * - Event system
 * - Audit logging
 * - Session registry (multi-device tracking)
 * - Nonce-based replay attack prevention
 * - Security policies
 * - Snapshots and recovery
 *
 * @example Basic usage
 *   $session = new Session($store);
 *   $session->put('user_id', 123);
 *   $userId = $session->get('user_id');
 *
 * @example Secure data with TTL
 *   $session->for('auth')->secure()->ttl(900)->put('token', $jwt);
 *
 * @example Flash messages
 *   $session->flash()->success('Profile updated!');
 *
 * @example With policies
 *   $session->registerPolicy(new MaxIdlePolicy(900));
 *
 * @author  Milos Stankovic
 * @package Shomsy\Components\Foundation\HTTP\Session
 * @version 4.0
 */
final class Session
{
    /**
     * The underlying session provider instance.
     */
    private SessionProvider $provider;

    /**
     * Session Constructor.
     *
     * @param SessionProvider $provider The session provider instance.
     */
    public function __construct(SessionProvider $provider)
    {
        $this->provider = $provider;
    }

    /**
     * Store a value in the session.
     *
     * @param string   $key   The key under which to store the value.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Optional time-to-live in seconds.
     *
     * @return void
     */
    public function put(string $key, mixed $value, int|null $ttl = null) : void
    {
        $this->provider->put($key, $value, $ttl);
    }

    /**
     * Retrieve a value from the session.
     *
     * @param string $key     The key to retrieve.
     * @param mixed  $default Default value if key doesn't exist.
     *
     * @return mixed The value or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->provider->get($key, $default);
    }

    /**
     * Check if a key exists in the session.
     *
     * @param string $key The key to check.
     *
     * @return bool True if the key exists.
     */
    public function has(string $key) : bool
    {
        return $this->provider->has($key);
    }

    /**
     * Remove a value from the session.
     *
     * @param string $key The key to remove.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        $this->provider->forget($key);
    }

    /**
     * Get all session data.
     *
     * @return array All session data.
     */
    public function all() : array
    {
        return $this->provider->all();
    }

    /**
     * Clear all session data.
     *
     * @return void
     */
    public function flush() : void
    {
        $this->provider->flush();
    }

    /**
     * Create a contextual session consumer with namespace isolation.
     *
     * This allows you to group related session data together and apply
     * specific behaviors (like encryption or TTL) to that group.
     *
     * @param string $context The context/namespace for the consumer.
     *
     * @return SessionConsumer A scoped session consumer.
     *
     * @example
     *   $session->for('cart')->secure()->put('items', $cartItems);
     */
    public function for(string $context) : SessionConsumer
    {
        return $this->provider->for($context);
    }

    /**
     * Alias for for() method - creates a scoped session consumer.
     *
     * @param string $namespace The namespace for the consumer.
     *
     * @return SessionConsumer A scoped session consumer.
     */
    public function scope(string $namespace) : SessionConsumer
    {
        return $this->provider->scope($namespace);
    }

    /**
     * Access the flash message feature.
     *
     * Flash messages are temporary messages that persist only for the next request.
     * Perfect for displaying feedback after form submissions or redirects.
     *
     * @return Flash The flash message manager.
     *
     * @example
     *   $session->flash()->success('User created successfully!');
     */
    public function flash() : Flash
    {
        return $this->provider->flash();
    }

    /**
     * Access the event system.
     *
     * Listen to session events like 'stored', 'retrieved', 'flushed', etc.
     *
     * @return Events The event dispatcher.
     *
     * @example
     *   $session->events()->listen('stored', function($data) {
     *       logger()->info('Session data stored', $data);
     *   });
     */
    public function events() : Events
    {
        return $this->provider->events();
    }

    /**
     * Register a security policy.
     *
     * Policies enforce security rules like maximum idle time, secure-only access,
     * IP validation, and more.
     *
     * @param PolicyInterface $policy The policy to register.
     *
     * @return self Fluent interface.
     *
     * @example
     *   $session->registerPolicy(new MaxIdlePolicy(900))
     *           ->registerPolicy(new SecureOnlyPolicy());
     */
    public function registerPolicy(PolicyInterface $policy) : self
    {
        $this->provider->registerPolicy($policy);
        return $this;
    }

    /**
     * Enable audit logging.
     *
     * Tracks all session operations for security auditing and compliance.
     *
     * @param string|null $path Optional path to the audit log file.
     *
     * @return self Fluent interface.
     *
     * @example
     *   $session->enableAudit('/var/log/session-audit.log');
     */
    public function enableAudit(string|null $path = null) : self
    {
        $this->provider->enableAudit($path);
        return $this;
    }

    /**
     * Create a snapshot of the current session state.
     *
     * Snapshots allow you to save and restore session state,
     * useful for complex workflows or rollback scenarios.
     *
     * @param string $name The snapshot name.
     *
     * @return void
     *
     * @example
     *   $session->snapshot('before_checkout');
     *   // ... complex checkout process
     *   if ($error) {
     *       $session->restore('before_checkout');
     *   }
     */
    public function snapshot(string $name) : void
    {
        $this->provider->snapshot($name);
    }

    /**
     * Restore a previously saved snapshot.
     *
     * @param string $name The snapshot name to restore.
     *
     * @return void
     */
    public function restore(string $name) : void
    {
        $this->provider->restore($name);
    }

    /**
     * Remember a value using lazy evaluation.
     *
     * If the key exists, return its value. Otherwise, execute the callback,
     * store the result, and return it.
     *
     * @param string   $key      The key to remember.
     * @param callable $callback Callback to generate the value.
     * @param int|null $ttl      Optional time-to-live in seconds.
     *
     * @return mixed The cached or freshly generated value.
     *
     * @example
     *   $user = $session->remember('current_user', function() {
     *       return User::find($userId);
     *   }, ttl: 3600);
     */
    public function remember(string $key, callable $callback, int|null $ttl = null) : mixed
    {
        return $this->provider->remember($key, $callback, $ttl);
    }

    /**
     * Regenerate the session ID.
     *
     * Important for preventing session fixation attacks, especially after login.
     *
     * @return void
     */
    public function regenerate() : void
    {
        $this->provider->regenerate();
    }

    /**
     * Login with automatic session regeneration.
     *
     * OWASP ASVS 3.2.1 compliant - automatically regenerates session ID
     * to prevent session fixation attacks.
     *
     * @param string $userId User identifier.
     * @param array  $data   Optional user data to store.
     *
     * @return void
     */
    public function login(string $userId, array $data = []) : void
    {
        $this->provider->login($userId, $data);
    }

    /**
     * Terminate the session securely.
     *
     * OWASP ASVS 3.2.3 compliant - properly destroys the session,
     * clears all data, and removes cookies.
     *
     * @param string $reason Termination reason for audit trail.
     *
     * @return void
     */
    public function terminate(string $reason = 'logout') : void
    {
        $this->provider->terminate($reason);
    }

    /**
     * Access the session registry for multi-device session management.
     *
     * @return SessionRegistry The session registry.
     *
     * @example
     *   $session->getRegistry()->terminateOtherSessions($userId, $currentSessionId);
     */
    public function getRegistry() : SessionRegistry
    {
        return $this->provider->getRegistry();
    }

    /**
     * Access the nonce manager for replay attack prevention.
     *
     * @return SessionNonce The nonce manager.
     *
     * @example
     *   $nonce = $session->getNonce()->generateForRequest('delete_account');
     *   // ... later
     *   $session->getNonce()->verifyForRequestOrFail('delete_account', $nonce);
     */
    public function getNonce() : SessionNonce
    {
        return $this->provider->getNonce();
    }

    /**
     * Get the underlying session provider.
     *
     * @return SessionProvider The provider instance.
     */
    public function getProvider() : SessionProvider
    {
        return $this->provider;
    }
}

=== examples/01-basic-operations.php ===
<?php

/**
 * Example 01: Basic Operations & Lifecycle
 *
 * ðŸ§  Theory:
 * Think of a session like a small notebook that your app keeps for each user.
 * In that notebook you can write things you want to remember between requests:
 * their name, their cart items, their preferences.
 *
 * Without a session, every HTTP request is â€œnewâ€ and â€œforgetfulâ€.
 * The server does not remember who you are from one page to the next.
 *
 * A session fixes that.
 * It gives you a safe place to store small pieces of data per user.
 *
 * ðŸ›¡ï¸ Real-world scenario:
 * - A user logs in once, but stays logged in across many pages.
 * - A user adds items to a shopping cart and sees them on the checkout page.
 * - A user changes a setting (dark mode on), and it stays that way.
 *
 * The session is the memory that makes all of this possible.
 *
 * âš™ï¸ In practice (what we do here):
 * - We start the session (open the notebook for this user).
 * - We write values: put data into the notebook.
 * - We read values: get data back later.
 * - We check if data exists.
 * - We remove data or clear everything when we are done.
 *
 * âœ… Result:
 * You will see how to:
 * - remember a user's name,
 * - update it,
 * - forget it,
 * - and finally destroy the whole session when it is no longer needed.
 *
 * ðŸ“˜ Vocabulary:
 * - Session: the userâ€™s personal notebook that the server keeps.
 * - Start: opening the notebook for this user.
 * - ID: a secret â€œnotebook numberâ€ that tells which notebook belongs to which user.
 * - Put: writing something into the notebook.
 * - Get: reading something from the notebook.
 * - Forget: erasing one note from the notebook.
 * - Flush: erasing everything in the notebook.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/**
 * Note: This example uses the actual Session API
 * as defined in SessionInterface / SessionContract
 * (start, id, put, get, has, forget, flush, destroy).
 * It is intended to be copy-pasteable against the
 * real implementation, not pseudo-code.
 */
/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

// ðŸ§  Step 1: Start the session lifecycle
//
// Think of this as: â€œopen the notebook for this userâ€.
// If the notebook is already open, this call simply ensures it is ready.
$session->start();

// Get the current session ID (the notebook number).
$sessionId = $session->id();

echo "Session started with ID: {$sessionId}\n\n";

// ðŸ§  Step 2: Basic put() and get()
//
// Think of [put('name', 'Alice')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:69:4-81:5) like writing â€œname = Aliceâ€ into the notebook.
// Later you can ask: â€œwhat is name?â€ using get('name').

// Store a simple value.
$session->put('name', 'Alice');

// Read it back.
$name = $session->get('name');

echo "Stored name: {$name}\n"; // Alice

// ðŸ§  Step 3: has() â€” does this note exist?
//
// [has('name')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:96:4-106:5) answers: â€œDoes the notebook contain a value called name?â€
// It returns true or false.
if ($session->has('name')) {
    echo "We have a name stored in the session.\n";
}

// ðŸ§  Step 4: Updating values
//
// Calling put() again with the same key simply overwrites the old value.
// Think of it like crossing out the old value and writing a new one.

$session->put('name', 'Bob');
echo "Updated name: " . $session->get('name') . "\n"; // Bob

// ðŸ§  Step 5: forget() â€” remove a single value
//
// [forget('name')](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:108:4-118:5) means: erase just this one line from the notebook.
// Other notes stay untouched.

$session->forget('name');

echo "After forget('name'):\n";
var_dump([
    'has_name' => $session->has('name'),   // false
    'name'     => $session->get('name'),   // null
]);

// ðŸ§  Step 6: put multiple values
//
// You can treat the session like a small key-value store
// for different pieces of user data.

$session->put('user_id', 42);
$session->put('role', 'admin');
$session->put('theme', 'dark');

echo "\nCurrent session data snapshot:\n";
var_dump([
    'user_id' => $session->get('user_id'),
    'role'    => $session->get('role'),
    'theme'   => $session->get('theme'),
]);

// ðŸ§  Step 7: flush() â€” clear everything
//
// [flush()](cci:1://file:///C:/Users/shomsy/PhpstormProjects/components/Foundation/HTTP/Session/Session.php:130:4-138:5) means: erase the whole notebook for this user.
// After this, it is as if the user never had a session.

$session->flush();

echo "\nAfter flush():\n";
var_dump([
    'user_id' => $session->get('user_id'), // null
    'role'    => $session->get('role'),    // null
    'theme'   => $session->get('theme'),   // null
]);

// ðŸ§  Step 8: destroy() â€” end the lifecycle
//
// Think of `destroy()` as:
//  - close the notebook,
//  - throw it away,
//  - tell the browser that this session is no longer valid.
//
// This is often used on logout.

$session->destroy();

echo "\nSession destroyed. ID is now: " . $session->id() . "\n";
// Depending on your implementation, this may be an empty string
// or a fresh ID after regeneration.


=== examples/02-scopes-and-namespaces.php ===
<?php

/**
 * Example 02: Scopes & Namespaces (for())
 *
 * ðŸ§  Theory:
 * Think of your session like a big closet ðŸ§³ that your app uses to store information.
 * Inside that closet, you can have many shelves â€” one for login data, one for a shopping cart,
 * one for user preferences, one for temporary messages.
 *
 * Each shelf has a name â€” and you decide what goes on it.
 *
 * The method `for('something')` is how you open one of those shelves.
 * Itâ€™s like saying: "Hey session, I want to work on the *auth shelf* now."
 *
 * That shelf becomes a *scope* â€” a small, private area inside the session where
 * all the keys you store live under that group.
 *
 * ðŸ’¡ Why it matters:
 * Without scopes, all your session data gets mixed in one big messy drawer.
 * With scopes, you can keep things clean and separate â€” no name collisions,
 * no confusion between modules, and easier debugging.
 *
 * Example:
 * - `for('auth')->put('token', '123')` saves under: `auth.token`
 * - `for('cart')->put('items', [...])` saves under: `cart.items`
 *
 * Each `for()` call opens a *namespace* â€” a logical box inside the session.
 * It doesnâ€™t create a new session, it just organizes your data.
 *
 * ðŸ›¡ï¸ Real-world scenario:
 * Imagine your app has three parts:
 * - "auth" â†’ handles login
 * - "cart" â†’ handles shopping
 * - "ui"   â†’ handles user preferences
 *
 * Each of these can store their own data in the same session safely:
 * - Auth can store token, roles, last login.
 * - Cart can store selected items, total, coupon.
 * - UI can store theme, language, layout.
 *
 * With scopes, they all live in the same closet â€” but on their own shelves.
 *
 * âš™ï¸ In practice:
 * - Use `for('auth')` when you work with login/session tokens.
 * - Use `for('cart')` for shopping data.
 * - Use `for('ui')` for user preferences.
 * - You can chain it with other features like `secure()` or `ttl()`.
 *
 * ðŸ“˜ Vocabulary:
 * - Scope: A named section of the session, like a labeled box or shelf.
 * - Namespace: A prefix added to all keys inside a scope.
 * - Collision: When two parts of code accidentally use the same key.
 * - Isolation: Keeping different session data separate.
 * - Chaining: Combining multiple modifiers in one line (e.g. `for()->secure()->ttl()`).
 *
 * âœ… Result:
 * You get clean, organized, easy-to-manage session data.
 * Each part of your app keeps its own data on its own shelf â€” no mixing, no overwriting.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$session->start();

echo "=== Example 02: Scopes & Namespaces ===\n\n";

// ðŸ§  Think of `$session` as the big closet where all your appâ€™s memory lives.
//
// Each `for('something')` is like opening a labeled box inside that closet.
//
// Letâ€™s create three different scopes (auth, cart, ui):
$auth = $session->for('auth');
$cart = $session->for('cart');
$ui   = $session->for('ui');

// ---------------------------------------------------------------------------
// ðŸ‘› AUTH SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores all authentication data.
//
// Think of it like a "login box" â€” only login-related data goes here.
//
$auth->put('token', 'user-token-abc123');
$auth->put('roles', ['user', 'editor']);
$auth->put('last_login', time());

// You can read them later:
$token = $auth->get('token');
echo "ðŸ” Token from auth scope: {$token}\n";

// ---------------------------------------------------------------------------
// ðŸ›’ CART SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores shopping cart data.
//
// Think of it like a "basket box" â€” where all userâ€™s items go.
//
$cart->put('items', ['T-shirt', 'Sneakers', 'Cap']);
$cart->put('total', 89.97);

// Read them later:
$items = implode(', ', $cart->get('items'));
$total = $cart->get('total');

echo "ðŸ›ï¸ Cart has: {$items} (Total: \\${$total})\n";

// ---------------------------------------------------------------------------
// ðŸŽ¨ UI SCOPE
// ---------------------------------------------------------------------------
//
// This shelf stores user preferences (theme, language, etc.)
//
// Think of it like a "settings box" â€” where the app remembers how you like things.
//
$ui->put('theme', 'dark');
$ui->put('language', 'en');

echo "ðŸŽ¨ UI theme: {$ui->get('theme')} | Language: {$ui->get('language')}\n";

// ---------------------------------------------------------------------------
// ðŸ§© UNDERSTANDING WHAT HAPPENS INTERNALLY
// ---------------------------------------------------------------------------
//
// Each scope automatically prefixes its data.
// So if we looked inside the raw session storage, weâ€™d see something like:
//
//   auth.token       => "user-token-abc123"
//   auth.roles       => ["user", "editor"]
//   auth.last_login  => 1702239123
//   cart.items       => ["T-shirt", "Sneakers", "Cap"]
//   cart.total       => 89.97
//   ui.theme         => "dark"
//   ui.language      => "en"
//
// ðŸ’¡ Think of it like a JSON structure:
//
// {
//   "auth": { "token": "...", "roles": [...], "last_login": ... },
//   "cart": { "items": [...], "total": ... },
//   "ui":   { "theme": "dark", "language": "en" }
// }
//
// All organized. All separate. All neat.
//
// ---------------------------------------------------------------------------
// âš™ï¸ YOU CAN EVEN CHAIN OTHER FEATURES
// ---------------------------------------------------------------------------
//
// For example, letâ€™s make our "auth" box secure and short-lived:
//
// ðŸ’¬ Think of it like this:
// "This is my login shelf. Lock it with encryption and make it forget
// everything after 15 minutes."
//
$session
    ->for('auth')
    ->secure()
    ->ttl(900)
    ->put('token', 'secure-jwt-xyz');

// ---------------------------------------------------------------------------
// âœ… RESULT
// ---------------------------------------------------------------------------
//
// - "auth" shelf keeps login info (secure, temporary)
// - "cart" shelf keeps shopping data
// - "ui" shelf keeps design preferences
// - Everything is isolated and easy to manage
//
// ðŸ’¡ Think of for('auth') like saying:
// "Open the login shelf â€” I only want to work there."
// ðŸ’¡ Think of for('cart') like saying:
// "Now open the shopping shelf."
// ðŸ’¡ Think of for('ui') like saying:
// "Open the preferences shelf."
//
// Each box keeps its own stuff.
// No more collisions. No more mess.

=== examples/03-security-and-encryption.php ===
<?php

/**
 * Example 03: Security & Encryption
 *
 * ðŸ§  Theory:
 * Think of your session like a small backpack that your app carries for each user.
 * Inside that backpack you can put important things: tokens, IDs, preferences.
 *
 * But there is a problem:
 * If someone steals the backpack, they can see everything inside.
 * That means they could pretend to be the user, or read secret data.
 *
 * Encryption is like putting everything inside a locked box
 * before you put it into the backpack.
 * The box can only be opened with a secret key that only your app knows.
 *
 * So even if an attacker steals the backpack,
 * all they see is a locked box with random-looking data.
 * They cannot read it, they cannot change it in a useful way.
 *
 * ðŸ›¡ï¸ Real-world scenario:
 * Imagine a user logs into an online banking app.
 * The app stores a session token that proves "this user is authenticated".
 * If that token is stored in plain text and someone steals it,
 * they can log in as that user without knowing the password.
 *
 * With encryption:
 * - The token is stored in an encrypted form.
 * - Even if someone dumps the session storage or intercepts the data,
 *   they only see garbage they cannot use.
 *
 * âš™ï¸ In practice (what we do here):
 * - We configure the Session Component with encryption enabled.
 * - We tell the Session: "for this area, always encrypt data before saving".
 * - We store a token with a time limit, so it auto-expires after 15 minutes.
 *
 * âœ… Result:
 * Your app can safely store sensitive values (tokens, emails, IDs)
 * without exposing them in plain text.
 * Even if the storage (filesystem, Redis, database) is leaked,
 * the attacker cannot simply read or reuse the data.
 *
 * ðŸ“˜ Vocabulary:
 * - Encryption: turning readable data into unreadable text using a secret key.
 * - Decryption: turning that unreadable text back into the original value.
 * - Secret key: a private value only your app knows, used to lock/unlock data.
 * - Token: a small piece of data that proves "who you are" to the app.
 * - TTL (Time To Live): how long data is allowed to live before it disappears.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$jwt = 'header.payload.signature'; // pretend this is a real JWT from your auth system

// ðŸ§  Explanation of the chain below:
//
// Think of `$session` like a helper that knows how to store data safely.
//
// `for('auth')`
//   Think of this like saving data in a box called "auth".
//   All login/authentication data goes into this one box,
//   so it does not mix with other things like "cart" or "preferences".
//
// `secure()`
//   This means: "Before you save anything in this box, lock it."
//   The data will be encrypted using a secret key.
//   Even if someone opens the storage, they only see random characters,
//   not the real value.
//
// `ttl(900)`
//   TTL means "time to live".
//   `ttl(900)` means: keep this data for 900 seconds (15 minutes), then delete it.
//   Think of it like a message that self-destructs after 15 minutes.
//   This is perfect for short-lived tokens.
//
// `put('token', $jwt)`
//   This means: "Save a value under the name token."
//   Here `$jwt` is your login or access token.
//   Combined with `secure()` and `ttl(900)`,
//   it becomes an encrypted, temporary token.
//
// âœ… Result:
//   The user's token is:
//   - stored only inside the "auth" area,
//   - encrypted so nobody can read it from raw storage,
//   - automatically removed after 15 minutes.
//

$session
    ->for('auth')
    ->secure()
    ->ttl(900)
    ->put('token', $jwt);

// Later in the request, or in the next request, you can read it back:
//
// Think of `get('token')` like opening the "auth" box
// and asking: "Do we still have the token for this user?"

$token = $session->for('auth')->get('token');

var_dump([
    'stored_token_value' => $token,
]);

=== examples/04-ttl-and-expiring-data.php ===
<?php

/**
 * Example 04: TTL & Autoâ€‘Expiring Data
 *
 * ðŸ§  Theory:
 * Think of TTL (Time To Live) like a small timer â±ï¸ attached to a piece of data.
 * When the timer runs out, the data disappears automatically.
 *
 * Without TTL, everything you put into the session stays there
 * until the session ends or you remove it manually.
 *
 * That is fine for some things (like a userâ€™s name),
 * but dangerous or noisy for others (like oneâ€‘time codes, OTPs, magic links).
 *
 * TTL lets you store temporary data in a safe way:
 * - Oneâ€‘time login codes
 * - Password reset tokens
 * - Email verification links
 * - Shortâ€‘lived â€œremember this only for a few minutesâ€ flags
 *
 * ðŸ›¡ï¸ Realâ€‘world scenario:
 * Imagine you send a user a 6â€‘digit code by SMS for login.
 * You want that code to work only for a short time (e.g. 5 minutes).
 *
 * With TTL you can say:
 * - â€œStore this code, but delete it automatically after 300 seconds.â€
 * - Even if you forget to clean it up, the system does it for you.
 *
 * âš™ï¸ In practice (what we do here):
 * - We store an OTP code with a TTL of 300 seconds (5 minutes).
 * - We try to read it before and after the TTL window.
 * - We see that after the TTL passes, the value is gone (null).
 *
 * âœ… Result:
 * You learn how to attach a â€œselfâ€‘destruct timerâ€ to session values,
 * so sensitive or temporary data does not live longer than it should.
 *
 * ðŸ“˜ Vocabulary:
 * - TTL (Time To Live): how long a value is allowed to exist before it is removed.
 * - OTP (Oneâ€‘Time Password): a short code used once and then discarded.
 * - Expiry: the moment when data becomes invalid and is removed.
 * - Window: the time period during which the data is still valid.
 */

use Avax\HTTP\Session\Session;

require __DIR__ . '/bootstrap.php';

/** @var Session $session */
$session = $sessionComponent; // from bootstrap, shared Session instance

$session->start();

echo "=== Example 04: TTL & Autoâ€‘Expiring Data ===\n\n";

// Let's say we generate a oneâ€‘time code for login:
$otp = '739214';

// ðŸ§  Explanation of the chain:
//
// Think of `$session` as the place where we temporarily remember this code.
//
// `for('auth')`
//   Think of this like a small box labeled "auth".
//   We keep all authenticationâ€‘related data in this box.
//
// `ttl(300)`
//   Means: "keep this value for 300 seconds (5 minutes), then delete it".
//   Think of it like a sticker that says: "throw this away in 5 minutes".
//
// `put('otp', $otp)`
//   Means: "store the OTP code under the name otp inside this box".
//
// âœ… Result:
//   We store a oneâ€‘time code that automatically disappears after 5 minutes.

$session
    ->for('auth')
    ->ttl(300)
    ->put('otp', $otp);

echo "Stored OTP in session (valid for 5 minutes): {$otp}\n";

// Immediately after storing, we can read it:
$currentOtp = $session->for('auth')->get('otp');
echo "Current OTP from session: " . var_export($currentOtp, true) . "\n";

// In a real app, some time passes here (user types the code, submits formâ€¦)
// For the sake of example, imagine this is a later request:

// ðŸ§  Check if OTP still exists before validating:
//
// If get('otp') returns null, it probably expired or was already used.
$otpFromSession = $session->for('auth')->get('otp');

if ($otpFromSession === null) {
    echo "OTP is no longer available (it may have expired or been used).\n";
} else {
    echo "OTP is still valid: {$otpFromSession}\n";
}

// In your real verification logic, you would compare user input with $otpFromSession
// and, on success, you would typically remove it:
//
//   $session->for('auth')->forget('otp');
//
// Even if you forget to call forget(), TTL will clean it up after 300 seconds.

=== examples/05-flash-messages.php ===
<?php
/**
 * Example 05: Flash Messages & Validation
 *
 * ðŸ§  Theory:
 * Flash messages are like sticky notes between two pages of your app ðŸ“„.
 *
 * They carry short pieces of information â€” like success, warnings, or errors â€”
 * from one request to the next, and then disappear automatically.
 *
 * Think of them as little messengers that deliver a message once,
 * then vanish forever ðŸ•Šï¸.
 *
 * ðŸ’¡ Why use Flash?
 * When your app redirects (like after submitting a form),
 * the next page doesnâ€™t know what happened before.
 * Flash messages help your app â€œremember just enoughâ€ to show:
 * - validation errors,
 * - confirmation messages,
 * - old input values.
 *
 * ðŸ› ï¸ Flash message methods:
 * - `success()` â†’ show a â€œyay!â€ message for successful actions
 * - `error()` â†’ show what went wrong (like validation errors)
 * - `info()` â†’ neutral notes or status
 * - `warning()` â†’ gentle alerts or cautions
 * - `add()` â†’ generic â€œset a custom flash keyâ€
 * - `now()` â†’ show message immediately (same request)
 * - `get()` â†’ read & delete message
 *
 * ðŸ§© Real-world scenario:
 * Imagine a user submits a form but forgets to fill something.
 * You validate it, find errors, and redirect back to the form.
 *
 * With Flash:
 * - You can store the validation errors and userâ€™s old input temporarily.
 * - On the next request, you show those messages in the view.
 *
 * ðŸ’¬ Think of it like:
 * â€œIâ€™ll write a quick note for the next page to read,
 * then throw it away once itâ€™s seen.â€
 */

use Avax\HTTP\Session\Session;

// Get the session instance (e.g. via DI container or singleton)
$session = Session::getInstance();

// ---------------------------------------------------------------------------
// ðŸ§  1. FORM VALIDATION FAILS
// ---------------------------------------------------------------------------
//
// Letâ€™s simulate a failed form submission â€” for example,
// the user forgot to enter an email or used a weak password.
//
$errors = [
    'email'    => 'Email is required.',
    'password' => 'Password must be at least 8 characters.',
];

// ðŸ’¡ Think of add('errors', $errors) like writing a small envelope
// and putting all error messages inside â€” it will be delivered
// to the *next* request.
//
$session->flash()->add('errors', $errors);

// ðŸ’¬ Similarly, we can flash the old input,
// so the form can refill itself automatically.
//
$session->flash()->add('old_input', $_POST);

// ðŸ§¾ We can also flash a success-style message for later:
$session->flash()->success('Your profile has been updated successfully.');

// ðŸ’¬ And maybe show something immediately (this request only):
$session->flash()->now('info', 'You are currently editing your profile.');

// ---------------------------------------------------------------------------
// ðŸ”„ 2. NEXT REQUEST (AFTER REDIRECT)
// ---------------------------------------------------------------------------
//
// Now imagine the user is redirected back to the form.
// On the next page load, the view can retrieve what was flashed.
//
$errors   = $session->flash()->get('errors', []);
$oldInput = $session->flash()->get('old_input', []);

// ðŸ’¬ Think of get('errors') like opening that envelope from your past self.
// Once you read it, the envelope disappears â€” no duplicates, no stale data.
//
$successMessage = $session->flash()->get('success');

// ---------------------------------------------------------------------------
// ðŸ§© 3. SHOWING FLASH DATA IN THE VIEW
// ---------------------------------------------------------------------------
//
// This part would normally live in your view layer (e.g., Twig or Blade).
// Weâ€™ll just simulate it with simple echo statements.
//
if ($successMessage) {
    echo "<div class='alert alert-success'>{$successMessage}</div>";
}

if ($errors) {
    echo "<div class='alert alert-danger'>";
    echo "<strong>Validation failed:</strong><br>";
    foreach ($errors as $field => $message) {
        echo "- {$field}: {$message}<br>";
    }
    echo "</div>";
}

// ðŸ’¡ Think of it like this:
// The â€œsuccessâ€ note was for the next page only.
// The â€œerrorsâ€ and â€œold_inputâ€ were carried here,
// then automatically erased once shown.
//
// On the next refresh, all of these will be gone â€” clean slate! âœ¨

// ---------------------------------------------------------------------------
// ðŸ§¹ 4. CLEARING FLASH
// ---------------------------------------------------------------------------
//
// You can also manually clear all flash data if needed.
//
$session->flash()->clear();

// ---------------------------------------------------------------------------
// âœ… RESULT
// ---------------------------------------------------------------------------
//
// - Flash is your appâ€™s one-request memory.
// - â€œadd()â€ â†’ set temporary data for the next page.
// - â€œsuccess()/error()/info()/warning()â€ â†’ quick helpers.
// - â€œget()â€ â†’ read and delete.
// - â€œnow()â€ â†’ show immediately (this request only).
// - â€œclear()â€ â†’ erase all flash data.
//
// ðŸ’¡ Think of Flash as the app whispering to itself between pages:
// â€œJust remember this message until tomorrow â€” then forget it.â€ ðŸŒ™
//

=== examples/06-events-and-hooks.php ===
<?php
/**
 * Example 06: Events & Hooks (Simplified for Everyone)
 *
 * ðŸ§  Theory:
 * When something happens inside the Session system (like saving or deleting data),
 * it can â€œshoutâ€ that information to anyone who wants to listen.
 *
 * These shouts are called â€œeventsâ€.
 * The people listening are called â€œlistenersâ€.
 *
 * Imagine your Session is a person in a busy kitchen ðŸ³:
 * - When they finish cooking (store data), they shout â€œDinnerâ€™s ready!â€
 * - When they clean the table (delete data), they shout â€œTable cleared!â€
 * Other cooks (listeners) can then react, like:
 * - One writes the meal to a logbook (â€œAuditâ€)
 * - Another counts how many meals were made today (â€œMetricsâ€)
 *
 * Events are not just for fun â€” they make your Session *observable*.
 * You can track, log, and respond to everything that happens.
 */

use Avax\HTTP\Session\Session;

// Get the Session instance
$session = Session::getInstance();

/**
 * === Step 1: Listening to events ===
 *
 * â€œListenâ€ means: do something when this event happens.
 */

$session->events()->listen('stored', function (array $data) {
    echo "[Event: stored] You saved '{$data['key']}' in your session.\n";
});

$session->events()->listen('deleted', function (array $data) {
    echo "[Event: deleted] You deleted '{$data['key']}' from your session.\n";
});

// === Step 2: Triggering events ===
// Each of these will automatically "shout" (dispatch) an event.
$session->put('username', 'John'); // triggers â€œstoredâ€
$session->forget('username');      // triggers â€œdeletedâ€


/**
 * === Step 3: Understanding setMode() ===
 *
 * Normally, events happen immediately (synchronously).
 * That means â€” when you save something, the event runs right away.
 *
 * But sometimes, you donâ€™t want to slow things down.
 * For example, logging or analytics can wait until after the page loads.
 *
 * Thatâ€™s where `setMode()` comes in!
 *
 * It changes *when and how* your events are delivered.
 *
 * ðŸ§© Think of it like sending a message:
 * - SYNC: You call your friend and talk right now.
 * - ASYNC_MEMORY: You leave them a sticky note â€” theyâ€™ll read it later.
 * - ASYNC_FILE: You write it down in a notebook â€” theyâ€™ll read it tomorrow.
 * - ASYNC_REDIS: You post it to a group chat â€” everyone will get it instantly.
 *
 * So, if your event just logs something to a file or database,
 * itâ€™s usually better to run it *asynchronously* (in the background)
 * so your user doesnâ€™t have to wait.
 */

// ðŸ§  Example: make events async (run later)
$session->events()->setMode('ASYNC_MEMORY');

$session->events()->listen('stored', function (array $data) {
    echo "[ASYNC Event: stored] I'll write '{$data['key']}' to a log file *after* the page loads.\n";
});

$session->put('settings', ['theme' => 'dark']); // event queued, not run immediately!

echo "Page is rendering...\n";

/**
 * ðŸ” Output explanation:
 * Youâ€™ll first see: â€œPage is rendering...â€
 * Then, after the script finishes, PHP will run your async listeners.
 * So the â€œ[ASYNC Event: stored] ...â€ message appears *after* the response ends.
 *
 * ðŸ’¡ Why? Because async events use a shutdown handler â€”
 * they collect events in memory and process them when PHP is done.
 *
 * This is great for performance:
 * - The user doesnâ€™t wait for logs or analytics
 * - The app feels faster
 * - You can handle thousands of events without slowing anything down
 *
 * ðŸ› ï¸ Tip:
 * In production, you might switch to:
 *   - ASYNC_FILE â†’ if you want logs written to disk
 *   - ASYNC_REDIS â†’ if you want events shared between multiple servers
 *
 * For example:
 *   $session->events()->setMode('ASYNC_REDIS');
 *   // Now all servers see the same events in real time
 */


/**
 * === Step 4: Combine everything together ===
 *
 * You can mix sync and async listeners freely:
 * - Sync â†’ for critical stuff (security, policy enforcement)
 * - Async â†’ for optional stuff (analytics, audit)
 *
 * Example:
 */
$session->events()->setMode('SYNC'); // switch back to instant mode

$session->events()->listen('stored', function (array $data) {
    echo "[SECURITY] Immediately verified '{$data['key']}' integrity.\n";
});

$session->events()->setMode('ASYNC_MEMORY'); // back to async for logs
$session->events()->listen('stored', function (array $data) {
    echo "[LOG] Queued '{$data['key']}' for audit logging.\n";
});

$session->put('user_id', 101);


/**
 * ðŸ§  Summary:
 * - setMode('SYNC') â†’ run listeners right away (instant reaction)
 * - setMode('ASYNC_MEMORY') â†’ run them later (after response ends)
 * - setMode('ASYNC_FILE') â†’ save events to disk (persistent queue)
 * - setMode('ASYNC_REDIS') â†’ send to Redis (shared queue for multi-server apps)
 *
 * ðŸ’¬ In simple words:
 * setMode() controls *when* the session â€œtellsâ€ its story.
 * You decide if it should speak now, whisper later, or write a note for others.
 */

=== examples/07-audit-and-metrics.php ===
<?php
/**
 * Example 07: Audit & Metrics
 *
 * ðŸ§  Theory:
 * The â€œAuditâ€ and â€œMetricsâ€ features help you **see and understand**
 * whatâ€™s really happening inside your Session system.
 *
 * Think of your session as a â€œblack boxâ€ ðŸ“¦ â€” you store, update, and delete data,
 * but without these tools, youâ€™d have no idea *when*, *how often*, or *by whom*.
 *
 * - ðŸ§¾ **Audit** keeps a historical log of what happened (like a journal).
 * - ðŸ“Š **Metrics** counts and measures actions (like a dashboard).
 *
 * Together, they make your Session *observable* â€” you can monitor, detect issues,
 * measure performance, and catch unusual activity in real time.
 *
 * ðŸ’¡ In simple words:
 * - Audit answers: â€œWhat happened?â€
 * - Metrics answers: â€œHow often did it happen?â€
 * - Security answers: â€œShould it have happened?â€
 *
 * These three work together to make your app reliable, measurable, and safe.
 */

use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Metrics;
use Avax\HTTP\Session\Session;

// Get a session instance
$session = Session::getInstance();

/**
 * === Step 1: Initialize the Audit and Metrics features ===
 *
 * The Audit feature records every session event (store, delete, flush, destroy)
 * and saves it to a structured log file (usually JSON or line-based text).
 *
 * The Metrics feature counts how many times things happen.
 * Example: how many times we stored something, deleted something, etc.
 */

$audit   = new Audit('/tmp/session_audit.log');   // Save audit entries to this file
$metrics = new Metrics();                         // In-memory metrics tracker

// Register them to listen to session events
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * ðŸ§© Think of this like adding two assistants to your Session:
 * - â€œAuditorâ€ writes everything down in a notebook (who did what, and when)
 * - â€œStatisticianâ€ keeps a counter on the wall tallying how many times it happened
 */

// === Step 2: Perform normal session actions ===
$session->put('user_id', 42);
$session->put('cart_items', ['apple', 'banana']);
$session->forget('cart_items');
$session->flush();

/**
 * ðŸ§  What happens under the hood:
 * - Every `put()` triggers a `stored` event â†’ Audit logs it, Metrics increments it.
 * - Every `forget()` triggers a `deleted` event â†’ Audit logs it, Metrics increments it.
 * - Every `flush()` triggers a `cleared` event â†’ both log and count it.
 *
 * ðŸ§¾ Example Audit log line (JSON):
 *   {"event":"stored","key":"user_id","time":"2025-12-05T18:24:00Z"}
 *
 * ðŸ“ˆ Example Metrics output:
 *   stored: 2
 *   deleted: 1
 *   cleared: 1
 */

// === Step 3: Review your audit logs ===
echo "\n--- Audit log content ---\n";
echo file_get_contents('/tmp/session_audit.log');

/**
 * ðŸ’¬ Real-world uses of Audit:
 * - ðŸ§‘â€ðŸ’¼ Compliance â€” prove who accessed what (GDPR, SOC2)
 * - ðŸ§  Debugging â€” track unexpected session mutations
 * - ðŸ”’ Security â€” detect abnormal access patterns or replay attacks
 *
 * For example:
 * - â€œWhy did the userâ€™s session reset at midnight?â€
 * - â€œWho deleted all the keys from this namespace?â€
 * - â€œWas this action done from a new IP?â€
 */

// === Step 4: Check your metrics counters ===
echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ðŸ’¡ Real-world uses of Metrics:
 * - Track total session writes/deletes
 * - Monitor spikes in session churn (possible attack)
 * - Visualize active session load in Prometheus or Grafana
 *
 * For example:
 * - â€œWe had 5k session stores/min â†’ possible login stormâ€
 * - â€œSpike in session deletions â†’ maybe session policy enforcement triggeredâ€
 */

// === Step 5: Customizing audit format ===
/**
 * Audit logs can be customized:
 * You can choose to write JSON, plain text, or even send logs to an external system.
 *
 * Example of custom formatter:
 */
$audit->setFormatter(function (string $event, array $context) {
    $time = date('H:i:s');

    return "[{$time}] EVENT: {$event} | CONTEXT: " . json_encode($context) . PHP_EOL;
});

$session->put('debug_key', 'value');

/**
 * Output will now look like:
 * [18:45:02] EVENT: stored | CONTEXT: {"key":"debug_key"}
 *
 * This gives you total control over how your logs are written and read.
 */

// === Step 6: Combining Audit + Metrics + Events ===
/**
 * You can have all three features working together like a team:
 *
 * Events  â†’ tell the story (who/what/when)
 * Audit   â†’ writes it down (record of truth)
 * Metrics â†’ counts it up (measure and visualize)
 *
 * This trio gives you 360Â° visibility into your applicationâ€™s session activity.
 *
 * ðŸ’¡ Tip:
 * You can ship these logs to tools like:
 * - ELK Stack (Elasticsearch + Logstash + Kibana)
 * - Grafana Loki
 * - Prometheus (via Metrics)
 * - Sentry or Bugsnag (for error traces)
 */

echo "\nâœ… Session Audit & Metrics example completed.\n";

/**
 * ðŸ§  Summary:
 * - Audit keeps history of every change (what happened)
 * - Metrics keeps counters (how often it happened)
 * - Together, they make your session system transparent
 *
 * ðŸ§© Think of them as:
 *   - Audit = Journal ðŸ“˜
 *   - Metrics = Dashboard ðŸ“Š
 *   - Events = Nerve signals âš¡
 *
 * With these three, your Session component isnâ€™t a â€œblack boxâ€ anymore â€”
 * itâ€™s an intelligent, traceable, and measurable system.
 */

/**
 * Example 07 (Extended): Audit & Metrics in a Real App
 *
 * ðŸ§  Real-world scenario:
 * Letâ€™s imagine weâ€™re building a real web app with login/logout.
 *
 * Each time a user logs in, we:
 *  - store their ID and name in the session
 *  - record the event in an audit log
 *  - increment our â€œactive sessionsâ€ counter
 *
 * Each time a user logs out, we:
 *  - remove their session data
 *  - log the logout event
 *  - decrement the counter
 *
 * This way, we always know:
 *  - Who logged in / logged out
 *  - When they did it
 *  - How many users are active right now
 *
 * This is how large enterprise systems maintain traceability and transparency.
 */

$session = Session::getInstance();
$audit   = new Audit('/tmp/audit_realworld.log');
$metrics = new Metrics();

// register features to listen on every event
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * === Step 1: Simulate a user login ===
 *
 * When a user logs in, we store session data.
 * Each of these will emit a `stored` event â†’ automatically logged and counted.
 */

function loginUser(Session $session, string $userId, string $username) : void
{
    $session->put('user_id', $userId);
    $session->put('username', $username);
    echo "âœ… User '{$username}' logged in.\n";
}

loginUser($session, 'U123', 'Alice');

/**
 * The Audit log will now have:
 *   {"event":"stored","key":"user_id",...}
 *   {"event":"stored","key":"username",...}
 *
 * And Metrics report will include:
 *   stored: 2
 */

/**
 * === Step 2: Simulate a page visit ===
 *
 * Even when users just browse around,
 * we can record â€œpage_accessedâ€ events manually.
 * This helps us measure engagement.
 */

$session->events()->dispatch('page_accessed', ['path' => '/dashboard', 'user_id' => 'U123']);

/**
 * === Step 3: Simulate a logout ===
 *
 * On logout, we remove all session data and
 * emit a â€œlogoutâ€ event for audit & metrics tracking.
 */

function logoutUser(Session $session) : void
{
    $session->flush(); // clears everything, emits `cleared`
    $session->events()->dispatch('logout', ['reason' => 'user_requested']);
    echo "ðŸšª User logged out.\n";
}

logoutUser($session);

/**
 * === Step 4: Review the results ===
 */
echo "\n--- Audit log ---\n";
echo file_get_contents('/tmp/audit_realworld.log');

echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ðŸ§  What did we get here?
 *
 * - Every important user action (login, browse, logout) was tracked.
 * - Audit provides *history* (who, what, when).
 * - Metrics provides *numbers* (how often it happened).
 *
 * ðŸ§¾ Audit snippet:
 * {"event":"stored","key":"user_id"}
 * {"event":"stored","key":"username"}
 * {"event":"logout","reason":"user_requested"}
 *
 * ðŸ“Š Metrics summary:
 * Array
 * (
 *   [stored] => 2
 *   [cleared] => 1
 *   [logout] => 1
 * )
 *
 * ðŸ§© Why this matters:
 * In production, this data helps you:
 * - Detect unusual activity (many logins per minute)
 * - Identify crashes (sessions that end too quickly)
 * - Prove compliance (who did what and when)
 *
 * ðŸ’¡ Tip:
 * You could also visualize `$metrics->report()` in a live dashboard,
 * or send `$audit` logs to Elastic / Loki / Sentry for monitoring.
 */

echo "\nâœ… Real-world Audit & Metrics demo completed.\n";

//  REAL WORLD EXAMPLE (continued)

/**
 * Example 07 (Extended): Audit & Metrics in a Real App
 *
 * ðŸ§  Real-world scenario:
 * Letâ€™s imagine weâ€™re building a real web app with login/logout.
 *
 * Each time a user logs in, we:
 *  - store their ID and name in the session
 *  - record the event in an audit log
 *  - increment our â€œactive sessionsâ€ counter
 *
 * Each time a user logs out, we:
 *  - remove their session data
 *  - log the logout event
 *  - decrement the counter
 *
 * This way, we always know:
 *  - Who logged in / logged out
 *  - When they did it
 *  - How many users are active right now
 *
 * This is how large enterprise systems maintain traceability and transparency.
 */

$session = Session::getInstance();
$audit   = new Audit('/tmp/audit_realworld.log');
$metrics = new Metrics();

// register features to listen on every event
$session->events()->listen('*', [$audit, 'record']);
$session->events()->listen('*', [$metrics, 'increment']);

/**
 * === Step 1: Simulate a user login ===
 *
 * When a user logs in, we store session data.
 * Each of these will emit a `stored` event â†’ automatically logged and counted.
 */

function loginUser(Session $session, string $userId, string $username) : void
{
    $session->put('user_id', $userId);
    $session->put('username', $username);
    echo "âœ… User '{$username}' logged in.\n";
}

loginUser($session, 'U123', 'Alice');

/**
 * The Audit log will now have:
 *   {"event":"stored","key":"user_id",...}
 *   {"event":"stored","key":"username",...}
 *
 * And Metrics report will include:
 *   stored: 2
 */

/**
 * === Step 2: Simulate a page visit ===
 *
 * Even when users just browse around,
 * we can record â€œpage_accessedâ€ events manually.
 * This helps us measure engagement.
 */

$session->events()->dispatch('page_accessed', ['path' => '/dashboard', 'user_id' => 'U123']);

/**
 * === Step 3: Simulate a logout ===
 *
 * On logout, we remove all session data and
 * emit a â€œlogoutâ€ event for audit & metrics tracking.
 */

function logoutUser(Session $session) : void
{
    $session->flush(); // clears everything, emits `cleared`
    $session->events()->dispatch('logout', ['reason' => 'user_requested']);
    echo "ðŸšª User logged out.\n";
}

logoutUser($session);

/**
 * === Step 4: Review the results ===
 */
echo "\n--- Audit log ---\n";
echo file_get_contents('/tmp/audit_realworld.log');

echo "\n--- Metrics summary ---\n";
print_r($metrics->report());

/**
 * ðŸ§  What did we get here?
 *
 * - Every important user action (login, browse, logout) was tracked.
 * - Audit provides *history* (who, what, when).
 * - Metrics provides *numbers* (how often it happened).
 *
 * ðŸ§¾ Audit snippet:
 * {"event":"stored","key":"user_id"}
 * {"event":"stored","key":"username"}
 * {"event":"logout","reason":"user_requested"}
 *
 * ðŸ“Š Metrics summary:
 * Array
 * (
 *   [stored] => 2
 *   [cleared] => 1
 *   [logout] => 1
 * )
 *
 * ðŸ§© Why this matters:
 * In production, this data helps you:
 * - Detect unusual activity (many logins per minute)
 * - Identify crashes (sessions that end too quickly)
 * - Prove compliance (who did what and when)
 *
 * ðŸ’¡ Tip:
 * You could also visualize `$metrics->report()` in a live dashboard,
 * or send `$audit` logs to Elastic / Loki / Sentry for monitoring.
 */

echo "\nâœ… Real-world Audit & Metrics demo completed.\n";

=== examples/08-security-policies-and-enforcement.php ===
<?php
/**
 * Example 08: Security Policies & Enforcement
 *
 * ðŸ§  Theory:
 * Security Policies are like *rules that guard your session*.
 * Each one watches over a specific type of risk and decides
 * whether the session should continue or be stopped.
 *
 * ðŸ’¬ Think of them as â€œsecurity guardsâ€ standing outside your session:
 * - One checks if youâ€™ve been gone too long (MaxIdlePolicy)
 * - One ensures you came through the secure HTTPS door (SecureOnlyPolicy)
 * - One verifies your ticket hasnâ€™t expired (MaxLifetimePolicy)
 * - One checks youâ€™re on the same network (SessionIpPolicy)
 * - One makes sure itâ€™s really your device (CrossAgentPolicy)
 * - And one manager makes sure all guards work together (CompositePolicy)
 *
 * ðŸ›¡ï¸ Why this matters:
 * Without these guards, sessions could stay open forever,
 * even on public computers, or travel over unsafe networks.
 *
 * ---------------------------------------------------------------------
 * ðŸ”’ Every Policy has a single job:
 *   â†’ To check ONE condition and either approve or reject the session.
 *
 * If it fails, it throws a PolicyViolationException â€”
 * which instantly ends or invalidates your session.
 * ---------------------------------------------------------------------
 *  ðŸ§  Enforcement
 *
 *  "Enforcement" means *actively applying* all security policies
 *  before allowing any session action.
 *
 *  Policies define the rules â€” enforcement ensures those rules
 *  are actually respected.
 *
 *  Think of it like a security guard at the door:
 *  - Policies = The building's rules
 *  - Enforcement = The guard checking everyone who enters
 *
 *  Without enforcement, policies are just words on paper.
 */

use Avax\HTTP\Session\Exceptions\PolicyViolationException;
use Avax\HTTP\Session\Security\Policies\{CompositePolicy,
    CrossAgentPolicy,
    MaxIdlePolicy,
    MaxLifetimePolicy,
    PolicyGroupBuilder,
    SecureOnlyPolicy,
    SessionIpPolicy};
use Avax\HTTP\Session\Session;

/**
 * Note: All policies used below (`MaxIdlePolicy`, `MaxLifetimePolicy`,
 * `SecureOnlyPolicy`, `SessionIpPolicy`, `CrossAgentPolicy`,
 * `CompositePolicy`, `PolicyGroupBuilder`) are real classes from the
 * session engine with the exact constructor signatures shown here.
 * This example is meant to be executable against the actual codebase.
 */

$session = Session::getInstance();

/**
 * -------------------------------------------------------------
 * ðŸ•’ 1. MaxIdlePolicy â€” â€œThe inactivity guardâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Checks how long a user has been inactive.
 * If too much time passes (say, 15 minutes), the session expires.
 *
 * ðŸ’¬ Think of it like:
 * Youâ€™re at a coffee shop using free Wi-Fi â˜•.
 * You walk away for too long, and the Wi-Fi disconnects â€” because it
 * assumes youâ€™re gone. Itâ€™s polite security, not punishment.
 *
 * ðŸ’¡ Why it exists:
 * - Prevents hijacking of forgotten sessions
 * - Logs out users who leave sessions open
 *
 * ðŸ¦ Real-world analogy:
 * Like an ATM ðŸ§ â€” if you stop pressing buttons, it cancels your session.
 */

$maxIdle = new MaxIdlePolicy(maxIdleSeconds: 15 * 60); // 15 minutes

/**
 * -------------------------------------------------------------
 * â³ 2. MaxLifetimePolicy â€” â€œThe absolute expiry guardâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * This one says, â€œNo matter how active you are, your session dies
 * after a fixed total time â€” for example, 2 hours.â€
 *
 * ðŸ’¬ Think of it like:
 * A parking ticket â±ï¸ â€” you can move your car around, but after
 * 2 hours the ticket expires no matter what.
 *
 * ðŸ’¡ Why it exists:
 * - Limits total lifetime of any session token
 * - Prevents attackers from reusing long-lived sessions
 *
 * ðŸ¢ Real-world analogy:
 * A concert wristband ðŸŽŸï¸ that stops being valid after midnight.
 */

/**
 * âš ï¸ NOTE: Donâ€™t confuse MaxLifetimePolicy with TTL.
 *
 * These two sound similar but control different things:
 *
 * - ðŸ•’ TTL (Time-To-Live) applies to a single key/value.
 *   â†’ Example: $session->put('otp', '123456', ttl: 300);
 *     Only this OTP will expire after 5 minutes.
 *
 * - â³ MaxLifetimePolicy applies to the entire session.
 *   â†’ Example: new MaxLifetimePolicy(3600);
 *     The whole session (all keys) will expire after 1 hour,
 *     even if the user keeps using it.
 *
 * ðŸ’¡ Think of it like:
 * - TTL = â€œThe milk in your fridge has an expiration date.â€ ðŸ¥›
 * - MaxLifetimePolicy = â€œThe whole fridge turns off at midnight.â€ ðŸ•›
 *
 * Use both for maximum safety:
 * TTL for short-lived sensitive data (like OTPs or tokens),
 * MaxLifetimePolicy for overall session expiration.
 */
$maxLifetime = new MaxLifetimePolicy(maxLifetimeSeconds: 2 * 3600); // 2 hours total lifetime

/**
 * -------------------------------------------------------------
 * ðŸ”’ 3. SecureOnlyPolicy â€” â€œThe HTTPS guardâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Allows sessions only over HTTPS connections.
 *
 * ðŸ’¬ Think of it like:
 * A private conversation in a soundproof room ðŸ”‡ â€”
 * if youâ€™re trying to talk through a megaphone in public (HTTP),
 * this guard slams the door shut.
 *
 * ðŸ’¡ Why it exists:
 * - Stops attackers from stealing cookies via sniffing
 * - Ensures your data travels through an encrypted tunnel
 *
 * ðŸ§ Real-world analogy:
 * Like whispering secrets in someoneâ€™s ear instead of shouting in the street.
 */

$secureOnly = new SecureOnlyPolicy(true);

/**
 * -------------------------------------------------------------
 * ðŸŒ 4. SessionIpPolicy â€” â€œThe network guardâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Ties your session to the same IP address it started from.
 * If your IP suddenly changes (for example, from one city to another),
 * it assumes something suspicious happened.
 *
 * ðŸ’¬ Think of it like:
 * You checked into a hotel under your name ðŸ¨.
 * If someone tries to use your room key from another building,
 * the hotel system locks it immediately.
 *
 * ðŸ’¡ Why it exists:
 * - Prevents hijacking when session IDs are stolen
 * - Ensures sessions canâ€™t jump between networks
 *
 * ðŸ•µï¸ Real-world analogy:
 * Like a keycard that only works at one hotel door â€” not anywhere else.
 */

$ipPolicy = new SessionIpPolicy();

/**
 * -------------------------------------------------------------
 * ðŸ§­ 5. CrossAgentPolicy â€” â€œThe device fingerprint guardâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Locks your session to the same browser or device that created it.
 * If you log in with Chrome and someone tries to use your session in Safari,
 * it gets blocked.
 *
 * ðŸ’¬ Think of it like:
 * Your face unlock feature on a phone ðŸ“± â€” it wonâ€™t open for anyone else.
 *
 * ðŸ’¡ Why it exists:
 * - Stops session reuse from stolen cookies
 * - Ensures the session only works on your original device
 *
 * ðŸ§© Real-world analogy:
 * Itâ€™s like a theater ticket ðŸŽ­ that says â€œvalid only on this seat and this showâ€.
 */

$crossAgent = new CrossAgentPolicy();

/**
 * -------------------------------------------------------------
 * ðŸ§© 6. CompositePolicy â€” â€œThe team managerâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Combines multiple smaller guards into one powerful security unit.
 *
 * ðŸ’¬ Think of it like:
 * A night club with several bouncers ðŸ•º:
 * - One checks your ID (SecureOnlyPolicy)
 * - One checks if youâ€™ve been idle (MaxIdlePolicy)
 * - One checks your ticket hasnâ€™t expired (MaxLifetimePolicy)
 *
 * If *any* says â€œnoâ€, youâ€™re not getting in.
 */

$compositePolicy = new CompositePolicy(policies: [
    $maxIdle,
    $maxLifetime,
    $secureOnly,
    $ipPolicy,
    $crossAgent
]);

/**
 * -------------------------------------------------------------
 * âš™ï¸ 7. Applying Policies to the Session
 * -------------------------------------------------------------
 *
 * Usually, a SessionManager / SessionProvider wires these policies
 * and runs them before operations like `get()`, `put()`, or
 * `regenerateId()`. In this example we call `$session->applyPolicy()`
 * directly only to make the enforcement flow explicit and easy to
 * follow in isolation.
 *
 * NOTE: In production, SessionProvider enforces these policies automatically.
 * You don't need to call applyPolicy() manually in your app code.
 */

try {
    $session->applyPolicy($compositePolicy);
    $session->put('user_id', 42);
    echo "âœ… Session is secure and active.\n";

    // Simulate user being idle too long
    sleep(seconds: 16 * 60); // 16 minutes

    // This triggers MaxIdlePolicy
    $session->get('user_id');

} catch (PolicyViolationException $e) {
    echo "ðŸš¨ Policy violation: {$e->getMessage()}\n";
}

/**
 * -------------------------------------------------------------
 * ðŸ§± 8. PolicyGroupBuilder â€” â€œThe recipe makerâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  What it does:
 * Lets you build a policy group with readable, fluent syntax.
 *
 * ðŸ’¬ Think of it like:
 * Writing your own â€œsecurity recipeâ€ in plain English.
 *
 * Example:
 * â€œAll sessions must be secure, expire after 15 minutes, and lock to device.â€
 *
 * Note: `PolicyGroupBuilder::create()->requireAll()->secureOnly()
 * ->maxIdle(900)->maxLifetime(3600)->ipBinding()->userAgentBinding()`
 * is the real fluent API from the policy subsystem, not pseudo-code.
 */

$securityRecipe = PolicyGroupBuilder::create()
    ->requireAll()
    ->secureOnly()
    ->maxIdle(seconds: 900)
    ->maxLifetime(seconds: 3600)
    ->ipBinding()
    ->userAgentBinding()
    ->endGroup()
    ->build();

$session->applyPolicy($securityRecipe);

echo "âœ… Built and applied security recipe successfully.\n";

/**
 * -------------------------------------------------------------
 * ðŸ§  9. How policies actually work inside the engine
 * -------------------------------------------------------------
 *
 * - Each policy implements `PolicyInterface` â†’ has `check(Session $session): void`
 * - The session engine runs `check()` for every active policy before any action
 * - If any fails â†’ throws `PolicyViolationException`
 *
 * ðŸ§© Simplified internal logic:
 *
 * class MaxIdlePolicy implements PolicyInterface {
 *     public function check(Session $session): void {
 *         $lastActivity = $session->getMeta('last_activity');
 *         if (time() - $lastActivity > $this->maxIdleTime) {
 *             throw new PolicyViolationException('Session expired due to inactivity.');
 *         }
 *     }
 * }
 *
 * ðŸ’¡ You never call `check()` manually â€” the framework does it for you.
 */

/**
 * -------------------------------------------------------------
 * ðŸ§© 10. Best Practices & Real-world Mapping
 * -------------------------------------------------------------
 *
 * ðŸ›¡ï¸ Always include at least:
 * - MaxIdlePolicy â†’ ends idle sessions
 * - SecureOnlyPolicy â†’ forces HTTPS
 *
 * ðŸ§© Add for extra safety:
 * - SessionIpPolicy â†’ ties session to the same IP
 * - CrossAgentPolicy â†’ ties session to the same device
 * - MaxLifetimePolicy â†’ expires sessions after total time
 *
 * ðŸ¢ Real-world examples:
 * - ðŸ’³ Online banking: auto-logout after 10 minutes (MaxIdle)
 * - âš™ï¸ Admin dashboards: HTTPS only (SecureOnly)
 * - ðŸ§‘â€ðŸ’» Corporate VPNs: IP bound sessions (SessionIp)
 * - ðŸ“± Mobile apps: device-bound sessions (CrossAgent)
 *
 * ðŸ” Advanced tip:
 * Combine these with your Audit feature to log all violations.
 * Youâ€™ll get a live feed of suspicious behavior.
 */

echo "\nâœ… Security Policies & Enforcement example completed successfully.\n";

/**
 * -------------------------------------------------------------
 * ðŸ§¾ Recap
 * -------------------------------------------------------------
 * - MaxIdlePolicy â†’ Like an ATM timeout â€” closes inactive sessions
 * - MaxLifetimePolicy â†’ Like a parking ticket â€” expires after total time
 * - SecureOnlyPolicy â†’ Like whispering secrets in private (HTTPS)
 * - SessionIpPolicy â†’ Like a hotel key that works only for one room
 * - CrossAgentPolicy â†’ Like Face ID â€” only works for your own device
 * - CompositePolicy â†’ Like a team of guards working together
 * - PolicyGroupBuilder â†’ Like writing a â€œsecurity recipeâ€
 *
 * ðŸ§  Together they form your sessionâ€™s immune system.
 * Your app automatically enforces good behavior â€” no extra work needed.
 *
 * ðŸ’¬ Think of it as:
 * â€œYour sessions now protect themselves.â€
 */

=== examples/09-recovery-and-backup.php ===
<?php
/**
 * Example 09: Recovery & Backup (Enterprise Edition - Corrected)
 * ============================================================
 *
 * ðŸ§  Theory:
 * Recovery is the sessionâ€™s built-in safety system â€” it ensures your
 * data *never gets lost* even during crashes, failed writes or
 * transaction errors.
 *
 * ðŸ’¬ Think of it as:
 * â€œUndo + Backup + Auto-healâ€ for your session state.
 */

use Avax\Filesystem\Storage\LocalFileStorage;
use Avax\HTTP\Session\Config\SessionConfig;
use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Data\Recovery;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Lifecycle\SessionProvider;
use Avax\HTTP\Session\Security\CookieManager;
use Avax\HTTP\Session\Security\EncrypterFactory;
use Avax\HTTP\Session\Security\Policies\PolicyGroupBuilder;
use Avax\HTTP\Session\Security\SessionRegistry;
use Avax\HTTP\Session\Security\SessionSignature;

// ----------------------------------------------------
// 1ï¸âƒ£ Setup: Enterprise-Ready Session Environment
// ----------------------------------------------------

/**
 * ðŸ§© Components:
 * - LocalFileStorage â†’ manages on-disk persistence
 * - FileStore â†’ filesystem-backed session storage
 * - Recovery â†’ snapshot/rollback manager (core service)
 * - EncrypterFactory â†’ AES-256-GCM encryption with key rotation
 * - SessionConfig â†’ immutable config object
 * - CookieManager â†’ applies Secure/HttpOnly/SameSite cookie flags
 * - Audit â†’ PSR-3 structured logging
 * - PolicyGroupBuilder â†’ defines idle/lifetime limits
 * - SessionSignature â†’ ensures integrity of session IDs
 */

$filesystem = new LocalFileStorage();

$store = new FileStore(
    storage  : $filesystem,
    directory: __DIR__ . '/storage/sessions'
);

// Core recovery engine (not a feature)
$recovery = new Recovery(store: $store);

// Enterprise-grade encryption (AES-256-GCM + rotation)
$encrypter = (new EncrypterFactory())->create();

// Secure cookie defaults
$cookieManager = new CookieManager();
$cookieManager->configureSessionCookie();

// Immutable configuration
$config = new SessionConfig(
    ttl   : 3600,
    secure: true,
);

// Optional supporting services
$audit     = new Audit(logPath: __DIR__ . '/logs/recovery_audit.log');
$signature = new SessionSignature(secretKey: $_ENV['SESSION_SIGNATURE_KEY'] ?? 'default-signature-key');
$registry  = new SessionRegistry(store: $store);

// Policy group (lifetime & idle)
$policies = PolicyGroupBuilder::create()
    ->requireAll()
    ->maxLifetime(3600)
    ->maxIdle(900)
    ->endGroup()
    ->build();

// Create session provider (main session engine)
$session = new SessionProvider(
    store    : $store,
    config   : $config,
    encrypter: $encrypter,
    recovery : $recovery, // âœ… now passed as dependency, not feature
    signature: $signature,
    policies : $policies,
    registry : $registry
);

// Attach only non-core features (observability, logging, metrics)
$session->registerFeature($audit);

// ----------------------------------------------------
// ðŸ§© DEMO 1 â€” Snapshot & Restore
// ----------------------------------------------------
/**
 * ðŸ§  Snapshot = save point.
 * Recovery lets you rewind to a safe state if corruption or crash occurs.
 */

try {
    $session->put('cart', ['item' => 'Laptop', 'price' => 1299]);
    $session->recovery()->snapshot();
    echo "ðŸ’¾ Snapshot created successfully.\n";

    // Simulate crash
    throw new RuntimeException("ðŸ’¥ Disk I/O failure while saving session!");
} catch (Throwable $e) {
    echo "âš ï¸ Crash detected: {$e->getMessage()}\n";

    $session->audit()->record('crash_detected', [
        'reason'    => $e->getMessage(),
        'timestamp' => time(),
    ]);

    $session->recovery()->restore();
    echo "âœ… Session restored from last snapshot.\n";
}

// ----------------------------------------------------
// ðŸ§© DEMO 2 â€” Transaction Safety (All or Nothing)
// ----------------------------------------------------
/**
 * ðŸ§  Transactions guarantee atomicity â€” either all operations succeed,
 * or none are applied (rollback ensures data consistency).
 */

try {
    $session->recovery()->snapshot();
    $session->recovery()->beginTransaction();

    $session->put('user_id', 42);
    $session->put('cart', ['item' => 'Headphones', 'price' => 199]);

    // Uncomment to simulate failure
    // throw new RuntimeException("ðŸ’¥ Payment gateway timeout!");

    $session->recovery()->commit();
    echo "âœ… Transaction committed successfully.\n";
} catch (Throwable $e) {
    echo "ðŸš¨ Transaction error: {$e->getMessage()}\n";

    $session->audit()->record('transaction_rollback', [
        'error'     => $e->getMessage(),
        'timestamp' => time(),
    ]);

    $session->recovery()->rollback();
    echo "â†©ï¸ Rolled back session to previous state.\n";
}

// ----------------------------------------------------
// ðŸ§© DEMO 3 â€” Automatic Recovery Integration
// ----------------------------------------------------
/**
 * ðŸ§  Recovery automatically restores the session from the
 * last valid snapshot if data corruption or crash is detected.
 */

try {
    echo "ðŸš€ Performing high-risk operation...\n";
    $session->put('temporary', ['step' => 1]);
    throw new RuntimeException("ðŸ’¥ Random crash occurred!");
} catch (Throwable $e) {
    echo "âš ï¸ System failure detected: {$e->getMessage()}\n";
    $session->recovery()->restore();
    echo "âœ… Session auto-restored from last known safe point.\n";
}

// ----------------------------------------------------
// ðŸ§¾ Final Recap
// ----------------------------------------------------
/**
 * âœ… snapshot() â†’ Save point
 * âœ… restore() â†’ Roll back to last safe state
 * âœ… transaction() â†’ Commit or rollback atomically
 *
 * ðŸ›¡ï¸ Enterprise Stack:
 * - AES-256-GCM encryption (EncrypterFactory)
 * - Recovery engine (core, not feature)
 * - Audit trail (PSR-3)
 * - HMAC session integrity (SessionSignature)
 * - Cookie hardening (CookieManager)
 * - Policy-based expiry (PolicyGroupBuilder)
 * - Registry tracking (SessionRegistry)
 */

echo "\nâœ… Enterprise Recovery & Backup demo completed.\n";

=== examples/10-observability-and-tracing.php ===
<?php
/**
 * Example 10: Observability & Self-Healing (Real Implementation)
 *
 * ðŸ§  THEORY:
 * Observability means your system can *see itself* â€”
 * it can tell you whatâ€™s happening inside, why itâ€™s happening,
 * and recover automatically when something goes wrong.
 *
 * You already have observability components â€” theyâ€™re just hidden in plain sight:
 *
 * - ðŸ•µï¸ Audit â†’ Records everything that happens (the â€œblack boxâ€)
 * - âš¡ Events â†’ Emits real-time signals (the â€œnervous systemâ€)
 * - ðŸ©¹ Recovery â†’ Restores the system when something fails (the â€œimmune systemâ€)
 *
 * Together, these make your Session component *self-aware and self-healing*.
 */

use Avax\Filesystem\Storage\LocalFileStorage;
use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Data\Recovery;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Lifecycle\SessionProvider;

// -------------------------------------------------------------
// 1ï¸âƒ£ SETUP â€” Build the observability stack
// -------------------------------------------------------------

/**
 * ðŸ§© The FileStore is your â€œmemory driveâ€.
 * Audit is your â€œblack boxâ€.
 * Events is your â€œevent busâ€ (real-time signaling).
 * Recovery is your â€œbackup & immune systemâ€.
 *
 * ðŸ§  But note:
 * Recovery is *not* a Session Feature â€” itâ€™s a helper service.
 * It doesnâ€™t â€œlive insideâ€ the session engine like Audit or Events.
 * Think of it as a mechanic who can repair the system from the outside.
 */

// 1ï¸âƒ£ Create proper storage backend
$filesystem = new LocalFileStorage();

// 2ï¸âƒ£ Pass it to FileStore (acts as the bridge between session and filesystem)
$store = new FileStore(
    storage  : $filesystem,
    directory: __DIR__ . '/storage/sessions'
);

// 3ï¸âƒ£ Initialize observability components
$audit    = new Audit(logPath: __DIR__ . '/logs/session/audit_observability.log');
$events   = new Events();
$recovery = new Recovery(store: $store); // âœ… helper, not feature

// 4ï¸âƒ£ Build the session provider
$session = new SessionProvider(store: $store);
$session->registerFeature($audit);
$session->registerFeature($events);

/**
 * -------------------------------------------------------------
 * 2ï¸âƒ£ AUDIT â€” The â€œblack box recorderâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  Concept:
 * The Audit feature logs every meaningful session action â€” put, get, flush, etc.
 * If something goes wrong, you can open its log and replay the story.
 *
 * ðŸ’¬ Think of it as a planeâ€™s black box âœˆï¸ â€”
 * it doesnâ€™t stop accidents, but it explains what happened.
 *
 * ðŸ§± Real-world analogy:
 * When a pilot reports â€œengine failureâ€, investigators check the black box.
 * When a user reports â€œI got logged outâ€, you check the audit log.
 */

$session->audit()->record(event: 'session_start', data: ['user_id' => 42]);
$session->put(key: 'user_id', value: 42);
$session->audit()->record(event: 'cart_update', data: ['action' => 'added item', 'item' => 'Laptop']);

/**
 * -------------------------------------------------------------
 * 3ï¸âƒ£ EVENTS â€” The â€œnervous systemâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  Concept:
 * The Events system emits real-time â€œsignalsâ€ whenever something happens.
 * For example: â€œstoredâ€, â€œdeletedâ€, â€œflushedâ€, â€œexpiredâ€.
 *
 * ðŸ’¬ Think of it like the nerves in your body â€”
 * they instantly notify you if somethingâ€™s hot, cold, or broken.
 *
 * ðŸ§± Real-world analogy:
 * Imagine touching something too hot ðŸ”¥ â€” your hand pulls away instantly.
 * Thatâ€™s how events allow instant reactions in your code.
 */

$session->events()->listen(event: 'stored', callback: static function ($data) {
    echo "ðŸ“¢ [Event] Key '{$data['key']}' was stored.\n";
});

$session->events()->listen(event: 'flushed', callback: static function () {
    echo "ðŸ§¹ [Event] All session data cleared.\n";
});

// Trigger some actions
$session->put(key: 'cart', value: ['item' => 'Laptop', 'price' => 1200]);
$session->flush();

/**
 * -------------------------------------------------------------
 * 4ï¸âƒ£ RECOVERY â€” The â€œimmune systemâ€
 * -------------------------------------------------------------
 *
 * ðŸ§  Concept:
 * Recovery automatically takes snapshots (backups) and can restore data
 * if the session is corrupted or a crash happens.
 *
 * ðŸ’¬ Think of it like an â€œundo buttonâ€ for your session.
 *
 * ðŸ§± Real-world analogy:
 * Imagine writing a long essay on your laptop, and the power goes out ðŸ’¥.
 * Auto-save brings everything back â€” thatâ€™s Recovery.
 *
 * âš™ï¸ Problem it solves:
 * Prevents total data loss due to exceptions, server errors, or backend issues.
 */

try {
    $session->put(key: 'checkout_step', value: 'shipping');
    $recovery->backup(); // âœ… make a safe snapshot

    // Simulate a crash
    throw new RuntimeException(message: 'ðŸ’¥ Disk failure while writing session!');
} catch (Throwable $e) {
    echo "âš ï¸ Error detected: {$e->getMessage()}\n";

    // âœ… Roll back to previous working state
    $recovery->restore();
    echo "âœ… Session state recovered successfully.\n";
}

/**
 * -------------------------------------------------------------
 * 5ï¸âƒ£ SELF-HEALING â€” Bringing it all together
 * -------------------------------------------------------------
 *
 * ðŸ§  Concept:
 * When something bad happens:
 *   - Events detect it instantly (reflex)
 *   - Audit records the details (memory)
 *   - Recovery restores the last safe state (healing)
 *
 * ðŸ’¬ In plain English:
 * â€œThe session system fell, noticed it, healed itself, and told you why.â€
 *
 * ðŸ§± Real-world analogy:
 * Like a self-driving car ðŸš— that detects a flat tire, slows down safely,
 * switches to backup power, and sends a diagnostic report.
 */

$events->listen(event: 'crash_detected', callback: function ($context) use ($audit) {
    $audit->record(event: 'crash_event', data: [
        'reason' => $context['reason'] ?? 'unknown',
        'time'   => date(format: 'c')
    ]);

    echo "ðŸ› ï¸ Auto-heal triggered for crash: {$context['reason']}\n";
});

// Simulate â€œself-healing eventâ€
$events->dispatch(event: 'crash_detected', data: ['reason' => 'database timeout']);

/**
 * -------------------------------------------------------------
 * ðŸ§¾ SUMMARY
 * -------------------------------------------------------------
 * âœ… Audit â€” records â€œwhat happenedâ€
 * âœ… Events â€” notify â€œwhen it happensâ€
 * âœ… Recovery â€” restores â€œwhen it failsâ€
 *
 * ðŸ§  Together, these make your Session *self-observing* and *resilient*.
 *
 * ðŸ’¬ Think of them like:
 * - The session can now *talk*, *remember*, and *heal*.
 * - You donâ€™t just store data â€” you manage a living, thinking system.
 */

echo "\nâœ… Observability & Self-Healing demo completed successfully.\n";

=== examples/11-Session-Lifecycle-&-Regeneration.php ===
<?php

/**
 * Example 11: Session Lifecycle & Regeneration
 *
 * ðŸ§  Theory:
 * Every session has a *lifecycle* â€” it is born, lives, renews itself, and eventually dies.
 *
 * This example demonstrates how the Session system handles:
 * - creation (starting a new session)
 * - regeneration (changing its ID for security)
 * - renewal (extending active sessions)
 * - expiration (ending idle or old sessions)
 * - termination (safe logout & cleanup)
 *
 * ðŸ’¬ Think of a session like a living organism:
 * - Itâ€™s born when a user logs in.
 * - It grows and evolves as you interact with your app.
 * - It renews its â€œidentityâ€ to stay safe.
 * - It dies when itâ€™s no longer needed â€” to keep the system clean.
 *
 * This lifecycle ensures your app remains secure, predictable, and self-maintaining.
 */

use Avax\Filesystem\Storage\LocalFileStorage;
use Avax\HTTP\Session\Data\FileStore;
use Avax\HTTP\Session\Exceptions\SessionException;
use Avax\HTTP\Session\Features\Audit;
use Avax\HTTP\Session\Features\Events;
use Avax\HTTP\Session\Lifecycle\SessionProvider;
use Avax\HTTP\Session\Security\Policies\PolicyGroupBuilder;
use Avax\HTTP\Session\Security\SessionRegistry;

// -------------------------------------------------------------
// 1ï¸âƒ£ SETUP â€” Preparing the environment
// -------------------------------------------------------------

/**
 * The FileStore handles where session data physically lives.
 * For example, here it writes serialized files to /storage/sessions/.
 */
$filesystem = new LocalFileStorage();
$store      = new FileStore(
    storage  : $filesystem,
    directory: __DIR__ . '/storage/sessions'
);

$audit    = new Audit(logPath: __DIR__ . '/logs/lifecycle_audit.log');
$events   = new Events();
$session  = new SessionProvider(store: $store);
$registry = new SessionRegistry(store: $store);

$session->registerFeature(feature: $audit);
$session->registerFeature(feature: $events);

// -------------------------------------------------------------
// 2ï¸âƒ£ SESSION BIRTH â€” â€œCreating a new lifeâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * A session is created when a user logs in or starts a new visit.
 * It receives a unique ID and empty storage.
 *
 * ðŸ’¬ In human terms:
 * Think of this as giving every user their own locker in a gym ðŸ‹ï¸.
 * They can now safely store personal items (data).
 */

$session->start();
$userId = 42;
$session->put(key: 'user_id', value: $userId);
$audit->record(event: 'session_created', data: ['user_id' => $userId]);

echo "ðŸ‘¶ Session started for user {$userId} with ID: {$session->getId()}\n";

// -------------------------------------------------------------
// 3ï¸âƒ£ SESSION ACTIVITY â€” â€œGrowing and changingâ€
// -------------------------------------------------------------
/**
 * As the user interacts with your app, you store or update data.
 * This represents an active, living session.
 *
 * Each write updates metadata â€” like last activity time.
 * This will matter later for idle timeout checks.
 */

$session->put(key: 'cart', value: ['item' => 'Laptop', 'price' => 1499]);
$audit->record(event: 'cart_update', data: ['item' => 'Laptop']);
echo "ðŸ§  User added item to cart.\n";

// -------------------------------------------------------------
// 4ï¸âƒ£ SESSION REGENERATION â€” â€œChanging identity for safetyâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * Session fixation attacks happen when an attacker tricks a victim
 * into using a known session ID. To prevent this, we *regenerate*
 * the ID after login or sensitive actions.
 *
 * ðŸ’¬ Think of it as changing your house locks ðŸ”‘ after someone gets a spare key.
 * The contents stay the same â€” but the key (session ID) changes.
 *
 * âš”ï¸ Prevents: Session Fixation Attack
 */

$oldId = $session->getId();
$session->regenerateId();
$newId = $session->getId();

$audit->record(event: 'session_regenerated', data: ['old_id' => $oldId, 'new_id' => $newId]);
echo sprintf("â™»ï¸ Session ID regenerated (old: %s â†’ new: %s)\n", $oldId, $newId);

// -------------------------------------------------------------
// 5ï¸âƒ£ SESSION RENEWAL â€” â€œExtending an active lifeâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * If a user stays active, we can â€œrenewâ€ their session
 * â€” meaning we extend its lifetime instead of expiring it.
 *
 * ðŸ’¬ Real-world example:
 * Think of a parking ticket â±ï¸.
 * If you keep feeding the meter (activity), your time extends.
 *
 * âš™ï¸ This works with MaxLifetimePolicy and MaxIdlePolicy.
 */

$policies = PolicyGroupBuilder::create()
    ->requireAll()
    ->maxIdle(seconds: 900)        // logout if idle 15 min
    ->maxLifetime(seconds: 3600)   // total life = 1 hour
    ->endGroup()
    ->build();

$session->registerPolicies(policies: [$policies]);
$session->renew();

$audit->record(event: 'session_renewed', data: ['user_id' => $userId]);
echo "ðŸ•’ Session lifetime extended â€” user is still active.\n";

// -------------------------------------------------------------
// 6ï¸âƒ£ SESSION EXPIRATION â€” â€œNatural deathâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * If a user leaves your app and goes idle too long,
 * MaxIdlePolicy automatically marks the session as expired.
 *
 * ðŸ’¬ Analogy:
 * Like your online banking session â€” if you go make coffee â˜•,
 * it logs you out after 10 minutes of inactivity.
 */

sleep(seconds: 1); // Simulate time passing
try {
    $session->applyPolicy($policies);
    echo "âœ… Session is still valid.\n";
} catch (SessionException $e) {
    echo "ðŸ’€ Session expired: {$e->getMessage()}\n";
    $session->destroy();
}

// -------------------------------------------------------------
// 7ï¸âƒ£ SESSION TERMINATION â€” â€œA clean and respectful goodbyeâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * Termination happens when the user explicitly logs out.
 * This wipes session data, revokes cookies, and updates the registry.
 *
 * ðŸ’¬ Think of it as returning your gym locker key ðŸ” and taking your stuff home.
 */

$session->destroy();
$audit->record(event: 'session_destroyed', data: ['user_id' => $userId]);
echo "ðŸ‘‹ User {$userId} logged out â€” session destroyed.\n";

// -------------------------------------------------------------
// 8ï¸âƒ£ SESSION REGISTRY â€” â€œTracking multiple livesâ€
// -------------------------------------------------------------
/**
 * ðŸ§  Concept:
 * The Session Registry keeps track of all user sessions
 * across devices, browsers, or regions.
 *
 * ðŸ’¬ Think of it like Netflix â†’ "You are logged in on: Chrome, iPhone, Smart TV"
 *
 * You can:
 * - revoke sessions on other devices
 * - inspect all active logins
 * - detect hijacking attempts
 */

// Register two devices for the same user
$registry->register(userId: (string) $userId, sessionId: $newId, metadata: ['user_agent' => 'Chrome on macOS']);
$registry->register(userId: (string) $userId, sessionId: 'XYZ987', metadata: ['user_agent' => 'iPhone Safari']);
$audit->record(event: 'registry_update', data: ['active_devices' => 2]);

echo "ðŸ“‹ Active sessions for user {$userId}:\n";
foreach ($registry->getSessionsByDevice(userId: (string) $userId) as $device => $sessions) {
    foreach ($sessions as $data) {
        echo " - {$device} â†’ {$data['session_id']}\n";
    }
}

// Simulate revoking one session (like user logs out on iPhone)
$registry->revoke(sessionId: 'XYZ987', reason: 'User manually logged out');
$audit->record(event: 'registry_revoke', data: ['device' => 'iPhone Safari']);
echo "ðŸš« Revoked iPhone session for user {$userId}.\n";

/**
 * -------------------------------------------------------------
 * ðŸ§¾ RECAP:
 * -------------------------------------------------------------
 * âœ… start() â€” new session born
 * âœ… put() â€” data written
 * âœ… regenerateId() â€” changed identity to prevent fixation
 * âœ… renew() â€” extended lifetime for active users
 * âœ… destroy() â€” end of life, all data wiped
 * âœ… registry â€” manage multiple â€œlivesâ€ across devices
 *
 * ðŸ’¬ Think of it as:
 * "Your sessions now have a complete life cycle â€”
 * they live, evolve, and die safely on their own."
 */

echo "\nðŸŒ Session Lifecycle demo completed successfully.\n";

=== examples/merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ðŸ“ Scanning directory: $TARGET_DIR"
echo "ðŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ðŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ðŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ðŸ§© Merged files : $MERGED"
echo "ðŸš« Skipped files: $SKIPPED"
echo "ðŸ“„ Output file  : $OUTPUT_FILE"

=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ðŸ“ Scanning directory: $TARGET_DIR"
echo "ðŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ðŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ðŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ðŸ§© Merged files : $MERGED"
echo "ðŸš« Skipped files: $SKIPPED"
echo "ðŸ“„ Output file  : $OUTPUT_FILE"

