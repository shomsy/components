=== API/FluentSession.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\API;

use Avax\HTTP\Session\Actions\RetrieveValue;
use Avax\HTTP\Session\Actions\StoreValue;
use Avax\HTTP\Session\Core\SessionContext;
use Avax\HTTP\Session\Features\Crypto\Actions\DecryptValue;
use Avax\HTTP\Session\Features\Crypto\Actions\EncryptValue;
use Avax\HTTP\Session\Features\TTL\Actions\CheckExpiration;
use Avax\HTTP\Session\Features\TTL\Actions\SetTTL;
use Avax\HTTP\Session\Storage\SessionStore;
use Avax\Security\Encryption\Contracts\EncrypterInterface;
use Closure;
use Stringable;

/**
 * FluentSession
 *
 * Fluent DSL builder for contextual session operations.
 *
 * This builder provides an immutable, chainable API for configuring
 * and executing session operations with various policies (encryption,
 * TTL, namespace isolation).
 *
 * Enterprise Rules:
 * - Immutability: Each method returns a new instance.
 * - Fluent API: Natural language method chaining.
 * - Context Preservation: Configuration is carried through the chain.
 *
 * Usage:
 *   Session::scope('cart')
 *       ->encrypt()
 *       ->withTTL(3600)
 *       ->store('items', [1, 2, 3]);
 *
 * @package Avax\HTTP\Session\API
 */
final readonly class FluentSession implements Stringable
{
    /**
     * FluentSession Constructor.
     *
     * @param SessionStore   $store   The session storage backend.
     * @param SessionContext $context The contextual configuration.
     */
    public function __construct(
        private SessionStore $store,
        private SessionContext $context
    ) {}

    /**
     * Enable encryption for stored values.
     *
     * Values stored after calling this method will be encrypted.
     *
     * Example:
     *   Session::builder()->encrypt()->store('token', $apiToken);
     *
     * @return self New immutable instance with encryption enabled.
     */
    public function encrypt(): self
    {
        // Clone context with encryption enabled.
        return new self(
            store: $this->store,
            context: $this->context->secure()
        );
    }

    /**
     * Set Time-To-Live for stored values.
     *
     * Values stored after calling this method will expire after the
     * specified duration.
     *
     * Example:
     *   Session::builder()->withTTL(300)->store('otp', '123456');
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self New immutable instance with TTL set.
     */
    public function withTTL(int $seconds): self
    {
        // Clone context with TTL set.
        return new self(
            store: $this->store,
            context: $this->context->withTTL($seconds)
        );
    }

    /**
     * Switch to a different namespace.
     *
     * Example:
     *   Session::builder()->namespace('admin')->store('role', 'superuser');
     *
     * @param string $namespace The namespace identifier.
     *
     * @return self New immutable instance with different namespace.
     */
    public function namespace(string $namespace): self
    {
        // Clone context with new namespace.
        return new self(
            store: $this->store,
            context: $this->context->forNamespace($namespace)
        );
    }

    /**
     * Store a value with the current context.
     *
     * This method applies all configured policies (encryption, TTL, namespace).
     *
     * Example:
     *   Session::scope('cart')->store('items', [1, 2, 3]);
     *
     * @param string $key   The session key.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function store(string $key, mixed $value): void
    {
        // Get encrypter from container.
        $encrypter = app(EncrypterInterface::class);

        // Create actions.
        $encryptAction = new EncryptValue($encrypter);
        $ttlAction = new SetTTL($this->store);

        // Delegate to StoreValue action.
        $action = new StoreValue(
            store: $this->store,
            context: $this->context,
            encryptor: $encryptAction,
            ttlSetter: $ttlAction
        );

        $action->execute(key: $key, value: $value);
    }

    /**
     * Retrieve a value with the current context.
     *
     * This method handles decryption and TTL validation automatically.
     *
     * Example:
     *   $items = Session::scope('cart')->retrieve('items', default: []);
     *
     * @param string $key     The session key.
     * @param mixed  $default The default value.
     *
     * @return mixed The retrieved value or default.
     */
    public function retrieve(string $key, mixed $default = null): mixed
    {
        // Get encrypter from container.
        $encrypter = app(EncrypterInterface::class);

        // Create actions.
        $decryptAction = new DecryptValue($encrypter);
        $ttlChecker = new CheckExpiration($this->store);

        // Delegate to RetrieveValue action.
        $action = new RetrieveValue(
            store: $this->store,
            context: $this->context,
            decryptor: $decryptAction,
            ttlChecker: $ttlChecker
        );

        return $action->execute(key: $key, default: $default);
    }

    /**
     * Check if a key exists in the current context.
     *
     * Example:
     *   if (Session::scope('cart')->has('items')) { ... }
     *
     * @param string $key The session key.
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool
    {
        // Resolve namespaced key.
        $resolvedKey = $this->resolveKey($key);

        return $this->store->has(key: $resolvedKey);
    }

    /**
     * Delete a value from the current context.
     *
     * Example:
     *   Session::scope('cart')->delete('items');
     *
     * @param string $key The session key.
     *
     * @return void
     */
    public function delete(string $key): void
    {
        // Resolve namespaced key.
        $resolvedKey = $this->resolveKey($key);

        $this->store->delete(key: $resolvedKey);
    }

    /**
     * Remember pattern - lazy evaluation.
     *
     * Retrieves a value or executes a callback to generate and store it.
     *
     * Example:
     *   $user = Session::scope('auth')->remember('user', fn() => User::find($id));
     *
     * @param string  $key      The session key.
     * @param Closure $callback The callback to generate the value.
     *
     * @return mixed The retrieved or generated value.
     */
    public function remember(string $key, Closure $callback): mixed
    {
        // Check if value exists.
        if ($this->has($key)) {
            return $this->retrieve($key);
        }

        // Execute callback to generate value.
        $value = $callback();

        // Store the generated value.
        $this->store(key: $key, value: $value);

        // Return the value.
        return $value;
    }

    /**
     * Magic invoke for quick retrieval.
     *
     * Example:
     *   $items = Session::scope('cart')('items', default: []);
     *
     * @param string $key     The session key.
     * @param mixed  $default The default value.
     *
     * @return mixed The retrieved value or default.
     */
    public function __invoke(string $key, mixed $default = null): mixed
    {
        return $this->retrieve(key: $key, default: $default);
    }

    /**
     * String representation for debugging.
     *
     * @return string
     */
    public function __toString(): string
    {
        return (string) $this->context;
    }

    /**
     * Resolve the full key with namespace prefix.
     *
     * @param string $key The base key.
     *
     * @return string The fully qualified key.
     */
    private function resolveKey(string $key): string
    {
        // Return raw key if no namespace or default namespace.
        if ($this->context->namespace === '' || $this->context->namespace === 'default') {
            return $key;
        }

        // Return namespaced key.
        return "{$this->context->namespace}.{$key}";
    }
}

=== API/SessionManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\API;

use Avax\HTTP\Session\Actions\InvalidateSession;
use Avax\HTTP\Session\Actions\RegenerateId;
use Avax\HTTP\Session\Actions\StartSession;
use Avax\HTTP\Session\Core\SessionContext;
use Avax\HTTP\Session\Features\Flash\FlashBag;
use Avax\HTTP\Session\Storage\SessionStore;
use Closure;

/**
 * SessionManager
 *
 * Main entry point for all session operations.
 *
 * This facade provides a clean, fluent DSL for session management,
 * orchestrating Actions and Features to deliver intuitive developer
 * experience.
 *
 * Enterprise Rules:
 * - Facade Pattern: Simplifies complex subsystem interactions.
 * - DSL Design: Natural language method names.
 * - Delegation: Delegates to Actions for testability.
 *
 * Usage:
 *   Session::scope('cart')->store('items', [1, 2, 3]);
 *   Session::flash('success', 'Saved!');
 *   Session::temporary(300)->store('otp', '123456');
 *
 * @package Avax\HTTP\Session\API
 */
final readonly class SessionManager
{
    /**
     * SessionManager Constructor.
     *
     * @param SessionStore $store The session storage backend.
     * @param FlashBag     $flash The flash messages feature.
     */
    public function __construct(
        private SessionStore $store,
        private FlashBag $flash
    ) {}

    /**
     * Start the session.
     *
     * Initializes the session lifecycle. Safe to call multiple times.
     *
     * @return self For method chaining.
     */
    public function start(): self
    {
        // Delegate to StartSession action.
        $action = new StartSession($this->store);
        $action->execute();

        return $this;
    }

    /**
     * Create a scoped session context.
     *
     * Enables namespace isolation for session data.
     *
     * Example:
     *   Session::scope('cart')->store('items', [1, 2, 3]);
     *
     * @param string $namespace The namespace identifier.
     *
     * @return FluentSession Fluent builder for scoped operations.
     */
    public function scope(string $namespace): FluentSession
    {
        // Create context for the namespace.
        $context = SessionContext::for($namespace);

        // Return fluent builder.
        return new FluentSession(
            store: $this->store,
            context: $context
        );
    }

    /**
     * Alias for scope() - more natural English.
     *
     * Example:
     *   Session::in('checkout')->store('payment', $data);
     *
     * @param string $namespace The namespace identifier.
     *
     * @return FluentSession Fluent builder for scoped operations.
     */
    public function in(string $namespace): FluentSession
    {
        return $this->scope($namespace);
    }

    /**
     * Create a temporary session with TTL.
     *
     * Values stored in this context will expire after the specified duration.
     *
     * Example:
     *   Session::temporary(300)->store('otp', '123456');
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return FluentSession Fluent builder with TTL.
     */
    public function temporary(int $seconds): FluentSession
    {
        // Create default context with TTL.
        $context = SessionContext::default()->withTTL($seconds);

        // Return fluent builder.
        return new FluentSession(
            store: $this->store,
            context: $context
        );
    }

    /**
     * Get the default fluent builder.
     *
     * Example:
     *   Session::builder()->encrypt()->store('token', $value);
     *
     * @return FluentSession Fluent builder with default context.
     */
    public function builder(): FluentSession
    {
        // Create default context.
        $context = SessionContext::default();

        // Return fluent builder.
        return new FluentSession(
            store: $this->store,
            context: $context
        );
    }

    /**
     * Quick flash message.
     *
     * Convenience method for adding flash messages.
     *
     * Example:
     *   Session::flash('success', 'Profile updated!');
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     * @param string $type  The message type (success, error, warning, info).
     *
     * @return void
     */
    public function flash(string $key, mixed $value, string $type = 'info'): void
    {
        // Delegate to FlashBag.
        $this->flash->add(key: $key, value: $value, type: $type);
    }

    /**
     * Access the flash bag.
     *
     * Example:
     *   Session::flashBag()->success('message', 'Saved!');
     *
     * @return FlashBag The flash messages feature.
     */
    public function flashBag(): FlashBag
    {
        return $this->flash;
    }

    /**
     * Remember pattern - lazy evaluation.
     *
     * Retrieves a value or executes a callback to generate and store it.
     *
     * Example:
     *   $user = Session::remember('current_user', fn() => User::find($id));
     *
     * @param string  $key      The session key.
     * @param Closure $callback The callback to generate the value.
     *
     * @return mixed The retrieved or generated value.
     */
    public function remember(string $key, Closure $callback): mixed
    {
        // Check if value exists.
        if ($this->store->has($key)) {
            return $this->store->get($key);
        }

        // Execute callback to generate value.
        $value = $callback();

        // Store the generated value.
        $this->store->put(key: $key, value: $value);

        // Return the value.
        return $value;
    }

    /**
     * Store a value in the default namespace.
     *
     * Example:
     *   Session::put('user_id', 123);
     *
     * @param string $key   The session key.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value): void
    {
        $this->store->put(key: $key, value: $value);
    }

    /**
     * Retrieve a value from the default namespace.
     *
     * Example:
     *   $userId = Session::get('user_id', default: null);
     *
     * @param string $key     The session key.
     * @param mixed  $default The default value.
     *
     * @return mixed The retrieved value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $this->store->get(key: $key, default: $default);
    }

    /**
     * Check if a key exists in the default namespace.
     *
     * Example:
     *   if (Session::has('user_id')) { ... }
     *
     * @param string $key The session key.
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool
    {
        return $this->store->has(key: $key);
    }

    /**
     * Delete a value from the default namespace.
     *
     * Example:
     *   Session::delete('user_id');
     *
     * @param string $key The session key.
     *
     * @return void
     */
    public function delete(string $key): void
    {
        $this->store->delete(key: $key);
    }

    /**
     * Get all session data.
     *
     * Example:
     *   $allData = Session::all();
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array
    {
        return $this->store->all();
    }

    /**
     * Invalidate and destroy the session.
     *
     * This is a security-critical operation that clears all data
     * and regenerates the session ID.
     *
     * Example:
     *   Session::invalidate(); // On logout
     *
     * @return void
     */
    public function invalidate(): void
    {
        // Delegate to InvalidateSession action.
        $action = new InvalidateSession($this->store);
        $action->execute();
    }

    /**
     * Regenerate the session ID.
     *
     * Security measure to prevent session fixation attacks.
     *
     * Example:
     *   Session::regenerate(); // After login
     *
     * @param bool $deleteOldSession Whether to destroy old session data.
     *
     * @return void
     */
    public function regenerate(bool $deleteOldSession = true): void
    {
        // Delegate to RegenerateId action.
        $action = new RegenerateId($this->store);
        $action->execute(deleteOldSession: $deleteOldSession);
    }

    /**
     * Get the current session ID.
     *
     * @return string The session identifier.
     */
    public function id(): string
    {
        return $this->store->getId();
    }
}

=== Actions/InvalidateSession.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Actions;

use Avax\HTTP\Session\Storage\SessionStore;

/**
 * InvalidateSession Action
 *
 * Single Responsibility: Securely destroy the current session.
 *
 * This action handles complete session invalidation, which includes:
 * - Clearing all session data
 * - Regenerating the session ID (prevents session fixation)
 * - Destroying the session on the storage backend
 *
 * Enterprise Rules:
 * - Security: Always regenerates ID to prevent session fixation attacks.
 * - Audit: Logs invalidation for security monitoring.
 * - Idempotent: Safe to call multiple times.
 *
 * Usage:
 *   $action = new InvalidateSession($store);
 *   $action->execute();
 *
 * Common Use Cases:
 * - User logout
 * - Session timeout
 * - Security breach response
 *
 * @package Avax\HTTP\Session\Actions
 */
final readonly class InvalidateSession
{
    /**
     * InvalidateSession Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Invalidate the session.
     *
     * This method performs a complete session teardown:
     * 1. Captures current session ID for logging
     * 2. Flushes all session data
     * 3. Regenerates session ID
     * 4. Logs the invalidation event
     *
     * Security Note:
     * - Regenerating the ID prevents session fixation attacks.
     * - All data is cleared to prevent information leakage.
     *
     * @return void
     */
    public function execute(): void
    {
        // Capture current session ID for audit logging.
        $oldSessionId = $this->store->getId();

        // Flush all session data to ensure clean slate.
        $this->store->flush();

        // Regenerate session ID and destroy old session file.
        // This prevents session fixation attacks.
        $this->store->regenerateId(deleteOldSession: true);

        // Log session invalidation for security audit trail.
        logger()?->info(
            message: 'Session invalidated successfully',
            context: [
                'old_session_id' => $oldSessionId,
                'new_session_id' => $this->store->getId(),
                'action' => 'InvalidateSession',
                'security_event' => true,
            ]
        );
    }
}

=== Actions/RegenerateId.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Actions;

use Avax\HTTP\Session\Storage\SessionStore;

/**
 * RegenerateId Action
 *
 * Single Responsibility: Regenerate the session ID for security.
 *
 * This action handles session ID regeneration, a critical security measure
 * to prevent session fixation and session hijacking attacks.
 *
 * Enterprise Rules:
 * - Security: Always called after authentication state changes.
 * - Audit: Logs regeneration events for security monitoring.
 * - Configurable: Can preserve or destroy old session data.
 *
 * Usage:
 *   $action = new RegenerateId($store);
 *   $action->execute(deleteOldSession: true);
 *
 * Common Use Cases:
 * - After successful login
 * - After privilege escalation
 * - Periodically during long sessions
 * - After sensitive operations
 *
 * @package Avax\HTTP\Session\Actions
 */
final readonly class RegenerateId
{
    /**
     * RegenerateId Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Regenerate session ID.
     *
     * This method regenerates the session ID while optionally preserving
     * or destroying the old session data.
     *
     * Security Note:
     * - Regenerating after login prevents session fixation attacks.
     * - Deleting old session prevents session hijacking via old ID.
     *
     * @param bool $deleteOldSession Whether to destroy the old session data.
     *                               Default: true (recommended for security).
     *
     * @return void
     */
    public function execute(bool $deleteOldSession = true): void
    {
        // Capture current session ID for audit logging.
        $oldSessionId = $this->store->getId();

        // Regenerate the session ID.
        // If deleteOldSession is true, the old session file is destroyed.
        $this->store->regenerateId(deleteOldSession: $deleteOldSession);

        // Capture new session ID.
        $newSessionId = $this->store->getId();

        // Log session ID regeneration for security audit trail.
        logger()?->info(
            message: 'Session ID regenerated successfully',
            context: [
                'old_session_id' => $oldSessionId,
                'new_session_id' => $newSessionId,
                'old_session_deleted' => $deleteOldSession,
                'action' => 'RegenerateId',
                'security_event' => true,
            ]
        );
    }
}

=== Actions/RetrieveValue.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Actions;

use Avax\HTTP\Session\Core\SessionContext;
use Avax\HTTP\Session\Features\Crypto\Actions\DecryptValue;
use Avax\HTTP\Session\Features\TTL\Actions\CheckExpiration;
use Avax\HTTP\Session\Storage\SessionStore;

/**
 * RetrieveValue Action
 *
 * Single Responsibility: Retrieve a value from the session with contextual processing.
 *
 * This action handles retrieving session data while:
 * - Checking TTL expiration
 * - Decrypting encrypted values
 * - Resolving namespaced keys
 * - Providing default fallback values
 *
 * Enterprise Rules:
 * - Security: Automatically decrypts encrypted data.
 * - TTL Enforcement: Returns null for expired values.
 * - Fail-safe: Returns default value on decryption failure.
 *
 * Usage:
 *   $action = new RetrieveValue($store, $context, $decryptor, $ttlChecker);
 *   $value = $action->execute('user_id', default: null);
 *
 * @package Avax\HTTP\Session\Actions
 */
final readonly class RetrieveValue
{
    /**
     * RetrieveValue Constructor.
     *
     * @param SessionStore    $store      The session storage backend.
     * @param SessionContext  $context    The contextual configuration.
     * @param DecryptValue    $decryptor  Action for decrypting values.
     * @param CheckExpiration $ttlChecker Action for validating TTL.
     */
    public function __construct(
        private SessionStore $store,
        private SessionContext $context,
        private DecryptValue $decryptor,
        private CheckExpiration $ttlChecker
    ) {}

    /**
     * Execute the action: Retrieve value with context.
     *
     * This method orchestrates the retrieval process:
     * 1. Resolves the namespaced key
     * 2. Checks TTL expiration
     * 3. Retrieves the raw value
     * 4. Decrypts if necessary
     * 5. Returns value or default
     *
     * @param string $key     The session key identifier.
     * @param mixed  $default The fallback value if key doesn't exist or is expired.
     *
     * @return mixed The retrieved value or default.
     */
    public function execute(string $key, mixed $default = null): mixed
    {
        // Resolve the full key with namespace prefix.
        $resolvedKey = $this->resolveKey($key);

        // Check if value has expired (TTL validation).
        if ($this->ttlChecker->execute($resolvedKey)) {
            // Value has expired, return default.
            logger()?->debug(
                message: 'Session value expired',
                context: [
                    'key' => $resolvedKey,
                    'action' => 'RetrieveValue',
                ]
            );

            return $default;
        }

        // Retrieve the raw value from storage.
        $value = $this->store->get(
            key: $resolvedKey,
            default: $default
        );

        // If value is null or default, return immediately.
        if ($value === null || $value === $default) {
            return $default;
        }

        // Check if value needs decryption.
        $metaKey = "{$resolvedKey}::__meta";
        $meta = $this->store->get(key: $metaKey, default: []);

        // Decrypt if metadata indicates encryption.
        if (isset($meta['encrypted']) && $meta['encrypted'] === true) {
            try {
                // Delegate decryption to specialized action.
                $value = $this->decryptor->execute($value);
            } catch (\RuntimeException $e) {
                // Decryption failed (tampering or corruption).
                // Log security warning and return default.
                logger()?->warning(
                    message: 'Session value decryption failed',
                    context: [
                        'key' => $resolvedKey,
                        'error' => $e->getMessage(),
                        'action' => 'RetrieveValue',
                    ]
                );

                return $default;
            }
        }

        // Return the processed value.
        return $value;
    }

    /**
     * Resolve the full key with namespace prefix.
     *
     * @param string $key The base key.
     *
     * @return string The fully qualified key.
     */
    private function resolveKey(string $key): string
    {
        // Return raw key if no namespace or default namespace.
        if ($this->context->namespace === '' || $this->context->namespace === 'default') {
            return $key;
        }

        // Return namespaced key.
        return "{$this->context->namespace}.{$key}";
    }
}

=== Actions/StartSession.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Actions;

use Avax\HTTP\Session\Storage\SessionStore;

/**
 * StartSession Action
 *
 * Single Responsibility: Initialize the session lifecycle.
 *
 * This action encapsulates the logic for starting a session, ensuring that
 * the session is properly initialized and ready for data storage and retrieval.
 *
 * Enterprise Rules:
 * - Idempotent: Starting an already-started session is safe (no-op).
 * - Security: Validates session configuration before initialization.
 * - Logging: Emits structured logs for audit trails.
 *
 * Usage:
 *   $action = new StartSession($store);
 *   $action->execute();
 *
 * @package Avax\HTTP\Session\Actions
 */
final readonly class StartSession
{
    /**
     * StartSession Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Start the session.
     *
     * This method delegates to the underlying storage mechanism to initialize
     * the session. If the session is already started, this is a no-op.
     *
     * Security Note:
     * - Ensures session configuration is valid before starting.
     * - Prevents session fixation by validating session ID format.
     *
     * @return void
     */
    public function execute(): void
    {
        // Check if session is already active to ensure idempotency.
        if ($this->store->isStarted()) {
            // Session already started, nothing to do.
            return;
        }

        // Delegate session initialization to the storage backend.
        $this->store->start();

        // Log session start for audit trail.
        logger()?->info(
            message: 'Session started successfully',
            context: [
                'session_id' => $this->store->getId(),
                'action' => 'StartSession',
            ]
        );
    }
}

=== Actions/StoreValue.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Actions;

use Avax\HTTP\Session\Core\SessionContext;
use Avax\HTTP\Session\Features\Crypto\Actions\EncryptValue;
use Avax\HTTP\Session\Features\TTL\Actions\SetTTL;
use Avax\HTTP\Session\Storage\SessionStore;

/**
 * StoreValue Action
 *
 * Single Responsibility: Store a value in the session with contextual policies.
 *
 * This action handles storing session data while respecting:
 * - Namespace isolation
 * - Encryption requirements
 * - TTL (Time-To-Live) expiration
 * - Metadata tracking
 *
 * Enterprise Rules:
 * - Security-first: Encrypts sensitive data when required.
 * - Validation: Guards against invalid keys and values.
 * - Atomicity: Storage is atomic (all-or-nothing).
 *
 * Usage:
 *   $action = new StoreValue($store, $context, $encryptor, $ttlManager);
 *   $action->execute('user_id', 123);
 *
 * @package Avax\HTTP\Session\Actions
 */
final readonly class StoreValue
{
    /**
     * StoreValue Constructor.
     *
     * @param SessionStore    $store     The session storage backend.
     * @param SessionContext  $context   The contextual configuration (namespace, TTL, encryption).
     * @param EncryptValue    $encryptor Action for encrypting values.
     * @param SetTTL          $ttlSetter Action for setting TTL metadata.
     */
    public function __construct(
        private SessionStore $store,
        private SessionContext $context,
        private EncryptValue $encryptor,
        private SetTTL $ttlSetter
    ) {}

    /**
     * Execute the action: Store value with context.
     *
     * This method orchestrates the storage process:
     * 1. Resolves the namespaced key
     * 2. Encrypts the value if required
     * 3. Sets TTL metadata if specified
     * 4. Stores the value atomically
     *
     * @param string $key   The session key identifier.
     * @param mixed  $value The value to store (must be serializable).
     *
     * @return void
     */
    public function execute(string $key, mixed $value): void
    {
        // Guard: Validate key is not empty.
        if (trim($key) === '') {
            throw new \InvalidArgumentException(
                message: 'Session key cannot be empty'
            );
        }

        // Resolve the full key with namespace prefix.
        $resolvedKey = $this->resolveKey($key);

        // Process value based on context policies.
        $processedValue = $value;

        // Apply encryption if required by context.
        if ($this->context->secure) {
            // Delegate encryption to specialized action.
            $processedValue = $this->encryptor->execute($value);
        }

        // Store the (potentially encrypted) value.
        $this->store->put(
            key: $resolvedKey,
            value: $processedValue
        );

        // Set TTL metadata if specified in context.
        if ($this->context->ttl !== null) {
            // Delegate TTL management to specialized action.
            $this->ttlSetter->execute(
                key: $resolvedKey,
                ttl: $this->context->ttl
            );
        }

        // Log the storage operation for audit trail.
        logger()?->debug(
            message: 'Session value stored',
            context: [
                'key' => $resolvedKey,
                'encrypted' => $this->context->secure,
                'ttl' => $this->context->ttl,
                'namespace' => $this->context->namespace,
                'action' => 'StoreValue',
            ]
        );
    }

    /**
     * Resolve the full key with namespace prefix.
     *
     * If a namespace is defined in the context, it is prepended to the key
     * to ensure logical isolation of session data.
     *
     * @param string $key The base key.
     *
     * @return string The fully qualified key.
     */
    private function resolveKey(string $key): string
    {
        // Return raw key if no namespace or default namespace.
        if ($this->context->namespace === '' || $this->context->namespace === 'default') {
            return $key;
        }

        // Return namespaced key.
        return "{$this->context->namespace}.{$key}";
    }
}

=== Core/SessionContext.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core;

use Avax\HTTP\Session\Enums\SessionTag;

/**
 * SessionContext Value Object
 *
 * Immutable configuration context for session operations.
 *
 * This value object encapsulates all contextual configuration for session
 * operations including namespace isolation, TTL expiration, encryption,
 * and semantic tagging.
 *
 * Enterprise Rules:
 * - Immutability: All modifications return new instances.
 * - Validation: Guards against invalid states.
 * - Type Safety: Strict typing throughout.
 *
 * Usage:
 *   $context = SessionContext::for('cart')
 *       ->secure()
 *       ->withTTL(3600);
 *
 * @package Avax\HTTP\Session\Core
 */
final readonly class SessionContext
{
    /**
     * SessionContext Constructor.
     *
     * @param string           $namespace Logical scope identifier (e.g. "user", "cart", "flash").
     * @param bool             $secure    Whether encryption is enforced for session values.
     * @param int|null         $ttl       Optional time-to-live in seconds for temporary data.
     * @param list<SessionTag> $tags      Domain-relevant tags for organizational metadata.
     */
    public function __construct(
        public string   $namespace,
        public bool     $secure = false,
        public int|null $ttl = null,
        public array    $tags = []
    ) {
        // Guard: Validate TTL is positive if set.
        if ($this->ttl !== null && $this->ttl <= 0) {
            throw new \InvalidArgumentException(
                message: "TTL must be positive, got: {$this->ttl}"
            );
        }

        // Guard: Validate namespace doesn't contain special characters.
        if (preg_match('/[^a-zA-Z0-9_\-.]/', $this->namespace)) {
            throw new \InvalidArgumentException(
                message: "Namespace contains invalid characters: {$this->namespace}"
            );
        }
    }

    /**
     * Factory: Create context for a specific namespace.
     *
     * @param string $namespace Logical namespace for grouping session data.
     *
     * @return self
     */
    public static function for(string $namespace): self
    {
        // Trim dots from namespace edges.
        $namespace = trim($namespace, '.');

        return new self(namespace: $namespace);
    }

    /**
     * Factory: Create default context.
     *
     * @return self
     */
    public static function default(): self
    {
        return new self(namespace: 'default');
    }

    /**
     * Clone with encryption enabled.
     *
     * Returns a new instance with secure flag set to true.
     *
     * @return self New immutable instance.
     */
    public function secure(): self
    {
        return new self(
            namespace: $this->namespace,
            secure: true,
            ttl: $this->ttl,
            tags: $this->tags
        );
    }

    /**
     * Clone with TTL set.
     *
     * Returns a new instance with specified TTL.
     *
     * @param int $ttl Time-to-live in seconds.
     *
     * @return self New immutable instance.
     */
    public function withTTL(int $ttl): self
    {
        return new self(
            namespace: $this->namespace,
            secure: $this->secure,
            ttl: $ttl,
            tags: $this->tags
        );
    }

    /**
     * Clone with tag added.
     *
     * Returns a new instance with the tag appended.
     *
     * @param SessionTag $tag The tag to add.
     *
     * @return self New immutable instance.
     */
    public function tag(SessionTag $tag): self
    {
        return new self(
            namespace: $this->namespace,
            secure: $this->secure,
            ttl: $this->ttl,
            tags: array_unique([...$this->tags, $tag])
        );
    }

    /**
     * Clone with different namespace.
     *
     * Returns a new instance with updated namespace.
     *
     * @param string $namespace The new namespace.
     *
     * @return self New immutable instance.
     */
    public function forNamespace(string $namespace): self
    {
        // Trim dots from namespace edges.
        $namespace = trim($namespace, '.');

        return new self(
            namespace: $namespace,
            secure: $this->secure,
            ttl: $this->ttl,
            tags: $this->tags
        );
    }

    /**
     * String representation for debugging.
     *
     * @return string
     */
    public function __toString(): string
    {
        return sprintf(
            'SessionContext(namespace="%s", secure=%s, ttl=%s, tags=%d)',
            $this->namespace,
            $this->secure ? 'true' : 'false',
            $this->ttl ?? 'null',
            count($this->tags)
        );
    }
}

=== Core/SessionData.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core;

/**
 * SessionData DTO
 *
 * Data Transfer Object for session data.
 *
 * This DTO encapsulates session data for transfer between layers,
 * providing type-safe serialization and deserialization.
 *
 * Enterprise Rules:
 * - Immutability: Once created, data cannot be modified.
 * - Type Safety: Enforces array structure.
 * - Serialization: Provides conversion methods.
 *
 * Usage:
 *   $data = SessionData::from(['user_id' => 123, 'name' => 'John']);
 *   $array = $data->toArray();
 *
 * @package Avax\HTTP\Session\Core
 */
final readonly class SessionData
{
    /**
     * SessionData Constructor.
     *
     * @param array<string, mixed> $data The session data.
     */
    public function __construct(
        private array $data
    ) {}

    /**
     * Create from array.
     *
     * @param array<string, mixed> $data The session data.
     *
     * @return self
     */
    public static function from(array $data): self
    {
        return new self(data: $data);
    }

    /**
     * Create empty session data.
     *
     * @return self
     */
    public static function empty(): self
    {
        return new self(data: []);
    }

    /**
     * Convert to array.
     *
     * @return array<string, mixed>
     */
    public function toArray(): array
    {
        return $this->data;
    }

    /**
     * Get a value by key.
     *
     * @param string $key     The key.
     * @param mixed  $default The default value.
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null): mixed
    {
        return $this->data[$key] ?? $default;
    }

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool
     */
    public function has(string $key): bool
    {
        return array_key_exists($key, $this->data);
    }

    /**
     * Merge with another SessionData.
     *
     * @param SessionData $other The other session data.
     *
     * @return self New instance with merged data.
     */
    public function merge(SessionData $other): self
    {
        return new self(
            data: array_merge($this->data, $other->data)
        );
    }

    /**
     * Filter data by keys.
     *
     * @param array<string> $keys The keys to include.
     *
     * @return self New instance with filtered data.
     */
    public function only(array $keys): self
    {
        return new self(
            data: array_intersect_key(
                $this->data,
                array_flip($keys)
            )
        );
    }

    /**
     * Exclude keys from data.
     *
     * @param array<string> $keys The keys to exclude.
     *
     * @return self New instance without excluded keys.
     */
    public function except(array $keys): self
    {
        return new self(
            data: array_diff_key(
                $this->data,
                array_flip($keys)
            )
        );
    }

    /**
     * Check if data is empty.
     *
     * @return bool
     */
    public function isEmpty(): bool
    {
        return empty($this->data);
    }

    /**
     * Get all keys.
     *
     * @return array<string>
     */
    public function keys(): array
    {
        return array_keys($this->data);
    }

    /**
     * Get count of items.
     *
     * @return int
     */
    public function count(): int
    {
        return count($this->data);
    }
}

=== Enums/SessionBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Enums;

/**
 * Enum `SessionBag`
 *
 * Represents the types of session data bags used in the session management system.
 * By using enums, this design allows for strict type safety and eliminates the risk
 * of invalid session bag type usage. Adhering to Clean Code principles, this ensures
 * the operation surrounding session bag types remains self-contained, predictable,
 * and scalable.
 *
 * @package Avax\HTTP\Session\Enums
 */
enum SessionBag: string
{
    /**
     * Flash Bag
     *
     * Represents the session bag for flash messages â€” temporary session
     * data that persists only until it is read during the next request.
     *
     * Example usage:
     * - Temporary notifications (e.g., "Your account has been updated.")
     * - Alerts displayed post-redirect.
     *
     * @var string
     */
    case Flash = 'flash';

    /**
     * Input Bag
     *
     * Captures user input data and retains it for redisplaying forms in case
     * of validation failures. This is commonly used to show old input in forms.
     *
     * Example usage:
     * - Preserving user input after form validation errors.
     *
     * @var string
     */
    case Input = 'input';

    /**
     * Validation Bag
     *
     * Holds validation error messages associated with forms or other input validation.
     * This helps maintain a clear separation of data related to failed validations.
     *
     * Example usage:
     * - Displaying form field or general error messages in the UI.
     *
     * @var string
     */
    case Validation = 'validation';
}
=== Enums/SessionDriver.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Enums;

/**
 * Enum `SessionDriver`
 *
 * Represents the available session storage drivers in the application's session handling system.
 * Enumerations here define clearly the specific storage mechanisms supported.
 * This adheres to the Single Responsibility Principle by isolating session-driver-related constants
 * in a self-contained construct. This type-safety ensures scalability and reduces potential usage errors.
 *
 * @package Avax\HTTP\Session\Enums
 */
enum SessionDriver: string
{
    /**
     * Native Session Driver
     *
     * Represents the use of PHP's default session handling mechanism.
     * Suited for applications where the native PHP session engine suffices,
     * such as basic file-based storage without external adapters.
     *
     * @var string
     */
    case Native = 'native';

    /**
     * Array-Based Session Driver
     *
     * Represents a memory-only session storage mechanism where session data
     * is stored in arrays. This is ideal for unit testing or scenarios
     * where persistent state is not required.
     *
     * @var string
     */
    case Array = 'array';
}
=== Enums/SessionTag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Enums;

/**
 * Enum `SessionTag`
 *
 * Represents different types of tags that categorize session data in the application.
 * By utilizing an enum, this structure ensures explicit type safety and eliminates
 * the risk of hardcoded or invalid session tag values. This adheres to Domain-Driven Design (DDD)
 * principles by enforcing strong domain boundaries and context-specific behavior.
 *
 * Enums provide clarity and predictability, making the codebase more expressive
 * and maintainable, ensuring clean design principles are upheld.
 *
 * @package Avax\HTTP\Session\Enums
 */
enum SessionTag: string
{
    /**
     * Flash Tag
     *
     * The flash tag is used to categorize session data that is temporary and designed
     * to last only until the next request is completed. Commonly used for passing
     * notifications or alerts across requests after a redirect.
     *
     * Example Use-Cases:
     * - Temporary feedback ("Your profile has been updated.")
     * - Notifications requiring user acknowledgment during the next request.
     *
     * @var string
     *
     * Usage:
     * ```
     * $session->set(SessionTag::Flash, 'Your changes have been saved!');
     * ```
     */
    case Flash = 'flash';

    /**
     * User Tag
     *
     * The user tag categorizes session data related specifically to the logged-in user.
     * This tag can be leveraged to store user-related metadata, preferences, or credentials
     * that are required during the session's lifecycle.
     *
     * Example Use-Cases:
     * - Authentication tokens.
     * - User preferences (e.g., locale, themes).
     *
     * @var string
     *
     * Usage:
     * ```
     * $session->set(SessionTag::User, ['id' => 123, 'name' => 'John Doe']);
     * ```
     */
    case User = 'user';
}
=== Exceptions/FlashBagKeyNotFoundException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * Exception thrown when attempting to retrieve a non-existent flash key.
 */
final class FlashBagKeyNotFoundException extends RuntimeException {}
=== Exceptions/SessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Exceptions;

use RuntimeException;

/**
 * SessionException
 * Custom exception class for session management errors.
 */
class SessionException extends RuntimeException {}
=== Features/Crypto/Actions/DecryptValue.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Crypto\Actions;

use Avax\Security\Encryption\Contracts\EncrypterInterface;

/**
 * DecryptValue Action
 *
 * Single Responsibility: Decrypt an encrypted session value.
 *
 * This action delegates to the encryption service to decrypt and restore
 * session data that was previously encrypted.
 *
 * Enterprise Rules:
 * - Security: Validates encrypted data integrity.
 * - Error handling: Throws on decryption failure (tampering detection).
 * - Logging: Records decryption failures for security monitoring.
 *
 * Usage:
 *   $action = new DecryptValue($encrypter);
 *   $decrypted = $action->execute($encryptedString);
 *
 * @package Avax\HTTP\Session\Features\Crypto\Actions
 */
final readonly class DecryptValue
{
    /**
     * DecryptValue Constructor.
     *
     * @param EncrypterInterface $encrypter The encryption service.
     */
    public function __construct(
        private EncrypterInterface $encrypter
    ) {}

    /**
     * Execute the action: Decrypt value.
     *
     * This method:
     * 1. Validates encrypted string format
     * 2. Decrypts using the encryption service
     * 3. Returns original value
     *
     * @param string $encryptedValue The encrypted value.
     *
     * @return mixed The decrypted original value.
     *
     * @throws \RuntimeException If decryption fails (tampering or corruption).
     */
    public function execute(string $encryptedValue): mixed
    {
        try {
            // Delegate decryption to the encryption service.
            // The encrypter handles deserialization internally.
            $decrypted = $this->encrypter->decrypt($encryptedValue);

            // Log decryption event (without sensitive data).
            logger()?->debug(
                message: 'Session value decrypted',
                context: [
                    'result_type' => get_debug_type($decrypted),
                    'action' => 'DecryptValue',
                    'security_event' => true,
                ]
            );

            return $decrypted;
        } catch (\Throwable $e) {
            // Log decryption failure as potential security event.
            // This could indicate tampering or data corruption.
            logger()?->warning(
                message: 'Session value decryption failed - possible tampering',
                context: [
                    'error' => $e->getMessage(),
                    'action' => 'DecryptValue',
                    'security_event' => true,
                    'severity' => 'high',
                ]
            );

            // Re-throw as RuntimeException.
            throw new \RuntimeException(
                message: 'Failed to decrypt session value: ' . $e->getMessage(),
                previous: $e
            );
        }
    }
}

=== Features/Crypto/Actions/EncryptValue.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Crypto\Actions;

use Avax\Security\Encryption\Contracts\EncrypterInterface;

/**
 * EncryptValue Action
 *
 * Single Responsibility: Encrypt a session value for secure storage.
 *
 * This action delegates to the encryption service to protect sensitive
 * session data from unauthorized access.
 *
 * Enterprise Rules:
 * - Security: Uses AES-256-GCM encryption.
 * - Validation: Ensures value is serializable.
 * - Error handling: Throws on encryption failure.
 *
 * Usage:
 *   $action = new EncryptValue($encrypter);
 *   $encrypted = $action->execute($sensitiveData);
 *
 * @package Avax\HTTP\Session\Features\Crypto\Actions
 */
final readonly class EncryptValue
{
    /**
     * EncryptValue Constructor.
     *
     * @param EncrypterInterface $encrypter The encryption service.
     */
    public function __construct(
        private EncrypterInterface $encrypter
    ) {}

    /**
     * Execute the action: Encrypt value.
     *
     * This method:
     * 1. Serializes the value if needed
     * 2. Encrypts using the encryption service
     * 3. Returns encrypted string
     *
     * @param mixed $value The value to encrypt.
     *
     * @return string The encrypted value.
     *
     * @throws \RuntimeException If encryption fails.
     */
    public function execute(mixed $value): string
    {
        try {
            // Delegate encryption to the encryption service.
            // The encrypter handles serialization internally.
            $encrypted = $this->encrypter->encrypt($value);

            // Log encryption event (without sensitive data).
            logger()?->debug(
                message: 'Session value encrypted',
                context: [
                    'value_type' => get_debug_type($value),
                    'action' => 'EncryptValue',
                    'security_event' => true,
                ]
            );

            return $encrypted;
        } catch (\Throwable $e) {
            // Log encryption failure.
            logger()?->error(
                message: 'Session value encryption failed',
                context: [
                    'error' => $e->getMessage(),
                    'action' => 'EncryptValue',
                    'security_event' => true,
                ]
            );

            // Re-throw as RuntimeException.
            throw new \RuntimeException(
                message: 'Failed to encrypt session value: ' . $e->getMessage(),
                previous: $e
            );
        }
    }
}

=== Features/Flash/Actions/AddFlash.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Flash\Actions;

use Avax\HTTP\Session\Features\Flash\FlashMessage;
use Avax\HTTP\Session\Storage\SessionStore;

/**
 * AddFlash Action
 *
 * Single Responsibility: Add a flash message to the session.
 *
 * This action encapsulates the logic for storing flash messages that persist
 * for exactly one request cycle (Post-Redirect-Get pattern).
 *
 * Enterprise Rules:
 * - Atomicity: Flash storage is atomic.
 * - Lifecycle: Messages are automatically cleaned up after retrieval.
 * - Type Safety: Uses FlashMessage value object.
 *
 * Usage:
 *   $action = new AddFlash($store);
 *   $action->execute('success', 'Profile updated!', 'success');
 *
 * @package Avax\HTTP\Session\Features\Flash\Actions
 */
final readonly class AddFlash
{
    /**
     * AddFlash Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Add flash message.
     *
     * This method:
     * 1. Creates a FlashMessage value object
     * 2. Stores it with flash prefix
     * 3. Tracks the key for cleanup
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     * @param string $type  The message type (success, error, warning, info).
     *
     * @return void
     */
    public function execute(string $key, mixed $value, string $type = 'info'): void
    {
        // Create flash message value object.
        // This validates the type and key.
        $message = new FlashMessage(
            key: $key,
            value: $value,
            type: $type
        );

        // Store flash message with special prefix.
        $this->store->put(
            key: "_flash.{$key}",
            value: $message->toArray()
        );

        // Track this key for automatic cleanup.
        // Get existing flash keys.
        $flashKeys = $this->store->get(key: '_flash._keys', default: []);

        // Add new key if not already tracked.
        if (!in_array($key, $flashKeys, strict: true)) {
            $flashKeys[] = $key;
            $this->store->put(key: '_flash._keys', value: $flashKeys);
        }

        // Log flash message addition.
        logger()?->debug(
            message: 'Flash message added',
            context: [
                'key' => $key,
                'type' => $type,
                'action' => 'AddFlash',
            ]
        );
    }
}

=== Features/Flash/Actions/GetFlash.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Flash\Actions;

use Avax\HTTP\Session\Features\Flash\FlashMessage;
use Avax\HTTP\Session\Storage\SessionStore;

/**
 * GetFlash Action
 *
 * Single Responsibility: Retrieve and remove a flash message.
 *
 * This action implements the "pull" pattern for flash messages:
 * - Retrieves the message
 * - Removes it from storage (one-time use)
 * - Returns the FlashMessage value object
 *
 * Enterprise Rules:
 * - Atomicity: Retrieval and removal are atomic.
 * - One-time use: Messages are deleted after retrieval.
 * - Type Safety: Returns FlashMessage or null.
 *
 * Usage:
 *   $action = new GetFlash($store);
 *   $message = $action->execute('success');
 *
 * @package Avax\HTTP\Session\Features\Flash\Actions
 */
final readonly class GetFlash
{
    /**
     * GetFlash Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Get and remove flash message.
     *
     * This method:
     * 1. Retrieves the flash message data
     * 2. Removes it from storage
     * 3. Returns FlashMessage object or null
     *
     * @param string $key The flash message identifier.
     *
     * @return FlashMessage|null The flash message or null if not found.
     */
    public function execute(string $key): FlashMessage|null
    {
        // Construct the flash storage key.
        $flashKey = "_flash.{$key}";

        // Retrieve the flash message data.
        $data = $this->store->get(key: $flashKey, default: null);

        // If no flash message exists, return null.
        if ($data === null) {
            return null;
        }

        // Remove the flash message from storage (one-time use).
        $this->store->delete(key: $flashKey);

        // Remove key from tracking list.
        $flashKeys = $this->store->get(key: '_flash._keys', default: []);
        $flashKeys = array_filter(
            $flashKeys,
            fn($k) => $k !== $key
        );
        $this->store->put(key: '_flash._keys', value: array_values($flashKeys));

        // Convert array data back to FlashMessage object.
        $message = FlashMessage::fromArray($data);

        // Log flash message retrieval.
        logger()?->debug(
            message: 'Flash message retrieved and removed',
            context: [
                'key' => $key,
                'type' => $message->type,
                'action' => 'GetFlash',
            ]
        );

        return $message;
    }

    /**
     * Peek at a flash message without removing it.
     *
     * Useful for displaying the same flash across multiple requests
     * (though this breaks the flash pattern).
     *
     * @param string $key The flash message identifier.
     *
     * @return FlashMessage|null The flash message or null if not found.
     */
    public function peek(string $key): FlashMessage|null
    {
        // Construct the flash storage key.
        $flashKey = "_flash.{$key}";

        // Retrieve the flash message data without removing.
        $data = $this->store->get(key: $flashKey, default: null);

        // If no flash message exists, return null.
        if ($data === null) {
            return null;
        }

        // Convert array data to FlashMessage object.
        return FlashMessage::fromArray($data);
    }
}

=== Features/Flash/FlashBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Flash;

use Avax\HTTP\Session\Features\Flash\Actions\AddFlash;
use Avax\HTTP\Session\Features\Flash\Actions\GetFlash;
use Avax\HTTP\Session\Storage\SessionStore;

/**
 * FlashBag
 *
 * Manages flash messages following the Post-Redirect-Get pattern.
 *
 * Flash messages are temporary notifications that persist for exactly one
 * request cycle, making them perfect for displaying feedback after form
 * submissions or redirects.
 *
 * Enterprise Rules:
 * - One-time use: Messages are consumed on retrieval.
 * - Type safety: Uses FlashMessage value objects.
 * - Composability: Delegates to Actions for testability.
 *
 * Usage:
 *   $flash = new FlashBag($store);
 *   $flash->add('success', 'Profile updated!');
 *   $message = $flash->get('success');
 *
 * @package Avax\HTTP\Session\Features\Flash
 */
final readonly class FlashBag
{
    /**
     * FlashBag Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Add a flash message.
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     * @param string $type  The message type (success, error, warning, info).
     *
     * @return void
     */
    public function add(string $key, mixed $value, string $type = 'info'): void
    {
        // Delegate to AddFlash action.
        $action = new AddFlash($this->store);
        $action->execute(key: $key, value: $value, type: $type);
    }

    /**
     * Retrieve and remove a flash message.
     *
     * @param string $key The flash message identifier.
     *
     * @return FlashMessage|null The flash message or null if not found.
     */
    public function get(string $key): FlashMessage|null
    {
        // Delegate to GetFlash action.
        $action = new GetFlash($this->store);
        return $action->execute(key: $key);
    }

    /**
     * Peek at a flash message without removing it.
     *
     * @param string $key The flash message identifier.
     *
     * @return FlashMessage|null The flash message or null if not found.
     */
    public function peek(string $key): FlashMessage|null
    {
        // Delegate to GetFlash action.
        $action = new GetFlash($this->store);
        return $action->peek(key: $key);
    }

    /**
     * Check if a flash message exists.
     *
     * @param string $key The flash message identifier.
     *
     * @return bool True if the flash message exists.
     */
    public function has(string $key): bool
    {
        return $this->store->has(key: "_flash.{$key}");
    }

    /**
     * Get all flash messages and remove them.
     *
     * @return array<string, FlashMessage> Array of flash messages keyed by identifier.
     */
    public function all(): array
    {
        // Get all tracked flash keys.
        $flashKeys = $this->store->get(key: '_flash._keys', default: []);

        // Retrieve all flash messages.
        $messages = [];
        foreach ($flashKeys as $key) {
            $message = $this->get($key);
            if ($message !== null) {
                $messages[$key] = $message;
            }
        }

        return $messages;
    }

    /**
     * Clear all flash messages.
     *
     * @return void
     */
    public function clear(): void
    {
        // Get all tracked flash keys.
        $flashKeys = $this->store->get(key: '_flash._keys', default: []);

        // Delete each flash message.
        foreach ($flashKeys as $key) {
            $this->store->delete(key: "_flash.{$key}");
        }

        // Clear the tracking list.
        $this->store->delete(key: '_flash._keys');
    }

    /**
     * Convenience method: Add success message.
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     *
     * @return void
     */
    public function success(string $key, mixed $value): void
    {
        $this->add(key: $key, value: $value, type: 'success');
    }

    /**
     * Convenience method: Add error message.
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     *
     * @return void
     */
    public function error(string $key, mixed $value): void
    {
        $this->add(key: $key, value: $value, type: 'error');
    }

    /**
     * Convenience method: Add warning message.
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     *
     * @return void
     */
    public function warning(string $key, mixed $value): void
    {
        $this->add(key: $key, value: $value, type: 'warning');
    }

    /**
     * Convenience method: Add info message.
     *
     * @param string $key   The flash message identifier.
     * @param mixed  $value The message content.
     *
     * @return void
     */
    public function info(string $key, mixed $value): void
    {
        $this->add(key: $key, value: $value, type: 'info');
    }
}

=== Features/Flash/FlashMessage.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\Flash;

/**
 * FlashMessage Value Object
 *
 * Immutable representation of a flash message.
 *
 * Flash messages are temporary notifications that persist for exactly one request
 * cycle, following the Post-Redirect-Get (PRG) pattern.
 *
 * Enterprise Rules:
 * - Immutability: Once created, cannot be modified.
 * - Type Safety: Enforces message type validation.
 * - Serializable: Can be stored in session storage.
 *
 * Usage:
 *   $flash = new FlashMessage(
 *       key: 'success',
 *       value: 'Profile updated successfully!',
 *       type: 'success'
 *   );
 *
 * @package Avax\HTTP\Session\Features\Flash
 */
final readonly class FlashMessage
{
    /**
     * Valid flash message types.
     */
    private const VALID_TYPES = ['success', 'error', 'warning', 'info'];

    /**
     * FlashMessage Constructor.
     *
     * @param string $key   The unique identifier for this flash message.
     * @param mixed  $value The message content (typically string, but can be array/object).
     * @param string $type  The message type (success, error, warning, info).
     */
    public function __construct(
        public string $key,
        public mixed $value,
        public string $type = 'info'
    ) {
        // Guard: Validate message type.
        if (!in_array($this->type, self::VALID_TYPES, strict: true)) {
            throw new \InvalidArgumentException(
                message: "Invalid flash message type: {$this->type}. " .
                    "Valid types: " . implode(', ', self::VALID_TYPES)
            );
        }

        // Guard: Validate key is not empty.
        if (trim($this->key) === '') {
            throw new \InvalidArgumentException(
                message: 'Flash message key cannot be empty'
            );
        }
    }

    /**
     * Check if this is a success message.
     *
     * @return bool True if type is 'success'.
     */
    public function isSuccess(): bool
    {
        return $this->type === 'success';
    }

    /**
     * Check if this is an error message.
     *
     * @return bool True if type is 'error'.
     */
    public function isError(): bool
    {
        return $this->type === 'error';
    }

    /**
     * Check if this is a warning message.
     *
     * @return bool True if type is 'warning'.
     */
    public function isWarning(): bool
    {
        return $this->type === 'warning';
    }

    /**
     * Check if this is an info message.
     *
     * @return bool True if type is 'info'.
     */
    public function isInfo(): bool
    {
        return $this->type === 'info';
    }

    /**
     * Convert to array for serialization.
     *
     * @return array<string, mixed>
     */
    public function toArray(): array
    {
        return [
            'key' => $this->key,
            'value' => $this->value,
            'type' => $this->type,
        ];
    }

    /**
     * Create from array (deserialization).
     *
     * @param array<string, mixed> $data The array data.
     *
     * @return self
     */
    public static function fromArray(array $data): self
    {
        return new self(
            key: $data['key'] ?? '',
            value: $data['value'] ?? null,
            type: $data['type'] ?? 'info'
        );
    }
}

=== Features/TTL/Actions/CheckExpiration.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\TTL\Actions;

use Avax\HTTP\Session\Storage\SessionStore;

/**
 * CheckExpiration Action
 *
 * Single Responsibility: Check if a session value has expired.
 *
 * This action validates TTL metadata and determines if a value should
 * be considered expired based on its expiration timestamp.
 *
 * Enterprise Rules:
 * - Automatic cleanup: Expired values are removed.
 * - Precision: Uses Unix timestamp comparison.
 * - Fail-safe: Missing metadata means no expiration.
 *
 * Usage:
 *   $action = new CheckExpiration($store);
 *   $isExpired = $action->execute('user_token');
 *
 * @package Avax\HTTP\Session\Features\TTL\Actions
 */
final readonly class CheckExpiration
{
    /**
     * CheckExpiration Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Check if value has expired.
     *
     * This method:
     * 1. Retrieves TTL metadata
     * 2. Compares expiration timestamp with current time
     * 3. Removes expired values automatically
     *
     * @param string $key The session key to check.
     *
     * @return bool True if expired, false otherwise.
     */
    public function execute(string $key): bool
    {
        // Construct metadata key.
        $metaKey = "{$key}::__meta";

        // Retrieve metadata.
        $meta = $this->store->get(key: $metaKey, default: []);

        // If no expiration metadata, value never expires.
        if (!isset($meta['expires_at'])) {
            return false;
        }

        // Get current timestamp.
        $now = time();

        // Check if value has expired.
        $isExpired = $now >= $meta['expires_at'];

        // If expired, perform automatic cleanup.
        if ($isExpired) {
            // Remove the expired value.
            $this->store->delete(key: $key);

            // Remove the metadata.
            $this->store->delete(key: $metaKey);

            // Log expiration event.
            logger()?->debug(
                message: 'Session value expired and removed',
                context: [
                    'key' => $key,
                    'expired_at' => $meta['expires_at'],
                    'current_time' => $now,
                    'action' => 'CheckExpiration',
                ]
            );
        }

        return $isExpired;
    }
}

=== Features/TTL/Actions/SetTTL.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Features\TTL\Actions;

use Avax\HTTP\Session\Storage\SessionStore;

/**
 * SetTTL Action
 *
 * Single Responsibility: Set Time-To-Live metadata for a session value.
 *
 * This action manages expiration metadata, allowing session values to
 * automatically expire after a specified duration.
 *
 * Enterprise Rules:
 * - Validation: TTL must be positive.
 * - Atomicity: Metadata storage is atomic.
 * - Precision: Uses Unix timestamp for exact expiration.
 *
 * Usage:
 *   $action = new SetTTL($store);
 *   $action->execute('user_token', 3600); // Expires in 1 hour
 *
 * @package Avax\HTTP\Session\Features\TTL\Actions
 */
final readonly class SetTTL
{
    /**
     * SetTTL Constructor.
     *
     * @param SessionStore $store The session storage backend.
     */
    public function __construct(
        private SessionStore $store
    ) {}

    /**
     * Execute the action: Set TTL metadata.
     *
     * This method:
     * 1. Validates TTL value
     * 2. Calculates expiration timestamp
     * 3. Stores metadata
     *
     * @param string $key The session key.
     * @param int    $ttl Time-to-live in seconds.
     *
     * @return void
     */
    public function execute(string $key, int $ttl): void
    {
        // Guard: Validate TTL is positive.
        if ($ttl <= 0) {
            throw new \InvalidArgumentException(
                message: "TTL must be positive, got: {$ttl}"
            );
        }

        // Calculate expiration timestamp.
        $expiresAt = time() + $ttl;

        // Construct metadata key.
        $metaKey = "{$key}::__meta";

        // Get existing metadata or create new.
        $meta = $this->store->get(key: $metaKey, default: []);

        // Set expiration timestamp.
        $meta['expires_at'] = $expiresAt;

        // Store updated metadata.
        $this->store->put(key: $metaKey, value: $meta);

        // Log TTL setting.
        logger()?->debug(
            message: 'TTL metadata set',
            context: [
                'key' => $key,
                'ttl_seconds' => $ttl,
                'expires_at' => $expiresAt,
                'action' => 'SetTTL',
            ]
        );
    }
}

=== Session.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session;

use Avax\Facade\BaseFacade;
use Avax\HTTP\Session\API\FluentSession;
use Avax\HTTP\Session\API\SessionManager;

/**
 * Session Facade
 *
 * Provides static access to the SessionManager.
 *
 * Usage:
 *   Session::scope('cart')->store('items', [1, 2, 3]);
 *   Session::flash('success', 'Saved!');
 *   Session::remember('user', fn() => User::find($id));
 *
 * @method static SessionManager start()
 * @method static FluentSession scope(string $namespace)
 * @method static FluentSession in(string $namespace)
 * @method static FluentSession temporary(int $seconds)
 * @method static FluentSession builder()
 * @method static void flash(string $key, mixed $value, string $type = 'info')
 * @method static mixed remember(string $key, \Closure $callback)
 * @method static void put(string $key, mixed $value)
 * @method static mixed get(string $key, mixed $default = null)
 * @method static bool has(string $key)
 * @method static void delete(string $key)
 * @method static array all()
 * @method static void invalidate()
 * @method static void regenerate(bool $deleteOldSession = true)
 * @method static string id()
 *
 * @see SessionManager
 */
final class Session extends BaseFacade
{
    protected static string $accessor = SessionManager::class;
}

=== Storage/ArrayStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

use Avax\HTTP\Session\Support\SessionIdGenerator;

/**
 * ArrayStore
 *
 * In-memory session storage implementation.
 *
 * This store keeps all session data in memory (PHP array), making it
 * perfect for testing and development. Data does NOT persist across requests.
 *
 * Enterprise Rules:
 * - Testing-focused: Ideal for unit tests.
 * - No persistence: Data lost after request ends.
 * - Fast: No I/O operations.
 *
 * Usage:
 *   $store = new ArrayStore();
 *   $store->start();
 *   $store->put('key', 'value');
 *
 * @package Avax\HTTP\Session\Storage
 */
final class ArrayStore implements SessionStore
{
    /**
     * In-memory session data.
     *
     * @var array<string, mixed>
     */
    private array $data = [];

    /**
     * Session started flag.
     *
     * @var bool
     */
    private bool $started = false;

    /**
     * Session ID.
     *
     * @var string|null
     */
    private string|null $sessionId = null;

    /**
     * Session ID generator.
     *
     * @var SessionIdGenerator
     */
    private readonly SessionIdGenerator $idGenerator;

    /**
     * ArrayStore Constructor.
     */
    public function __construct()
    {
        // Initialize ID generator.
        $this->idGenerator = new SessionIdGenerator();
    }

    /**
     * Start the session.
     *
     * @return void
     */
    public function start(): void
    {
        // Mark as started if not already.
        if (!$this->started) {
            $this->started = true;

            // Generate session ID if not set.
            if ($this->sessionId === null) {
                $this->sessionId = $this->idGenerator->generate();
            }
        }
    }

    /**
     * Check if session is started.
     *
     * @return bool True if session is active.
     */
    public function isStarted(): bool
    {
        return $this->started;
    }

    /**
     * Get the current session ID.
     *
     * @return string The session identifier.
     */
    public function getId(): string
    {
        // Ensure session is started.
        $this->start();

        // Return session ID.
        return $this->sessionId ?? '';
    }

    /**
     * Regenerate the session ID.
     *
     * @param bool $deleteOldSession Whether to destroy old session data.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true): void
    {
        // Ensure session is started.
        $this->start();

        // Generate new session ID.
        $this->sessionId = $this->idGenerator->generate();

        // Optionally clear data.
        if ($deleteOldSession) {
            $this->flush();
        }
    }

    /**
     * Store a value in the session.
     *
     * @param string $key   The storage key.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value): void
    {
        // Ensure session is started.
        $this->start();

        // Store in memory.
        $this->data[$key] = $value;
    }

    /**
     * Retrieve a value from the session.
     *
     * @param string $key     The storage key.
     * @param mixed  $default The default value.
     *
     * @return mixed The stored value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        // Ensure session is started.
        $this->start();

        // Return value or default.
        return $this->data[$key] ?? $default;
    }

    /**
     * Check if a key exists.
     *
     * @param string $key The storage key.
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool
    {
        // Ensure session is started.
        $this->start();

        // Check if key exists in data.
        return array_key_exists($key, $this->data);
    }

    /**
     * Delete a value from the session.
     *
     * @param string $key The storage key.
     *
     * @return void
     */
    public function delete(string $key): void
    {
        // Ensure session is started.
        $this->start();

        // Remove from memory.
        unset($this->data[$key]);
    }

    /**
     * Get all session data.
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array
    {
        // Ensure session is started.
        $this->start();

        // Return all data.
        return $this->data;
    }

    /**
     * Clear all session data.
     *
     * @return void
     */
    public function flush(): void
    {
        // Ensure session is started.
        $this->start();

        // Empty data array.
        $this->data = [];
    }
}

=== Storage/NativeStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

/**
 * NativeStore
 *
 * Native PHP session storage implementation.
 *
 * This store uses PHP's native $_SESSION superglobal for persistence,
 * providing a production-ready storage backend with file-based persistence.
 *
 * Enterprise Rules:
 * - Production-ready: Uses battle-tested PHP session mechanism.
 * - Security: Supports secure session configuration.
 * - Persistence: Data persists across requests.
 *
 * Usage:
 *   $store = new NativeStore();
 *   $store->start();
 *   $store->put('key', 'value');
 *
 * @package Avax\HTTP\Session\Storage
 */
final class NativeStore implements SessionStore
{
    /**
     * Start the session.
     *
     * Initializes PHP's native session mechanism if not already started.
     * Safe to call multiple times (idempotent).
     *
     * @return void
     */
    public function start(): void
    {
        // Check if session is not active.
        if (session_status() === PHP_SESSION_NONE) {
            // Start native PHP session.
            session_start();
        }
    }

    /**
     * Check if session is started.
     *
     * @return bool True if session is active.
     */
    public function isStarted(): bool
    {
        return session_status() === PHP_SESSION_ACTIVE;
    }

    /**
     * Get the current session ID.
     *
     * @return string The session identifier.
     */
    public function getId(): string
    {
        // Ensure session is started.
        $this->start();

        // Return session ID.
        return session_id();
    }

    /**
     * Regenerate the session ID.
     *
     * @param bool $deleteOldSession Whether to destroy old session data.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true): void
    {
        // Ensure session is started.
        $this->start();

        // Regenerate session ID.
        session_regenerate_id(delete_old_session: $deleteOldSession);
    }

    /**
     * Store a value in the session.
     *
     * @param string $key   The storage key.
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value): void
    {
        // Ensure session is started.
        $this->start();

        // Store in $_SESSION.
        $_SESSION[$key] = $value;
    }

    /**
     * Retrieve a value from the session.
     *
     * @param string $key     The storage key.
     * @param mixed  $default The default value.
     *
     * @return mixed The stored value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        // Ensure session is started.
        $this->start();

        // Return value or default.
        return $_SESSION[$key] ?? $default;
    }

    /**
     * Check if a key exists.
     *
     * @param string $key The storage key.
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool
    {
        // Ensure session is started.
        $this->start();

        // Check if key exists in $_SESSION.
        return array_key_exists($key, $_SESSION);
    }

    /**
     * Delete a value from the session.
     *
     * @param string $key The storage key.
     *
     * @return void
     */
    public function delete(string $key): void
    {
        // Ensure session is started.
        $this->start();

        // Remove from $_SESSION.
        unset($_SESSION[$key]);
    }

    /**
     * Get all session data.
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array
    {
        // Ensure session is started.
        $this->start();

        // Return entire $_SESSION.
        return $_SESSION;
    }

    /**
     * Clear all session data.
     *
     * @return void
     */
    public function flush(): void
    {
        // Ensure session is started.
        $this->start();

        // Empty $_SESSION.
        $_SESSION = [];
    }
}

=== Storage/SessionStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Storage;

/**
 * SessionStore Interface
 *
 * Contract for session storage backends.
 *
 * This interface defines the persistence layer for session data,
 * abstracting away the underlying storage mechanism (native PHP,
 * Redis, database, etc.).
 *
 * Enterprise Rules:
 * - Atomicity: All operations must be atomic.
 * - Idempotency: Safe to call operations multiple times.
 * - Security: Must support secure session ID generation.
 *
 * Implementations:
 * - NativeStore: PHP native sessions
 * - ArrayStore: In-memory (testing)
 * - RedisStore: Redis backend
 * - DatabaseStore: Database backend
 *
 * @package Avax\HTTP\Session\Storage
 */
interface SessionStore
{
    /**
     * Start the session.
     *
     * Initializes the session storage and makes it ready for operations.
     * Must be idempotent (safe to call multiple times).
     *
     * @return void
     */
    public function start(): void;

    /**
     * Check if session is started.
     *
     * @return bool True if session is active.
     */
    public function isStarted(): bool;

    /**
     * Get the current session ID.
     *
     * @return string The session identifier.
     */
    public function getId(): string;

    /**
     * Regenerate the session ID.
     *
     * Creates a new session ID while optionally preserving or destroying
     * the old session data.
     *
     * @param bool $deleteOldSession Whether to destroy old session data.
     *
     * @return void
     */
    public function regenerateId(bool $deleteOldSession = true): void;

    /**
     * Store a value in the session.
     *
     * @param string $key   The storage key.
     * @param mixed  $value The value to store (must be serializable).
     *
     * @return void
     */
    public function put(string $key, mixed $value): void;

    /**
     * Retrieve a value from the session.
     *
     * @param string $key     The storage key.
     * @param mixed  $default The default value if key doesn't exist.
     *
     * @return mixed The stored value or default.
     */
    public function get(string $key, mixed $default = null): mixed;

    /**
     * Check if a key exists in the session.
     *
     * @param string $key The storage key.
     *
     * @return bool True if key exists.
     */
    public function has(string $key): bool;

    /**
     * Delete a value from the session.
     *
     * @param string $key The storage key.
     *
     * @return void
     */
    public function delete(string $key): void;

    /**
     * Get all session data.
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array;

    /**
     * Clear all session data.
     *
     * Removes all data but keeps the session active.
     *
     * @return void
     */
    public function flush(): void;
}

=== Support/ArrayBagRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support;

use Avax\DataHandling\ArrayHandling\Arrhae;
use Avax\HTTP\Session\Contracts\BagRegistryInterface;
use Avax\HTTP\Session\Contracts\FlashBagInterface;
use Avax\HTTP\Session\Contracts\SessionBagInterface;
use InvalidArgumentException;

/**
 * ArrayBagRegistry
 *
 * A mutable registry for managing named session bags in a type-safe,
 * extensible, and runtime-configurable manner.
 *
 * This class adheres strictly to Clean Architecture and DDD practices,
 * allowing for dynamic registration, safe retrieval, and logical filtering.
 *
 * @package Avax\HTTP\Session\Support
 */
final class ArrayBagRegistry implements BagRegistryInterface
{
    /**
     * Internal map of session bags using the `Arrhae` data structure
     * for advanced array manipulation and type safety.
     *
     * @var Arrhae<string, SessionBagInterface>
     */
    private Arrhae $map;

    /**
     * Constructor.
     *
     * @param array<string, SessionBagInterface> $bags
     *        Initial session bags provided during instantiation.
     */
    public function __construct(array $bags = [])
    {
        $this->map = new Arrhae(items: $bags);
    }

    /**
     * Dynamically register a session bag at runtime.
     *
     * Allows middleware, modules, or packages to extend the registry without
     * needing to recreate it from scratch.
     *
     * @param string $name             Unique bag identifier.
     * @param SessionBagInterface $bag The session bag instance.
     *
     * @return void
     */
    public function register(string $name, SessionBagInterface $bag) : void
    {
        $this->map->set(key: $name, value: $bag);
    }

    /**
     * Retrieve a registered session bag by its name.
     *
     * @param string $name
     *        The unique identifier for the session bag to retrieve.
     *
     * @return SessionBagInterface
     *
     * @throws InvalidArgumentException
     *         If the specified bag name is not found in the registry.
     */
    public function get(string $name) : SessionBagInterface
    {
        if (! $this->map->has(key: $name)) {
            logger()->error(
                'Session bag could not be found in the registry.',
                ['name' => $name]
            );

            throw new InvalidArgumentException(
                message: "Session bag [{$name}] not found in registry."
            );
        }

        return $this->map->get(key: $name);
    }

    /**
     * Determine whether a session bag exists by name.
     *
     * @param string $name The bag key to check.
     *
     * @return bool True if the bag exists; false otherwise.
     */
    public function has(string $name) : bool
    {
        return $this->map->has(key: $name);
    }

    /**
     * Returns a filtered registry instance with only the specified bag keys.
     *
     * This enables scoped registries for specific purposes (e.g., flash-only or validation-only).
     *
     * @param array<string> $keys Keys to include.
     *
     * @return BagRegistryInterface A new filtered registry.
     */
    public function only(array $keys) : BagRegistryInterface
    {
        return new self(bags: $this->map->only(keys: $keys)->toArray());
    }

    /**
     * Returns a filtered registry excluding specified bag keys.
     *
     * Useful for removing internal or reserved bags from DX exposure.
     *
     * @param array<string> $keys Keys to exclude.
     *
     * @return BagRegistryInterface A new filtered registry.
     */
    public function except(array $keys) : BagRegistryInterface
    {
        return new self(bags: $this->map->except(keys: $keys)->toArray());
    }

    /**
     * Retrieve all available bag keys currently registered.
     *
     * @return array<string> List of all registered bag names.
     */
    public function keys() : array
    {
        return $this->map->keys();
    }

    /**
     * Retrieve all registered session bags in the registry.
     *
     * This method returns the complete mapping of bag names to their respective
     * SessionBagInterface instances.
     * It is useful for introspection, debugging,
     * or batch operations on all session bags.
     *
     * @return array<string, SessionBagInterface>
     *         An associative array where the key is the bag name, and the value is the bag instance.
     */
    public function all() : array
    {
        return $this->map->toArray();
    }

    /**
     * Retrieves the flash message session bag.
     *
     * The `FlashBag` session bag is designed to store temporary messages or
     * data, persisting only until the next request by default. It simplifies
     * the handling of transient application states like success notifications,
     * validation alerts, or session-based one-time flags.
     *
     * Example usage:
     * ```php
     * $flashBag = $bagRegistry->flash();
     * $flashBag->put('success', 'Your account has been updated.');
     * ```
     *
     * Dependency on `FlashBagInterface`:
     * - `FlashBagInterface` extends `SessionBagInterface`, ensuring robust
     *    session-management capabilities with added functionality for
     *    managing flash-specific use cases, like `keep()` or `reflash()`.
     *
     * @return FlashBagInterface
     *   A flash message session bag adhering to FlashBagInterface, providing
     *   encapsulated methods tailored for transient data persistence.
     */
    public function flash() : FlashBagInterface
    {
        return app(abstract: FlashBagInterface::class);
    }

    /**
     * Retrieves the error message session bag.
     *
     * The `ErrorBag` is a generic session bag used to store validation
     * errors, user feedback, or any application state that needs to persist
     * across multiple requests. By handling errors via a dedicated bag,
     * developers can centralize error management into a structured container.
     *
     * Example usage:
     * ```php
     * $errorBag = $bagRegistry->errors();
     * $errorBag->put('email', 'The email address is invalid.');
     * ```
     *
     * Dependency on `SessionBagInterface`:
     * - The `ErrorBag` follows the contract defined by `SessionBagInterface`,
     *   guaranteeing functionality such as value retrieval, storage, and
     *   clearing, while allowing customization for error-related use cases.
     *
     * @return SessionBagInterface
     *   A generic session bag adhering to SessionBagInterface, providing
     *   flexible storage capabilities for error messages or other keyed data.
     */
    public function errors() : SessionBagInterface
    {
        return app(abstract: SessionBagInterface::class);
    }
}
=== Support/Bags/AbstractFlashBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Bags;

use Avax\HTTP\Session\Contracts\FlashBagInterface;
use Avax\HTTP\Session\Contracts\SessionBagInterface;

/**
 * AbstractFlashBag
 *
 * A base class for implementing session flash bags. Flash bags are used to manage
 * temporary session data that is only available for the next request cycle.
 * This abstraction ensures that common tasks, such as adding, retrieving, and clearing
 * flash data, are handled in a consistent and reusable way.
 *
 * @package Avax\HTTP\Session\Support\Bags
 */
abstract class AbstractFlashBag implements SessionBagInterface
{
    /**
     * Constructor to initialize the FlashBagInterface dependency.
     *
     * @param FlashBagInterface $flash An implementation of FlashBagInterface used to manage flash session data.
     */
    public function __construct(protected FlashBagInterface $flash) {}

    /**
     * Retrieve and remove a value from the flash bag in one call.
     * This operation is destructive â€“ once the value is read, it is deleted from storage.
     *
     * @param string     $key     The key to pull from the flash bag.
     * @param mixed|null $default Optional fallback value if the key does not exist.
     *
     * @return mixed|null The pulled value or the default if not found.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        // Retrieve the value, then remove it from storage before returning.
        $value = $this->get(key: $key, default: $default);
        $this->forget(key: $key);

        return $value;
    }

    /**
     * Retrieve a value from the flash bag, or return a default value if the key does not exist.
     *
     * @param string     $key     The key to retrieve from the flash bag.
     * @param mixed|null $default The default value to return if the key does not exist (optional).
     *
     * @return mixed|null The value associated with the key, or the default value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Retrieve all flash data and attempt to return the value for the given key.
        return $this->all()[$key] ?? $default;
    }

    /**
     * Retrieve all key-value pairs currently stored in the flash bag.
     *
     * @return array<string, mixed> An associative array of all flash data.
     */
    public function all() : array
    {
        // Fetch all flash data using the unique flash key and ensure it is an array.
        $data = $this->flash->get(key: $this->flashKey(), default: []);

        // Verify the data is a valid array before returning it; otherwise, return an empty array.
        return is_array($data) ? $data : [];
    }

    /**
     * Retrieve the unique flash key associated with this specific bag.
     *
     * This function must be implemented by subclasses to specify a unique identifier
     * for their flash storage within the session.
     *
     * @return string The flash key associated with the bag.
     */
    abstract protected function flashKey() : string;

    /**
     * Remove a specific key-value pair from the flash bag.
     *
     * @param string $key The key to remove from the flash bag.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        // Retrieve all existing flash data.
        $data = $this->all();

        // Check if the key exists and remove it if present.
        if (array_key_exists($key, $data)) {
            unset($data[$key]);

            // Save the updated data back to the flash storage.
            $this->flash->put(
                key  : $this->flashKey(),
                value: $data
            );
        }
    }

    /**
     * Store a new key-value pair in the flash bag.
     *
     * If the key already exists, its value will be overwritten with the new value.
     *
     * @param string $key   The key under which the value will be stored.
     * @param mixed  $value The value to associate with the given key.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        // Retrieve all existing flash data.
        $data = $this->all();

        // Associate the new value with the specified key.
        $data[$key] = $value;

        // Save the updated data back to the flash storage.
        $this->flash->put(
            key  : $this->flashKey(),
            value: $data
        );
    }

    /**
     * Determine whether the flash bag contains a specific key.
     *
     * @param string $key The key to check for existence.
     *
     * @return bool True if the key exists; false otherwise.
     */
    public function has(string $key) : bool
    {
        // Use array_key_exists to verify if the key exists within the retrieved flash data.
        return array_key_exists($key, $this->all());
    }

    /**
     * Clear all data stored in the flash bag.
     *
     * This operation will remove all stored key-value pairs and reset the storage.
     *
     * @return void
     */
    public function clear() : void
    {
        // Update the flash storage by setting an empty array to the flash key.
        $this->flash->put(
            key  : $this->flashKey(),
            value: []
        );
    }
}

=== Support/Bags/BagRegistryDecorator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Bags;

use Avax\HTTP\Session\Contracts\BagRegistryInterface;
use Avax\HTTP\Session\Contracts\FlashBagInterface;
use Avax\HTTP\Session\Contracts\SessionBagInterface;
use Avax\HTTP\Session\Enums\SessionBag;
use InvalidArgumentException;
use RuntimeException;

/**
 * Class BagRegistryDecorator
 *
 * A strongly typed decorator for accessing and managing session bags through the BagRegistryInterface.
 * This provides a type-safe, expressive API over the generic bag registry, aligning with DDD principles.
 *
 * @package Avax\HTTP\Session\Support\Bags
 */
final readonly class BagRegistryDecorator
{
    /**
     * @var BagRegistryInterface $delegate
     *
     * The wrapped instance of the bag registry that provides general-purpose session bag operations.
     */
    public function __construct(private BagRegistryInterface $delegate) {}

    /**
     * Retrieve the Flash Bag.
     *
     * This method resolves and returns the registered flash bag from the registry while
     * enforcing conformance to the FlashBagInterface. Throws an exception if the type mismatch occurs.
     *
     * @return FlashBagInterface
     *   The flash bag instance used for storing temporary session data.
     *
     * @throws InvalidArgumentException
     *   If the retrieved bag does not implement FlashBagInterface.
     */
    public function flash() : FlashBagInterface
    {
        // Retrieve the "flash" bag from the delegate registry.
        $bag = $this->delegate->get(name: 'flash');

        // Validate that the retrieved bag implements FlashBagInterface.
        if (! $bag instanceof FlashBagInterface) {
            throw new InvalidArgumentException(message: 'Registered bag "flash" must implement FlashBagInterface.');
        }

        // Return the strongly typed flash bag instance.
        return $bag;
    }

    /**
     * Retrieves a session bag by key.
     *
     * Delegates the retrieval logic to a lower-level abstraction, ensuring
     * that the session bag associated with the provided key is returned.
     * If the bag is not found, an exception will be propagated by the delegate.
     *
     * @param string $key The unique key identifying the session bag in the registry.
     *                    Must be a non-empty string that conforms to system key standards.
     *
     * @return SessionBagInterface The session bag associated with the specified key.
     *
     * @throws InvalidArgumentException If the session bag does not exist in the registry.
     * @throws RuntimeException If an unexpected error occurs during the retrieval process.
     */
    public function get(string $key) : SessionBagInterface
    {
        // Delegates the "get" call to the underlying session delegate, leveraging named arguments for clarity.
        return $this->delegate->get(name: $key);
    }

    /**
     * Retrieve the Input Bag.
     *
     * The input bag captures user inputs, allowing their persistence for redisplaying forms,
     * particularly on validation errors.
     *
     * @return SessionBagInterface
     *   The session bag instance for input data.
     *
     * @throws InvalidArgumentException
     *   If the bag cannot be resolved or registered correctly.
     */
    public function input() : SessionBagInterface
    {
        // Resolve the "input" bag using its enumeration value.
        return $this->delegate->get(name: SessionBag::Input->value);
    }

    /**
     * Retrieve the Validation Errors Bag.
     *
     * This bag contains validation error messages, useful for isolating error-related session
     * context and presenting it within user interfaces.
     *
     * @return SessionBagInterface
     *   The session bag instance for validation errors.
     *
     * @throws InvalidArgumentException
     *   If the bag cannot be accessed correctly from the registry.
     */
    public function errors() : SessionBagInterface
    {
        // Resolve the "validation" bag using its enumeration value.
        return $this->delegate->get(name: SessionBag::Validation->value);
    }
}
=== Support/Bags/FlashBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Bags;

use Avax\HTTP\Session\Contracts\FlashBagInterface;
use Avax\HTTP\Session\Contracts\SessionInterface;
use Avax\HTTP\Session\Exceptions\FlashBagKeyNotFoundException;
use InvalidArgumentException;

/**
 * Class FlashBag
 *
 * A specialized, production-grade component for managing temporary flash data in a PHP-based session.
 *
 * Flash data refers to data that persists for the duration of one request/response cycle
 * and is automatically removed afterward. This class provides methods to handle such data
 * with support for re-flashing and deletion.
 *
 * @final
 */
final class FlashBag implements FlashBagInterface
{
    /**
     * @const string FLASH_KEY
     * The session key used to store temporary flash data for the current request cycle.
     */
    private const string FLASH_KEY = '_flash';

    /**
     * @const string FLASH_KEEP_KEY
     * The session key used to track flash data preserved for the next request.
     * When data is "kept," it survives one additional request.
     */
    private const string FLASH_KEEP_KEY = '_flash_keep';

    /**
     * FlashBag constructor.
     *
     * @param SessionInterface $session The session instance responsible for managing flash data.
     */
    public function __construct(private readonly SessionInterface $session) {}

    /**
     * Retrieves and removes a flash value from storage.
     *
     * If the key is not found, a default value is returned or an exception is thrown (if no default is provided).
     *
     * @param string     $key     The key whose value should be retrieved and removed.
     * @param mixed|null $default A fallback value to return if the key is not found.
     *
     * @return mixed The value associated with the specified key.
     * @throws FlashBagKeyNotFoundException If the key does not exist and no default is specified.
     */
    public function pull(string $key, mixed $default = null) : mixed
    {
        // Fetch all flash data currently stored in the session.
        $flashes = $this->getFlashes();

        // Check whether the key exists in the stored flash data.
        if (! array_key_exists($key, $flashes)) {
            // If no default value is provided, throw an exception for missing flash key.
            if ($default === null) {
                throw new FlashBagKeyNotFoundException(message: sprintf('Flash key "%s" not found.', $key));
            }

            return $default;
        }

        // Retrieve the value associated with the key.
        $value = $flashes[$key];

        // Remove the key-value pair from the flash storage.
        unset($flashes[$key]);

        // Save the modified flash data to the session.
        $this->updateFlashes(data: $flashes);

        return $value;
    }

    /**
     * Helper method: Retrieves all flash data from the session.
     *
     * @return array<string, mixed> A collection of key-value pairs in flash storage.
     */
    private function getFlashes() : array
    {
        return $this->session->get(key: self::FLASH_KEY, default: []);
    }

    /**
     * Retrieves a flash value by its key, without removing it from flash storage.
     *
     * If the key is not found, the default value is returned instead.
     *
     * @param string     $key     The key identifying the flash value.
     * @param mixed|null $default A fallback value if the key is not found.
     *
     * @return mixed The value associated with the key or the default value.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        // Fetch all flash data from the session storage.
        $flashes = $this->getFlashes();

        // Return the value from the flash array if it exists, otherwise return the provided default.
        return $flashes[$key] ?? $default;
    }

    /**
     * Helper method: Updates flash data in the session.
     *
     * @param array<string, mixed> $data The updated flash data to store in the session.
     *
     * @return void
     */
    private function updateFlashes(array $data) : void
    {
        $this->session->put(key: self::FLASH_KEY, value: $data);
    }

    /**
     * Stores a value under a specific key in flash storage for one request cycle.
     *
     * @param string $key   A unique identifier for the flash data.
     * @param mixed  $value The value to store in the session.
     *
     * @return void
     * @throws InvalidArgumentException If the provided key is empty.
     */
    public function put(string $key, mixed $value) : void
    {
        // Check that a valid key is provided, preventing empty or invalid keys.
        if (empty($key)) {
            throw new InvalidArgumentException(message: 'Flash key cannot be empty.');
        }

        // Retrieve all stored flash data or initialize an empty array.
        $flashes = $this->getFlashes();

        // Add the given value under the specified key.
        $flashes[$key] = $value;

        // Update the session with the modified flashes.
        $this->updateFlashes(data: $flashes);
    }

    /**
     * Determines whether a flash value is stored under the given key.
     *
     * @param string $key The key to check for existence in flash storage.
     *
     * @return bool True if the key exists, otherwise false.
     */
    public function has(string $key) : bool
    {
        // Checks for key existence in the collection of flash data.
        return array_key_exists($key, $this->getFlashes());
    }

    /**
     * Retrieves all current flash data stored in the session.
     *
     * @return array<string, mixed> An associative array of all key-value pairs in flash storage.
     */
    public function all() : array
    {
        // Return all flash data as an associative array.
        return $this->getFlashes();
    }

    /**
     * Preserves the specified flash key for the subsequent request cycle.
     *
     * Instead of being deleted after the current request, the value is migrated to the "kept" storage.
     *
     * @param string $key The flash key to preserve for the next request.
     *
     * @return void
     */
    public function keep(string $key) : void
    {
        // Retrieve both current flash data and kept flash data.
        $flashes   = $this->getFlashes();
        $flashKeep = $this->getKeptFlashes();

        // Add the specified key's value to the kept flash data if it exists.
        if (array_key_exists($key, $flashes)) {
            $flashKeep[$key] = $flashes[$key];

            // Update the session with the modified kept flash storage.
            $this->updateKeptFlashes(data: $flashKeep);
        }
    }

    /**
     * Helper method: Retrieves all kept flash data from the session.
     *
     * @return array<string, mixed> A collection of key-value pairs explicitly preserved for the next request.
     */
    private function getKeptFlashes() : array
    {
        return $this->session->get(key: self::FLASH_KEEP_KEY, default: []);
    }

    /**
     * Helper method: Updates the kept flash data in the session.
     *
     * @param array<string, mixed> $data The updated kept flash data to store in the session.
     *
     * @return void
     */
    private function updateKeptFlashes(array $data) : void
    {
        $this->session->put(key: self::FLASH_KEEP_KEY, value: $data);
    }

    /**
     * Preserves all flash data, extending its lifespan for the next request.
     *
     * @return void
     */
    public function reflash() : void
    {
        // Retrieve the current flash data from session storage.
        $flashes = $this->getFlashes();

        // Update the kept flashes with all current flashes for re-flashing.
        $this->updateKeptFlashes(data: $flashes);
    }

    /**
     * Removes a specific flash key from storage.
     *
     * @param string $key The key to delete from flash data.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        // Retrieve all existing flash data from session storage.
        $flashes = $this->getFlashes();

        // Delete the specified key from the flash storage.
        unset($flashes[$key]);

        // Persist the modified flash data to the session.
        $this->updateFlashes(data: $flashes);
    }

    /**
     * Clears all flash values, including both current flashes and kept flashes stored in the session.
     *
     * This method ensures that the flash storage is completely reset, effectively removing
     * both the active flash bag (`_flash`) and the kept/retained flash bag (`_flash_keep`).
     *
     * This can be useful in cases where the flash state needs to be programmatically reset
     * or the session needs to ensure no stale flash values remain.
     *
     * It interacts with two specific session keys:
     * - `self::FLASH_KEY`: Represents the key holding the active flash messages.
     * - `self::FLASH_KEEP_KEY`: Represents the key tracking flash messages marked to persist.
     *
     * @return void
     */
    public function clear() : void
    {
        // Deletes the `_flash` key from the session storage, effectively clearing
        // all active flash messages currently held in the flash bag.
        $this->session->delete(key: self::FLASH_KEY);

        // Deletes the `_flash_keep` key from the session storage, ensuring
        // that no kept flash messages persist into later requests.
        $this->session->delete(key: self::FLASH_KEEP_KEY);
    }

    /**
     * Loads and manages flash data for the current session lifecycle.
     *
     * This method handles the lifecycle of flash messages as follows:
     * - Retrieves the kept flashes from the previous request.
     * - Overwrites the current flash data with the kept flashes.
     * - Clears the kept flashes to reset state for the next request.
     *
     * @return void
     */
    public function load() : void
    {
        // Retrieve flash messages marked to be kept from the previous request.
        $kept = $this->getKeptFlashes();

        // Overwrite the current flash data with the kept flash messages.
        $this->updateFlashes(data: $kept);

        // Reset the kept flash messages for future request cycles.
        $this->updateKeptFlashes(data: []);
    }

    /**
     * Sweeps and clears all flash data at the end of the request lifecycle.
     *
     * This ensures no flash data persists beyond the intended scope.
     *
     * @return void
     */
    public function sweep() : void
    {
        // Clears the existing flash messages stored in the session to avoid persistence.
        $this->updateFlashes(data: []);
    }
}
=== Support/Bags/InputBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Bags;

use Avax\HTTP\Session\Contracts\FlashBagInterface;
use InvalidArgumentException;

/**
 * **InputBag**
 *
 * Responsible for flashing and retrieving old input values from the session.
 * This class is primarily designed to aid in repopulating form inputs after validation failures.
 */
final class InputBag extends AbstractFlashBag
{
    /**
     * Session flash key used to store old input data.
     * This constant helps identify the location of input data in the session.
     *
     * @var string
     */
    private const string FLASH_KEY = '_old_input';

    /**
     * Constructor.
     *
     * @param FlashBagInterface $flash FlashBag instance responsible for managing session flash data.
     */
    public function __construct(FlashBagInterface $flash)
    {
        parent::__construct(flash: $flash);
    }

    /**
     * **Flash Input Data**
     *
     * Stores input data in the session for one-time use in the next request.
     * Throws an exception if the provided input data is empty.
     *
     * @param array<string, mixed> $input The associative array of input data to be stored.
     *
     * @return void
     *
     * @throws InvalidArgumentException If $input is an empty array.
     */
    public function flashInput(array $input) : void
    {
        if (empty($input)) {
            throw new InvalidArgumentException(message: 'Input data cannot be empty when flashing to the session.');
        }

        $this->flash->put(key: $this->flashKey(), value: $input);
    }

    /**
     * Retrieves the session flash key used to store old input data.
     *
     * @return string The session flash key as a string.
     */
    protected function flashKey() : string
    {
        return self::FLASH_KEY;
    }

    /**
     * Retrieves all input keys currently stored in the session.
     *
     * @return array<string> A list of flashed input keys.
     */
    public function keys() : array
    {
        return array_keys($this->all());
    }

    /**
     * **Retrieve Flashed Input Data**
     *
     * Fetches flashed input data from the session and ensures it is returned as an array.
     *
     * @return array<string, mixed>|null Returns the flashed data as an array if available,
     *                                   or null if no data exists or the session doesn't hold an array.
     */
    private function getFlashedData() : array|null
    {
        $data = $this->flash->get(key: $this->flashKey(), default: []);

        return is_array($data) ? $data : null;
    }
}

=== Support/Bags/ValidationBag.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Bags;

use Avax\HTTP\Session\Contracts\FlashBagInterface;

/**
 * Class ValidationBag
 *
 * Provides functionality to manage flashable validation errors for form input fields.
 * This class enables temporary storage of validation errors in a session flash bag, allowing them
 * to persist across a single request-response cycle.
 *
 * @package Avax\HTTP\Session\Support\Bags
 */
final class ValidationBag extends AbstractFlashBag
{
    /**
     * The key used to store validation errors in the flash bag.
     *
     * @var string
     */
    private const string FLASH_KEY = '_errors';

    /**
     * Constructor.
     *
     * @param FlashBagInterface $flash FlashBag instance responsible for session flash error storage.
     */
    public function __construct(FlashBagInterface $flash)
    {
        parent::__construct(flash: $flash);
    }

    /**
     * Stores a set of validation errors in the flash bag for temporary usage.
     *
     * @param array<string, string|array<string>> $errors Associative array containing validation errors.
     *
     * @return void
     */
    public function flashErrors(array $errors) : void
    {
        $this->flash->put(key: $this->flashKey(), value: $errors);
    }

    /**
     * Retrieve the unique flash key associated with this specific bag.
     *
     * @return string The flash key associated with the bag.
     */
    protected function flashKey() : string
    {
        return self::FLASH_KEY;
    }

    /**
     * Retrieves the list of all input key names that have validation errors.
     *
     * @return array<string> An array of key names that contain validation errors.
     */
    public function keys() : array
    {
        return array_keys($this->all());
    }
}

=== Support/Factories/BagRegistryFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Factories;

use Avax\HTTP\Session\Contracts\BagRegistryInterface;
use Avax\HTTP\Session\Contracts\Factories\BagRegistryFactoryInterface;
use Avax\HTTP\Session\Contracts\SessionInterface;
use Avax\HTTP\Session\Enums\SessionBag;
use Avax\HTTP\Session\Support\ArrayBagRegistry;
use Avax\HTTP\Session\Support\Bags\FlashBag;
use Avax\HTTP\Session\Support\Bags\InputBag;
use Avax\HTTP\Session\Support\Bags\ValidationBag;

/**
 * BagRegistryFactory
 *
 * Factory responsible for creating a default BagRegistry instance, containing core session bags.
 * These session bags include:
 * - **FlashBag**: For temporary session data (e.g., notifications).
 * - **InputBag**: For preserving user input (e.g., forms).
 * - **ValidationBag**: For maintaining validation errors.
 *
 * **Design Goals**:
 * - Ensure all core session bags are registered via enum-based identifiers.
 * - Maintain extensibility and strong type safety without sacrificing simplicity.
 *
 * @final
 */
final class BagRegistryFactory implements BagRegistryFactoryInterface
{
    /**
     * Creates and returns an instance of BagRegistry containing default session bags.
     *
     * This factory initializes the following session bags:
     * - `FlashBag`: For handling flash session data, persists for a single request.
     * - `InputBag`: Depends on `FlashBag` for preserving form input data.
     * - `ValidationBag`: Depends on `FlashBag` for managing validation errors.
     *
     * **Key Design Objectives**:
     * - Dependency Injection is utilized to inject the `SessionInterface`.
     * - Enum identifiers ensure clear, extensible mapping of session bags.
     *
     * @return BagRegistryInterface The created BagRegistry initialized with default session bags.
     */
    public function create(SessionInterface $session) : BagRegistryInterface
    {
        // Instantiate the FlashBag, passing the session dependency.
        // FlashBag is used to manage data that persists for only one request lifecycle.
        $flashBag = new FlashBag(session: $session);

        // Return an ArrayBagRegistry containing predefined session bags.
        // Each bag is registered using a unique key derived from the SessionBag enum.
        return new ArrayBagRegistry(
            bags: [
                      // Register the FlashBag using the SessionBag::Flash identifier.
                      SessionBag::Flash->value      => $flashBag,

                      // Register the InputBag instance; it relies on FlashBag for retaining user-submitted forms.
                      SessionBag::Input->value      => new InputBag(flash: $flashBag),

                      // Register the ValidationBag instance; it also depends on FlashBag to persist validation errors.
                      SessionBag::Validation->value => new ValidationBag(flash: $flashBag),
                  ]
        );
    }
}
=== Support/Factories/SessionDriverFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support\Factories;

use Avax\HTTP\Session\Contracts\Factories\BagRegistryFactoryInterface;
use Avax\HTTP\Session\Contracts\SessionInterface;
use Avax\HTTP\Session\Drivers\ArraySession;
use Avax\HTTP\Session\Drivers\NativeSession;
use Avax\HTTP\Session\Enums\SessionDriver;
use Avax\HTTP\Session\Exceptions\SessionException;
use Avax\HTTP\Session\Stores\ArraySessionStore;
use Avax\HTTP\Session\Stores\NativeSessionStore;

/**
 * Factory for creating session driver instances with DI-compliant store/registry configuration.
 *
 * This factory encapsulates the creation logic for various session drivers, ensuring
 * proper configuration of their dependencies such as stores and registries.
 * This approach adheres to the Dependency Inversion Principle (DIP),
 * promoting decoupling and testability.
 *
 * @final Ensures the integrity of the factory, disallowing inheritance as per DDD.
 */
final readonly class SessionDriverFactory
{
    /**
     * Factory interface to create session bag registry instances.
     *
     * @var BagRegistryFactoryInterface $registryFactory
     * A contract to abstract the creation of bag registries for session drivers.
     */
    public function __construct(
        private BagRegistryFactoryInterface $registryFactory // Constructor Promotion for clarity and efficiency.
    ) {}

    /**
     * Factory method to create and configure a new session driver instance.
     *
     * This method maps string-based driver types to their respective
     * session implementation, such as `NativeSession` or `ArraySession`.
     *
     * It uses a robust error-checking mechanism to validate supported drivers (e.g., Enum `SessionDriver`).
     *
     * @param string $driver
     *   The session driver's type, represented as a string (e.g., 'Native', 'Array').
     *
     * @return SessionInterface
     *   The fully configured session implementation.
     *
     * @throws SessionException
     *   Thrown if an unsupported or invalid session driver is passed to the factory.
     */
    public function create(string $driver) : SessionInterface
    {
        // Convert the provided driver type to an Enum instance; returns null if invalid.
        $enum = SessionDriver::tryFrom(value: $driver);

        // Check if the given driver is supported. If not, throw a custom SessionException.
        if ($enum === null) {
            throw new SessionException(
                message: sprintf(
                         // Compose a detailed error message, explicitly listing supported drivers.
                             "Invalid session driver: '%s'. Supported drivers are: %s.",
                             $driver,
                             implode(
                                 ', ',
                                 array_map(
                                     static fn(SessionDriver $d) : string => $d->value,
                                     SessionDriver::cases()
                                 )
                             )
                         )
            );
        }

        // Use `match` to delegate the driver creation logic to specific private methods.
        return match ($enum) {
            SessionDriver::Native => $this->createNativeDriver(),
            SessionDriver::Array  => $this->createArrayDriver(),
        };
    }

    /**
     * Private factory method for creating a `NativeSession` driver.
     *
     * - Encapsulates the instantiation of a native PHP session.
     * - Injects the session store (`NativeSessionStore`) with a DI-compliant registry factory.
     *
     * @return NativeSession
     *   A fully configured instance of the `NativeSession` driver.
     */
    private function createNativeDriver() : NativeSession
    {
        return new NativeSession(
        // NativeSession requires a specific storage implementation.
            store          : new NativeSessionStore(),
            // Passing in a lazily evaluated factory to enable bag registry resolution.
            registryFactory: fn(SessionInterface $s) => $this->registryFactory->create(session: $s)
        );
    }

    /**
     * Private factory method for creating an `ArraySession` driver.
     *
     * - Encapsulates the instantiation of an in-memory session.
     * - Leverages an `ArraySessionStore` for non-persistent data storage.
     *
     * @return ArraySession
     *   A fully configured instance of the `ArraySession` driver.
     */
    private function createArrayDriver() : ArraySession
    {
        return new ArraySession(
        // ArraySession uses an in-memory storage implementation.
            store          : new ArraySessionStore(),
            // A lazily evaluated factory creates a session bag registry for this session.
            registryFactory: fn(SessionInterface $s) => $this->registryFactory->create(session: $s)
        );
    }

    /**
     * Provides access to the BagRegistryFactoryInterface for testability and runtime overrides.
     *
     * This method promotes flexibility by exposing the registry factory instance,
     * allowing consumers to interact with the factory (e.g., mocking in tests).
     *
     * @return BagRegistryFactoryInterface
     *   The factory responsible for creating bag registries for sessions.
     */
    public function getRegistry() : BagRegistryFactoryInterface
    {
        return $this->registryFactory;
    }
}
=== Support/SessionIdGenerator.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support;

/**
 * SessionIdGenerator
 *
 * Cryptographically secure session ID generator.
 *
 * This utility generates random, unpredictable session identifiers
 * using cryptographically secure random number generation.
 *
 * Enterprise Rules:
 * - Security: Uses CSPRNG (Cryptographically Secure Pseudo-Random Number Generator).
 * - Uniqueness: Extremely low collision probability.
 * - Standards: Follows OWASP session management guidelines.
 *
 * Usage:
 *   $generator = new SessionIdGenerator();
 *   $sessionId = $generator->generate();
 *
 * @package Avax\HTTP\Session\Support
 */
final readonly class SessionIdGenerator
{
    /**
     * Default session ID length in bytes.
     */
    private const DEFAULT_LENGTH = 32;

    /**
     * SessionIdGenerator Constructor.
     *
     * @param int $length The length of the session ID in bytes.
     */
    public function __construct(
        private int $length = self::DEFAULT_LENGTH
    ) {
        // Guard: Validate length is positive.
        if ($this->length <= 0) {
            throw new \InvalidArgumentException(
                message: "Session ID length must be positive, got: {$this->length}"
            );
        }

        // Guard: Validate length is reasonable (not too short).
        if ($this->length < 16) {
            throw new \InvalidArgumentException(
                message: "Session ID length must be at least 16 bytes for security, got: {$this->length}"
            );
        }
    }

    /**
     * Generate a cryptographically secure session ID.
     *
     * This method uses random_bytes() which is a CSPRNG on all
     * supported platforms.
     *
     * @return string The generated session ID (hexadecimal).
     */
    public function generate(): string
    {
        try {
            // Generate cryptographically secure random bytes.
            $randomBytes = random_bytes($this->length);

            // Convert to hexadecimal string.
            $sessionId = bin2hex($randomBytes);

            // Log generation (without the actual ID for security).
            logger()?->debug(
                message: 'Session ID generated',
                context: [
                    'length_bytes' => $this->length,
                    'length_hex' => strlen($sessionId),
                    'action' => 'SessionIdGenerator',
                ]
            );

            return $sessionId;
        } catch (\Exception $e) {
            // Log failure.
            logger()?->critical(
                message: 'Failed to generate session ID',
                context: [
                    'error' => $e->getMessage(),
                    'action' => 'SessionIdGenerator',
                ]
            );

            // Re-throw as RuntimeException.
            throw new \RuntimeException(
                message: 'Failed to generate secure session ID: ' . $e->getMessage(),
                previous: $e
            );
        }
    }

    /**
     * Validate a session ID format.
     *
     * Checks if the provided string is a valid hexadecimal session ID
     * of the expected length.
     *
     * @param string $sessionId The session ID to validate.
     *
     * @return bool True if valid, false otherwise.
     */
    public function validate(string $sessionId): bool
    {
        // Expected length in hexadecimal (2 chars per byte).
        $expectedLength = $this->length * 2;

        // Check length.
        if (strlen($sessionId) !== $expectedLength) {
            return false;
        }

        // Check if hexadecimal.
        if (!ctype_xdigit($sessionId)) {
            return false;
        }

        return true;
    }
}

=== Support/SessionSerializer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Support;

/**
 * SessionSerializer
 *
 * Handles serialization and deserialization of session data.
 *
 * This utility provides safe, type-preserving serialization for
 * session data storage and retrieval.
 *
 * Enterprise Rules:
 * - Type Safety: Preserves PHP types during serialization.
 * - Security: Validates serialized data before deserialization.
 * - Error Handling: Graceful failure on corrupt data.
 *
 * Usage:
 *   $serializer = new SessionSerializer();
 *   $serialized = $serializer->serialize($data);
 *   $data = $serializer->deserialize($serialized);
 *
 * @package Avax\HTTP\Session\Support
 */
final readonly class SessionSerializer
{
    /**
     * Serialize data for storage.
     *
     * Converts PHP values to a storable string format.
     *
     * @param mixed $data The data to serialize.
     *
     * @return string The serialized data.
     */
    public function serialize(mixed $data): string
    {
        try {
            // Use PHP's native serialization.
            // This preserves types and handles complex objects.
            $serialized = serialize($data);

            // Log serialization (without sensitive data).
            logger()?->debug(
                message: 'Session data serialized',
                context: [
                    'data_type' => get_debug_type($data),
                    'serialized_length' => strlen($serialized),
                    'action' => 'SessionSerializer',
                ]
            );

            return $serialized;
        } catch (\Exception $e) {
            // Log serialization failure.
            logger()?->error(
                message: 'Session data serialization failed',
                context: [
                    'error' => $e->getMessage(),
                    'data_type' => get_debug_type($data),
                    'action' => 'SessionSerializer',
                ]
            );

            // Re-throw as RuntimeException.
            throw new \RuntimeException(
                message: 'Failed to serialize session data: ' . $e->getMessage(),
                previous: $e
            );
        }
    }

    /**
     * Deserialize data from storage.
     *
     * Converts a serialized string back to PHP values.
     *
     * @param string $serialized The serialized data.
     *
     * @return mixed The deserialized data.
     */
    public function deserialize(string $serialized): mixed
    {
        try {
            // Use PHP's native deserialization.
            // Set allowed_classes to true to allow all classes.
            $data = unserialize($serialized, ['allowed_classes' => true]);

            // Check if deserialization failed.
            if ($data === false && $serialized !== serialize(false)) {
                throw new \RuntimeException('Deserialization returned false');
            }

            // Log deserialization (without sensitive data).
            logger()?->debug(
                message: 'Session data deserialized',
                context: [
                    'result_type' => get_debug_type($data),
                    'serialized_length' => strlen($serialized),
                    'action' => 'SessionSerializer',
                ]
            );

            return $data;
        } catch (\Exception $e) {
            // Log deserialization failure.
            logger()?->warning(
                message: 'Session data deserialization failed',
                context: [
                    'error' => $e->getMessage(),
                    'serialized_length' => strlen($serialized),
                    'action' => 'SessionSerializer',
                ]
            );

            // Re-throw as RuntimeException.
            throw new \RuntimeException(
                message: 'Failed to deserialize session data: ' . $e->getMessage(),
                previous: $e
            );
        }
    }

    /**
     * Check if a string is valid serialized data.
     *
     * @param string $data The data to validate.
     *
     * @return bool True if valid serialized data.
     */
    public function isValid(string $data): bool
    {
        // Attempt to unserialize without throwing.
        $result = @unserialize($data);

        // If unserialize returns false, check if it's actually serialized false.
        if ($result === false) {
            return $data === serialize(false);
        }

        return true;
    }
}

=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ðŸ“ Scanning directory: $TARGET_DIR"
echo "ðŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ðŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ðŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ðŸ§© Merged files : $MERGED"
echo "ðŸš« Skipped files: $SKIPPED"
echo "ðŸ“„ Output file  : $OUTPUT_FILE"

