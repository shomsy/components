=== Audit/Audit.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Audit;

use Avax\Logging\LoggerFactory;
use Psr\Log\LoggerInterface;
use Throwable;

/**
 * ðŸ§  Audit - Enterprise-Grade Session Audit Logger
 * ============================================================
 *
 * This feature provides structured, secure, and resilient audit logging
 * for all session lifecycle events within the Avax HTTP framework.
 *
 * It integrates seamlessly with your `LoggerFactory` and PSR-3 loggers,
 * automatically attaching contextual data such as:
 * - environment name (dev/staging/prod)
 * - session ID
 * - user ID (if available)
 * - client IP address
 * - timestamp
 *
 * ðŸ’¬ Think of it as:
 * â€œThe corporate black box for your session layer â€”
 *  every action is recorded, structured, and traceable.â€
 *
 * âš™ï¸ Key Features:
 * - âœ… PSR-3 compliant â€” works with any logger implementation
 * - âœ… JSON-structured logs â€” ready for ELK, Loki, or Datadog ingestion
 * - âœ… Crash-safe â€” never throws exceptions during logging
 * - âœ… Context-aware â€” captures environment, IP, and session metadata
 * - âœ… Sensitive-data sanitization â€” masks tokens, passwords, secrets
 *
 * @package Avax\HTTP\Session\Features
 * @author  â€”
 */
final class Audit
{

    /**
     * The PSR-3 compliant logger used to record audit events.
     *
     * This is resolved automatically using the `LoggerFactory`
     * if no custom logger is provided in the constructor.
     *
     * @var LoggerInterface
     */
    private readonly LoggerInterface $logger;

    /**
     * Optional log file path for fallback or standalone use.
     *
     * @var string|null
     */
    private readonly string|null $logPath;

    // -------------------------------------------------------------------------
    // ðŸš€ CONSTRUCTOR
    // -------------------------------------------------------------------------

    /**
     * Construct a new Audit feature instance.
     *
     * @param LoggerInterface|null $logger  Optional PSR-3 logger instance.
     * @param string|null          $logPath Optional direct log file path (fallback mode).
     *
     * ðŸ’¬ Think of it as:
     * â€œYou can give me a PSR logger, a file path â€” or nothing.
     *  Iâ€™ll make sure your audit events are never lost.â€
     */
    public function __construct(LoggerInterface|null $logger = null, string|null $logPath = null)
    {
        $this->logger  = $logger ?? (new LoggerFactory())->createLoggerFor(channel: 'session-audit');
        $this->logPath = $logPath;
    }

    /**
     * Record a structured audit event.
     *
     * This method safely logs session actions, with contextual metadata.
     * It never throws exceptions â€” even if the logger or file operation fails.
     *
     * @param string               $event Event name (e.g. 'session_created', 'key_deleted').
     * @param array<string, mixed> $data  Additional context (e.g. user ID, request details).
     *
     * ðŸ’¬ Example:
     * ```php
     * $audit->record('session_regenerated', [
     *     'user_id' => 42,
     *     'old_id'  => 'abc123',
     *     'new_id'  => 'xyz789'
     * ]);
     * ```
     *
     * @return void
     */
    public function record(string $event, array $data = []) : void
    {
        $payload = [
            'timestamp'   => date(format: 'c'),
            'event'       => strtoupper(string: $event),
            'environment' => getenv(name: 'APP_ENV') ?: 'production',
            'session_id'  => $data['session_id'] ?? null,
            'user_id'     => $data['user_id'] ?? null,
            'ip_address'  => $this->resolveClientIp(),
            'action_data' => $this->sanitize(data: $data),
        ];

        try {
            // âœ… PSR-3 structured log entry
            $this->logger->info(message: '[SESSION_AUDIT]', context: $payload);
        } catch (Throwable $e) {
            // âš ï¸ Fail-safe fallback â€” write to file if possible
            if ($this->logPath) {
                $this->writeToFile(payload: $payload);
            } else {
                error_log(message: "âš ï¸ [Audit] Logging failed: {$e->getMessage()}");
            }
        }
    }

    /**
     * Determine the client's IP address safely.
     *
     * Handles typical proxy headers to extract the real IP
     * while remaining compatible with direct connections.
     *
     * @return string|null The detected client IP, or null if not available.
     */
    private function resolveClientIp() : string|null
    {
        return $_SERVER['HTTP_CLIENT_IP']
            ?? $_SERVER['HTTP_X_FORWARDED_FOR']
            ?? $_SERVER['REMOTE_ADDR']
            ?? null;
    }

    // -------------------------------------------------------------------------
    // ðŸ§  AUDIT LOGIC
    // -------------------------------------------------------------------------

    /**
     * Sanitize potentially sensitive data before logging.
     *
     * Removes or masks fields that could contain confidential information,
     * such as passwords, tokens, or API keys.
     *
     * Supports deep recursive sanitization for nested arrays.
     *
     * @param array<string, mixed> $data Input data to clean.
     *
     * @return array<string, mixed> Sanitized version of the data.
     */
    private function sanitize(array $data) : array
    {
        $blacklist = ['password', 'token', 'api_key', 'secret'];
        $clean     = [];

        foreach ($data as $key => $value) {
            if (is_array(value: $value)) {
                $clean[$key] = $this->sanitize(data: $value);
                continue;
            }

            $clean[$key] = in_array(needle: $key, haystack: $blacklist, strict: true)
                ? '***MASKED***'
                : $value;
        }

        return $clean;
    }

    // -------------------------------------------------------------------------
    // ðŸ§© HELPERS
    // -------------------------------------------------------------------------

    /**
     * Write the audit payload to file in JSON format.
     *
     * @param array<string, mixed> $payload Structured log data.
     *
     * @return void
     */
    private function writeToFile(array $payload) : void
    {
        $json = json_encode(value: $payload, flags: JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        $dir  = dirname(path: $this->logPath);

        if (! is_dir(filename: $dir)) {
            mkdir(directory: $dir, permissions: 0775, recursive: true);
        }

        @file_put_contents(filename: $this->logPath, data: $json . PHP_EOL, flags: FILE_APPEND | LOCK_EX);
    }

    /**
     * Resolve the current user's ID from session context.
     *
     * Attempts to infer `user_id` automatically from PHP session data.
     * If unavailable, returns null.
     *
     * @return int|null The current user's ID, or null if unknown.
     */
    private function resolveUserId() : int|null
    {
        return $_SESSION['user_id'] ?? null;
    }
}

=== Audit/AuditManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Audit;

use Psr\Log\LoggerInterface;

/**
 * ðŸ§  AuditManager - Session Audit Operations Orchestrator
 * ============================================================
 *
 * The AuditManager orchestrates all session auditing and logging
 * operations for compliance, security, and debugging purposes.
 *
 * This manager provides:
 * - Structured event logging with context
 * - PSR-3 logger integration
 * - Sensitive data sanitization
 * - Audit trail management
 *
 * ðŸ’¡ Design Philosophy:
 * Audit logging is critical for security compliance (GDPR, SOC2, etc.)
 * and debugging. This manager ensures all session operations are
 * properly logged without impacting performance or exposing sensitive data.
 *
 * @package Avax\HTTP\Session\Audit
 * @author  Milos
 * @version 5.0
 */
final readonly class AuditManager
{
    /**
     * AuditManager Constructor.
     *
     * @param Audit $audit The audit feature instance.
     */
    public function __construct(private Audit $audit) {}


    // ----------------------------------------------------------------
    // ðŸ”¹ Lifecycle Management
    // ----------------------------------------------------------------

    /**
     * Record a session event with contextual data.
     *
     * Logs the event with automatic context enrichment including:
     * - Timestamp
     * - User ID (if available)
     * - Client IP address
     * - Session ID
     *
     * Sensitive data is automatically sanitized before logging.
     *
     * @param string               $event Event name (e.g., 'session.put', 'login').
     * @param array<string, mixed> $data  Event-specific data.
     *
     * @return void
     */
    public function record(string $event, array $data = []) : void
    {
        $this->audit->record($event, $data);
    }

    /**
     * Disable audit logging.
     *
     * Stops recording events and optionally writes a final log entry.
     *
     * @return self Fluent interface.
     */
    public function disable() : self
    {
        $this->audit->terminate();

        return $this;
    }


    // ----------------------------------------------------------------
    // ðŸ”¹ Internal Access
    // ----------------------------------------------------------------

    /**
     * Get the underlying Audit instance.
     *
     * Provides direct access to the audit feature for advanced operations.
     *
     * @return Audit The audit instance.
     */
    public function audit() : Audit
    {
        return $this->audit;
    }
}

=== Core/Config.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core;

/**
 * Config - Configuration Value Object
 *
 * Immutable configuration for SessionManager initialization.
 *
 * Provides clean, readable configuration without constructor parameter soup.
 *
 * @example
 *   $config = new Config(
 *       ttl: 3600,
 *       secure: true,
 *       encryptionKey: 'secret'
 *   );
 *
 *   $session = new SessionManager($store, $config);
 *
 * @package Avax\HTTP\Session
 */
final readonly class Config
{
    /**
     * Config Constructor.
     *
     * @param int|null    $ttl           Default TTL in seconds.
     * @param bool        $secure        Enable auto-encryption by default.
     * @param string|null $encryptionKey Encryption key for secure values.
     */
    public function __construct(
        public int|null    $ttl = null,
        public bool        $secure = false,
        public string|null $encryptionKey = null
    ) {}

    /**
     * Create default configuration.
     *
     * @return self
     */
    public static function default() : self
    {
        return new self();
    }

    /**
     * Create secure configuration.
     *
     * @param string $encryptionKey The encryption key.
     *
     * @return self
     */
    public static function secure(string $encryptionKey) : self
    {
        return new self(secure: true, encryptionKey: $encryptionKey);
    }

    /**
     * Create temporary configuration with TTL.
     *
     * @param int $ttl TTL in seconds.
     *
     * @return self
     */
    public static function temporary(int $ttl) : self
    {
        return new self(ttl: $ttl);
    }
}

=== Core/CoreManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core;

use Avax\HTTP\Session\Core\Lifecycle\SessionEngine;
use Avax\HTTP\Session\Core\Lifecycle\SessionScope;
use Avax\HTTP\Session\Shared\Contracts\Security\Encrypter;

/**
 * CoreManager - Core Session Operations Orchestrator
 * ============================================================
 *
 * The CoreManager is responsible for orchestrating all fundamental
 * session operations including storage, retrieval, encryption, and
 * basic lifecycle management.
 *
 * This manager acts as the central coordinator for:
 * - Session data storage (put/get/has/forget/flush)
 * - Automatic encryption/decryption of session values
 * - TTL (time-to-live) management
 * - Namespace and context isolation
 * - Lazy evaluation (remember pattern)
 * - Policy enforcement
 *
 * Design Philosophy:
 * The CoreManager delegates actual implementation to SessionEngine
 * while providing a clean, focused API for core session operations.
 * It ensures separation of concerns by handling ONLY core functionality,
 * leaving Recovery, Audit, and Events to their respective managers.
 *
 * @package Avax\HTTP\Session\Core
 * @author  Milos
 * @version 5.0
 */
final readonly class CoreManager
{
    /**
     * CoreManager Constructor.
     *
     * @param SessionEngine $engine The core session engine.
     */
    public function __construct(private SessionEngine $engine) {}

    // ----------------------------------------------------------------
    // Core Data Operations
    // ----------------------------------------------------------------

    /**
     * Remove a specific key from the session.
     *
     * @param string $key The session key to remove.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        $this->engine->storage()->delete(key: $key);
    }

    /**
     * Retrieve all session data.
     *
     * Returns the complete session dataset as an associative array.
     * Useful for debugging, snapshots, or bulk operations.
     *
     * @return array<string, mixed> All session data.
     */
    public function all() : array
    {
        return $this->engine->storage()->all();
    }

    /**
     * Get a session consumer for a specific context.
     *
     * Contexts allow you to isolate session data by logical domain
     * (e.g., 'cart', 'user', 'preferences').
     *
     * @param string $context The context identifier.
     *
     * @return SessionScope A scoped session consumer.
     */
    public function for(string $context) : SessionScope
    {
        return $this->engine->for(context: $context);
    }

    /**
     * Get a session consumer for a specific namespace.
     *
     * Namespaces provide hierarchical isolation of session data.
     *
     * @param string $namespace The namespace identifier.
     *
     * @return SessionScope A namespaced session consumer.
     */
    public function scope(string $namespace) : SessionScope
    {
        return $this->engine->scope(namespace: $namespace);
    }

    /**
     * Get or compute a session value (lazy evaluation pattern).
     *
     * If the key exists, returns its value.
     * If not, executes the callback, stores the result with optional TTL, and returns it.
     *
     * @param string   $key      The session key.
     * @param callable $callback Function to compute the value if missing.
     * @param int|null $ttl      Optional TTL for the computed value.
     *
     * @return mixed The cached or computed value.
     */
    public function remember(string $key, callable $callback, ?int $ttl = null) : mixed
    {
        // Check if key already exists
        if ($this->has(key: $key)) {
            return $this->get(key: $key);
        }

        // Key doesn't exist - compute value via callback
        $value = $callback();

        // Store the computed value with optional TTL
        $this->put(key: $key, value: $value, ttl: $ttl);

        return $value;
    }

    /**
     * Check if a session key exists.
     *
     * @param string $key The session key to check.
     *
     * @return bool True if the key exists, false otherwise.
     */
    public function has(string $key) : bool
    {
        return $this->engine->storage()->has(key: $key);
    }

    // ----------------------------------------------------------------
    // Contextual Access
    // ----------------------------------------------------------------

    /**
     * Retrieve a value from the session.
     *
     * Automatically decrypts the value if it was stored encrypted.
     *
     * @param string $key     The session key.
     * @param mixed  $default Default value if key doesn't exist.
     *
     * @return mixed The session value or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        return $this->engine->get(key: $key, default: $default);
    }

    /**
     * Store a value in the session.
     *
     * Automatically encrypts the value if secure mode is enabled
     * in the session configuration.
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Optional time-to-live in seconds.
     *
     * @return void
     */
    public function put(string $key, mixed $value, int|null $ttl = null) : void
    {
        $this->engine->put(key: $key, value: $value, ttl: $ttl);
    }

    // ----------------------------------------------------------------
    // Lazy Evaluation & Caching
    // ----------------------------------------------------------------

    /**
     * Get the session configuration.
     *
     * @return Config The immutable configuration object.
     */
    public function config() : Config
    {
        return $this->engine->config();
    }

    // ----------------------------------------------------------------
    // Configuration & Security
    // ----------------------------------------------------------------

    /**
     * Get the encryption handler.
     *
     * @return Encrypter The active encrypter instance.
     */
    public function encrypter() : Encrypter
    {
        return $this->engine->encrypter();
    }

    // ----------------------------------------------------------------
    // Lifecycle Operations
    // ----------------------------------------------------------------

    /**
     * Regenerate the session ID.
     *
     * Critical security operation to prevent session fixation attacks.
     * Should be called on login, privilege elevation, etc.
     *
     * @return void
     */
    public function regenerate() : void
    {
        $this->engine->regenerate();
    }

    /**
     * Terminate the session.
     *
     * Securely destroys the session and clears all data.
     *
     * @param string $reason Termination reason (for audit logs).
     *
     * @return void
     */
    public function terminate(string $reason = 'logout') : void
    {
        $this->engine->terminate(reason: $reason);
    }

    /**
     * Clear all session data.
     *
     * This operation removes all keys from the session store.
     * Use with caution as this is irreversible (unless using Recovery).
     *
     * @return void
     */
    public function flush() : void
    {
        $this->engine->flush();
    }

    // ----------------------------------------------------------------
    // Internal Access
    // ----------------------------------------------------------------

    /**
     * Get the underlying SessionEngine.
     *
     * Provides access to the core engine for advanced operations.
     *
     * @return SessionEngine The session engine instance.
     */
    public function engine() : SessionEngine
    {
        return $this->engine;
    }
}

=== Core/Lifecycle/SessionEngine.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core\Lifecycle;

use Avax\HTTP\Session\Audit\Audit;
use Avax\HTTP\Session\Core\Config;
use Avax\HTTP\Session\Core\Lifecycle;
use Avax\HTTP\Session\Events\Events;
use Avax\HTTP\Session\Recovery\Recovery;
use Avax\HTTP\Session\Shared\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Shared\Contracts\Security\SessionIdProviderInterface;
use Avax\HTTP\Session\Shared\Contracts\Storage\StoreInterface;
use Avax\HTTP\Session\Shared\Security\Policies\PolicyInterface;
use Avax\HTTP\Session\Shared\Security\SessionNonce;
use Avax\HTTP\Session\Shared\Security\SessionRegistry;
use Avax\HTTP\Session\Shared\Security\SessionSignature;
use Throwable;

/**
 * Class SessionEngine
 * ============================================================
 * ðŸ§  Core Session Lifecycle Coordinator
 *
 * The central â€œkernelâ€ of the Avax session system.
 * It connects persistent storage, encryption, recovery,
 * security policies, and observability features into one cohesive unit.
 *
 * Responsibilities:
 *  - Manages persistent session storage (file, Redis, etc.)
 *  - Encrypts/decrypts session values via Encrypter
 *  - Provides Recovery safety (snapshots, rollback, transactions)
 *  - Enforces policies (max idle, lifetime, secure-only, etc.)
 *  - Maintains session registry (multi-login & concurrency)
 *  - Applies signature integrity via SessionSignature
 *  - Integrates PSR-3 observability features (Audit, Metrics, etc.)
 *
 * ðŸ’¬ Think of it as the â€œsession OS kernelâ€ â€” everything passes through it.
 *
 * @package Avax\HTTP\Session\Core
 */
final readonly class SessionEngine
{
    /**
     * SessionEngine Constructor.
     *
     * All dependencies injected via DI - no runtime registration.
     * Policies and Features are immutable after construction.
     *
     * @param StoreInterface             $store      Persistent session store driver.
     * @param Config                     $config     Immutable configuration object.
     * @param Encrypter                  $encrypter  Encryption engine for secure payloads.
     * @param Recovery                   $recovery   Recovery manager for backup and rollback.
     * @param SessionIdProviderInterface $idProvider Session ID generation and management.
     * @param Audit|null                 $audit      Audit feature for logging.
     * @param Events|null                $events     Events feature for dispatching.
     * @param SessionSignature|null      $signature  Optional integrity validator for session IDs.
     * @param PolicyInterface|null       $policies   Optional policy group or composite.
     * @param SessionRegistry|null       $registry   Optional multi-login registry handler.
     */
    public function __construct(
        private StoreInterface             $store,
        private Config                     $config,
        private Encrypter                  $encrypter,
        private Recovery                   $recovery,
        private SessionIdProviderInterface $idProvider,
        private Audit|null                 $audit = null,
        private Events|null                $events = null,
        private SessionSignature|null      $signature = null,
        private PolicyInterface|null       $policies = null,
        private SessionRegistry|null       $registry = null
    ) {}

    // ---------------------------------------------------------------------
    // ðŸ”¹ Core Accessors
    // ---------------------------------------------------------------------

    /**
     * Get the session data store.
     */
    public function storage(): StoreInterface
    {
        return $this->store;
    }

    /**
     * Get the immutable configuration for this session.
     */
    public function config(): Config
    {
        return $this->config;
    }

    /**
     * Get the active encryption handler.
     */
    public function encrypter(): Encrypter
    {
        return $this->encrypter;
    }

    /**
     * Get the session recovery manager (snapshots, rollback, transactions).
     */
    public function recovery(): Recovery
    {
        return $this->recovery;
    }

    /**
     * Get the cryptographic session signature validator, if configured.
     */
    public function signature(): SessionSignature|null
    {
        return $this->signature;
    }

    /**
     * Get the currently active session policy or composite policy group.
     */
    public function policies(): PolicyInterface|null
    {
        return $this->policies;
    }

    /**
     * Get the session registry for tracking user sessions (multi-login control).
     */
    public function registry(): SessionRegistry|null
    {
        return $this->registry;
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Feature Accessors (Immutable - Injected via DI)
    // ---------------------------------------------------------------------

    /**
     * Restore the session to the last valid snapshot.
     */
    public function restore(): void
    {
        $this->recovery->restore();
        $this->audit()?->record(event: 'session_restored', data: ['time' => time()]);
    }

    /**
     * Get the Audit feature (injected via DI).
     *
     * @return Audit|null The audit feature or null.
     */
    public function audit(): Audit|null
    {
        return $this->audit;
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Recovery Operations
    // ---------------------------------------------------------------------

    /**
     * Execute a callback within a transactional session context.
     * If an exception occurs, the transaction is automatically rolled back.
     *
     * @param callable $callback The function to execute atomically.
     *
     * @throws Throwable Re-throws the original exception if the transaction fails.
     */
    public function transactional(callable $callback): void
    {
        try {
            $this->recovery->beginTransaction();
            $callback($this);
            $this->recovery->commit();

            $this->audit()?->record(event: 'transaction_committed');
        } catch (Throwable $e) {
            $this->recovery->rollback();
            $this->audit()?->record(event: 'transaction_rolled_back', data: ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Create a session consumer for a specific context.
     *
     * Contexts allow you to isolate session data by logical domain.
     *
     * @param string $context The context identifier.
     *
     * @return \Avax\HTTP\Session\Core\Lifecycle\SessionScope A scoped session consumer.
     */
    public function for(string $context): Lifecycle\SessionScope
    {
        return new Lifecycle\SessionScope(namespace: $context, engine: $this);
    }

    /**
     * Create a session consumer for a specific namespace.
     *
     * Namespaces provide hierarchical isolation of session data.
     *
     * @param string $namespace The namespace identifier.
     *
     * @return \Avax\HTTP\Session\Core\Lifecycle\SessionScope A namespaced session consumer.
     */
    public function scope(string $namespace): Lifecycle\SessionScope
    {
        return new Lifecycle\SessionScope(namespace: $namespace, engine: $this);
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Recovery Convenience Wrappers
    // ---------------------------------------------------------------------

    /**
     * Get the session nonce for replay protection.
     *
     * @return SessionNonce|null The session nonce or null.
     */
    public function nonce(): SessionNonce|null
    {
        // Create a SessionNonce instance using the store
        return new SessionNonce(store: $this->store);
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Policy Enforcement
    // ---------------------------------------------------------------------

    /**
     * Build session context for policy evaluation.
     *
     * Creates a comprehensive context array containing all relevant
     * session metadata for security policy enforcement.
     *
     * @return array<string, mixed> Session context data.
     */
    private function buildContext(): array
    {
        return [
            'session_id'    => $this->idProvider->current(),
            'ip'            => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
            'user_agent'    => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
            'last_activity' => time(),
            'created_at'    => $this->store->get('_created_at', time()),
            'user_id'       => $this->store->get('user_id')
        ];
    }

    /**
     * Perform user login operation.
     *
     * This is a high-level convenience method that:
     * 1. Regenerates the session ID (prevents session fixation)
     * 2. Stores user authentication data
     * 3. Registers the session in the multi-device registry
     * 4. Records audit trail
     * 5. Dispatches login events
     *
     * Enterprise Features:
     * - Automatic session ID regeneration
     * - Multi-device session tracking
     * - Comprehensive audit logging
     * - Event-driven architecture integration
     * - IP address and user agent tracking
     *
     * @param string $userId User identifier (username, email, or UUID).
     * @param array  $data   Additional user data to store in session.
     *
     * @return void
     */
    public function login(string $userId, array $data = []): void
    {
        // Step 1: Enforce security policies
        $this->policies?->enforce($this->buildContext());

        // Step 2: Regenerate session ID for security
        $this->regenerate();

        // Step 2: Store user authentication data
        $this->put(key: 'user_id', value: $userId);
        $this->put(key: 'user_data', value: $data);
        $this->put(key: 'logged_in_at', value: time());
        $this->put(key: 'last_activity', value: time());

        // Step 3: Store security metadata
        $this->put(key: 'ip_address', value: $_SERVER['REMOTE_ADDR'] ?? 'unknown');
        $this->put(key: 'user_agent', value: $_SERVER['HTTP_USER_AGENT'] ?? 'unknown');

        // Step 4: Register in multi-device registry (if available)
        $this->registry?->register(
            userId: $userId,
            sessionId: session_id(),
            metadata: [
                'ip'         => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown',
                'login_time' => time()
            ]
        );

        // Step 5: Audit logging
        $this->audit()?->record(
            event: 'user_login',
            data: [
                'user_id'   => $userId,
                'timestamp' => time(),
                'ip'        => $_SERVER['REMOTE_ADDR'] ?? 'unknown'
            ]
        );

        // Step 6: Dispatch login event
        $this->events()?->dispatch(
            event: 'session.login',
            data: compact(var_name: 'userId')
        );
    }

    /**
     * Regenerate the session ID.
     *
     * Critical security operation to prevent session fixation attacks.
     * Uses SessionIdProvider for proper ID regeneration.
     *
     * @return void
     */
    public function regenerate(): void
    {
        // Enforce security policies before regeneration
        $this->policies?->enforce($this->buildContext());

        // Get old ID before regeneration
        $oldId = $this->idProvider->current();

        // Regenerate using provider (handles native PHP session or custom)
        $newId = $this->idProvider->regenerate();

        // Audit the regeneration
        $this->audit()?->record(
            event: 'session.lifecycle.regenerate',
            data: compact('oldId', 'newId')
        );

        // Dispatch event
        $this->events()?->dispatch(
            event: 'session.lifecycle.regenerate',
            data: compact('oldId', 'newId')
        );
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Contextual Session Consumers
    // ---------------------------------------------------------------------

    /**
     * Get the Events feature (injected via DI).
     *
     * @return Events|null The events feature or null.
     */
    public function events(): Events|null
    {
        return $this->events;
    }

    /**
     * Store a value in the session (automatically encrypted if configured).
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Time-to-live in seconds (null = never expires).
     */
    public function put(string $key, mixed $value, int|null $ttl = null): void
    {
        // Enforce security policies
        $this->policies?->enforce($this->buildContext());

        // Update registry activity
        $this->registry?->updateActivity(
            sessionId: $this->idProvider->current(),
            lastActivity: time()
        );

        $payload = $this->config->secure
            ? $this->encrypter->encrypt(value: $value)
            : $value;

        $this->store->put(key: $key, value: $payload, ttl: $ttl);

        $this->audit()?->record(
            event: 'session.data.put',
            data: compact('key', 'ttl')
        );

        $this->events()?->dispatch(
            event: 'session.data.put',
            data: compact('key')
        );
    }

    // ---------------------------------------------------------------------
    // ðŸ”¹ Lifecycle & Security Operations
    // ---------------------------------------------------------------------

    /**
     * Terminate the session securely.
     *
     * This is a comprehensive session termination that:
     * 1. Clears all session data
     * 2. Unregisters from multi-device registry
     * 3. Invalidates session cookies
     * 4. Records audit trail with termination reason
     * 5. Dispatches termination events
     *
     * Enterprise Features:
     * - Secure data wiping
     * - Multi-device session cleanup
     * - Comprehensive audit trail
     * - Reason tracking for compliance
     * - Event-driven notifications
     *
     * Common Reasons:
     * - 'logout' - User-initiated logout
     * - 'timeout' - Session timeout/inactivity
     * - 'security' - Security policy violation
     * - 'admin' - Administrative termination
     * - 'concurrent' - Concurrent login limit exceeded
     *
     * @param string $reason Termination reason for audit purposes.
     *
     * @return void
     */
    public function terminate(string $reason = 'logout'): void
    {
        // Step 1: Get user ID before clearing (for audit)
        $userId = $this->get(key: 'user_id');

        // Step 2: Unregister from multi-device registry
        $this->registry?->terminateSession(
            userId: $userId,
            sessionId: $this->idProvider->current() // or session_id()
        );

        // Step 3: Audit the termination BEFORE clearing data
        $this->audit()?->record(
            event: 'session_terminated',
            data: [
                'user_id'          => $userId,
                'reason'           => $reason,
                'timestamp'        => time(),
                'session_duration' => time() - ($this->get(key: 'logged_in_at') ?? time())
            ]
        );

        // Step 4: Dispatch termination event
        $this->events()?->dispatch(
            event: 'session.terminated',
            data: compact('userId', 'reason')
        );

        // Step 5: Clear all session data
        $this->flush();

        // Step 6: Destroy PHP session (if using native sessions)
        if (session_status() === PHP_SESSION_ACTIVE) {
            session_destroy();
        }
    }

    /**
     * Retrieve a value from the session store (auto-decrypted if necessary).
     *
     * @param string $key     Session key.
     * @param mixed  $default Default value if key does not exist.
     *
     * @return mixed The session value or the default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        // Enforce security policies
        $this->policies?->enforce($this->buildContext());

        // Update registry activity
        $this->registry?->updateActivity(
            sessionId: $this->idProvider->current(),
            lastActivity: time()
        );

        $data = $this->store->get(key: $key, default: $default);

        if ($data === null) {
            return $default;
        }

        if ($this->config->secure && is_string(value: $data)) {
            $data = $this->encrypter->decrypt($data);
        }

        $this->audit()?->record(event: 'get', data: compact(var_name: 'key'));

        return $data;
    }

    /**
     * Flush (clear) all session data.
     */
    public function flush(): void
    {
        $this->store->flush();
        $this->audit()?->record(event: 'flush');
    }
}

=== Core/Lifecycle/SessionScope.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core\Lifecycle;

/**
 * SessionScope - Contextual Session Consumer
 *
 * Represents a contextual, purpose-specific consumer of the SessionEngine.
 * Created via $session->for($context) or $session->scope($context).
 *
 * engine-Consumer Pattern:
 * - SessionEngine = engine (aggregate root, lifecycle management)
 * - SessionScope = Consumer (contextual DSL adapter)
 *
 * Features:
 * - Namespace isolation (e.g., 'cart', 'user', 'admin')
 * - TTL configuration
 * - Auto-encryption via secure() method
 * - Chainable fluent API
 *
 * @example
 *   $session->for('cart')
 *       ->secure()
 *       ->ttl(3600)
 *       ->put('items', $items);
 *
 * @package Avax\HTTP\Session\Lifecycle
 */
final class SessionScope
{
    private int|null $ttl    = null;
    private bool     $secure = false;

    /**
     * SessionScope Constructor.
     *
     * @param string        $namespace The consumer context namespace.
     * @param SessionEngine $engine    The session engine.
     */
    public function __construct(
        private readonly string        $namespace,
        private readonly SessionEngine $engine
    ) {}

    /**
     * Enable auto-encryption for all operations in this consumer context.
     *
     * @return self Fluent interface.
     */
    public function secure() : self
    {
        $this->secure = true;

        return $this;
    }

    /**
     * Remove a value from this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        $scopedKey = $this->buildKey($key);
        $this->engine->storage()->delete(key: $scopedKey);
    }

    /**
     * Build scoped key with namespace and security suffix.
     *
     * @param string $key The base key.
     *
     * @return string The scoped key.
     */
    private function buildKey(string $key) : string
    {
        $scopedKey = "{$this->namespace}.{$key}";

        if ($this->secure) {
            $scopedKey .= '_secure';
        }

        return $scopedKey;
    }

    /**
     * Remember a value using lazy evaluation.
     *
     * Proxy to engine's get/put methods with scoped key.
     *
     * @param string   $key      The key (will be namespaced).
     * @param callable $callback Callback to generate value.
     *
     * @return mixed The cached or generated value.
     */
    public function remember(string $key, callable $callback) : mixed
    {
        $scopedKey = $this->buildKey($key);

        if ($this->engine->storage()->has(key: $scopedKey)) {
            return $this->engine->get(key: $scopedKey);
        }

        $value = $callback();
        $this->engine->put(key: $scopedKey, value: $value);

        return $value;
    }

    /**
     * Check if a key exists in this consumer context.
     *
     * @param string $key The key (will be namespaced).
     *
     * @return bool True if key exists.
     */
    public function has(string $key) : bool
    {
        $scopedKey = $this->buildKey($key);

        return $this->engine->storage()->has(key: $scopedKey);
    }

    /**
     * Retrieve a value from this consumer context.
     *
     * @param string $key     The key (will be namespaced).
     * @param mixed  $default Default value if not found.
     *
     * @return mixed The retrieved value or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $scopedKey = $this->buildKey($key);

        return $this->engine->get(
            key    : $scopedKey,
            default: $default
        );
    }

    /**
     * Store a value in this consumer context.
     *
     * @param string $key   The key (will be namespaced).
     * @param mixed  $value The value to store.
     *
     * @return void
     */
    public function put(string $key, mixed $value) : void
    {
        $scopedKey = $this->buildKey($key);
        $this->engine->put(
            key  : $scopedKey,
            value: $value,
            ttl  : $this->ttl
        );
    }

    /**
     * Create a temporary consumer with TTL.
     *
     * Shortcut for ->ttl() configuration.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Consumer with TTL configured.
     */
    public function temporary(int $seconds) : self
    {
        return $this->ttl($seconds);
    }

    /**
     * Set TTL for all operations in this consumer context.
     *
     * @param int $seconds Time-to-live in seconds.
     *
     * @return self Fluent interface.
     */
    public function ttl(int $seconds) : self
    {
        $this->ttl = $seconds;

        return $this;
    }

    /**
     * String representation for debugging.
     *
     * @return string Debug representation.
     */
    public function __toString() : string
    {
        return sprintf(
            'SessionScope(%s, secure=%s, ttl=%s)',
            $this->namespace,
            $this->secure ? 'true' : 'false',
            $this->ttl ?? 'null'
        );
    }
}

=== Core/Storage/FileStore.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Core\Storage;

use Avax\Filesystem\Storage\FileStorageInterface;
use Avax\HTTP\Session\Shared\Contracts\Storage\StoreInterface;
use RuntimeException;
use Throwable;

/**
 * FileStore - Enterprise-Grade File-Based Session Storage
 * ============================================================
 *
 * Enhanced file storage with metadata support including:
 * - Original key preservation (no MD5 key loss)
 * - TTL/expiration support
 * - Creation and modification timestamps
 * - Namespace-based operations
 *
 * File Format:
 * ```php
 * [
 *     'key' => 'user_id',           // Original key
 *     'value' => 'user123',         // Actual value
 *     'created_at' => 1702234567,   // Creation timestamp
 *     'expires_at' => 1702238167,   // Expiration (null = never)
 * ]
 * ```
 *
 * @package Avax\HTTP\Session\Core\Storage
 */
final readonly class FileStore implements StoreInterface
{
    public function __construct(
        private FileStorageInterface $storage,
        private string               $directory = 'sessions'
    ) {}

    /**
     * Save a session value with metadata.
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Time-to-live in seconds (null = never expires).
     *
     * @return void
     */
    public function put(string $key, mixed $value, ?int $ttl = null): void
    {
        $path = $this->pathFor(key: $key);

        $metadata = [
            'key'        => $key,
            'value'      => $value,
            'created_at' => time(),
            'expires_at' => $ttl ? time() + $ttl : null,
        ];

        try {
            $this->storage->write(
                path: $path,
                content: serialize($metadata)
            );
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to write session key '{$key}': " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Retrieve a session value.
     *
     * Automatically checks expiration and deletes expired entries.
     *
     * @param string $key     Session key.
     * @param mixed  $default Default value if key doesn't exist or expired.
     *
     * @return mixed The session value or default.
     */
    public function get(string $key, mixed $default = null): mixed
    {
        $path = $this->pathFor(key: $key);

        if (!$this->storage->exists(path: $path)) {
            return $default;
        }

        try {
            $metadata = unserialize($this->storage->read(path: $path));

            // Check expiration
            if (isset($metadata['expires_at']) && $metadata['expires_at'] !== null) {
                if (time() > $metadata['expires_at']) {
                    // Expired - delete and return default
                    $this->delete(key: $key);
                    return $default;
                }
            }

            return $metadata['value'] ?? $default;
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to read session key '{$key}': " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Check if a key exists and is not expired.
     *
     * @param string $key The session key.
     *
     * @return bool True if exists and not expired.
     */
    public function has(string $key): bool
    {
        $path = $this->pathFor(key: $key);

        if (!$this->storage->exists(path: $path)) {
            return false;
        }

        try {
            $metadata = unserialize($this->storage->read(path: $path));

            // Check expiration
            if (isset($metadata['expires_at']) && $metadata['expires_at'] !== null) {
                if (time() > $metadata['expires_at']) {
                    $this->delete(key: $key);
                    return false;
                }
            }

            return true;
        } catch (Throwable) {
            return false;
        }
    }

    /**
     * Delete a specific session key.
     *
     * @param string $key The session key.
     *
     * @return void
     */
    public function delete(string $key): void
    {
        try {
            $this->storage->delete(path: $this->pathFor(key: $key));
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to delete session key '{$key}': " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Retrieve all session data with original keys.
     *
     * Returns array with original keys (not MD5 hashes).
     * Automatically filters out expired entries.
     *
     * @return array<string, mixed> All session data.
     */
    public function all(): array
    {
        try {
            $files = $this->storage->listFiles($this->directory);
            $data  = [];

            foreach ($files as $file) {
                $content  = $this->storage->read(path: $file);
                $metadata = unserialize($content);

                // Skip expired entries
                if (isset($metadata['expires_at']) && $metadata['expires_at'] !== null) {
                    if (time() > $metadata['expires_at']) {
                        $this->storage->delete(path: $file);
                        continue;
                    }
                }

                // Use original key, not MD5 hash
                $originalKey        = $metadata['key'] ?? basename($file, '.sess');
                $data[$originalKey] = $metadata['value'] ?? null;
            }

            return $data;
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to read all session data: " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Delete all session data.
     *
     * @return void
     */
    public function flush(): void
    {
        try {
            $this->storage->deleteDirectory(directory: $this->directory);
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to flush session directory: " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Flush all keys matching a namespace prefix.
     *
     * Example: flushNamespace('cart') deletes 'cart.items', 'cart.total', etc.
     *
     * @param string $prefix The namespace prefix.
     *
     * @return void
     */
    public function flushNamespace(string $prefix): void
    {
        try {
            $files = $this->storage->listFiles($this->directory);

            foreach ($files as $file) {
                $content  = $this->storage->read(path: $file);
                $metadata = unserialize($content);

                $originalKey = $metadata['key'] ?? '';

                // Delete if key starts with prefix
                if (str_starts_with($originalKey, $prefix . '.')) {
                    $this->storage->delete(path: $file);
                }
            }
        } catch (Throwable $e) {
            throw new RuntimeException(
                message: "Failed to flush namespace '{$prefix}': " . $e->getMessage(),
                code: 0,
                previous: $e
            );
        }
    }

    /**
     * Build a consistent file path for the given key.
     *
     * Uses MD5 hash for filesystem safety while preserving original key in metadata.
     *
     * @param string $key The session key.
     *
     * @return string The file path.
     */
    private function pathFor(string $key): string
    {
        return "{$this->directory}/" . md5($key) . '.sess';
    }
}

=== Events/AsyncEventDispatcher.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Events;

use Exception;
use InvalidArgumentException;

/**
 * AsyncEventDispatcher - Asynchronous Event Dispatcher
 *
 * High-throughput event dispatcher with queue-based async processing.
 * Prevents event handling from blocking main request flow.
 *
 * Features:
 * - Queue-based async dispatch
 * - Batch processing
 * - Error handling and retry logic
 * - Memory-efficient (bounded queue)
 * - Graceful shutdown
 *
 * Modes:
 * - SYNC: Immediate synchronous dispatch (default, backward compatible)
 * - ASYNC_MEMORY: In-memory queue, processed on shutdown
 * - ASYNC_FILE: File-based queue, processed by background worker
 * - ASYNC_REDIS: Redis queue (requires Redis extension)
 *
 * @example Sync mode (default)
 *   $dispatcher = new AsyncEventDispatcher();
 *   $dispatcher->listen('event', $callback);
 *   $dispatcher->dispatch('event', $data);  // Immediate
 *
 * @example Async memory mode
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_MEMORY);
 *   $dispatcher->dispatch('event', $data);  // Queued, processed on shutdown
 *
 * @example Async file mode (for background workers)
 *   $dispatcher = new AsyncEventDispatcher(AsyncEventDispatcher::MODE_ASYNC_FILE, '/tmp/events.queue');
 *   $dispatcher->dispatch('event', $data);  // Written to file
 *
 * @package Avax\HTTP\Session\Events
 */
final class AsyncEventDispatcher
{
    public const string MODE_SYNC         = 'sync';
    public const string MODE_ASYNC_MEMORY = 'async_memory';
    public const string MODE_ASYNC_FILE   = 'async_file';
    public const string MODE_ASYNC_REDIS  = 'async_redis';

    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var array<array{event: string, data: array}> Event queue
     */
    private array $queue = [];

    /**
     * @var bool Shutdown handler registered
     */
    private bool $shutdownRegistered = false;

    /**
     * @var int Maximum queue size (prevent memory exhaustion)
     */
    private int $maxQueueSize = 1000;

    /**
     * @var int Batch size for processing
     */
    private int $batchSize = 100;

    /**
     * AsyncEventDispatcher Constructor.
     *
     * @param string|null $mode      Dispatch mode (sync|async_memory|async_file|async_redis).
     * @param string|null $queuePath Queue file path (for async_file mode).
     * @param object|null $redis     Redis instance (for async_redis mode).
     */
    public function __construct(
        private string|null          $mode = null,
        private readonly string|null $queuePath = null,
        private readonly object|null $redis = null
    )
    {
        $this->mode ??= self::MODE_SYNC;
        if ($mode === self::MODE_ASYNC_FILE && $queuePath === null) {
            throw new InvalidArgumentException(message: 'Queue path required for async_file mode');
        }

        if ($this->mode === self::MODE_ASYNC_REDIS && $this->redis === null) {
            throw new InvalidArgumentException(message: 'Redis instance required for async_redis mode');
        }
    }

    /**
     * Register a one-time listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function once(string $event, callable $callback) : self
    {
        $wrapper = function (array $data) use ($callback, $event, &$wrapper) {
            $callback($data);
            $this->removeListener(event: $event, callback: $wrapper);
        };

        return $this->listen(event: $event, callback: $wrapper);
    }

    /**
     * Remove a specific listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback to remove.
     *
     * @return self Fluent interface.
     */
    public function removeListener(string $event, callable $callback) : self
    {
        if (! isset($this->listeners[$event])) {
            return $this;
        }

        $this->listeners[$event] = array_filter(
            array   : $this->listeners[$event],
            callback: static fn($listener) => $listener !== $callback
        );

        return $this;
    }

    /**
     * Register an event listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback Callback function.
     *
     * @return self Fluent interface.
     */
    public function listen(string $event, callable $callback) : self
    {
        if (! isset($this->listeners[$event])) {
            $this->listeners[$event] = [];
        }

        $this->listeners[$event][] = $callback;

        return $this;
    }

    /**
     * Dispatch an event.
     *
     * Behavior depends on mode:
     * - SYNC: Immediate dispatch
     * - ASYNC_MEMORY: Queue in memory, process on shutdown
     * - ASYNC_FILE: Write to file queue
     * - ASYNC_REDIS: Push to Redis queue
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []) : void
    {
        match ($this->mode) {
            self::MODE_SYNC         => $this->dispatchSync(event: $event, data: $data),
            self::MODE_ASYNC_MEMORY => $this->dispatchAsyncMemory(event: $event, data: $data),
            self::MODE_ASYNC_FILE   => $this->dispatchAsyncFile(event: $event, data: $data),
            self::MODE_ASYNC_REDIS  => $this->dispatchAsyncRedis(event: $event, data: $data),
            default                 => throw new InvalidArgumentException(message: "Invalid mode: {$this->mode}")
        };
    }

    /**
     * Dispatch event synchronously (immediate).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchSync(string $event, array $data) : void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            try {
                $callback($data);
            } catch (Exception $e) {
                error_log(message: "Event listener error [{$event}]: " . $e->getMessage());
            }
        }
    }

    /**
     * Dispatch event asynchronously (memory queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncMemory(string $event, array $data) : void
    {
        // Check queue size limit
        if (count(value: $this->queue) >= $this->maxQueueSize) {
            error_log(message: "Event queue full, dropping event: {$event}");

            return;
        }

        // Add to queue
        $this->queue[] = compact('event', 'data');

        // Register shutdown handler (once)
        if (! $this->shutdownRegistered) {
            register_shutdown_function(callback: [$this, 'processQueue']);
            $this->shutdownRegistered = true;
        }
    }

    /**
     * Dispatch event asynchronously (file queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncFile(string $event, array $data) : void
    {
        $payload = json_encode(value: ['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Append to queue file (atomic)
        file_put_contents(
            filename: $this->queuePath,
            data    : $payload . PHP_EOL,
            flags   : FILE_APPEND | LOCK_EX
        );
    }

    /**
     * Dispatch event asynchronously (Redis queue).
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    private function dispatchAsyncRedis(string $event, array $data) : void
    {
        $payload = json_encode(value: ['event' => $event, 'data' => $data, 'timestamp' => time()]);

        // Push to Redis list
        $this->redis->rPush('session:events', $payload);
    }

    /**
     * Process queued events (called on shutdown).
     *
     * @return void
     */
    public function processQueue() : void
    {
        if (empty($this->queue)) {
            return;
        }

        // Process in batches
        $batches = array_chunk(array: $this->queue, length: $this->batchSize);

        foreach ($batches as $batch) {
            foreach ($batch as $item) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
            }
        }

        // Clear queue
        $this->queue = [];
    }

    /**
     * Process file queue (for background workers).
     *
     * Reads events from file queue and dispatches them.
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processFileQueue(int $limit = 0) : int
    {
        if (! file_exists(filename: $this->queuePath)) {
            return 0;
        }

        $handle = fopen(filename: $this->queuePath, mode: 'r+');
        if (! $handle) {
            return 0;
        }

        // Lock file
        flock(stream: $handle, operation: LOCK_EX);

        $processed = 0;
        $remaining = [];

        while (($line = fgets(stream: $handle)) !== false) {
            if ($limit > 0 && $processed >= $limit) {
                $remaining[] = $line;
                continue;
            }

            $item = json_decode(json: trim(string: $line), associative: true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
                $processed++;
            }
        }

        // Rewrite file with remaining events
        ftruncate(stream: $handle, size: 0);
        rewind(stream: $handle);
        foreach ($remaining as $line) {
            fwrite(stream: $handle, data: $line);
        }

        flock(stream: $handle, operation: LOCK_UN);
        fclose(stream: $handle);

        return $processed;
    }

    /**
     * Process Redis queue (for background workers).
     *
     * @param int $limit Maximum events to process (0 = all).
     *
     * @return int Number of events processed.
     */
    public function processRedisQueue(int $limit = 0) : int
    {
        $processed = 0;

        while ($limit === 0 || $processed < $limit) {
            $payload = $this->redis->lPop('session:events');
            if (! $payload) {
                break;
            }

            $item = json_decode(json: $payload, associative: true);
            if ($item && isset($item['event'], $item['data'])) {
                $this->dispatchSync(event: $item['event'], data: $item['data']);
                $processed++;
            }
        }

        return $processed;
    }

    /**
     * Get queue size.
     *
     * @return int Number of queued events.
     */
    public function getQueueSize() : int
    {
        return match ($this->mode) {
            self::MODE_ASYNC_MEMORY => count(value: $this->queue),
            self::MODE_ASYNC_FILE   => $this->getFileQueueSize(),
            self::MODE_ASYNC_REDIS  => $this->getRedisQueueSize(),
            default                 => 0
        };
    }

    /**
     * Get file queue size.
     *
     * @return int Number of lines in queue file.
     */
    private function getFileQueueSize() : int
    {
        if (! file_exists(filename: $this->queuePath)) {
            return 0;
        }

        return count(value: file(filename: $this->queuePath));
    }

    /**
     * Get Redis queue size.
     *
     * @return int Number of items in Redis list.
     */
    private function getRedisQueueSize() : int
    {
        return $this->redis->lLen('session:events');
    }

    /**
     * Set maximum queue size.
     *
     * @param int $size Maximum size.
     *
     * @return self Fluent interface.
     */
    public function setMaxQueueSize(int $size) : self
    {
        $this->maxQueueSize = $size;

        return $this;
    }

    /**
     * Set batch size for processing.
     *
     * @param int $size Batch size.
     *
     * @return self Fluent interface.
     */
    public function setBatchSize(int $size) : self
    {
        $this->batchSize = $size;

        return $this;
    }

    /**
     * Get current mode.
     *
     * @return string Mode.
     */
    public function getMode() : string
    {
        return $this->mode;
    }

    /**
     * Clear all listeners.
     *
     * @return self Fluent interface.
     */
    public function clearListeners() : self
    {
        $this->listeners = [];

        return $this;
    }

    /**
     * Clear queue.
     *
     * @return self Fluent interface.
     */
    public function clearQueue() : self
    {
        $this->queue = [];

        return $this;
    }
}

=== Events/Events.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Events;

use Avax\HTTP\Session\Shared\Contracts\FeatureInterface;

/**
 * Events - Simple Event Dispatcher
 *
 * Provides basic pub/sub functionality for session events.
 *
 * Events:
 * - stored: When a value is stored
 * - retrieved: When a value is retrieved
 * - deleted: When a value is deleted
 * - flushed: When session is flushed
 *
 * @example
 *   $events->listen('stored', function($data) {
 *       logger()->info('Value stored', $data);
 *   });
 *
 *   // One-time listener
 *   $events->once('stored', function($data) {
 *       metrics()->increment('session.first_write');
 *   });
 *
 * @package Avax\HTTP\Session
 */
final class Events implements FeatureInterface
{
    /**
     * @var array<string, array<callable>> Event listeners
     */
    private array $listeners = [];

    /**
     * @var bool Feature enabled state
     */
    private bool $enabled = true;

    /**
     * Register a one-time event listener.
     *
     * Listener will be automatically removed after first dispatch.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function once(string $event, callable $callback): void
    {
        $wrapper = function ($data) use ($callback, $event, &$wrapper) {
            $callback($data);
            $this->removeListener($event, $wrapper);
        };

        $this->listen($event, $wrapper);
    }

    /**
     * Remove an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback to remove.
     *
     * @return void
     */
    public function removeListener(string $event, callable $callback): void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        $this->listeners[$event] = array_filter(
            $this->listeners[$event],
            fn($listener) => $listener !== $callback
        );
    }

    /**
     * Register an event listener.
     *
     * @param string   $event    The event name.
     * @param callable $callback The callback.
     *
     * @return void
     */
    public function listen(string $event, callable $callback): void
    {
        $this->listeners[$event][] = $callback;
    }

    /**
     * Dispatch an event to all registered listeners.
     *
     * @param string               $event The event name.
     * @param array<string, mixed> $data  Event data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []): void
    {
        if (! isset($this->listeners[$event])) {
            return;
        }

        foreach ($this->listeners[$event] as $callback) {
            $callback($data);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function boot(): void
    {
        // Events are ready on construction
        $this->enabled = true;
    }

    /**
     * {@inheritdoc}
     */
    public function terminate(): void
    {
        // Clear all listeners on termination
        $this->listeners = [];
        $this->enabled   = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getName(): string
    {
        return 'events';
    }

    /**
     * {@inheritdoc}
     */
    public function isEnabled(): bool
    {
        return $this->enabled;
    }
}

=== Events/EventsManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Events;

/**
 * ðŸ§  EventsManager - Session Events Operations Orchestrator
 * ============================================================
 *
 * The EventsManager orchestrates all event-driven operations within
 * the session system, providing pub/sub functionality for reactive
 * programming and integration with external systems.
 *
 * This manager provides:
 * - Event listener registration (persistent and one-time)
 * - Synchronous event dispatching
 * - Asynchronous event dispatching (if configured)
 * - Listener lifecycle management
 *
 * ðŸ’¡ Design Philosophy:
 * Events enable reactive session architecture where external systems
 * can respond to session changes in real-time. This manager ensures
 * clean separation between event producers and consumers.
 *
 * Common Events:
 * - session.stored: When a value is stored
 * - session.retrieved: When a value is retrieved
 * - session.deleted: When a value is deleted
 * - session.flushed: When session is cleared
 * - session.login: When user logs in
 * - session.terminated: When session ends
 * - session.transaction.commit: When transaction commits
 * - session.transaction.rollback: When transaction rolls back
 *
 * @package Avax\HTTP\Session\Events
 * @author  Milos
 * @version 5.0
 */
final readonly class EventsManager
{
    /**
     * EventsManager Constructor.
     *
     * @param Events                    $events          The synchronous event dispatcher.
     * @param AsyncEventDispatcher|null $asyncDispatcher Optional async event dispatcher.
     */
    public function __construct(
        private Events                    $events,
        private AsyncEventDispatcher|null $asyncDispatcher = null
    ) {}

    // ----------------------------------------------------------------
    // ðŸ”¹ Event Listener Registration
    // ----------------------------------------------------------------

    /**
     * Register a persistent event listener.
     *
     * The listener will be called every time the event is dispatched.
     *
     * @param string   $event    Event name to listen for.
     * @param callable $callback Function to execute when event fires.
     *
     * @return void
     *
     * @example
     * ```php
     * $events->listen('session.stored', function($data) {
     *     logger()->info('Session updated', $data);
     * });
     * ```
     */
    public function listen(string $event, callable $callback) : void
    {
        $this->events->listen($event, $callback);
    }

    /**
     * Register a one-time event listener.
     *
     * The listener will be called only once, then automatically removed.
     *
     * @param string   $event    Event name to listen for.
     * @param callable $callback Function to execute when event fires.
     *
     * @return void
     *
     * @example
     * ```php
     * $events->once('session.login', function($data) {
     *     metrics()->increment('first_login');
     * });
     * ```
     */
    public function once(string $event, callable $callback) : void
    {
        $this->events->once($event, $callback);
    }

    /**
     * Remove a specific event listener.
     *
     * @param string   $event    Event name.
     * @param callable $callback The callback to remove.
     *
     * @return void
     */
    public function removeListener(string $event, callable $callback) : void
    {
        $this->events->removeListener($event, $callback);
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Event Dispatching
    // ----------------------------------------------------------------

    /**
     * Dispatch an event asynchronously.
     *
     * Listeners will be executed in the background if async dispatcher
     * is configured. Falls back to synchronous dispatch otherwise.
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event payload data.
     *
     * @return void
     */
    public function dispatchAsync(string $event, array $data = []) : void
    {
        if ($this->asyncDispatcher !== null) {
            $this->asyncDispatcher->dispatch($event, $data);
        } else {
            // Fallback to synchronous dispatch
            $this->events->dispatch($event, $data);
        }
    }

    /**
     * Dispatch an event synchronously.
     *
     * All registered listeners will be called immediately in sequence.
     *
     * @param string               $event Event name.
     * @param array<string, mixed> $data  Event payload data.
     *
     * @return void
     */
    public function dispatch(string $event, array $data = []) : void
    {
        $this->events->dispatch($event, $data);
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Lifecycle Management
    // ----------------------------------------------------------------

    /**
     * Enable event dispatching.
     *
     * Activates the event system.
     *
     * @return void
     */
    public function enable() : void
    {
        $this->events->boot();
    }

    /**
     * Disable event dispatching.
     *
     * Stops event processing and clears all listeners.
     *
     * @return void
     */
    public function disable() : void
    {
        $this->events->terminate();
    }

    /**
     * Check if event system is enabled.
     *
     * @return bool True if enabled, false otherwise.
     */
    public function isEnabled() : bool
    {
        return $this->events->isEnabled();
    }

    /**
     * Get the feature name.
     *
     * @return string The events feature identifier.
     */
    public function getName() : string
    {
        return $this->events->getName();
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Internal Access
    // ----------------------------------------------------------------

    /**
     * Get the underlying Events instance.
     *
     * Provides direct access to the event dispatcher for advanced operations.
     *
     * @return Events The events instance.
     */
    public function events() : Events
    {
        return $this->events;
    }

    /**
     * Get the async event dispatcher if configured.
     *
     * @return AsyncEventDispatcher|null The async dispatcher or null.
     */
    public function asyncDispatcher() : AsyncEventDispatcher|null
    {
        return $this->asyncDispatcher;
    }
}

=== Recovery/Recovery.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Recovery;

use Avax\HTTP\Session\Audit\Audit;
use Avax\HTTP\Session\Shared\Contracts\Storage\StoreInterface;
use Avax\HTTP\Session\Shared\Exceptions\RecoveryException;
use Avax\HTTP\Session\Shared\Serialization\Serializer;
use Throwable;

/**
 * ðŸ§  Recovery - Session Recovery Manager (Enhanced)
 *
 * Adds enterprise-friendly method aliases for integration with
 * SessionEngine: snapshot(), beginTransaction(), commit(), rollback().
 *
 * Backups are stored in memory only and scoped to the current PHP
 * process/request. This is intended as a short-lived safety net for
 * snapshots and transactions, not a durable, cross-process backup.
 *
 * This version remains backward-compatible with backup()/transaction().
 */
final class Recovery
{
    private const string DEFAULT_BACKUP = 'default';

    /**
     * @var array<string, array> Backup storage
     */
    private array $backups = [];

    /**
     * @var bool Transaction state
     */
    private bool $inTransaction = false;

    /**
     * @var string|null Current transaction backup name
     */
    private string|null $currentTransaction = null;

    public function __construct(
        private readonly StoreInterface $store,
        private readonly Audit|null     $audit = null
    ) {}

    // -----------------------------------------------------------------
    // ðŸ§± Compatibility Layer (for SessionEngine)
    // -----------------------------------------------------------------

    /**
     * Create a snapshot of the current session state.
     *
     * Alias for backup() with a default logical name.
     */
    public function snapshot(string $name = self::DEFAULT_BACKUP) : void
    {
        $this->backup(name: $name);
    }

    /**
     * Create an in-memory backup of the entire session store.
     *
     * @param string $name Logical backup identifier within this process.
     */
    public function backup(string $name = self::DEFAULT_BACKUP) : void
    {
        $data = $this->store->all();

        $this->backups[$name] = [
            'data'      => $data,
            'timestamp' => time(),
            'hash'      => hash(algo: 'sha256', data: serialize(value: $data)),
        ];
    }

    /**
     * Start a transactional backup (atomic session operation).
     */
    public function beginTransaction() : void
    {
        if ($this->inTransaction) {
            throw RecoveryException::transactionAlreadyStarted();
        }

        $this->currentTransaction = 'tx_' . uniqid();
        $this->backup(name: $this->currentTransaction);
        $this->inTransaction = true;
    }

    /**
     * Commit a transaction (finalize and remove backup).
     *
     * @throws RecoveryException If there is no active transaction or
     *                           internal transaction state is invalid.
     */
    public function commit() : void
    {
        if (! $this->inTransaction) {
            throw RecoveryException::noActiveTransaction(operation: 'commit');
        }
        if ($this->currentTransaction === null) {
            throw RecoveryException::invalidTransactionState();
        }

        $backupName = $this->currentTransaction;
        $this->deleteBackup(name: $backupName);
        $this->currentTransaction = null;
        $this->inTransaction      = false;

        $this->audit?->record(
            event: 'transaction_committed',
            data : [
                'backup'    => $backupName,
                'timestamp' => time(),
            ]);
    }

    // -----------------------------------------------------------------
    // ðŸ”¹ Original API
    // -----------------------------------------------------------------

    /**
     * Delete a named in-memory backup.
     */
    public function deleteBackup(string $name = self::DEFAULT_BACKUP) : bool
    {
        if (! isset($this->backups[$name])) {
            return false;
        }

        unset($this->backups[$name]);

        return true;
    }

    /**
     * Rollback current transaction to last snapshot.
     *
     * @throws RecoveryException If there is no active transaction or
     *                           internal transaction state is invalid.
     */
    public function rollback() : void
    {
        if (! $this->inTransaction) {
            throw RecoveryException::noActiveTransaction(operation: 'rollback');
        }
        if ($this->currentTransaction === null) {
            throw RecoveryException::invalidTransactionState();
        }

        $backupName = $this->currentTransaction;
        $this->restore(name: $backupName);
        $this->deleteBackup(name: $backupName);
        $this->currentTransaction = null;
        $this->inTransaction      = false;

        if ($this->audit !== null) {
            $this->audit->record(event: 'transaction_rollback', data: [
                'backup'    => $backupName,
                'timestamp' => time(),
                'reason'    => 'rollback',
            ]);
        }
    }

    /**
     * Restore session state from a named in-memory backup.
     *
     * @throws RecoveryException If backup integrity check fails.
     */
    public function restore(string $name = self::DEFAULT_BACKUP) : bool
    {
        if (! isset($this->backups[$name])) {
            return false;
        }

        $backup = $this->backups[$name];

        // Optional integrity check to detect accidental or malicious changes
        if (isset($backup['hash'])) {
            $expected = $backup['hash'];
            $current  = hash(algo: 'sha256', data: serialize(value: $backup['data']));

            if (! hash_equals(known_string: $expected, user_string: $current)) {
                throw RecoveryException::integrityCheckFailed(name: $name);
            }
        }

        $this->store->flush();

        foreach ($backup['data'] as $key => $value) {
            $this->store->put(key: $key, value: $value);
        }

        return true;
    }

    /**
     * Check whether a named backup exists.
     */
    public function hasBackup(string $name = self::DEFAULT_BACKUP) : bool
    {
        return isset($this->backups[$name]);
    }

    /**
     * List all logical backup identifiers currently held in memory.
     *
     * @return array<int, string>
     */
    public function listBackups() : array
    {
        return array_keys(array: $this->backups);
    }

    /**
     * Get metadata about a named backup (age, size, timestamp).
     */
    public function getBackupInfo(string $name = self::DEFAULT_BACKUP) : array|null
    {
        if (! isset($this->backups[$name])) {
            return null;
        }

        return [
            'name'      => $name,
            'timestamp' => $this->backups[$name]['timestamp'],
            'size'      => count(value: $this->backups[$name]['data']),
            'age'       => time() - $this->backups[$name]['timestamp'],
        ];
    }

    /**
     * Drop all in-memory backups for this Recovery instance.
     */
    public function clearAllBackups() : void
    {
        $this->backups = [];
    }

    /**
     * Check whether a recovery transaction is currently active.
     *
     * This is a convenience helper for callers that want to branch
     * on state instead of handling RecoveryException from commit()
     * or rollback().
     */
    public function isInTransaction() : bool
    {
        return $this->inTransaction;
    }

    /**
     * Perform an operation with automatic backup and rollback on failure.
     *
     * Keeps the original exception as previous while surfacing a
     * domain-specific RecoveryException to callers.
     *
     * @throws RecoveryException If the wrapped operation fails.
     */
    public function transaction(callable $operation, string $backupName = '') : mixed
    {
        $backupName = $backupName ?: 'transaction_' . uniqid();
        $this->backup(name: $backupName);

        try {
            $result = $operation();
            $this->deleteBackup(name: $backupName);

            if ($this->audit !== null) {
                $this->audit->record(event: 'transaction_committed', data: [
                    'backup'    => $backupName,
                    'timestamp' => time(),
                ]);
            }

            return $result;
        } catch (Throwable $e) {
            $this->restore(name: $backupName);
            $this->deleteBackup(name: $backupName);

            if ($this->audit !== null) {
                $this->audit->record(event: 'transaction_rolled_back', data: [
                    'backup'    => $backupName,
                    'timestamp' => time(),
                    'error'     => $e->getMessage(),
                ]);
            }

            throw RecoveryException::transactionFailed(reason: $e->getMessage());
        }
    }

    /**
     * Export the current session data as a serialized string.
     *
     * Intended for trusted internal tooling (CLI, admin utilities).
     */
    public function export() : string
    {
        return serialize(value: $this->store->all());
    }

    /**
     * Import session data from a serialized snapshot string.
     *
     * Security:
     * - Intended for trusted inputs only (internal tools).
     * - Uses safeUnserialize() to disallow arbitrary object
     *   instantiation during import.
     */
    public function import(string $data) : bool
    {
        try {
            $serializer  = new Serializer();
            $sessionData = $serializer->safeUnserialize(data: $data);

            if (! is_array(value: $sessionData)) {
                return false;
            }

            $this->store->flush();

            foreach ($sessionData as $key => $value) {
                $this->store->put(key: $key, value: $value);
            }

            return true;
        } catch (Throwable) {
            return false;
        }
    }
}

=== Recovery/RecoveryManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Recovery;

use Avax\HTTP\Session\Audit\Audit;
use Throwable;

/**
 * ðŸ§  RecoveryManager - Session Recovery Operations Orchestrator
 * ============================================================
 *
 * The RecoveryManager orchestrates all session recovery operations
 * including snapshots, rollbacks, and transactional execution.
 *
 * This manager provides:
 * - Snapshot creation and restoration
 * - Transactional session operations (begin/commit/rollback)
 * - Backup management (list, delete, info)
 * - Import/export functionality for session state
 *
 * ðŸ’¡ Design Philosophy:
 * Recovery operations are critical for maintaining session integrity.
 * This manager ensures that session state can be safely backed up,
 * restored, and managed transactionally without affecting other domains.
 *
 * @package Avax\HTTP\Session\Recovery
 * @author  Milos
 * @version 5.0
 */
final readonly class RecoveryManager
{
    /**
     * RecoveryManager Constructor.
     *
     * @param Recovery   $recovery The recovery engine.
     * @param Audit|null $audit    Optional audit logger for recovery events.
     */
    public function __construct(
        private Recovery   $recovery,
        private Audit|null $audit = null
    ) {}

    // ----------------------------------------------------------------
    // ðŸ”¹ Snapshot Operations
    // ----------------------------------------------------------------

    /**
     * Create a snapshot of the current session state.
     *
     * Snapshots are in-memory backups that can be restored later.
     * Useful for implementing undo functionality or safe operations.
     *
     * @param string $name Snapshot identifier (default: 'default').
     *
     * @return void
     */
    public function snapshot(string $name = 'default') : void
    {
        $this->recovery->snapshot(name: $name);
        $this->audit?->record(event: 'recovery.snapshot.created', data: compact(var_name: 'name'));
    }

    /**
     * Restore session state from a named snapshot.
     *
     * Replaces current session data with the snapshot contents.
     *
     * @param string $name Snapshot identifier (default: 'default').
     *
     * @return void
     *
     * @throws \Avax\HTTP\Session\Exceptions\RecoveryException If snapshot doesn't exist or is corrupted.
     */
    public function restore(string $name = 'default') : void
    {
        $this->recovery->restore(name: $name);
        $this->audit?->record(event: 'recovery.snapshot.restored', data: compact(var_name: 'name'));
    }

    /**
     * Check if a snapshot exists.
     *
     * @param string $name Snapshot identifier.
     *
     * @return bool True if snapshot exists, false otherwise.
     */
    public function hasBackup(string $name = 'default') : bool
    {
        return $this->recovery->hasBackup(name: $name);
    }

    /**
     * List all available snapshots.
     *
     * Returns an array of snapshot names currently held in memory.
     *
     * @return array<int, string> List of snapshot identifiers.
     */
    public function listBackups() : array
    {
        return $this->recovery->listBackups();
    }

    /**
     * Get metadata about a snapshot.
     *
     * Returns information like creation timestamp, size, etc.
     *
     * @param string $name Snapshot identifier.
     *
     * @return array<string, mixed> Snapshot metadata.
     */
    public function getBackupInfo(string $name = 'default') : array
    {
        return $this->recovery->getBackupInfo(name: $name);
    }

    /**
     * Delete a specific snapshot.
     *
     * @param string $name Snapshot identifier.
     *
     * @return void
     */
    public function deleteBackup(string $name = 'default') : void
    {
        $this->recovery->deleteBackup(name: $name);
        $this->audit?->record(event: 'recovery.snapshot.deleted', data: compact(var_name: 'name'));
    }

    /**
     * Clear all snapshots from memory.
     *
     * Removes all backup data. Use with caution.
     *
     * @return void
     */
    public function clearAllBackups() : void
    {
        $this->recovery->clearAllBackups();
        $this->audit?->record(event: 'recovery.snapshots.cleared');
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Transactional Operations
    // ----------------------------------------------------------------

    /**
     * Check if a transaction is currently active.
     *
     * @return bool True if transaction is active, false otherwise.
     */
    public function isInTransaction() : bool
    {
        return $this->recovery->isInTransaction();
    }

    /**
     * Execute a callback within a transactional context.
     *
     * Automatically begins a transaction, executes the callback,
     * and commits on success or rolls back on failure.
     *
     * @param callable $callback The operation to execute.
     *
     * @return void
     *
     * @throws Throwable Re-throws the original exception after rollback.
     */
    public function transaction(callable $callback) : void
    {
        try {
            $this->beginTransaction();
            $callback($this);
            $this->commit();
        } catch (Throwable $e) {
            $this->rollback();
            $this->audit?->record(
                event: 'recovery.transaction.failed',
                data : [
                    'error' => $e->getMessage(),
                    'trace' => $e->getTraceAsString()
                ]);

            throw $e;
        }
    }

    /**
     * Begin a session transaction.
     *
     * Creates an automatic snapshot that will be used for rollback
     * if the transaction fails.
     *
     * @return void
     */
    public function beginTransaction() : void
    {
        $this->recovery->beginTransaction();
        $this->audit?->record(event: 'recovery.transaction.began');
    }

    /**
     * Commit the current transaction.
     *
     * Finalizes the transaction and removes the automatic snapshot.
     *
     * @return void
     *
     * @throws \Avax\HTTP\Session\Exceptions\RecoveryException If no transaction is active.
     */
    public function commit() : void
    {
        $this->recovery->commit();
        $this->audit?->record(event: 'recovery.transaction.committed');
    }

    /**
     * Rollback the current transaction.
     *
     * Restores session state to the snapshot taken at transaction start.
     *
     * @return void
     *
     * @throws \Avax\HTTP\Session\Exceptions\RecoveryException If no transaction is active.
     */
    public function rollback() : void
    {
        $this->recovery->rollback();
        $this->audit?->record(event: 'recovery.transaction.rolled_back');
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Import/Export Operations
    // ----------------------------------------------------------------

    /**
     * Export current session state as a serialized string.
     *
     * Useful for backup, migration, or debugging purposes.
     *
     * âš ï¸ Security Note: Intended for trusted internal use only.
     *
     * @return string Serialized session data.
     */
    public function export() : string
    {
        $data = $this->recovery->export();
        $this->audit?->record(event: 'recovery.session.exported');

        return $data;
    }

    /**
     * Import session state from a serialized string.
     *
     * Replaces current session data with imported state.
     *
     * âš ï¸ Security Note: Only import data from trusted sources.
     * Uses safe unserialization to prevent object injection attacks.
     *
     * @param string $data Serialized session data.
     *
     * @return void
     */
    public function import(string $data) : void
    {
        $this->recovery->import(data: $data);
        $this->audit?->record(event: 'recovery.session.imported');
    }

    // ----------------------------------------------------------------
    // ðŸ”¹ Internal Access
    // ----------------------------------------------------------------

    /**
     * Get the underlying Recovery instance.
     *
     * Provides direct access to the recovery engine for advanced operations.
     *
     * @return Recovery The recovery instance.
     */
    public function recovery() : Recovery
    {
        return $this->recovery;
    }
}

=== Session.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session;

use Avax\HTTP\Session\Audit\AuditManager;
use Avax\HTTP\Session\Core\CoreManager;
use Avax\HTTP\Session\Core\Lifecycle\SessionScope;
use Avax\HTTP\Session\Events\EventsManager;
use Avax\HTTP\Session\Recovery\RecoveryManager;
use Avax\HTTP\Session\Shared\Security\Policies\PolicyInterface;
use Avax\HTTP\Session\Shared\Security\SessionNonce;
use Avax\HTTP\Session\Shared\Security\SessionRegistry;
use LogicException;
use Throwable;

/**
 * ðŸ§  Session - Unified Enterprise Facade
 * ============================================================
 *
 * The all-in-one orchestrator for Avax's session engine.
 *
 * This class unifies multiple session subsystems into a single,
 * developer-friendly API â€” covering:
 *
 * - **Core Operations**: Secure data storage (encrypted, signed)
 * - **TTL & Namespacing**: Time-to-live and namespace isolation
 * - **Flash Messages**: Temporary session data
 * - **Event Bus**: Integration with event-driven architecture
 * - **Auditing**: PSR-3 compliant logging and compliance tracking
 * - **Recovery**: Snapshots, rollback, and transactional operations
 * - **Multi-Device**: Registry tracking for concurrent sessions
 * - **Security**: Policies, nonce-based replay protection
 *
 * ðŸ’¡ **Architecture**:
 * This facade delegates to four domain managers:
 * - `CoreManager`: Handles all core session operations
 * - `RecoveryManager`: Manages snapshots and transactions
 * - `AuditManager`: Provides audit logging and compliance
 * - `EventsManager`: Coordinates event dispatching
 *
 * Each manager is responsible for its own domain, ensuring clean
 * separation of concerns and modular architecture.
 *
 * @package Avax\HTTP\Session
 * @author  Milos
 * @version 5.0
 */
final readonly class Session
{
    /**
     * Session Constructor.
     *
     * @param CoreManager     $core     Core session operations manager.
     * @param RecoveryManager $recovery Recovery operations manager.
     * @param AuditManager    $audit    Audit logging manager.
     * @param EventsManager   $events   Event dispatching manager.
     */
    public function __construct(
        private CoreManager     $core,
        private RecoveryManager $recovery,
        private AuditManager    $audit,
        private EventsManager   $events
    ) {}

    // ----------------------------------------------------------------
    // ðŸ§± Core Data API
    // ----------------------------------------------------------------

    /**
     * Store a value in the session.
     *
     * Automatically encrypts the value if secure mode is enabled.
     * Triggers audit logging and event dispatching.
     *
     * @param string   $key   The session key.
     * @param mixed    $value The value to store.
     * @param int|null $ttl   Optional time-to-live in seconds.
     *
     * @return void
     */
    public function put(string $key, mixed $value, int|null $ttl = null) : void
    {
        $this->core->put(key: $key, value: $value, ttl: $ttl);
        $this->audit->record(event: 'session.put', data: compact('key'));
        $this->events->dispatch(event: 'session.stored', data: compact('key'));
    }

    /**
     * Retrieve a value from the session.
     *
     * Automatically decrypts the value if it was stored encrypted.
     * Triggers event dispatching for retrieval tracking.
     *
     * @param string $key     The session key.
     * @param mixed  $default Default value if key doesn't exist.
     *
     * @return mixed The session value or default.
     */
    public function get(string $key, mixed $default = null) : mixed
    {
        $value = $this->core->get(key: $key, default: $default);
        $this->events->dispatch(event: 'session.retrieved', data: compact('key'));

        return $value;
    }

    /**
     * Check if a session key exists.
     *
     * @param string $key The session key to check.
     *
     * @return bool True if the key exists, false otherwise.
     */
    public function has(string $key) : bool
    {
        return $this->core->has(key: $key);
    }

    /**
     * Remove a specific key from the session.
     *
     * Triggers audit logging and event dispatching.
     *
     * @param string $key The session key to remove.
     *
     * @return void
     */
    public function forget(string $key) : void
    {
        $this->core->forget(key: $key);
        $this->audit->record(event: 'session.forget', data: compact('key'));
        $this->events->dispatch(event: 'session.deleted', data: compact('key'));
    }

    /**
     * Clear all session data.
     *
     * This operation removes all keys from the session store.
     * Triggers audit logging and event dispatching.
     *
     * @return void
     */
    public function flush() : void
    {
        $this->core->flush();
        $this->audit->record(event: 'session.flush');
        $this->events->dispatch(event: 'session.flushed');
    }

    /**
     * Get a session consumer for a specific context.
     *
     * **Purpose**: Isolate session data by logical domain or feature.
     *
     * **Use Case**: When you need to separate data by business context
     * (e.g., 'cart', 'checkout', 'wizard', 'admin').
     *
     * **Example**:
     * ```php
     * $session->for('cart')->put('items', $items);
     * $session->for('checkout')->put('step', 2);
     * ```
     *
     * **Difference from scope()**:
     * - `for()` is for **flat, context-based** isolation
     * - `scope()` is for **hierarchical, namespace-based** isolation
     *
     * @param string $context The context identifier (e.g., 'cart', 'wizard').
     *
     * @return SessionScope A scoped session consumer.
     */
    public function for(string $context) : SessionScope
    {
        return $this->core->for(context: $context);
    }

    // ----------------------------------------------------------------
    // ðŸ§  Contextual Consumers
    // ----------------------------------------------------------------

    /**
     * Get a session consumer for a specific namespace.
     *
     * **Purpose**: Isolate session data using hierarchical namespaces.
     *
     * **Use Case**: When you need nested, hierarchical data organization
     * (e.g., 'user.preferences', 'app.settings.theme').
     *
     * **Example**:
     * ```php
     * $session->scope('user.preferences')->put('theme', 'dark');
     * $session->scope('app.settings')->put('locale', 'en');
     * ```
     *
     * **Difference from for()**:
     * - `scope()` supports **dot notation** for hierarchical namespaces
     * - `for()` is for **flat contexts** without hierarchy
     *
     * **Note**: Both methods return the same `SessionScope` object.
     * The distinction is semantic and helps with code readability.
     *
     * @param string $namespace The namespace identifier (supports dot notation).
     *
     * @return SessionScope A namespaced session consumer.
     */
    public function scope(string $namespace) : SessionScope
    {
        return $this->core->scope(namespace: $namespace);
    }

    /**
     * Get or compute a session value (lazy evaluation pattern).
     *
     * **How it works:**
     * 1. If the key exists â†’ returns its value immediately
     * 2. If not â†’ executes callback, stores result with optional TTL, returns it
     *
     * **Example:**
     * ```php
     * $user = $session->remember('user_profile', function() {
     *     return Database::query('SELECT * FROM users WHERE id = ?', [123]);
     * }, ttl: 3600); // Cache for 1 hour
     * ```
     *
     * @param string   $key      The session key.
     * @param callable $callback Function to compute the value if missing.
     * @param int|null $ttl      Optional TTL for the computed value.
     *
     * @return mixed The cached or computed value.
     */
    public function remember(string $key, callable $callback, int|null $ttl = null) : mixed
    {
        return $this->core->remember(key: $key, callback: $callback, ttl: $ttl);
    }

    // ----------------------------------------------------------------
    // Security Policy Management
    // ----------------------------------------------------------------

    /**
     * Register a security policy.
     *
     * **IMPORTANT:** Policies cannot be altered at runtime in this architecture.
     * All security policies must be configured via DI in SessionServiceProvider.
     *
     * This method exists for API compatibility but will throw an exception.
     *
     * @param PolicyInterface $policy The policy to register.
     *
     * @return self Fluent interface.
     * @throws \LogicException Always throws - policies are immutable.
     */
    public function registerPolicy(PolicyInterface $policy) : self
    {
        throw new LogicException(
            'Session policies cannot be altered at runtime. ' .
            'Configure all security policies via DI in SessionServiceProvider.'
        );
    }

    // ----------------------------------------------------------------
    // âš–ï¸ Policies & Security
    // ----------------------------------------------------------------

    /**
     * Create a snapshot of the current session state.
     *
     * @param string $name Snapshot identifier (default: 'default').
     *
     * @return void
     */
    public function snapshot(string $name = 'default') : void
    {
        $this->recovery->snapshot(name: $name);
    }

    // ----------------------------------------------------------------
    // ðŸ’¾ Recovery API
    // ----------------------------------------------------------------

    /**
     * Restore session state from a named snapshot.
     *
     * @param string $name Snapshot identifier (default: 'default').
     *
     * @return void
     */
    public function restore(string $name = 'default') : void
    {
        $this->recovery->restore(name: $name);
    }

    /**
     * Execute a callback within a transactional context.
     *
     * Automatically begins a transaction, executes the callback,
     * and commits on success or rolls back on failure.
     *
     * @param callable $callback The operation to execute.
     *
     * @return void
     *
     * @throws Throwable Re-throws the original exception after rollback.
     */
    public function transaction(callable $callback) : void
    {
        $this->recovery->transaction(callback: function () use ($callback) {
            $callback($this);
        });
    }

    /**
     * Regenerate the session ID.
     *
     * Critical security operation to prevent session fixation attacks.
     * Should be called on login, privilege elevation, etc.
     *
     * @return void
     * @throws \Random\RandomException
     */
    public function regenerate() : void
    {
        $this->core->regenerate();
        $this->audit->record(event: 'session.regenerated');
    }

    // ----------------------------------------------------------------
    // âš™ï¸ Session Lifecycle
    // ----------------------------------------------------------------

    /**
     * Perform login operation.
     *
     * Stores user authentication data and regenerates session ID.
     *
     * @param string $userId User identifier.
     * @param array  $data   Additional user data to store.
     *
     * @return void
     */
    public function login(string $userId, array $data = []) : void
    {
        $this->core->engine()->login(userId: $userId, data: $data);
        $this->audit->record(event: 'session.login', data: compact('userId'));
        $this->events->dispatch(event: 'session.login', data: compact('userId'));
    }

    /**
     * Terminate the session.
     *
     * Securely destroys the session and clears all data.
     *
     * @param string $reason Termination reason (for audit logs).
     *
     * @return void
     */
    public function terminate(string $reason = 'logout') : void
    {
        $this->core->terminate(reason: $reason);
        $this->audit->record(event: 'session.terminated', data: compact('reason'));
        $this->events->dispatch(event: 'session.terminated', data: compact('reason'));
    }

    /**
     * Get the session registry for multi-device tracking.
     *
     * @return SessionRegistry|null The session registry or null.
     */
    public function getRegistry() : SessionRegistry|null
    {
        return $this->core->engine()->registry();
    }

    // ----------------------------------------------------------------
    // ðŸ” Security Subsystems
    // ----------------------------------------------------------------

    /**
     * Get the session nonce for replay protection.
     *
     * @return SessionNonce|null The session nonce or null.
     */
    public function nonce() : SessionNonce|null
    {
        return $this->core->engine()->nonce();
    }

    /**
     * Access the Core domain manager.
     *
     * Provides direct access to core session operations.
     *
     * @return CoreManager The core manager instance.
     */
    public function core() : CoreManager
    {
        return $this->core;
    }

    // ----------------------------------------------------------------
    // ðŸª„ Fluent Domain Accessors
    // ----------------------------------------------------------------

    /**
     * Access the Recovery domain manager.
     *
     * Provides direct access to recovery operations.
     *
     * @return RecoveryManager The recovery manager instance.
     */
    public function recovery() : RecoveryManager
    {
        return $this->recovery;
    }

    /**
     * Access the Audit domain manager.
     *
     * Provides direct access to audit logging.
     *
     * @return AuditManager The audit manager instance.
     */
    public function audit() : AuditManager
    {
        return $this->audit;
    }

    /**
     * Access the Events domain manager.
     *
     * Provides direct access to event dispatching.
     *
     * @return EventsManager The events manager instance.
     */
    public function events() : EventsManager
    {
        return $this->events;
    }

    /**
     * Get session statistics and diagnostics.
     *
     * @return array<string, mixed> Session statistics.
     */
    public function stats() : array
    {
        return [
            'total_keys'     => count($this->all()),
            'audit_enabled'  => $this->audit->isEnabled(),
            'events_enabled' => $this->events->isEnabled(),
        ];
    }

    // ----------------------------------------------------------------
    // ðŸ©º Diagnostics
    // ----------------------------------------------------------------

    /**
     * Retrieve all session data.
     *
     * @return array<string, mixed> All session data.
     */
    public function all() : array
    {
        return $this->core->all();
    }
}

=== Shared/Contracts/FeatureInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts;

/**
 * FeatureInterface - Session Feature Lifecycle Contract
 *
 * Defines lifecycle hooks for session features.
 * Enables automatic initialization and cleanup.
 *
 * Features implement this interface to:
 * - Initialize on session start (boot)
 * - Cleanup on session end (terminate)
 * - Declare feature name for debugging
 *
 * @package Avax\HTTP\Session\Contracts
 */
interface FeatureInterface
{
    /**
     * Boot the feature.
     *
     * Called when session starts or feature is first accessed.
     * Use for initialization logic.
     *
     * @return void
     */
    public function boot() : void;

    /**
     * Terminate the feature.
     *
     * Called when session terminates or is destroyed.
     * Use for cleanup logic (flush logs, save state, etc).
     *
     * @return void
     */
    public function terminate() : void;

    /**
     * Get feature name.
     *
     * @return string Feature identifier.
     */
    public function getName() : string;

    /**
     * Check if feature is enabled.
     *
     * @return bool True if feature is active.
     */
    public function isEnabled() : bool;
}

=== Shared/Contracts/Security/Encrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts\Security;

/**
 * Encrypter - Encryption Contract
 *
 * Defines the contract for session value encryption/decryption.
 * Enables flexible crypto implementations (OpenSSL, Sodium, etc.).
 *
 * @example
 *   $encrypted = $encrypter->encrypt('sensitive-data');
 *   $decrypted = $encrypter->decrypt($encrypted);
 *
 * @package Avax\HTTP\Session\Contracts
 */
interface Encrypter
{
    /**
     * Encrypt a value.
     *
     * @param mixed $value The value to encrypt.
     *
     * @return string The encrypted value.
     */
    public function encrypt(mixed $value) : string;

    /**
     * Decrypt a value.
     *
     * @param string $encrypted The encrypted value.
     *
     * @return mixed The decrypted value.
     * @throws \RuntimeException If decryption fails.
     */
    public function decrypt(string $encrypted) : mixed;
}

=== Shared/Contracts/Security/SessionIdProviderInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts\Security;

/**
 * SessionIdProviderInterface
 *
 * Contract for session ID generation and management.
 *
 * Implementations:
 * - NativeSessionIdProvider: Uses PHP's native session functions
 * - CustomSessionIdProvider: Custom session ID management
 *
 * @package Avax\HTTP\Session\Shared\Contracts\Security
 */
interface SessionIdProviderInterface
{
    /**
     * Generate a new session ID.
     *
     * @return string The generated session ID.
     */
    public function generate(): string;

    /**
     * Regenerate the current session ID.
     *
     * This is critical for preventing session fixation attacks.
     * Should be called on login, privilege elevation, etc.
     *
     * @param bool $deleteOld Whether to delete the old session data.
     *
     * @return string The new session ID.
     */
    public function regenerate(bool $deleteOld = true): string;

    /**
     * Get the current session ID.
     *
     * @return string The current session ID.
     */
    public function current(): string;

    /**
     * Set a custom session ID.
     *
     * @param string $id The session ID to set.
     *
     * @return void
     */
    public function set(string $id): void;

    /**
     * Check if a session is active.
     *
     * @return bool True if session is active.
     */
    public function isActive(): bool;
}

=== Shared/Contracts/SessionContract.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts;

use Avax\HTTP\Session\Events\Events;
use Avax\HTTP\Session\Features\Flash;
use Avax\HTTP\Session\Providers\SessionConsumer;

/**
 * SessionContract - Formal API Contract
 *
 * Defines the public API for session management.
 *
 * Purpose:
 * - API stability for testing and DI
 * - Clear contract for implementations
 * - Documentation of public interface
 *
 * Note: This is a formal contract, not used internally.
 * SessionManager implements this implicitly.
 *
 * @package Avax\HTTP\Session
 */
interface SessionContract
{
    /**
     * Store a value.
     *
     * @param string   $key   The key.
     * @param mixed    $value The value.
     * @param int|null $ttl   Optional TTL.
     *
     * @return void
     */
    public function put(string $key, mixed $value, int|null $ttl = null): void;

    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed
     */
    public function get(string $key, mixed $default = null): mixed;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool
     */
    public function has(string $key): bool;

    /**
     * Remove a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function forget(string $key): void;

    /**
     * Get all data.
     *
     * @return array<string, mixed>
     */
    public function all(): array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush(): void;

    /**
     * Create scoped session.
     *
     * @param string $namespace The namespace.
     *
     * @return SessionConsumer Scoped consumer.
     */
    public function scope(string $namespace): SessionConsumer;

    /**
     * Access flash messages.
     *
     * @return \Avax\HTTP\Session\Features\Flash Flash instance.
     */
    public function flash(): Flash;

    /**
     * Access events.
     *
     * @return \Avax\HTTP\Session\Features\Events Events instance.
     */
    public function events(): Events;
}

=== Shared/Contracts/SessionInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts;

use Avax\HTTP\Session\Events\Events;
use Avax\HTTP\Session\Features\Flash;

/**
 * SessionInterface
 *
 * Unified contract for the refactored session component.
 * Provides a small, expressive API used across HTTP, Auth and Security layers.
 */
interface SessionInterface
{
    public function put(string $key, mixed $value, int|null $ttl = null): void;

    /**
     * Alias for put().
     */
    public function set(string $key, mixed $value, int|null $ttl = null): void;

    public function get(string $key, mixed $default = null): mixed;

    public function has(string $key): bool;

    public function forget(string $key): void;

    /**
     * Alias for forget().
     */
    public function delete(string $key): void;

    /**
     * Alias for forget().
     */
    public function remove(string $key): void;

    public function all(): array;

    public function flush(): void;

    /**
     * Start the underlying session mechanism (idempotent).
     */
    public function start(): bool;

    public function regenerateId(bool $deleteOldSession = true): void;

    public function getId(): string;

    public function login(string $userId): void;

    public function terminate(string $reason = 'logout'): void;

    public function remember(string $key, callable $callback, int|null $ttl = null): mixed;

    public function flash(): Flash;

    public function events(): Events;
}

=== Shared/Contracts/Storage/StoreInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Contracts\Storage;

/**
 * StoreInterface - Storage Abstraction
 *
 * Minimal contract for session persistence.
 *
 * Implementations:
 * - FileStore: File-based storage
 * - NativeStore: PHP native sessions
 * - ArrayStore: In-memory (for testing)
 * - RedisStore: Redis backend
 * - DatabaseStore: Database backend
 *
 * @package Avax\HTTP\Session
 */
interface StoreInterface
{
    /**
     * Retrieve a value.
     *
     * @param string $key     The key.
     * @param mixed  $default Default value.
     *
     * @return mixed The value or default.
     */
    public function get(string $key, mixed $default = null): mixed;

    /**
     * Store a value with optional TTL.
     *
     * @param string   $key   The key.
     * @param mixed    $value The value.
     * @param int|null $ttl   Time-to-live in seconds (null = never expires).
     *
     * @return void
     */
    public function put(string $key, mixed $value, ?int $ttl = null): void;

    /**
     * Check if key exists.
     *
     * @param string $key The key.
     *
     * @return bool True if exists.
     */
    public function has(string $key): bool;

    /**
     * Delete a value.
     *
     * @param string $key The key.
     *
     * @return void
     */
    public function delete(string $key): void;

    /**
     * Get all data.
     *
     * @return array<string, mixed> All data.
     */
    public function all(): array;

    /**
     * Clear all data.
     *
     * @return void
     */
    public function flush(): void;

    /**
     * Flush all keys matching a namespace prefix.
     *
     * Example: flushNamespace('cart') deletes 'cart.items', 'cart.total', etc.
     *
     * @param string $prefix The namespace prefix.
     *
     * @return void
     */
    public function flushNamespace(string $prefix): void;
}

=== Shared/Exceptions/EncryptionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Exceptions;

use RuntimeException;

/**
 * EncryptionException
 *
 * Thrown when encryption or decryption fails.
 */
final class EncryptionException extends RuntimeException {}

=== Shared/Exceptions/RecoveryException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Exceptions;

/**
 * RecoveryException - Session Recovery Errors
 *
 * Specialized exception type for all failures originating from the
 * Recovery subsystem (snapshots, transactions, integrity checks).
 *
 * This allows callers and higher-level components (SessionEngine,
 * admin tooling, observability pipeline) to distinguish recovery
 * errors from generic runtime problems.
 */
final class RecoveryException extends SessionException
{
    public static function transactionAlreadyStarted() : self
    {
        return new self(message: 'Recovery transaction already started.');
    }

    public static function noActiveTransaction(string $operation) : self
    {
        return new self(message: "No active recovery transaction to {$operation}.");
    }

    public static function invalidTransactionState() : self
    {
        return new self(message: 'Recovery transaction state is invalid.');
    }

    public static function integrityCheckFailed(string $name) : self
    {
        return new self(message: "Recovery backup integrity check failed for '{$name}'.");
    }

    public static function transactionFailed(string $reason) : self
    {
        return new self(message: 'Recovery transaction failed: ' . $reason);
    }
}

=== Shared/Exceptions/SerializationException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Exceptions;

use RuntimeException;
use Throwable;

/**
 * SerializationException
 *
 * Thrown when serialization or deserialization operations fail.
 *
 * @package Avax\HTTP\Session\Shared\Exceptions
 */
final class SerializationException extends RuntimeException
{
    /**
     * Create exception for serialization failure.
     *
     * @param string         $reason   Reason for failure.
     * @param Throwable|null $previous Previous exception.
     *
     * @return self
     */
    public static function serializationFailed(string $reason, ?Throwable $previous = null): self
    {
        return new self(
            message: "Serialization failed: {$reason}",
            code: 0,
            previous: $previous
        );
    }

    /**
     * Create exception for deserialization failure.
     *
     * @param string         $reason   Reason for failure.
     * @param Throwable|null $previous Previous exception.
     *
     * @return self
     */
    public static function deserializationFailed(string $reason, ?Throwable $previous = null): self
    {
        return new self(
            message: "Deserialization failed: {$reason}",
            code: 0,
            previous: $previous
        );
    }

    /**
     * Create exception for compression failure.
     *
     * @return self
     */
    public static function compressionFailed(): self
    {
        return new self('Data compression failed');
    }

    /**
     * Create exception for decompression failure.
     *
     * @return self
     */
    public static function decompressionFailed(): self
    {
        return new self('Data decompression failed');
    }

    /**
     * Create exception for integrity check failure.
     *
     * @return self
     */
    public static function integrityCheckFailed(): self
    {
        return new self('Data integrity check failed - checksum mismatch');
    }

    /**
     * Create exception for invalid format.
     *
     * @param string $reason Reason for invalid format.
     *
     * @return self
     */
    public static function invalidFormat(string $reason): self
    {
        return new self("Invalid data format: {$reason}");
    }

    /**
     * Create exception for JSON encoding failure.
     *
     * @param string         $reason   Reason for failure.
     * @param Throwable|null $previous Previous exception.
     *
     * @return self
     */
    public static function jsonEncodeFailed(string $reason, ?Throwable $previous = null): self
    {
        return new self(
            message: "JSON encoding failed: {$reason}",
            code: 0,
            previous: $previous
        );
    }

    /**
     * Create exception for JSON decoding failure.
     *
     * @param string         $reason   Reason for failure.
     * @param Throwable|null $previous Previous exception.
     *
     * @return self
     */
    public static function jsonDecodeFailed(string $reason, ?Throwable $previous = null): self
    {
        return new self(
            message: "JSON decoding failed: {$reason}",
            code: 0,
            previous: $previous
        );
    }
}

=== Shared/Exceptions/SessionException.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Exceptions;

use RuntimeException;

/**
 * SessionException - Base Exception
 *
 * Base exception for all session-related errors.
 *
 * @package Avax\HTTP\Session\Exceptions
 */
class SessionException extends RuntimeException {}

=== Shared/Security/CookieManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use InvalidArgumentException;

/**
 * CookieManager - Centralized Cookie Policy Enforcement
 *
 * OWASP ASVS 3.4.1 Compliant
 *
 * Enforces secure cookie attributes (Secure, HttpOnly, SameSite).
 * Prevents common cookie-based attacks:
 * - XSS (via HttpOnly)
 * - Man-in-the-middle (via Secure)
 * - CSRF (via SameSite)
 *
 * @package Avax\HTTP\Session\Security
 */
final readonly class CookieManager
{
    /**
     * CookieManager Constructor.
     *
     * @param bool   $secure   Require HTTPS (default: true).
     * @param bool   $httpOnly Prevent JavaScript access (default: true).
     * @param string $sameSite SameSite policy: 'Lax', 'Strict', 'None' (default: 'Lax').
     * @param string $path     Cookie path (default: '/').
     * @param string $domain   Cookie domain (default: '').
     * @param int    $lifetime Cookie lifetime in seconds (default: 0 = session).
     */
    public function __construct(
        private bool   $secure = true,
        private bool   $httpOnly = true,
        private string $sameSite = 'Lax',
        private string $path = '/',
        private string $domain = '',
        private int    $lifetime = 0
    )
    {
        // Validate SameSite
        if (! in_array($sameSite, ['Lax', 'Strict', 'None'], true)) {
            throw new InvalidArgumentException(
                "Invalid SameSite value: {$sameSite}. Must be 'Lax', 'Strict', or 'None'."
            );
        }

        // SameSite=None requires Secure flag
        if ($sameSite === 'None' && ! $secure) {
            throw new InvalidArgumentException(
                'SameSite=None requires Secure flag to be true (HTTPS only).'
            );
        }
    }

    /**
     * Create a strict security configuration.
     *
     * - SameSite=Strict
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function strict() : self
    {
        return new self(
            secure  : true,
            httpOnly: true,
            sameSite: 'Strict'
        );
    }

    /**
     * Create a lax security configuration (default).
     *
     * - SameSite=Lax
     * - Secure=true
     * - HttpOnly=true
     *
     * @return self
     */
    public static function lax() : self
    {
        return new self(
            secure  : true,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Create a development configuration (insecure).
     *
     * - SameSite=Lax
     * - Secure=false
     * - HttpOnly=true
     *
     * @return self
     */
    public static function development() : self
    {
        return new self(
            secure  : false,
            httpOnly: true,
            sameSite: 'Lax'
        );
    }

    /**
     * Set a cookie with enforced security attributes.
     *
     * @param string $name    Cookie name.
     * @param string $value   Cookie value.
     * @param int    $expires Expiration timestamp (0 = session).
     *
     * @return bool True on success.
     */
    public function set(string $name, string $value, int $expires = 0) : bool
    {
        $expires = $expires ?: ($this->lifetime ? time() + $this->lifetime : 0);

        // PHP 7.3+ array format
        return setcookie($name, $value, [
            'expires'  => $expires,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Delete a cookie.
     *
     * Sets expiration to past time to trigger browser deletion.
     *
     * @param string $name Cookie name.
     *
     * @return bool True on success.
     */
    public function delete(string $name) : bool
    {
        return setcookie($name, '', [
            'expires'  => time() - 3600,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get a cookie value.
     *
     * @param string     $name    Cookie name.
     * @param mixed|null $default Default value.
     *
     * @return mixed Cookie value or default.
     */
    public function get(string $name, mixed $default = null) : mixed
    {
        return $_COOKIE[$name] ?? $default;
    }

    /**
     * Check if a cookie exists.
     *
     * @param string $name Cookie name.
     *
     * @return bool True if exists.
     */
    public function has(string $name) : bool
    {
        return isset($_COOKIE[$name]);
    }

    /**
     * Configure session cookie parameters.
     *
     * OWASP ASVS 3.2.2 Compliant
     *
     * Applies security policy to PHP session cookies.
     *
     * @return void
     */
    public function configureSessionCookie() : void
    {
        session_set_cookie_params([
            'lifetime' => $this->lifetime,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'secure'   => $this->secure,
            'httponly' => $this->httpOnly,
            'samesite' => $this->sameSite,
        ]);
    }

    /**
     * Get current cookie configuration.
     *
     * @return array<string, mixed> Configuration array.
     */
    public function getConfig() : array
    {
        return [
            'secure'   => $this->secure,
            'httpOnly' => $this->httpOnly,
            'sameSite' => $this->sameSite,
            'path'     => $this->path,
            'domain'   => $this->domain,
            'lifetime' => $this->lifetime,
        ];
    }

    /**
     * Check if configuration is production-ready.
     *
     * @return bool True if secure configuration.
     */
    public function isSecure() : bool
    {
        return $this->secure && $this->httpOnly && $this->sameSite !== 'None';
    }
}

=== Shared/Security/Crypto/OpenSSLEncrypter.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Crypto;

use Avax\HTTP\Session\Shared\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Shared\Exceptions\EncryptionException;
use RuntimeException;

/**
 * OpenSSLEncrypter
 *
 * Standard AES-256-CBC implementation using PHP's OpenSSL extension.
 */
final class OpenSSLEncrypter implements Encrypter
{
    private const string CIPHER = 'AES-256-CBC';

    public function __construct(
        private readonly string $key
    ) {}

    public function encrypt(mixed $value): string
    {
        $ivLength = openssl_cipher_iv_length(self::CIPHER);
        $iv       = openssl_random_pseudo_bytes($ivLength);

        $serialized = serialize($value);

        $ciphertext = openssl_encrypt(
            data: $serialized,
            cipher_algo: self::CIPHER,
            passphrase: $this->key,
            options: OPENSSL_RAW_DATA,
            iv: $iv
        );

        if ($ciphertext === false) {
            throw new EncryptionException('Encryption failed: OpenSSL error');
        }

        // Return combined IV + Ciphertext (base64 encoded)
        return base64_encode($iv . $ciphertext);
    }

    public function decrypt(string $encrypted): mixed
    {
        $data = base64_decode($encrypted, true);
        if ($data === false) {
            throw new EncryptionException('Decryption failed: Invalid base64 data');
        }

        $ivLength = openssl_cipher_iv_length(self::CIPHER);

        if (strlen($data) < $ivLength) {
            throw new EncryptionException('Decryption failed: Payload too short');
        }

        $iv         = substr($data, 0, $ivLength);
        $ciphertext = substr($data, $ivLength);

        $serialized = openssl_decrypt(
            data: $ciphertext,
            cipher_algo: self::CIPHER,
            passphrase: $this->key,
            options: OPENSSL_RAW_DATA,
            iv: $iv
        );

        if ($serialized === false) {
            throw new EncryptionException('Decryption failed: OpenSSL error');
        }

        // Secure unserialization (allowed classes could be restricted if needed)
        // using allowed_classes: true for now to match broad usage
        return unserialize($serialized);
    }
}

=== Shared/Security/EncrypterFactory.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use Avax\HTTP\Session\Shared\Contracts\Security\Encrypter;
use Avax\HTTP\Session\Shared\Security\Crypto\OpenSSLEncrypter;
use Exception;
use RuntimeException;

/**
 * EncrypterFactory - Encrypter with Key Management
 *
 * OWASP ASVS 3.1.3 Compliant
 *
 * Integrates KeyManager with encryption operations.
 * Supports key rotation by attempting decryption with all known keys.
 *
 * @package Avax\HTTP\Session\Security
 */
final class EncrypterFactory
{
    private KeyManager $keyManager;

    /**
     * EncrypterFactory Constructor.
     *
     * @param KeyManager|null $keyManager Key manager (optional, creates default).
     */
    public function __construct(KeyManager|null $keyManager = null)
    {
        $this->keyManager = $keyManager ?? new KeyManager();
    }

    /**
     * Encrypt with active key.
     *
     * @param mixed $value Value to encrypt.
     *
     * @return string Encrypted payload.
     */
    public function encrypt(mixed $value) : string
    {
        return $this->create()->encrypt(value: $value);
    }

    /**
     * Create encrypter with active key.
     *
     * @return Encrypter Encrypter instance.
     */
    public function create() : Encrypter
    {
        $activeKey = $this->keyManager->getActiveKey();

        return new OpenSSLEncrypter(key: $activeKey);
    }

    /**
     * Decrypt with key rotation support.
     *
     * Attempts decryption with all known keys (active + rotated).
     * Enables seamless key rotation.
     *
     * @param string $payload Encrypted payload.
     *
     * @return mixed Decrypted value.
     *
     * @throws \RuntimeException If decryption fails with all keys.
     */
    public function decrypt(string $payload) : mixed
    {
        $allKeys = $this->keyManager->getAllKeys();

        foreach ($allKeys as $key) {
            try {
                $encrypter = new OpenSSLEncrypter(key: $key);

                return $encrypter->decrypt(payload: $payload);
            } catch (Exception $e) {
                // Try next key
                continue;
            }
        }

        // All keys failed
        throw new RuntimeException(
            message: 'Decryption failed with all known keys - possible tampering or key mismatch'
        );
    }
}

=== Shared/Security/KeyManager.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use RuntimeException;

/**
 * KeyManager - Encryption Key Management
 *
 * Handles key retrieval and rotation support for the session encrypter.
 */
final class KeyManager
{
    /**
     * Retrieve the currently active encryption key.
     *
     * @return string The binary key string.
     * @throws RuntimeException If no valid key is found.
     */
    public function getActiveKey(): string
    {
        // Try specific session key first
        $key = $_ENV['SESSION_ENCRYPTION_KEY'] ?? $_ENV['APP_KEY'] ?? null;

        if (empty($key)) {
            // For development fallback only - explicitly insecure
            return 'insecure-default-key-32-bytes-long!!';
        }

        return (string) $key;
    }

    /**
     * Retrieve all valid keys for decryption (active + rotated).
     *
     * @return array<string> List of keys.
     */
    public function getAllKeys(): array
    {
        $keys = [];
        $active = $this->getActiveKey();
        $keys[] = $active;

        // Support for previous keys (rotation) could be added here
        // e.g. checking $_ENV['SESSION_PREVIOUS_KEYS']

        return $keys;
    }
}

=== Shared/Security/NativeSessionIdProvider.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use Avax\HTTP\Session\Shared\Contracts\Security\SessionIdProviderInterface;

/**
 * NativeSessionIdProvider
 *
 * Uses PHP's native session functions for session ID management.
 *
 * This is the recommended provider for most applications as it:
 * - Integrates with PHP's session handling
 * - Works with session handlers (files, Redis, etc.)
 * - Provides built-in security features
 *
 * @package Avax\HTTP\Session\Shared\Security
 */
final class NativeSessionIdProvider implements SessionIdProviderInterface
{
    /**
     * Generate a new session ID.
     *
     * @return string The generated session ID.
     */
    public function generate(): string
    {
        // Start session if not already started
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        return session_id();
    }

    /**
     * Regenerate the current session ID.
     *
     * Uses PHP's session_regenerate_id() for secure regeneration.
     *
     * @param bool $deleteOld Whether to delete the old session data.
     *
     * @return string The new session ID.
     */
    public function regenerate(bool $deleteOld = true): string
    {
        // Ensure session is started
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        // Regenerate ID
        session_regenerate_id($deleteOld);

        return session_id();
    }

    /**
     * Get the current session ID.
     *
     * @return string The current session ID.
     */
    public function current(): string
    {
        // Start session if needed
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        return session_id();
    }

    /**
     * Set a custom session ID.
     *
     * @param string $id The session ID to set.
     *
     * @return void
     */
    public function set(string $id): void
    {
        // Can only set ID before session starts
        if (session_status() === PHP_SESSION_NONE) {
            session_id($id);
            session_start();
        }
    }

    /**
     * Check if a session is active.
     *
     * @return bool True if session is active.
     */
    public function isActive(): bool
    {
        return session_status() === PHP_SESSION_ACTIVE;
    }
}

=== Shared/Security/Policies/CompositePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use Exception;
use InvalidArgumentException;
use RuntimeException;

/**
 * CompositePolicy - Composite Policy Pattern
 *
 * Combines multiple policies into a single policy.
 * Enables grouping and reusable policy sets.
 *
 * Execution Modes:
 * - ALL: All policies must pass (default, AND logic)
 * - ANY: At least one policy must pass (OR logic)
 * - NONE: All policies must fail (inverse logic)
 *
 * @example
 *   $composite = new CompositePolicy([
 *       new MaxIdlePolicy(900),
 *       new SecureOnlyPolicy(),
 *       new SessionIpPolicy()
 *   ]);
 *
 * @example With ANY mode
 *   $composite = CompositePolicy::any([
 *       new AdminRolePolicy(),
 *       new SuperuserPolicy()
 *   ]);
 *
 * @package Avax\HTTP\Session\Shared\Security\Policies
 */
final class CompositePolicy implements PolicyInterface
{
    public const MODE_ALL  = 'all';
    public const MODE_ANY  = 'any';
    public const MODE_NONE = 'none';

    /**
     * @var array<PolicyInterface> Child policies
     */
    private array $policies = [];

    /**
     * CompositePolicy Constructor.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $mode     Execution mode (all|any|none).
     * @param string                 $name     Policy name.
     */
    public function __construct(
        array          $policies = [],
        private string $mode = self::MODE_ALL,
        private string $name = 'composite'
    )
    {
        foreach ($policies as $policy) {
            $this->add($policy);
        }
    }

    /**
     * Add a child policy.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy) : self
    {
        $this->policies[] = $policy;

        return $this;
    }

    /**
     * Create composite with ALL mode (AND logic).
     *
     * All policies must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function all(array $policies, string $name = 'composite_all') : self
    {
        return new self($policies, self::MODE_ALL, $name);
    }

    /**
     * Create composite with ANY mode (OR logic).
     *
     * At least one policy must pass.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function any(array $policies, string $name = 'composite_any') : self
    {
        return new self($policies, self::MODE_ANY, $name);
    }

    /**
     * Create composite with NONE mode (inverse logic).
     *
     * All policies must fail.
     *
     * @param array<PolicyInterface> $policies Child policies.
     * @param string                 $name     Policy name.
     *
     * @return self
     */
    public static function none(array $policies, string $name = 'composite_none') : self
    {
        return new self($policies, self::MODE_NONE, $name);
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        if (empty($this->policies)) {
            return; // No policies to enforce
        }

        match ($this->mode) {
            self::MODE_ALL  => $this->enforceAll($data),
            self::MODE_ANY  => $this->enforceAny($data),
            self::MODE_NONE => $this->enforceNone($data),
            default         => throw new InvalidArgumentException("Invalid mode: {$this->mode}")
        };
    }

    /**
     * Enforce ALL policies (AND logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy fails.
     */
    private function enforceAll(array $data) : void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);
            } catch (Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        if (! empty($failures)) {
            throw new RuntimeException(
                sprintf(
                    'Composite policy "%s" failed (ALL mode): %s',
                    $this->name,
                    implode('; ', $failures)
                )
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * Enforce ANY policy (OR logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If all policies fail.
     */
    private function enforceAny(array $data) : void
    {
        $failures = [];

        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);

                return; // At least one passed, success!
            } catch (Exception $e) {
                $failures[] = sprintf(
                    '%s: %s',
                    $policy->getName(),
                    $e->getMessage()
                );
            }
        }

        // All policies failed
        throw new RuntimeException(
            sprintf(
                'Composite policy "%s" failed (ANY mode): All child policies failed: %s',
                $this->name,
                implode('; ', $failures)
            )
        );
    }

    /**
     * Enforce NONE policy (inverse logic).
     *
     * @param array<string, mixed> $data Session data.
     *
     * @return void
     * @throws \RuntimeException If any policy passes.
     */
    private function enforceNone(array $data) : void
    {
        foreach ($this->policies as $policy) {
            try {
                $policy->enforce($data);

                // Policy passed, but we wanted it to fail
                throw new RuntimeException(
                    sprintf(
                        'Composite policy "%s" failed (NONE mode): Policy "%s" should have failed but passed',
                        $this->name,
                        $policy->getName()
                    )
                );
            } catch (Exception $e) {
                // Policy failed, which is what we wanted (continue)
                continue;
            }
        }

        // All policies failed, which is what we wanted (success)
    }

    /**
     * Get child policies.
     *
     * @return array<PolicyInterface> Child policies.
     */
    public function getPolicies() : array
    {
        return $this->policies;
    }

    /**
     * Get execution mode.
     *
     * @return string Mode (all|any|none).
     */
    public function getMode() : string
    {
        return $this->mode;
    }

    /**
     * Check if composite is empty.
     *
     * @return bool True if no child policies.
     */
    public function isEmpty() : bool
    {
        return empty($this->policies);
    }

    /**
     * Get number of child policies.
     *
     * @return int Count.
     */
    public function count() : int
    {
        return count($this->policies);
    }
}

=== Shared/Security/Policies/CrossAgentPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use Avax\HTTP\Session\Shared\Contracts\Security\ServerContext;
use Avax\HTTP\Session\Shared\Exceptions\PolicyViolationException;
use Avax\HTTP\Session\Shared\Security\NativeServerContext;

/**
 * CrossAgentPolicy - User Agent Consistency Policy
 *
 * Detects session hijacking by comparing User-Agent strings.
 * If User-Agent changes during session lifetime, policy is violated.
 *
 * Uses ServerContext for testability.
 *
 * @package Avax\HTTP\Session\Shared\Security\Policies
 */
final class CrossAgentPolicy implements PolicyInterface
{
    /**
     * CrossAgentPolicy Constructor.
     *
     * @param ServerContext|null $serverContext Server context (default: native).
     */
    public function __construct(
        private ServerContext|null $serverContext = null
    )
    {
        $this->serverContext ??= new NativeServerContext();
    }

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        $storedAgent  = $data['_user_agent'] ?? null;
        $currentAgent = $this->serverContext->getUserAgent();

        // First time - store current agent
        if ($storedAgent === null) {
            return;
        }

        // Agent mismatch - possible hijacking
        if ($storedAgent !== $currentAgent) {
            throw PolicyViolationException::forPolicy(
                'cross_agent',
                'User Agent mismatch detected - possible session hijacking'
            );
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return 'cross_agent';
    }
}

=== Shared/Security/Policies/MaxIdlePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use RuntimeException;

/**
 * MaxIdlePolicy - Session Idle Timeout Policy
 *
 * Enforces maximum idle time for sessions. If session is inactive
 * longer than the configured period, policy violation is triggered.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class MaxIdlePolicy implements PolicyInterface
{
    /**
     * MaxIdlePolicy Constructor.
     *
     * @param int $maxIdleSeconds Maximum idle time in seconds (default: 30 minutes).
     */
    public function __construct(
        private int $maxIdleSeconds = 1800
    ) {}

    /**
     * Enforce max idle policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session is idle too long.
     */
    public function enforce(array $data) : void
    {
        $lastActivity = $data['_last_activity'] ?? null;

        if ($lastActivity === null) {
            return;
        }

        $idleTime = time() - $lastActivity;

        if ($idleTime > $this->maxIdleSeconds) {
            throw new RuntimeException(
                sprintf(
                    'Session expired due to inactivity. Idle for %d seconds (max: %d).',
                    $idleTime,
                    $this->maxIdleSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'max_idle';
    }
}

=== Shared/Security/Policies/MaxLifetimePolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use RuntimeException;

/**
 * MaxLifetimePolicy - Session Maximum Lifetime Policy
 *
 * Enforces absolute maximum lifetime for sessions regardless of activity.
 * Once session reaches max lifetime, it must be terminated.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class MaxLifetimePolicy implements PolicyInterface
{
    /**
     * MaxLifetimePolicy Constructor.
     *
     * @param int $maxLifetimeSeconds Maximum session lifetime in seconds (default: 1 hour).
     */
    public function __construct(
        private int $maxLifetimeSeconds = 3600
    ) {}

    /**
     * Enforce max lifetime policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If session exceeded max lifetime.
     */
    public function enforce(array $data) : void
    {
        $createdAt = $data['_created_at'] ?? null;

        if ($createdAt === null) {
            return;
        }

        $lifetime = time() - $createdAt;

        if ($lifetime > $this->maxLifetimeSeconds) {
            throw new RuntimeException(
                sprintf(
                    'Session expired (max lifetime). Active for %d seconds (max: %d).',
                    $lifetime,
                    $this->maxLifetimeSeconds
                )
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'max_lifetime';
    }
}

=== Shared/Security/Policies/PolicyGroupBuilder.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use RuntimeException;

/**
 * PolicyGroupBuilder - Fluent Builder for Policy Groups
 *
 * Provides Spring Security-style fluent API for building policy groups.
 * Makes complex policy configurations readable and maintainable.
 *
 * @example Basic usage
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->add(new MaxIdlePolicy(900))
 *           ->add(new SecureOnlyPolicy())
 *       ->build();
 *
 * @example Complex groups
 *   $policies = PolicyGroupBuilder::create()
 *       ->requireAll()
 *           ->maxIdle(900)
 *           ->secureOnly()
 *           ->requireAny()
 *               ->ipBinding()
 *               ->userAgentBinding()
 *           ->endGroup()
 *       ->build();
 *
 * @package Avax\HTTP\Session\Shared\Security\Policies
 */
final class PolicyGroupBuilder
{
    /**
     * @var CompositePolicy|null Root composite policy
     */
    private CompositePolicy|null $root = null;

    /**
     * @var CompositePolicy|null Current working composite
     */
    private CompositePolicy|null $current = null;

    /**
     * @var array<CompositePolicy> Stack for nested groups
     */
    private array $stack = [];

    /**
     * PolicyGroupBuilder Constructor.
     */
    private function __construct()
    {
        // Use create() factory instead
    }

    /**
     * Create a security hardened preset.
     *
     * Includes:
     * - MaxIdle: 15 minutes
     * - MaxLifetime: 8 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Strict
     * - User Agent Binding
     *
     * @return PolicyInterface Built policy.
     */
    public static function securityHardened() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'security_hardened')
            ->maxIdle(seconds: 900)              // 15 minutes
            ->maxLifetime(seconds: 28800)        // 8 hours
            ->secureOnly()
            ->ipBinding()
            ->userAgentBinding()
            ->build();
    }

    /**
     * Build the final policy structure.
     *
     * @return PolicyInterface|CompositePolicy Built policy.
     */
    public function build() : PolicyInterface|CompositePolicy
    {
        if ($this->root === null) {
            throw new RuntimeException(message: 'No policies configured. Use requireAll(), requireAny(), or requireNone() to start.');
        }

        // If only one policy in root, return it directly
        if ($this->root->count() === 1) {
            return $this->root->getPolicies()[0];
        }

        return $this->root;
    }

    /**
     * Add CrossAgentPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function userAgentBinding() : self
    {
        return $this->add(policy: new CrossAgentPolicy());
    }

    /**
     * Add a custom policy to current group.
     *
     * @param PolicyInterface $policy Policy to add.
     *
     * @return self Fluent interface.
     */
    public function add(PolicyInterface $policy) : self
    {
        if ($this->current === null) {
            throw new RuntimeException(message: 'No active group. Call requireAll(), requireAny(), or requireNone() first.');
        }

        $this->current->add(policy: $policy);

        return $this;
    }

    /**
     * Add SessionIpPolicy to current group.
     *
     * @param bool $strict Strict mode (default: true).
     *
     * @return self Fluent interface.
     */
    public function ipBinding(bool $strict = true) : self
    {
        return $this->add(policy: new SessionIpPolicy(strictMode: $strict));
    }

    /**
     * Add SecureOnlyPolicy to current group.
     *
     * @return self Fluent interface.
     */
    public function secureOnly() : self
    {
        return $this->add(policy: new SecureOnlyPolicy());
    }

    /**
     * Add MaxLifetimePolicy to current group.
     *
     * @param int $seconds Maximum lifetime in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxLifetime(int $seconds) : self
    {
        return $this->add(policy: new MaxLifetimePolicy(maxLifetimeSeconds: $seconds));
    }

    /**
     * Add MaxIdlePolicy to current group.
     *
     * @param int $seconds Maximum idle time in seconds.
     *
     * @return self Fluent interface.
     */
    public function maxIdle(int $seconds) : self
    {
        return $this->add(policy: new MaxIdlePolicy(maxIdleSeconds: $seconds));
    }

    /**
     * Start a "require all" group (AND logic).
     *
     * All policies in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAll(string $name = 'require_all') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_ALL, name: $name);
    }

    /**
     * Start a new group.
     *
     * @param string $mode Group mode (all|any|none).
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    private function startGroup(string $mode, string $name) : self
    {
        $composite = new CompositePolicy(policies: [], mode: $mode, name: $name);

        if ($this->root === null) {
            // First group becomes root
            $this->root    = $composite;
            $this->current = $composite;
        } else {
            // Nested group
            if ($this->current === null) {
                throw new RuntimeException(message: 'Current group is null. This should not happen.');
            }

            // Add nested group to current
            $this->current->add(policy: $composite);

            // Push current to stack
            $this->stack[] = $this->current;

            // Make nested group current
            $this->current = $composite;
        }

        return $this;
    }

    /**
     * Create a new builder instance.
     *
     * @return self
     */
    public static function create() : self
    {
        return new self();
    }

    /**
     * Create a balanced security preset.
     *
     * Includes:
     * - MaxIdle: 30 minutes
     * - MaxLifetime: 24 hours
     * - SecureOnly: HTTPS required
     * - IP Binding: Relaxed
     *
     * @return PolicyInterface Built policy.
     */
    public static function balanced() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'balanced')
            ->maxIdle(seconds: 1800)             // 30 minutes
            ->maxLifetime(seconds: 86400)        // 24 hours
            ->secureOnly()
            ->ipBinding(strict: false)
            ->build();
    }

    /**
     * Create a development-friendly preset.
     *
     * Includes:
     * - MaxIdle: 2 hours
     * - MaxLifetime: 7 days
     *
     * @return PolicyInterface Built policy.
     */
    public static function development() : PolicyInterface
    {
        return self::create()
            ->requireAll(name: 'development')
            ->maxIdle(seconds: 7200)             // 2 hours
            ->maxLifetime(seconds: 604800)       // 7 days
            ->build();
    }

    /**
     * Start a "require any" group (OR logic).
     *
     * At least one policy in this group must pass.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireAny(string $name = 'require_any') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_ANY, name: $name);
    }

    /**
     * Start a "require none" group (inverse logic).
     *
     * All policies in this group must fail.
     *
     * @param string $name Group name.
     *
     * @return self Fluent interface.
     */
    public function requireNone(string $name = 'require_none') : self
    {
        return $this->startGroup(mode: CompositePolicy::MODE_NONE, name: $name);
    }

    /**
     * End current group and return to parent.
     *
     * @return self Fluent interface.
     */
    public function endGroup() : self
    {
        if (empty($this->stack)) {
            throw new RuntimeException(message: 'No group to end. Already at root level.');
        }

        $this->current = array_pop(array: $this->stack);

        return $this;
    }

    /**
     * Build and return as array of policies.
     *
     * Useful for bulk registration with PolicyEnforcer.
     *
     * @return array<PolicyInterface> Policies.
     */
    public function buildAsArray() : array
    {
        $policy = $this->build();

        if ($policy instanceof CompositePolicy) {
            return [$policy];
        }

        return [$policy];
    }
}

=== Shared/Security/Policies/PolicyInterface.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

/**
 * PolicyInterface - Session Security Policy Contract
 *
 * Defines the contract for session security policies.
 * Policies are enforced before each session operation.
 *
 * @package Avax\HTTP\Session\Policies
 */
interface PolicyInterface
{
    /**
     * Enforce the policy rules.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If policy is violated.
     */
    public function enforce(array $data) : void;

    /**
     * Get the policy name.
     *
     * @return string The policy identifier.
     */
    public function getName() : string;
}

=== Shared/Security/Policies/SecureOnlyPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use RuntimeException;

/**
 * SecureOnlyPolicy - HTTPS-Only Session Policy
 *
 * Enforces that session operations only occur over HTTPS.
 * Prevents session hijacking over insecure connections.
 *
 * @package Avax\HTTP\Session\Policies
 */
final class SecureOnlyPolicy implements PolicyInterface
{
    /**
     * Enforce HTTPS-only policy.
     *
     * @param array<string, mixed> $data Current session data.
     *
     * @return void
     * @throws \RuntimeException If connection is not HTTPS.
     */
    public function enforce(array $data) : void
    {
        $isSecure = ! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';

        if (! $isSecure) {
            throw new RuntimeException(
                'Session access requires HTTPS connection for security.'
            );
        }
    }

    /**
     * Get policy name.
     *
     * @return string Policy identifier.
     */
    public function getName() : string
    {
        return 'secure_only';
    }
}

=== Shared/Security/Policies/SessionIpPolicy.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security\Policies;

use Avax\HTTP\Session\Shared\Exceptions\PolicyViolationException;

/**
 * SessionIpPolicy - IP Address Binding Policy
 *
 * OWASP ASVS 3.4.1 Compliant
 *
 * Binds sessions to client IP address to detect session hijacking.
 * Supports both strict mode (exact match) and relaxed mode (subnet match).
 *
 * Security Trade-offs:
 * - Strict: More secure, but breaks with mobile networks (IP changes)
 * - Relaxed: Less secure, but handles legitimate IP changes
 *
 * @package Avax\HTTP\Session\Shared\Security\Policies
 */
final class SessionIpPolicy implements PolicyInterface
{
    /**
     * SessionIpPolicy Constructor.
     *
     * @param bool $strictMode If true, require exact IP match. If false, allow /24 subnet.
     */
    public function __construct(
        private bool $strictMode = false
    ) {}

    /**
     * {@inheritdoc}
     */
    public function enforce(array $data) : void
    {
        $storedIp  = $data['_client_ip'] ?? null;
        $currentIp = $_SERVER['REMOTE_ADDR'] ?? '';

        // First time - no stored IP yet
        if ($storedIp === null) {
            return;
        }

        if ($this->strictMode) {
            // Strict: Exact match required
            if ($storedIp !== $currentIp) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_strict',
                    'IP address mismatch (strict) - possible session hijacking'
                );
            }
        } else {
            // Relaxed: Same /24 subnet
            if (! $this->isSameSubnet($storedIp, $currentIp)) {
                throw PolicyViolationException::forPolicy(
                    'ip_binding_relaxed',
                    'IP subnet mismatch - possible session hijacking'
                );
            }
        }
    }

    /**
     * Check if two IPs are in the same /24 subnet.
     *
     * @param string $ip1 First IP.
     * @param string $ip2 Second IP.
     *
     * @return bool True if same subnet.
     */
    private function isSameSubnet(string $ip1, string $ip2) : bool
    {
        $parts1 = explode('.', $ip1);
        $parts2 = explode('.', $ip2);

        // Compare first 3 octets (class C subnet)
        return $parts1[0] === $parts2[0]
            && $parts1[1] === $parts2[1]
            && $parts1[2] === $parts2[2];
    }

    /**
     * {@inheritdoc}
     */
    public function getName() : string
    {
        return $this->strictMode ? 'ip_binding_strict' : 'ip_binding_relaxed';
    }
}

=== Shared/Security/SessionNonce.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use Avax\HTTP\Session\Shared\Contracts\Storage\StoreInterface;
use RuntimeException;

/**
 * SessionNonce - Replay Attack Prevention
 *
 * OWASP ASVS 3.3.4 Compliant
 *
 * Generates and validates single-use tokens (nonces) to prevent
 * replay attacks on critical state-changing operations.
 *
 * Nonces are cryptographically secure random values.
 *
 * @package Avax\HTTP\Session\Security
 */
final class SessionNonce
{
    private const string NONCE_KEY    = '_nonce';
    private const int    NONCE_LENGTH = 16; // 128 bits

    /**
     * SessionNonce Constructor.
     *
     * @param StoreInterface $store Session storage.
     */
    public function __construct(
        private readonly StoreInterface $store
    ) {}

    /**
     * Generate a new nonce.
     *
     * Stores it in session for later verification.
     *
     * @return string Hex-encoded nonce.
     * @throws \Random\RandomException
     */
    public function generate() : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $this->store->put(key: self::NONCE_KEY, value: $nonce);

        return $nonce;
    }

    /**
     * Verify nonce or throw exception.
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid.
     */
    public function verifyOrFail(string $providedNonce) : void
    {
        if (! $this->verify($providedNonce)) {
            throw new RuntimeException(
                'Invalid or missing nonce - potential replay attack detected'
            );
        }
    }

    /**
     * Verify and consume a nonce.
     *
     * Nonce is deleted after verification (single-use).
     *
     * @param string $providedNonce Nonce to verify.
     *
     * @return bool True if nonce is valid.
     */
    public function verify(string $providedNonce) : bool
    {
        $storedNonce = $this->store->get(key: self::NONCE_KEY);

        if ($storedNonce === null) {
            return false; // No nonce stored
        }

        // Consume nonce (delete it)
        $this->store->delete(key: self::NONCE_KEY);

        // Constant-time comparison
        return hash_equals($storedNonce, $providedNonce);
    }

    /**
     * Check if a nonce exists in session.
     *
     * @return bool True if nonce present.
     */
    public function exists() : bool
    {
        return $this->store->has(key: self::NONCE_KEY);
    }

    // ========================================
    // PER-REQUEST NONCE (REPLAY ATTACK PREVENTION)
    // ========================================

    /**
     * Generate a per-request nonce.
     *
     * Used for critical operations that should only execute once.
     * Each request gets a unique nonce that expires after use.
     *
     * @param string $action Action identifier (e.g., 'delete_account', 'transfer_funds').
     *
     * @return string Hex-encoded nonce.
     * @throws \Random\RandomException
     */
    public function generateForRequest(string $action) : string
    {
        $nonce = bin2hex(random_bytes(self::NONCE_LENGTH));
        $key   = self::NONCE_KEY . ".{$action}";

        $this->store->put(
            key  : $key,
            value: [
                'nonce'      => $nonce,
                'created_at' => time(),
                'action'     => $action,
            ]);

        return $nonce;
    }

    /**
     * Verify per-request nonce or throw exception.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds.
     *
     * @return void
     *
     * @throws \RuntimeException If nonce invalid or expired.
     */
    public function verifyForRequestOrFail(string $action, string $providedNonce, int $maxAge = 300) : void
    {
        if (! $this->verifyForRequest($action, $providedNonce, $maxAge)) {
            throw new RuntimeException(
                "Invalid or expired nonce for action '{$action}' - potential replay attack detected"
            );
        }
    }

    /**
     * Verify and consume a per-request nonce.
     *
     * @param string $action        Action identifier.
     * @param string $providedNonce Nonce to verify.
     * @param int    $maxAge        Maximum age in seconds (default: 300 = 5 minutes).
     *
     * @return bool True if valid.
     */
    public function verifyForRequest(string $action, string $providedNonce, int $maxAge = 300) : bool
    {
        $key    = self::NONCE_KEY . ".{$action}";
        $stored = $this->store->get(key: $key);

        if ($stored === null) {
            return false; // No nonce for this action
        }

        // Check expiration
        if (time() - $stored['created_at'] > $maxAge) {
            $this->store->delete(key: $key);

            return false; // Expired
        }

        // Consume nonce (delete it)
        $this->store->delete(key: $key);

        // Constant-time comparison
        return hash_equals($stored['nonce'], $providedNonce);
    }

    /**
     * Clear all per-request nonces.
     *
     * @return void
     */
    public function clearAllRequests() : void
    {
        $all = $this->store->all();

        foreach (array_keys($all) as $key) {
            if (str_starts_with($key, self::NONCE_KEY . '.')) {
                $this->store->delete(key: $key);
            }
        }
    }

    /**
     * Get all active per-request nonces.
     *
     * Useful for debugging.
     *
     * @return array<string, array> Action => nonce data.
     */
    public function getActiveRequests() : array
    {
        $all    = $this->store->all();
        $nonces = [];

        foreach ($all as $key => $value) {
            if (str_starts_with($key, self::NONCE_KEY . '.') && is_array($value)) {
                $action          = substr($key, strlen(self::NONCE_KEY) + 1);
                $nonces[$action] = $value;
            }
        }

        return $nonces;
    }
}

=== Shared/Security/SessionRegistry.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use Avax\HTTP\Session\Shared\Contracts\Storage\StoreInterface;
use SensitiveParameter;

/**
 * ðŸ§  SessionRegistry â€” Multi-Device Session Management
 *
 * ------------------------------------------------------------------------
 * THEORY (for dummies):
 * ------------------------------------------------------------------------
 * Imagine every user has a small â€œnotebookâ€ ðŸ“’ where all their active
 * sessions are recorded â€” each page is one device or browser where
 * theyâ€™re currently logged in.
 *
 * That notebook is the *Session Registry*.
 *
 * Its job is to:
 * - Keep track of all active sessions per user ðŸ‘¤
 * - Detect if a session is too old or idle â³
 * - Let you force logout from other devices ðŸªŸ
 * - Revoke or block compromised sessions ðŸš«
 *
 * Think of it as your â€œcontrol roomâ€ for all user logins.
 * ------------------------------------------------------------------------
 *
 * ðŸ›¡ï¸ Why it exists:
 * Without a registry, you canâ€™t:
 * - Prevent stolen tokens from staying valid forever
 * - Enforce â€œsingle-device loginâ€ or session limits
 * - View all devices a user is logged in from
 * - Revoke access after password change or breach
 *
 * This is required by OWASP ASVS 3.3.8 â€” â€œApplications must allow
 * sessions to be revoked and limit concurrent sessions.â€
 *
 * ------------------------------------------------------------------------
 * TECHNICAL OVERVIEW:
 * ------------------------------------------------------------------------
 * - All data is stored inside your Session Store (FileStore / RedisStore)
 * - Each user has their own â€œregistry keyâ€: _registry_{userId}
 * - Each session entry contains metadata like IP, user-agent, timestamps
 * - A separate â€œrevoked listâ€ stores sessions that are invalid forever
 *
 * ðŸ’¡ Think of it as two tables:
 *   1ï¸âƒ£ Active sessions per user
 *   2ï¸âƒ£ Revoked (banned) sessions globally
 * ------------------------------------------------------------------------
 */
final class SessionRegistry
{
    private const string REGISTRY_PREFIX = '_registry_';

    public function __construct(
        private readonly StoreInterface $store
    ) {}

    // ============================================================
    // 1ï¸âƒ£ REGISTRATION â€” adding new sessions
    // ============================================================

    /**
     * Register a new session for a user.
     *
     * ðŸ§  What happens:
     * Every time a user logs in, we record:
     * - Which session ID they got
     * - From what IP and device (metadata)
     * - When it was created
     */
    public function register(string $userId, #[SensitiveParameter] string $sessionId, array $metadata = []) : void
    {
        $key      = self::REGISTRY_PREFIX . $userId;
        $sessions = $this->store->get(key: $key, default: []);

        $sessions[$sessionId] = array_merge($metadata, [
            'created_at'    => time(),
            'last_activity' => time(),
        ]);

        $this->store->put(key: $key, value: $sessions);
    }

    // ============================================================
    // 2ï¸âƒ£ ACTIVITY â€” updating and checking
    // ============================================================

    /**
     * Update last activity timestamp.
     *
     * ðŸ’¬ Think of this as â€œheartbeatâ€ â€” every time user interacts,
     * we update the time so we know theyâ€™re still alive ðŸ«€.
     */
    public function updateActivity(string $userId, #[SensitiveParameter] string $sessionId) : void
    {
        $sessions = $this->getActiveSessions($userId);
        if (! isset($sessions[$sessionId])) {
            return;
        }

        $sessions[$sessionId]['last_activity'] = time();
        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);
    }

    /**
     * Retrieve all active sessions for a user.
     */
    public function getActiveSessions(string $userId) : array
    {
        return $this->store->get(key: self::REGISTRY_PREFIX . $userId, default: []);
    }

    /**
     * Get metadata for a specific session.
     */
    public function getSessionMetadata(string $userId, #[SensitiveParameter] string $sessionId) : array|null
    {
        $sessions = $this->getActiveSessions($userId);

        return $sessions[$sessionId] ?? null;
    }

    /**
     * Terminate all sessions except the current one.
     *
     * ðŸ§  Useful when user logs in again and you want
     * to â€œkick outâ€ other devices â€” classic â€œsingle device loginâ€.
     */
    public function terminateOtherSessions(string $userId, #[SensitiveParameter] string $exceptSessionId) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $sessionId => $meta) {
            if ($sessionId !== $exceptSessionId) {
                unset($sessions[$sessionId]);
                $terminated++;
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return $terminated;
    }

    // ============================================================
    // 3ï¸âƒ£ TERMINATION â€” ending sessions
    // ============================================================

    /**
     * Terminate one specific session.
     */
    public function terminateSession(string $userId, #[SensitiveParameter] string $sessionId) : bool
    {
        $sessions = $this->getActiveSessions($userId);
        if (! isset($sessions[$sessionId])) {
            return false;
        }

        unset($sessions[$sessionId]);
        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return true;
    }

    /**
     * Terminate all sessions from a given device / browser.
     */
    public function terminateDevice(string $userId, string $userAgent) : int
    {
        $sessions   = $this->getActiveSessions($userId);
        $terminated = 0;

        foreach ($sessions as $id => $meta) {
            if (($meta['user_agent'] ?? '') === $userAgent) {
                unset($sessions[$id]);
                $terminated++;
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . $userId, value: $sessions);

        return $terminated;
    }

    /**
     * Check if user exceeded allowed number of sessions.
     *
     * Example: allow only 2 devices per account.
     */
    public function hasExceededLimit(string $userId, int $limit) : bool
    {
        return $this->countActiveSessions($userId) >= $limit;
    }

    // ============================================================
    // 4ï¸âƒ£ LIMITS â€” enforcing concurrent session limits
    // ============================================================

    /**
     * Count how many sessions user currently has.
     */
    public function countActiveSessions(string $userId) : int
    {
        return count($this->getActiveSessions($userId));
    }

    // ============================================================
    // 5ï¸âƒ£ REVOCATION LIST â€” permanently blocked sessions
    // ============================================================

    /**
     * Add a session to global revocation list.
     *
     * ðŸ’¬ Once revoked, a session is forever invalid â€” even if cookie exists.
     * Typical use cases:
     * - Password change
     * - Security breach
     * - Manual admin logout
     */
    public function revoke(#[SensitiveParameter] string $sessionId, string $reason = 'manual_revocation') : void
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        $revoked[$sessionId] = [
            'revoked_at' => time(),
            'reason'     => $reason,
        ];

        $this->store->put(key: $key, value: $revoked);
    }

    /**
     * Check if a session is revoked.
     */
    public function isRevoked(#[SensitiveParameter] string $sessionId) : bool
    {
        return isset($this->getAllRevoked()[$sessionId]);
    }

    /**
     * Get the global list of revoked sessions.
     *
     * ðŸ§  Purpose:
     * Exposes the complete revocation table so higher-level components
     * (admin panels, audit tools, security dashboards) can inspect which
     * session IDs are permanently blocked and why.
     *
     * ðŸ’¬ Think of it as:
     * â€œShow me the blacklist of all sessions that are not allowed to log in
     * anymore, regardless of cookie or token state.â€
     *
     * @return array<string, array{
     *     revoked_at:int,
     *     reason:string
     * }> Map of session ID to revocation metadata.
     */
    public function getAllRevoked() : array
    {
        return $this->store->get(key: self::REGISTRY_PREFIX . 'revoked', default: []);
    }

    /**
     * Remove session from revocation list.
     */
    public function unrevoke(#[SensitiveParameter] string $sessionId) : bool
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);

        if (! isset($revoked[$sessionId])) {
            return false;
        }

        unset($revoked[$sessionId]);
        $this->store->put(key: $key, value: $revoked);

        return true;
    }

    /**
     * Clear old revoked sessions (default 30 days).
     */
    public function clearOldRevocations(int $maxAge = 2_592_000) : int
    {
        $key     = self::REGISTRY_PREFIX . 'revoked';
        $revoked = $this->store->get(key: $key, default: []);
        $cleared = 0;

        foreach ($revoked as $id => $meta) {
            if (time() - $meta['revoked_at'] > $maxAge) {
                unset($revoked[$id]);
                $cleared++;
            }
        }

        $this->store->put(key: $key, value: $revoked);

        return $cleared;
    }

    /**
     * Count the total number of revoked sessions.
     *
     * This method inspects the global revocation list and returns
     * how many session IDs are currently marked as revoked.
     *
     * @return int Number of revoked sessions.
     */
    public function countRevoked() : int
    {
        return count($this->getAllRevoked());
    }

    /**
     * Get detailed revocation metadata for a specific session.
     *
     * ðŸ§  Purpose:
     * Allows security and audit layers to understand *why* a session was
     * revoked (e.g. password change, breach response, manual admin action).
     *
     * ðŸ’¬ Think of it as:
     * â€œTell me the story behind this session ID â€” when it was blocked and for
     * what reason.â€
     *
     * @param string $sessionId The session identifier to inspect.
     *
     * @return array<string, mixed>|null Revocation metadata or null if not revoked.
     */
    public function getRevocationDetails(#[SensitiveParameter] string $sessionId) : array|null
    {
        return $this->getAllRevoked()[$sessionId] ?? null;
    }

    // ============================================================
    // 6ï¸âƒ£ MAINTENANCE â€” cleanup and purge
    // ============================================================

    /**
     * Remove all session records for a user â€” including revoked ones.
     * Use this when deleting user accounts completely.
     */
    public function purgeUser(string $userId) : void
    {
        $this->store->delete(self::REGISTRY_PREFIX . $userId);

        $revoked = $this->getAllRevoked();
        foreach ($revoked as $sid => $meta) {
            if (($meta['user_id'] ?? null) === $userId) {
                unset($revoked[$sid]);
            }
        }

        $this->store->put(key: self::REGISTRY_PREFIX . 'revoked', value: $revoked);
    }

    /**
     * Group user sessions by device (user-agent).
     */
    public function getSessionsByDevice(string $userId) : array
    {
        $sessions = $this->getActiveSessions($userId);
        $devices  = [];

        foreach ($sessions as $sid => $meta) {
            $fingerprint             = $meta['user_agent'] ?? 'unknown';
            $devices[$fingerprint][] = ['session_id' => $sid] + $meta;
        }

        return $devices;
    }
}

=== Shared/Security/SessionSignature.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Security;

use RuntimeException;
use SensitiveParameter;

/**
 * Class SessionSignature
 * ------------------------------------------------------------
 * ðŸ›¡ï¸ Enterprise-Grade Session Integrity Protection
 *
 * Provides cryptographic signing and verification of session
 * payloads to prevent tampering and replay attacks.
 *
 * âœ… OWASP ASVS 3.3.3 â€” "Verify that all session tokens are signed
 * or encrypted using a strong cryptographic algorithm."
 *
 * Implements HMAC-SHA256 integrity protection using immutable keys.
 *
 * ðŸ’¡ Supports key rotation â€” allowing seamless transition from an
 * old secret to a new one without breaking existing sessions.
 *
 * @example Basic usage:
 *   $signature = new SessionSignature(secretKey: $_ENV['SESSION_KEY']);
 *   $hash = $signature->sign($sessionData);
 *   $signature->verify($sessionData, $hash);
 *
 * @package Avax\HTTP\Session\Security
 */
final class SessionSignature
{
    private const string ALGO = 'sha256';

    /**
     * @var string Primary secret key for signing.
     */
    private string $primaryKey;

    /**
     * @var string|null Optional secondary key for fallback verification (key rotation support).
     */
    private string|null $secondaryKey;

    /**
     * Constructor.
     *
     * @param string      $secretKey   Primary secret key (HMAC key).
     * @param string|null $fallbackKey Optional old key (used for key rotation verification).
     *
     * @throws RuntimeException If provided key(s) are invalid or too short.
     */
    public function __construct(#[SensitiveParameter] string $secretKey, string|null $fallbackKey = null)
    {
        if (strlen(string: $secretKey) < 32) {
            throw new RuntimeException(message: 'SessionSignature: Secret key must be at least 32 bytes long.');
        }

        $this->primaryKey   = $secretKey;
        $this->secondaryKey = $fallbackKey;
    }

    // ------------------------------------------------------------
    // ðŸ”’ Signing
    // ------------------------------------------------------------

    /**
     * Verify integrity of session data using HMAC signature.
     *
     * Performs constant-time comparison to mitigate timing attacks.
     *
     * If verification fails with the primary key and a secondary key
     * is defined, verification is attempted again using the fallback key.
     *
     * @param string $data      Original session payload.
     * @param string $signature Expected signature (hexadecimal).
     *
     * @return bool True if signature is valid; false otherwise.
     */
    public function verify(string $data, string $signature) : bool
    {
        $expected = $this->sign(data: $data);

        // Primary key check
        if (hash_equals(known_string: $expected, user_string: $signature)) {
            return true;
        }

        // Optional fallback check (for rotated keys)
        if ($this->secondaryKey !== null) {
            $fallbackSignature = hash_hmac(algo: self::ALGO, data: $data, key: $this->secondaryKey);

            return hash_equals(known_string: $fallbackSignature, user_string: $signature);
        }

        return false;
    }

    // ------------------------------------------------------------
    // ðŸ” Verification
    // ------------------------------------------------------------

    /**
     * Generate an HMAC signature for given session data.
     *
     * @param string $data The session payload to sign.
     *
     * @return string Hexadecimal HMAC signature.
     */
    public function sign(string $data) : string
    {
        return hash_hmac(
            algo: self::ALGO,
            data: $data,
            key : $this->primaryKey
        );
    }

    // ------------------------------------------------------------
    // âš™ï¸ Accessors
    // ------------------------------------------------------------

    /**
     * Retrieve the current HMAC algorithm in use.
     *
     * @return string Algorithm identifier (e.g., sha256).
     */
    public function getAlgorithm() : string
    {
        return self::ALGO;
    }

    /**
     * Retrieve the currently active primary signing key.
     *
     * âš ï¸ For internal use only â€” do not expose in logs or debug output.
     *
     * @return string Active signing key.
     */
    public function getKey() : string
    {
        return $this->primaryKey;
    }

    /**
     * Check if a secondary key is configured (key rotation mode).
     *
     * @return bool True if secondary key available.
     */
    public function hasFallbackKey() : bool
    {
        return $this->secondaryKey !== null;
    }
}

=== Shared/Serialization/Serializer.php ===
<?php

declare(strict_types=1);

namespace Avax\HTTP\Session\Shared\Serialization;

use Avax\HTTP\Session\Shared\Exceptions\SerializationException;

/**
 * Serializer - Enterprise-Grade Serialization Handler
 * ============================================================
 *
 * Provides secure, type-safe serialization and deserialization
 * for session data with built-in security measures.
 *
 * Enterprise Features:
 * - Safe deserialization (prevents object injection attacks)
 * - Type validation and sanitization
 * - Compression support for large payloads
 * - Integrity verification via checksums
 * - Detailed error handling and logging
 * - Support for custom serialization formats
 *
 * Security:
 * - Prevents arbitrary object instantiation during unserialize
 * - Validates data integrity before deserialization
 * - Sanitizes input to prevent injection attacks
 * - Implements whitelist-based class filtering
 *
 * @package Avax\HTTP\Session\Shared\Serialization
 * @author  Milos
 * @version 1.0
 */
final class Serializer
{
    /**
     * Allowed classes for safe deserialization.
     *
     * Only these classes can be instantiated during unserialize.
     * Empty array = no objects allowed (arrays and scalars only).
     *
     * @var array<int, string>
     */
    private array $allowedClasses = [];

    /**
     * Enable compression for large payloads.
     *
     * @var bool
     */
    private bool $compressionEnabled = false;

    /**
     * Compression threshold in bytes.
     *
     * Data larger than this will be compressed.
     *
     * @var int
     */
    private int $compressionThreshold = 1024;

    /**
     * Enable integrity checking via checksums.
     *
     * @var bool
     */
    private bool $integrityCheckEnabled = true;

    /**
     * Serializer Constructor.
     *
     * @param array<int, string> $allowedClasses      Classes allowed during deserialization.
     * @param bool               $compressionEnabled  Enable compression for large data.
     * @param int                $compressionThreshold Minimum size for compression (bytes).
     * @param bool               $integrityCheck      Enable checksum verification.
     */
    public function __construct(
        array $allowedClasses = [],
        bool  $compressionEnabled = false,
        int   $compressionThreshold = 1024,
        bool  $integrityCheck = true
    ) {
        $this->allowedClasses = $allowedClasses;
        $this->compressionEnabled = $compressionEnabled;
        $this->compressionThreshold = $compressionThreshold;
        $this->integrityCheckEnabled = $integrityCheck;
    }

    // ----------------------------------------------------------------
    // Core Serialization
    // ----------------------------------------------------------------

    /**
     * Serialize data with optional compression and integrity check.
     *
     * @param mixed $data The data to serialize.
     *
     * @return string Serialized (and optionally compressed) data.
     *
     * @throws SerializationException If serialization fails.
     */
    public function serialize(mixed $data): string
    {
        try {
            // Step 1: Serialize the data
            $serialized = serialize($data);

            // Step 2: Apply compression if enabled and data is large enough
            if ($this->compressionEnabled && strlen($serialized) > $this->compressionThreshold) {
                $compressed = gzcompress($serialized, 6);
                if ($compressed === false) {
                    throw SerializationException::compressionFailed();
                }
                $serialized = 'GZIP:' . $compressed;
            }

            // Step 3: Add integrity checksum if enabled
            if ($this->integrityCheckEnabled) {
                $checksum = hash('sha256', $serialized);
                $serialized = $checksum . ':' . $serialized;
            }

            return $serialized;
        } catch (\Throwable $e) {
            throw SerializationException::serializationFailed($e->getMessage(), $e);
        }
    }

    /**
     * Deserialize data with security checks.
     *
     * This method implements safe deserialization by:
     * 1. Verifying data integrity (if enabled)
     * 2. Decompressing data (if compressed)
     * 3. Using allowed_classes to prevent object injection
     *
     * @param string $data The serialized data.
     *
     * @return mixed The deserialized data.
     *
     * @throws SerializationException If deserialization fails or integrity check fails.
     */
    public function deserialize(string $data): mixed
    {
        try {
            // Step 1: Verify integrity checksum if enabled
            if ($this->integrityCheckEnabled) {
                if (!str_contains($data, ':')) {
                    throw SerializationException::invalidFormat('Missing checksum separator');
                }

                [$checksum, $payload] = explode(':', $data, 2);

                $expectedChecksum = hash('sha256', $payload);
                if (!hash_equals($expectedChecksum, $checksum)) {
                    throw SerializationException::integrityCheckFailed();
                }

                $data = $payload;
            }

            // Step 2: Decompress if data was compressed
            if (str_starts_with($data, 'GZIP:')) {
                $compressed = substr($data, 5);
                $decompressed = gzuncompress($compressed);
                if ($decompressed === false) {
                    throw SerializationException::decompressionFailed();
                }
                $data = $decompressed;
            }

            // Step 3: Safe unserialize with allowed_classes
            $result = unserialize($data, ['allowed_classes' => $this->allowedClasses]);

            if ($result === false && $data !== serialize(false)) {
                throw SerializationException::deserializationFailed('Unserialize returned false');
            }

            return $result;
        } catch (SerializationException $e) {
            throw $e;
        } catch (\Throwable $e) {
            throw SerializationException::deserializationFailed($e->getMessage(), $e);
        }
    }

    // ----------------------------------------------------------------
    // Safe Deserialization (Legacy Compatibility)
    // ----------------------------------------------------------------

    /**
     * Safe deserialization that NEVER allows object instantiation.
     *
     * This is the most secure option - only arrays and scalar values
     * can be deserialized. No objects are allowed.
     *
     * Use this for untrusted data or when you only need arrays/scalars.
     *
     * @param string $data The serialized data.
     *
     * @return mixed The deserialized data (arrays and scalars only).
     *
     * @throws SerializationException If deserialization fails.
     */
    public function safeUnserialize(string $data): mixed
    {
        try {
            // Force allowed_classes to false (no objects allowed)
            $result = unserialize($data, ['allowed_classes' => false]);

            if ($result === false && $data !== serialize(false)) {
                throw SerializationException::deserializationFailed('Safe unserialize returned false');
            }

            return $result;
        } catch (\Throwable $e) {
            throw SerializationException::deserializationFailed($e->getMessage(), $e);
        }
    }

    // ----------------------------------------------------------------
    // JSON Serialization (Alternative Format)
    // ----------------------------------------------------------------

    /**
     * Serialize data to JSON format.
     *
     * JSON is safer than PHP serialize for untrusted data and
     * is also more portable across different systems.
     *
     * @param mixed $data  The data to serialize.
     * @param int   $flags JSON encoding flags.
     *
     * @return string JSON-encoded data.
     *
     * @throws SerializationException If JSON encoding fails.
     */
    public function toJson(mixed $data, int $flags = JSON_THROW_ON_ERROR): string
    {
        try {
            return json_encode($data, $flags);
        } catch (\JsonException $e) {
            throw SerializationException::jsonEncodeFailed($e->getMessage(), $e);
        }
    }

    /**
     * Deserialize data from JSON format.
     *
     * @param string $json  The JSON-encoded data.
     * @param bool   $assoc Return associative arrays instead of objects.
     * @param int    $flags JSON decoding flags.
     *
     * @return mixed The decoded data.
     *
     * @throws SerializationException If JSON decoding fails.
     */
    public function fromJson(string $json, bool $assoc = true, int $flags = JSON_THROW_ON_ERROR): mixed
    {
        try {
            return json_decode($json, $assoc, 512, $flags);
        } catch (\JsonException $e) {
            throw SerializationException::jsonDecodeFailed($e->getMessage(), $e);
        }
    }

    // ----------------------------------------------------------------
    // Configuration
    // ----------------------------------------------------------------

    /**
     * Set allowed classes for deserialization.
     *
     * @param array<int, string> $classes Fully qualified class names.
     *
     * @return self Fluent interface.
     */
    public function setAllowedClasses(array $classes): self
    {
        $this->allowedClasses = $classes;

        return $this;
    }

    /**
     * Enable or disable compression.
     *
     * @param bool $enabled Enable compression.
     *
     * @return self Fluent interface.
     */
    public function setCompression(bool $enabled): self
    {
        $this->compressionEnabled = $enabled;

        return $this;
    }

    /**
     * Set compression threshold.
     *
     * @param int $bytes Minimum size in bytes for compression.
     *
     * @return self Fluent interface.
     */
    public function setCompressionThreshold(int $bytes): self
    {
        $this->compressionThreshold = $bytes;

        return $this;
    }

    /**
     * Enable or disable integrity checking.
     *
     * @param bool $enabled Enable integrity checks.
     *
     * @return self Fluent interface.
     */
    public function setIntegrityCheck(bool $enabled): self
    {
        $this->integrityCheckEnabled = $enabled;

        return $this;
    }

    // ----------------------------------------------------------------
    // Utility Methods
    // ----------------------------------------------------------------

    /**
     * Check if data is serialized.
     *
     * @param string $data The data to check.
     *
     * @return bool True if data appears to be serialized.
     */
    public function isSerialized(string $data): bool
    {
        // Check for PHP serialization format
        if (preg_match('/^([adObis]):/', $data)) {
            return true;
        }

        // Check for our compressed format
        if (str_starts_with($data, 'GZIP:')) {
            return true;
        }

        // Check for our integrity-checked format
        if ($this->integrityCheckEnabled && str_contains($data, ':')) {
            return true;
        }

        return false;
    }

    /**
     * Get the size of serialized data.
     *
     * @param mixed $data The data to measure.
     *
     * @return int Size in bytes.
     */
    public function getSerializedSize(mixed $data): int
    {
        return strlen($this->serialize($data));
    }

    /**
     * Check if data would be compressed.
     *
     * @param mixed $data The data to check.
     *
     * @return bool True if data would be compressed.
     */
    public function wouldCompress(mixed $data): bool
    {
        if (!$this->compressionEnabled) {
            return false;
        }

        $serialized = serialize($data);

        return strlen($serialized) > $this->compressionThreshold;
    }
}

=== command.sh ===
#!/usr/bin/env bash
set -e

echo "ðŸš€ Starting enterprise Session v5 structure setup..."

# ðŸ“ Automatski pronaÄ‘i root Avax folder
BASE_DIR=$(find . -type d -path "*/Avax/HTTP/Session" | head -n 1)

if [ -z "$BASE_DIR" ]; then
  echo "âŒ Could not find Avax/HTTP/Session directory!"
  exit 1
fi

echo "ðŸ“ Found Session base at: $BASE_DIR"

# 1ï¸âƒ£ Kreiraj novu enterprise strukturu
mkdir -p v5/Avax/HTTP/Session/{Core/{Config,Data,Lifecycle},Recovery/Data,Audit/Features,Events/Features}

# 2ï¸âƒ£ Kopiraj postojeÄ‡e fajlove u nove module
echo "ðŸ“¦ Copying files into v5 structure..."

# --- Core ---
cp -v "$BASE_DIR/Config/SessionConfig.php" v5/Avax/HTTP/Session/Core/Config/ 2>/dev/null || true
cp -v "$BASE_DIR/Data/FileStore.php" v5/Avax/HTTP/Session/Core/Data/ 2>/dev/null || true
cp -v "$BASE_DIR/Data/"*".php" v5/Avax/HTTP/Session/Core/Data/ 2>/dev/null || true
cp -v "$BASE_DIR/Lifecycle/SessionProvider.php" v5/Avax/HTTP/Session/Core/Lifecycle/ 2>/dev/null || true

# --- Recovery ---
cp -v "$BASE_DIR/Data/Recovery.php" v5/Avax/HTTP/Session/Recovery/Data/ 2>/dev/null || true

# --- Audit ---
cp -v "$BASE_DIR/Features/Audit.php" v5/Avax/HTTP/Session/Audit/Features/ 2>/dev/null || true

# --- Events ---
cp -v "$BASE_DIR/Features/Events.php" v5/Avax/HTTP/Session/Events/Features/ 2>/dev/null || true
cp -v "$BASE_DIR/Features/AsyncEventDispatcher.php" v5/Avax/HTTP/Session/Events/Features/ 2>/dev/null || true

# --- Session Root (Facade) ---
cp -v "$BASE_DIR/Session.php" v5/Avax/HTTP/Session/ 2>/dev/null || true

# 3ï¸âƒ£ Kreiraj Manager fajlove (ako ne postoje)
echo "ðŸ§  Generating Manager placeholders..."
touch v5/Avax/HTTP/Session/Core/CoreManager.php
touch v5/Avax/HTTP/Session/Recovery/RecoveryManager.php
touch v5/Avax/HTTP/Session/Audit/AuditManager.php
touch v5/Avax/HTTP/Session/Events/EventsManager.php

# 4ï¸âƒ£ PrikaÅ¾i finalnu strukturu (fallback ako tree ne postoji)
echo "âœ… Enterprise structure created successfully:"
find v5/Avax/HTTP/Session -type f | sort

=== examples/merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ðŸ“ Scanning directory: $TARGET_DIR"
echo "ðŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ðŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ðŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ðŸ§© Merged files : $MERGED"
echo "ðŸš« Skipped files: $SKIPPED"
echo "ðŸ“„ Output file  : $OUTPUT_FILE"

=== merge-files.sh ===
#!/bin/bash

###############################################################################
# merge-files.sh
# -----------------------------------------------------------------------------
# Merges all text-based files under a directory (recursively) into a single file.
# Skips .txt and .md files by default unless --include-ext is used.
# Ignores specific directories: vendor, docker, public, storage, tmp, tools.
###############################################################################

set -euo pipefail

EXCLUDE_EXT=()
INCLUDE_EXT=()
DRY_RUN=false

# Hardcoded list of directories to ignore
# shellcheck disable=SC2054
IGNORE_DIRS=("vendor" "docker" "public" "storage" "tmp" "tools" ".idea" ".git" "Infrastructure/Framework",
"Presentation/resources", "resources")

print_help() {
    cat << EOF
Usage: $0 [options] /path/to/directory

Options:
  --exclude-ext ext1,ext2      Ignore files with these extensions
  --include-ext ext1,ext2      Include ONLY files with these extensions
  --dry-run                    Show which files would be processed
  --help                       Show this help message
EOF
    exit 0
}

error() {
    echo "âŒ $1" >&2
    exit 1
}

parse_csv_to_array() {
    IFS=',' read -ra ARR <<< "$1"
    echo "${ARR[@]}"
}

POSITIONAL_ARGS=()
TARGET_DIR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude-ext)
            EXCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --include-ext)
            INCLUDE_EXT=($(parse_csv_to_array "$2"))
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            print_help
            ;;
        -*|--*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]}"

if [ "$#" -ne 1 ]; then
    error "Missing required argument: target directory"
fi

TARGET_DIR="$1"

if [ ! -d "$TARGET_DIR" ]; then
    error "Directory '$TARGET_DIR' does not exist."
fi

# Convert to absolute path for consistency
TARGET_DIR=$(realpath "$TARGET_DIR")

if [ "${#EXCLUDE_EXT[@]}" -gt 0 ] && [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
    error "You cannot use --exclude-ext and --include-ext at the same time."
fi

# Always skip .txt and .md unless --include-ext is used
SKIPPED_EXT=("txt" "md" "yaml" "env")
if [ "${#INCLUDE_EXT[@]}" -eq 0 ]; then
    EXCLUDE_EXT+=("${SKIPPED_EXT[@]}")
fi

ROOT_FOLDER_NAME=$(basename "$TARGET_DIR")
OUTPUT_FILE="${TARGET_DIR}/${ROOT_FOLDER_NAME}.txt"

> "$OUTPUT_FILE"

echo "ðŸ“ Scanning directory: $TARGET_DIR"
echo "ðŸ“„ Output file: $OUTPUT_FILE"

# Log ignored directories
if [ "${#IGNORE_DIRS[@]}" -gt 0 ]; then
    echo "ðŸš« Ignoring directories:"
    for dir in "${IGNORE_DIRS[@]}"; do
        echo "   - $dir"
    done
fi

echo "----------------------------------------"

CURRENT=0
MERGED=0
SKIPPED=0

# Build prune expression
PRUNE_EXPR=()
for dir in "${IGNORE_DIRS[@]}"; do
    PRUNE_EXPR+=(-path "$TARGET_DIR/$dir" -prune -o)
done
# Remove last -o
unset 'PRUNE_EXPR[${#PRUNE_EXPR[@]}-1]'

# Find and process files excluding pruned dirs
while IFS= read -r FILE; do
    REL_PATH="${FILE#$TARGET_DIR/}"
    EXT="${FILE##*.}"

    if [ "${#INCLUDE_EXT[@]}" -gt 0 ]; then
        if [[ ! " ${INCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (not in include list): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    else
        if [[ " ${EXCLUDE_EXT[@]} " =~ " ${EXT} " ]]; then
            echo "â­ï¸  Skipping (excluded by default or option): $REL_PATH"
            SKIPPED=$((SKIPPED + 1))
            continue
        fi
    fi

    CURRENT=$((CURRENT + 1))
    MERGED=$((MERGED + 1))

    if [ "$DRY_RUN" = true ]; then
        echo "ðŸ§ª [DRY-RUN] Would merge: $REL_PATH"
        continue
    fi

    echo "ðŸ”„ [$CURRENT] Merging: $REL_PATH"

    {
        echo "=== $REL_PATH ==="
        cat "$FILE"
        echo ""
    } >> "$OUTPUT_FILE"
done < <(
    find "$TARGET_DIR" \( "${PRUNE_EXPR[@]}" \) -o -type f -print | sort -u
)

echo "----------------------------------------"
echo "âœ… Done!"
echo "ðŸ§© Merged files : $MERGED"
echo "ðŸš« Skipped files: $SKIPPED"
echo "ðŸ“„ Output file  : $OUTPUT_FILE"

